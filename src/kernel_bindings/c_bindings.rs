/* automatically generated by rust-bindgen 0.55.1 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage, Align> {
    storage: Storage,
    align: [Align; 0],
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage, align: [] }
    }
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::core::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::core::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::core::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::core::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::core::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
#[repr(C)]
pub struct __BindgenUnionField<T>(::core::marker::PhantomData<T>);
impl<T> __BindgenUnionField<T> {
    #[inline]
    pub const fn new() -> Self {
        __BindgenUnionField(::core::marker::PhantomData)
    }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T {
        ::core::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T {
        ::core::mem::transmute(self)
    }
}
impl<T> ::core::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self {
        Self::new()
    }
}
impl<T> ::core::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self {
        Self::new()
    }
}
impl<T> ::core::marker::Copy for __BindgenUnionField<T> {}
impl<T> ::core::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
impl<T> ::core::hash::Hash for __BindgenUnionField<T> {
    fn hash<H: ::core::hash::Hasher>(&self, _state: &mut H) {}
}
impl<T> ::core::cmp::PartialEq for __BindgenUnionField<T> {
    fn eq(&self, _other: &__BindgenUnionField<T>) -> bool {
        true
    }
}
impl<T> ::core::cmp::Eq for __BindgenUnionField<T> {}
pub type __s8 = c_types::c_schar;
pub type __u8 = c_types::c_uchar;
pub type __s16 = c_types::c_short;
pub type __u16 = c_types::c_ushort;
pub type __s32 = c_types::c_int;
pub type __u32 = c_types::c_uint;
pub type __s64 = c_types::c_longlong;
pub type __u64 = c_types::c_ulonglong;
pub type s8 = __s8;
pub type u8_ = __u8;
pub type s16 = __s16;
pub type u16_ = __u16;
pub type s32 = __s32;
pub type u32_ = __u32;
pub type s64 = __s64;
pub type u64_ = __u64;
pub type __kernel_long_t = c_types::c_long;
pub type __kernel_ulong_t = c_types::c_ulong;
pub type __kernel_pid_t = c_types::c_int;
pub type __kernel_uid32_t = c_types::c_uint;
pub type __kernel_gid32_t = c_types::c_uint;
pub type __kernel_size_t = __kernel_ulong_t;
pub type __kernel_ssize_t = __kernel_long_t;
pub type __kernel_loff_t = c_types::c_longlong;
pub type __kernel_time64_t = c_types::c_longlong;
pub type __kernel_clock_t = __kernel_long_t;
pub type __kernel_timer_t = c_types::c_int;
pub type __kernel_clockid_t = c_types::c_int;
pub type __le16 = __u16;
pub type __be16 = __u16;
pub type __be32 = __u32;
pub type __be64 = __u64;
pub type __sum16 = __u16;
pub type __wsum = __u32;
pub type __poll_t = c_types::c_uint;
pub type __kernel_dev_t = u32_;
pub type dev_t = __kernel_dev_t;
pub type umode_t = c_types::c_ushort;
pub type pid_t = __kernel_pid_t;
pub type clockid_t = __kernel_clockid_t;
pub type bool_ = bool;
pub type uid_t = __kernel_uid32_t;
pub type gid_t = __kernel_gid32_t;
pub type loff_t = __kernel_loff_t;
pub type u_int8_t = u8_;
#[doc = " The type used for indexing onto a disc or disc partition."]
#[doc = ""]
#[doc = " Linux always considers sectors to be 512 bytes long independently"]
#[doc = " of the devices real block size."]
#[doc = ""]
#[doc = " blkcnt_t is the type of the inode's block count."]
pub type sector_t = u64_;
pub type blkcnt_t = u64_;
pub type dma_addr_t = u64_;
pub type gfp_t = c_types::c_uint;
pub type slab_flags_t = c_types::c_uint;
pub type fmode_t = c_types::c_uint;
pub type phys_addr_t = u64_;
pub type resource_size_t = phys_addr_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct atomic_t {
    pub counter: c_types::c_int,
}
#[test]
fn bindgen_test_layout_atomic_t() {
    assert_eq!(
        ::core::mem::size_of::<atomic_t>(),
        4usize,
        concat!("Size of: ", stringify!(atomic_t))
    );
    assert_eq!(
        ::core::mem::align_of::<atomic_t>(),
        4usize,
        concat!("Alignment of ", stringify!(atomic_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<atomic_t>())).counter as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(atomic_t),
            "::",
            stringify!(counter)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct atomic64_t {
    pub counter: s64,
}
#[test]
fn bindgen_test_layout_atomic64_t() {
    assert_eq!(
        ::core::mem::size_of::<atomic64_t>(),
        8usize,
        concat!("Size of: ", stringify!(atomic64_t))
    );
    assert_eq!(
        ::core::mem::align_of::<atomic64_t>(),
        8usize,
        concat!("Alignment of ", stringify!(atomic64_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<atomic64_t>())).counter as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(atomic64_t),
            "::",
            stringify!(counter)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct list_head {
    pub next: *mut list_head,
    pub prev: *mut list_head,
}
#[test]
fn bindgen_test_layout_list_head() {
    assert_eq!(
        ::core::mem::size_of::<list_head>(),
        16usize,
        concat!("Size of: ", stringify!(list_head))
    );
    assert_eq!(
        ::core::mem::align_of::<list_head>(),
        8usize,
        concat!("Alignment of ", stringify!(list_head))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<list_head>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(list_head),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<list_head>())).prev as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(list_head),
            "::",
            stringify!(prev)
        )
    );
}
impl Default for list_head {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hlist_head {
    pub first: *mut hlist_node,
}
#[test]
fn bindgen_test_layout_hlist_head() {
    assert_eq!(
        ::core::mem::size_of::<hlist_head>(),
        8usize,
        concat!("Size of: ", stringify!(hlist_head))
    );
    assert_eq!(
        ::core::mem::align_of::<hlist_head>(),
        8usize,
        concat!("Alignment of ", stringify!(hlist_head))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hlist_head>())).first as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hlist_head),
            "::",
            stringify!(first)
        )
    );
}
impl Default for hlist_head {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hlist_node {
    pub next: *mut hlist_node,
    pub pprev: *mut *mut hlist_node,
}
#[test]
fn bindgen_test_layout_hlist_node() {
    assert_eq!(
        ::core::mem::size_of::<hlist_node>(),
        16usize,
        concat!("Size of: ", stringify!(hlist_node))
    );
    assert_eq!(
        ::core::mem::align_of::<hlist_node>(),
        8usize,
        concat!("Alignment of ", stringify!(hlist_node))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hlist_node>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hlist_node),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hlist_node>())).pprev as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hlist_node),
            "::",
            stringify!(pprev)
        )
    );
}
impl Default for hlist_node {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[doc = " struct callback_head - callback structure for use with RCU and task_work"]
#[doc = " @next: next update requests in a list"]
#[doc = " @func: actual update function to call after the grace period."]
#[doc = ""]
#[doc = " The struct is aligned to size of pointer. On most architectures it happens"]
#[doc = " naturally due ABI requirements, but some architectures (like CRIS) have"]
#[doc = " weird ABI and we need to ask it explicitly."]
#[doc = ""]
#[doc = " The alignment is required to guarantee that bit 0 of @next will be"]
#[doc = " clear under normal conditions -- as long as we use call_rcu() or"]
#[doc = " call_srcu() to queue the callback."]
#[doc = ""]
#[doc = " This guarantee is important for few reasons:"]
#[doc = "  - future call_rcu_lazy() will make use of lower bits in the pointer;"]
#[doc = "  - the structure shares storage space in struct page with @compound_head,"]
#[doc = "    which encode PageTail() in bit 0. The guarantee is needed to avoid"]
#[doc = "    false-positive PageTail()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct callback_head {
    pub next: *mut callback_head,
    pub func: ::core::option::Option<unsafe extern "C" fn(head: *mut callback_head)>,
}
#[test]
fn bindgen_test_layout_callback_head() {
    assert_eq!(
        ::core::mem::size_of::<callback_head>(),
        16usize,
        concat!("Size of: ", stringify!(callback_head))
    );
    assert_eq!(
        ::core::mem::align_of::<callback_head>(),
        8usize,
        concat!("Alignment of ", stringify!(callback_head))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<callback_head>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(callback_head),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<callback_head>())).func as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(callback_head),
            "::",
            stringify!(func)
        )
    );
}
impl Default for callback_head {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct user_namespace {
    pub uid_map: uid_gid_map,
    pub gid_map: uid_gid_map,
    pub projid_map: uid_gid_map,
    pub count: atomic_t,
    pub parent: *mut user_namespace,
    pub level: c_types::c_int,
    pub owner: kuid_t,
    pub group: kgid_t,
    pub ns: ns_common,
    pub flags: c_types::c_ulong,
    pub keyring_name_list: list_head,
    pub user_keyring_register: *mut key,
    pub keyring_sem: rw_semaphore,
    pub persistent_keyring_register: *mut key,
    pub work: work_struct,
    pub set: ctl_table_set,
    pub sysctls: *mut ctl_table_header,
    pub ucounts: *mut ucounts,
    pub ucount_max: [c_types::c_int; 9usize],
}
#[test]
fn bindgen_test_layout_user_namespace() {
    assert_eq!(
        ::core::mem::size_of::<user_namespace>(),
        536usize,
        concat!("Size of: ", stringify!(user_namespace))
    );
    assert_eq!(
        ::core::mem::align_of::<user_namespace>(),
        8usize,
        concat!("Alignment of ", stringify!(user_namespace))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<user_namespace>())).uid_map as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(user_namespace),
            "::",
            stringify!(uid_map)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<user_namespace>())).gid_map as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(user_namespace),
            "::",
            stringify!(gid_map)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<user_namespace>())).projid_map as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(user_namespace),
            "::",
            stringify!(projid_map)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<user_namespace>())).count as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(user_namespace),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<user_namespace>())).parent as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(user_namespace),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<user_namespace>())).level as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(user_namespace),
            "::",
            stringify!(level)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<user_namespace>())).owner as *const _ as usize },
        236usize,
        concat!(
            "Offset of field: ",
            stringify!(user_namespace),
            "::",
            stringify!(owner)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<user_namespace>())).group as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(user_namespace),
            "::",
            stringify!(group)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<user_namespace>())).ns as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(user_namespace),
            "::",
            stringify!(ns)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<user_namespace>())).flags as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(user_namespace),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<user_namespace>())).keyring_name_list as *const _ as usize
        },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(user_namespace),
            "::",
            stringify!(keyring_name_list)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<user_namespace>())).user_keyring_register as *const _ as usize
        },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(user_namespace),
            "::",
            stringify!(user_keyring_register)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<user_namespace>())).keyring_sem as *const _ as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(user_namespace),
            "::",
            stringify!(keyring_sem)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<user_namespace>())).persistent_keyring_register as *const _
                as usize
        },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(user_namespace),
            "::",
            stringify!(persistent_keyring_register)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<user_namespace>())).work as *const _ as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(user_namespace),
            "::",
            stringify!(work)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<user_namespace>())).set as *const _ as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(user_namespace),
            "::",
            stringify!(set)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<user_namespace>())).sysctls as *const _ as usize },
        480usize,
        concat!(
            "Offset of field: ",
            stringify!(user_namespace),
            "::",
            stringify!(sysctls)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<user_namespace>())).ucounts as *const _ as usize },
        488usize,
        concat!(
            "Offset of field: ",
            stringify!(user_namespace),
            "::",
            stringify!(ucounts)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<user_namespace>())).ucount_max as *const _ as usize },
        496usize,
        concat!(
            "Offset of field: ",
            stringify!(user_namespace),
            "::",
            stringify!(ucount_max)
        )
    );
}
impl Default for user_namespace {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kuid_t {
    pub val: uid_t,
}
#[test]
fn bindgen_test_layout_kuid_t() {
    assert_eq!(
        ::core::mem::size_of::<kuid_t>(),
        4usize,
        concat!("Size of: ", stringify!(kuid_t))
    );
    assert_eq!(
        ::core::mem::align_of::<kuid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(kuid_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kuid_t>())).val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kuid_t),
            "::",
            stringify!(val)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kgid_t {
    pub val: gid_t,
}
#[test]
fn bindgen_test_layout_kgid_t() {
    assert_eq!(
        ::core::mem::size_of::<kgid_t>(),
        4usize,
        concat!("Size of: ", stringify!(kgid_t))
    );
    assert_eq!(
        ::core::mem::align_of::<kgid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(kgid_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kgid_t>())).val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kgid_t),
            "::",
            stringify!(val)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kernel_cap_struct {
    pub cap: [__u32; 2usize],
}
#[test]
fn bindgen_test_layout_kernel_cap_struct() {
    assert_eq!(
        ::core::mem::size_of::<kernel_cap_struct>(),
        8usize,
        concat!("Size of: ", stringify!(kernel_cap_struct))
    );
    assert_eq!(
        ::core::mem::align_of::<kernel_cap_struct>(),
        4usize,
        concat!("Alignment of ", stringify!(kernel_cap_struct))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernel_cap_struct>())).cap as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kernel_cap_struct),
            "::",
            stringify!(cap)
        )
    );
}
pub type kernel_cap_t = kernel_cap_struct;
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct module {
    pub state: module_state,
    pub list: list_head,
    pub name: [c_types::c_char; 56usize],
    pub mkobj: module_kobject,
    pub modinfo_attrs: *mut module_attribute,
    pub version: *const c_types::c_char,
    pub srcversion: *const c_types::c_char,
    pub holders_dir: *mut kobject,
    pub syms: *const kernel_symbol,
    pub crcs: *const s32,
    pub num_syms: c_types::c_uint,
    pub param_lock: mutex,
    pub kp: *mut kernel_param,
    pub num_kp: c_types::c_uint,
    pub num_gpl_syms: c_types::c_uint,
    pub gpl_syms: *const kernel_symbol,
    pub gpl_crcs: *const s32,
    pub unused_syms: *const kernel_symbol,
    pub unused_crcs: *const s32,
    pub num_unused_syms: c_types::c_uint,
    pub num_unused_gpl_syms: c_types::c_uint,
    pub unused_gpl_syms: *const kernel_symbol,
    pub unused_gpl_crcs: *const s32,
    pub sig_ok: bool_,
    pub async_probe_requested: bool_,
    pub gpl_future_syms: *const kernel_symbol,
    pub gpl_future_crcs: *const s32,
    pub num_gpl_future_syms: c_types::c_uint,
    pub num_exentries: c_types::c_uint,
    pub extable: *mut exception_table_entry,
    pub init: ::core::option::Option<unsafe extern "C" fn() -> c_types::c_int>,
    pub core_layout: module_layout,
    pub init_layout: module_layout,
    pub arch: mod_arch_specific,
    pub taints: c_types::c_ulong,
    pub num_bugs: c_types::c_uint,
    pub bug_list: list_head,
    pub bug_table: *mut bug_entry,
    pub kallsyms: *mut mod_kallsyms,
    pub core_kallsyms: mod_kallsyms,
    pub sect_attrs: *mut module_sect_attrs,
    pub notes_attrs: *mut module_notes_attrs,
    pub args: *mut c_types::c_char,
    pub percpu: *mut c_types::c_void,
    pub percpu_size: c_types::c_uint,
    pub num_tracepoints: c_types::c_uint,
    pub tracepoints_ptrs: *mut tracepoint_ptr_t,
    pub num_srcu_structs: c_types::c_uint,
    pub srcu_struct_ptrs: *mut *mut srcu_struct,
    pub num_bpf_raw_events: c_types::c_uint,
    pub bpf_raw_events: *mut bpf_raw_event_map,
    pub jump_entries: *mut jump_entry,
    pub num_jump_entries: c_types::c_uint,
    pub num_trace_bprintk_fmt: c_types::c_uint,
    pub trace_bprintk_fmt_start: *mut *const c_types::c_char,
    pub trace_events: *mut *mut trace_event_call,
    pub num_trace_events: c_types::c_uint,
    pub trace_evals: *mut *mut trace_eval_map,
    pub num_trace_evals: c_types::c_uint,
    pub num_ftrace_callsites: c_types::c_uint,
    pub ftrace_callsites: *mut c_types::c_ulong,
    pub klp: bool_,
    pub klp_alive: bool_,
    pub klp_info: *mut klp_modinfo,
    pub source_list: list_head,
    pub target_list: list_head,
    pub exit: ::core::option::Option<unsafe extern "C" fn()>,
    pub refcnt: atomic_t,
    pub ei_funcs: *mut error_injection_entry,
    pub num_ei_funcs: c_types::c_uint,
}
#[test]
fn bindgen_test_layout_module() {
    assert_eq!(
        ::core::mem::size_of::<module>(),
        896usize,
        concat!("Size of: ", stringify!(module))
    );
    assert_eq!(
        ::core::mem::align_of::<module>(),
        64usize,
        concat!("Alignment of ", stringify!(module))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).state as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).list as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).name as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).mkobj as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(mkobj)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).modinfo_attrs as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(modinfo_attrs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).version as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).srcversion as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(srcversion)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).holders_dir as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(holders_dir)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).syms as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(syms)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).crcs as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(crcs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).num_syms as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(num_syms)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).param_lock as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(param_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).kp as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(kp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).num_kp as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(num_kp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).num_gpl_syms as *const _ as usize },
        276usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(num_gpl_syms)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).gpl_syms as *const _ as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(gpl_syms)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).gpl_crcs as *const _ as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(gpl_crcs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).unused_syms as *const _ as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(unused_syms)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).unused_crcs as *const _ as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(unused_crcs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).num_unused_syms as *const _ as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(num_unused_syms)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).num_unused_gpl_syms as *const _ as usize },
        316usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(num_unused_gpl_syms)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).unused_gpl_syms as *const _ as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(unused_gpl_syms)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).unused_gpl_crcs as *const _ as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(unused_gpl_crcs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).sig_ok as *const _ as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(sig_ok)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).async_probe_requested as *const _ as usize },
        337usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(async_probe_requested)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).gpl_future_syms as *const _ as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(gpl_future_syms)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).gpl_future_crcs as *const _ as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(gpl_future_crcs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).num_gpl_future_syms as *const _ as usize },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(num_gpl_future_syms)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).num_exentries as *const _ as usize },
        364usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(num_exentries)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).extable as *const _ as usize },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(extable)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).init as *const _ as usize },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(init)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).core_layout as *const _ as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(core_layout)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).init_layout as *const _ as usize },
        464usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(init_layout)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).arch as *const _ as usize },
        544usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(arch)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).taints as *const _ as usize },
        544usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(taints)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).num_bugs as *const _ as usize },
        552usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(num_bugs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).bug_list as *const _ as usize },
        560usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(bug_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).bug_table as *const _ as usize },
        576usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(bug_table)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).kallsyms as *const _ as usize },
        584usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(kallsyms)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).core_kallsyms as *const _ as usize },
        592usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(core_kallsyms)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).sect_attrs as *const _ as usize },
        624usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(sect_attrs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).notes_attrs as *const _ as usize },
        632usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(notes_attrs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).args as *const _ as usize },
        640usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(args)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).percpu as *const _ as usize },
        648usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(percpu)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).percpu_size as *const _ as usize },
        656usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(percpu_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).num_tracepoints as *const _ as usize },
        660usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(num_tracepoints)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).tracepoints_ptrs as *const _ as usize },
        664usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(tracepoints_ptrs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).num_srcu_structs as *const _ as usize },
        672usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(num_srcu_structs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).srcu_struct_ptrs as *const _ as usize },
        680usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(srcu_struct_ptrs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).num_bpf_raw_events as *const _ as usize },
        688usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(num_bpf_raw_events)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).bpf_raw_events as *const _ as usize },
        696usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(bpf_raw_events)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).jump_entries as *const _ as usize },
        704usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(jump_entries)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).num_jump_entries as *const _ as usize },
        712usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(num_jump_entries)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).num_trace_bprintk_fmt as *const _ as usize },
        716usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(num_trace_bprintk_fmt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).trace_bprintk_fmt_start as *const _ as usize },
        720usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(trace_bprintk_fmt_start)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).trace_events as *const _ as usize },
        728usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(trace_events)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).num_trace_events as *const _ as usize },
        736usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(num_trace_events)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).trace_evals as *const _ as usize },
        744usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(trace_evals)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).num_trace_evals as *const _ as usize },
        752usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(num_trace_evals)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).num_ftrace_callsites as *const _ as usize },
        756usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(num_ftrace_callsites)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).ftrace_callsites as *const _ as usize },
        760usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(ftrace_callsites)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).klp as *const _ as usize },
        768usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(klp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).klp_alive as *const _ as usize },
        769usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(klp_alive)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).klp_info as *const _ as usize },
        776usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(klp_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).source_list as *const _ as usize },
        784usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(source_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).target_list as *const _ as usize },
        800usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(target_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).exit as *const _ as usize },
        816usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(exit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).refcnt as *const _ as usize },
        824usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(refcnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).ei_funcs as *const _ as usize },
        832usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(ei_funcs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).num_ei_funcs as *const _ as usize },
        840usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(num_ei_funcs)
        )
    );
}
impl Default for module {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kernel_symbol {
    pub value_offset: c_types::c_int,
    pub name_offset: c_types::c_int,
    pub namespace_offset: c_types::c_int,
}
#[test]
fn bindgen_test_layout_kernel_symbol() {
    assert_eq!(
        ::core::mem::size_of::<kernel_symbol>(),
        12usize,
        concat!("Size of: ", stringify!(kernel_symbol))
    );
    assert_eq!(
        ::core::mem::align_of::<kernel_symbol>(),
        4usize,
        concat!("Alignment of ", stringify!(kernel_symbol))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernel_symbol>())).value_offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kernel_symbol),
            "::",
            stringify!(value_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernel_symbol>())).name_offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(kernel_symbol),
            "::",
            stringify!(name_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernel_symbol>())).namespace_offset as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(kernel_symbol),
            "::",
            stringify!(namespace_offset)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct file_system_type {
    pub name: *const c_types::c_char,
    pub fs_flags: c_types::c_int,
    pub init_fs_context:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut fs_context) -> c_types::c_int>,
    pub parameters: *const fs_parameter_description,
    pub mount: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file_system_type,
            arg2: c_types::c_int,
            arg3: *const c_types::c_char,
            arg4: *mut c_types::c_void,
        ) -> *mut dentry,
    >,
    pub kill_sb: ::core::option::Option<unsafe extern "C" fn(arg1: *mut super_block)>,
    pub owner: *mut module,
    pub next: *mut file_system_type,
    pub fs_supers: hlist_head,
    pub s_lock_key: lock_class_key,
    pub s_umount_key: lock_class_key,
    pub s_vfs_rename_key: lock_class_key,
    pub s_writers_key: [lock_class_key; 3usize],
    pub i_lock_key: lock_class_key,
    pub i_mutex_key: lock_class_key,
    pub i_mutex_dir_key: lock_class_key,
}
#[test]
fn bindgen_test_layout_file_system_type() {
    assert_eq!(
        ::core::mem::size_of::<file_system_type>(),
        72usize,
        concat!("Size of: ", stringify!(file_system_type))
    );
    assert_eq!(
        ::core::mem::align_of::<file_system_type>(),
        8usize,
        concat!("Alignment of ", stringify!(file_system_type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_system_type>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(file_system_type),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_system_type>())).fs_flags as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(file_system_type),
            "::",
            stringify!(fs_flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<file_system_type>())).init_fs_context as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(file_system_type),
            "::",
            stringify!(init_fs_context)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_system_type>())).parameters as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(file_system_type),
            "::",
            stringify!(parameters)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_system_type>())).mount as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(file_system_type),
            "::",
            stringify!(mount)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_system_type>())).kill_sb as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(file_system_type),
            "::",
            stringify!(kill_sb)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_system_type>())).owner as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(file_system_type),
            "::",
            stringify!(owner)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_system_type>())).next as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(file_system_type),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_system_type>())).fs_supers as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(file_system_type),
            "::",
            stringify!(fs_supers)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_system_type>())).s_lock_key as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(file_system_type),
            "::",
            stringify!(s_lock_key)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_system_type>())).s_umount_key as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(file_system_type),
            "::",
            stringify!(s_umount_key)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<file_system_type>())).s_vfs_rename_key as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(file_system_type),
            "::",
            stringify!(s_vfs_rename_key)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_system_type>())).s_writers_key as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(file_system_type),
            "::",
            stringify!(s_writers_key)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_system_type>())).i_lock_key as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(file_system_type),
            "::",
            stringify!(i_lock_key)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_system_type>())).i_mutex_key as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(file_system_type),
            "::",
            stringify!(i_mutex_key)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<file_system_type>())).i_mutex_dir_key as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(file_system_type),
            "::",
            stringify!(i_mutex_dir_key)
        )
    );
}
impl Default for file_system_type {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn printk(fmt: *const c_types::c_char, ...) -> c_types::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct static_key {
    pub enabled: atomic_t,
    pub __bindgen_anon_1: static_key__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union static_key__bindgen_ty_1 {
    pub type_: c_types::c_ulong,
    pub entries: *mut jump_entry,
    pub next: *mut static_key_mod,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_static_key__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<static_key__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(static_key__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<static_key__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(static_key__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<static_key__bindgen_ty_1>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(static_key__bindgen_ty_1),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<static_key__bindgen_ty_1>())).entries as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(static_key__bindgen_ty_1),
            "::",
            stringify!(entries)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<static_key__bindgen_ty_1>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(static_key__bindgen_ty_1),
            "::",
            stringify!(next)
        )
    );
}
impl Default for static_key__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_static_key() {
    assert_eq!(
        ::core::mem::size_of::<static_key>(),
        16usize,
        concat!("Size of: ", stringify!(static_key))
    );
    assert_eq!(
        ::core::mem::align_of::<static_key>(),
        8usize,
        concat!("Alignment of ", stringify!(static_key))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<static_key>())).enabled as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(static_key),
            "::",
            stringify!(enabled)
        )
    );
}
impl Default for static_key {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct jump_entry {
    pub code: s32,
    pub target: s32,
    pub key: c_types::c_long,
}
#[test]
fn bindgen_test_layout_jump_entry() {
    assert_eq!(
        ::core::mem::size_of::<jump_entry>(),
        16usize,
        concat!("Size of: ", stringify!(jump_entry))
    );
    assert_eq!(
        ::core::mem::align_of::<jump_entry>(),
        8usize,
        concat!("Alignment of ", stringify!(jump_entry))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<jump_entry>())).code as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(jump_entry),
            "::",
            stringify!(code)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<jump_entry>())).target as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(jump_entry),
            "::",
            stringify!(target)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<jump_entry>())).key as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(jump_entry),
            "::",
            stringify!(key)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct file_operations {
    pub owner: *mut module,
    pub llseek: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut file, arg2: loff_t, arg3: c_types::c_int) -> loff_t,
    >,
    pub read: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: *mut c_types::c_char,
            arg3: usize,
            arg4: *mut loff_t,
        ) -> isize,
    >,
    pub write: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: *const c_types::c_char,
            arg3: usize,
            arg4: *mut loff_t,
        ) -> isize,
    >,
    pub read_iter: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut kiocb, arg2: *mut iov_iter) -> isize,
    >,
    pub write_iter: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut kiocb, arg2: *mut iov_iter) -> isize,
    >,
    pub iopoll: ::core::option::Option<
        unsafe extern "C" fn(kiocb: *mut kiocb, spin: bool_) -> c_types::c_int,
    >,
    pub iterate: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut file, arg2: *mut dir_context) -> c_types::c_int,
    >,
    pub iterate_shared: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut file, arg2: *mut dir_context) -> c_types::c_int,
    >,
    pub poll: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut file, arg2: *mut poll_table_struct) -> __poll_t,
    >,
    pub unlocked_ioctl: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: c_types::c_uint,
            arg3: c_types::c_ulong,
        ) -> c_types::c_long,
    >,
    pub compat_ioctl: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: c_types::c_uint,
            arg3: c_types::c_ulong,
        ) -> c_types::c_long,
    >,
    pub mmap: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut file, arg2: *mut vm_area_struct) -> c_types::c_int,
    >,
    pub mmap_supported_flags: c_types::c_ulong,
    pub open: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut inode, arg2: *mut file) -> c_types::c_int,
    >,
    pub flush: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut file, id: fl_owner_t) -> c_types::c_int,
    >,
    pub release: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut inode, arg2: *mut file) -> c_types::c_int,
    >,
    pub fsync: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: loff_t,
            arg3: loff_t,
            datasync: c_types::c_int,
        ) -> c_types::c_int,
    >,
    pub fasync: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: c_types::c_int,
            arg2: *mut file,
            arg3: c_types::c_int,
        ) -> c_types::c_int,
    >,
    pub lock: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: c_types::c_int,
            arg3: *mut file_lock,
        ) -> c_types::c_int,
    >,
    pub sendpage: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: *mut page,
            arg3: c_types::c_int,
            arg4: usize,
            arg5: *mut loff_t,
            arg6: c_types::c_int,
        ) -> isize,
    >,
    pub get_unmapped_area: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: c_types::c_ulong,
            arg3: c_types::c_ulong,
            arg4: c_types::c_ulong,
            arg5: c_types::c_ulong,
        ) -> c_types::c_ulong,
    >,
    pub check_flags:
        ::core::option::Option<unsafe extern "C" fn(arg1: c_types::c_int) -> c_types::c_int>,
    pub setfl: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut file, arg2: c_types::c_ulong) -> c_types::c_int,
    >,
    pub flock: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: c_types::c_int,
            arg3: *mut file_lock,
        ) -> c_types::c_int,
    >,
    pub splice_write: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut pipe_inode_info,
            arg2: *mut file,
            arg3: *mut loff_t,
            arg4: usize,
            arg5: c_types::c_uint,
        ) -> isize,
    >,
    pub splice_read: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: *mut loff_t,
            arg3: *mut pipe_inode_info,
            arg4: usize,
            arg5: c_types::c_uint,
        ) -> isize,
    >,
    pub setlease: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: c_types::c_long,
            arg3: *mut *mut file_lock,
            arg4: *mut *mut c_types::c_void,
        ) -> c_types::c_int,
    >,
    pub fallocate: ::core::option::Option<
        unsafe extern "C" fn(
            file: *mut file,
            mode: c_types::c_int,
            offset: loff_t,
            len: loff_t,
        ) -> c_types::c_long,
    >,
    pub show_fdinfo: ::core::option::Option<unsafe extern "C" fn(m: *mut seq_file, f: *mut file)>,
    pub copy_file_range: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: loff_t,
            arg3: *mut file,
            arg4: loff_t,
            arg5: usize,
            arg6: c_types::c_uint,
        ) -> isize,
    >,
    pub remap_file_range: ::core::option::Option<
        unsafe extern "C" fn(
            file_in: *mut file,
            pos_in: loff_t,
            file_out: *mut file,
            pos_out: loff_t,
            len: loff_t,
            remap_flags: c_types::c_uint,
        ) -> loff_t,
    >,
    pub fadvise: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: loff_t,
            arg3: loff_t,
            arg4: c_types::c_int,
        ) -> c_types::c_int,
    >,
}
#[test]
fn bindgen_test_layout_file_operations() {
    assert_eq!(
        ::core::mem::size_of::<file_operations>(),
        264usize,
        concat!("Size of: ", stringify!(file_operations))
    );
    assert_eq!(
        ::core::mem::align_of::<file_operations>(),
        8usize,
        concat!("Alignment of ", stringify!(file_operations))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_operations>())).owner as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(file_operations),
            "::",
            stringify!(owner)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_operations>())).llseek as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(file_operations),
            "::",
            stringify!(llseek)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_operations>())).read as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(file_operations),
            "::",
            stringify!(read)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_operations>())).write as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(file_operations),
            "::",
            stringify!(write)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_operations>())).read_iter as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(file_operations),
            "::",
            stringify!(read_iter)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_operations>())).write_iter as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(file_operations),
            "::",
            stringify!(write_iter)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_operations>())).iopoll as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(file_operations),
            "::",
            stringify!(iopoll)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_operations>())).iterate as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(file_operations),
            "::",
            stringify!(iterate)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_operations>())).iterate_shared as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(file_operations),
            "::",
            stringify!(iterate_shared)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_operations>())).poll as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(file_operations),
            "::",
            stringify!(poll)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_operations>())).unlocked_ioctl as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(file_operations),
            "::",
            stringify!(unlocked_ioctl)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_operations>())).compat_ioctl as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(file_operations),
            "::",
            stringify!(compat_ioctl)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_operations>())).mmap as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(file_operations),
            "::",
            stringify!(mmap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<file_operations>())).mmap_supported_flags as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(file_operations),
            "::",
            stringify!(mmap_supported_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_operations>())).open as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(file_operations),
            "::",
            stringify!(open)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_operations>())).flush as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(file_operations),
            "::",
            stringify!(flush)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_operations>())).release as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(file_operations),
            "::",
            stringify!(release)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_operations>())).fsync as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(file_operations),
            "::",
            stringify!(fsync)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_operations>())).fasync as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(file_operations),
            "::",
            stringify!(fasync)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_operations>())).lock as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(file_operations),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_operations>())).sendpage as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(file_operations),
            "::",
            stringify!(sendpage)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<file_operations>())).get_unmapped_area as *const _ as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(file_operations),
            "::",
            stringify!(get_unmapped_area)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_operations>())).check_flags as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(file_operations),
            "::",
            stringify!(check_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_operations>())).setfl as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(file_operations),
            "::",
            stringify!(setfl)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_operations>())).flock as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(file_operations),
            "::",
            stringify!(flock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_operations>())).splice_write as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(file_operations),
            "::",
            stringify!(splice_write)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_operations>())).splice_read as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(file_operations),
            "::",
            stringify!(splice_read)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_operations>())).setlease as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(file_operations),
            "::",
            stringify!(setlease)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_operations>())).fallocate as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(file_operations),
            "::",
            stringify!(fallocate)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_operations>())).show_fdinfo as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(file_operations),
            "::",
            stringify!(show_fdinfo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<file_operations>())).copy_file_range as *const _ as usize
        },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(file_operations),
            "::",
            stringify!(copy_file_range)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<file_operations>())).remap_file_range as *const _ as usize
        },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(file_operations),
            "::",
            stringify!(remap_file_range)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_operations>())).fadvise as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(file_operations),
            "::",
            stringify!(fadvise)
        )
    );
}
impl Default for file_operations {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct bug_entry {
    pub bug_addr_disp: c_types::c_int,
    pub file_disp: c_types::c_int,
    pub line: c_types::c_ushort,
    pub flags: c_types::c_ushort,
}
#[test]
fn bindgen_test_layout_bug_entry() {
    assert_eq!(
        ::core::mem::size_of::<bug_entry>(),
        12usize,
        concat!("Size of: ", stringify!(bug_entry))
    );
    assert_eq!(
        ::core::mem::align_of::<bug_entry>(),
        4usize,
        concat!("Alignment of ", stringify!(bug_entry))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bug_entry>())).bug_addr_disp as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bug_entry),
            "::",
            stringify!(bug_addr_disp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bug_entry>())).file_disp as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(bug_entry),
            "::",
            stringify!(file_disp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bug_entry>())).line as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bug_entry),
            "::",
            stringify!(line)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bug_entry>())).flags as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(bug_entry),
            "::",
            stringify!(flags)
        )
    );
}
pub type time64_t = __s64;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __kernel_timespec {
    pub tv_sec: __kernel_time64_t,
    pub tv_nsec: c_types::c_longlong,
}
#[test]
fn bindgen_test_layout___kernel_timespec() {
    assert_eq!(
        ::core::mem::size_of::<__kernel_timespec>(),
        16usize,
        concat!("Size of: ", stringify!(__kernel_timespec))
    );
    assert_eq!(
        ::core::mem::align_of::<__kernel_timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(__kernel_timespec))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__kernel_timespec>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__kernel_timespec>())).tv_nsec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct timespec64 {
    pub tv_sec: time64_t,
    pub tv_nsec: c_types::c_long,
}
#[test]
fn bindgen_test_layout_timespec64() {
    assert_eq!(
        ::core::mem::size_of::<timespec64>(),
        16usize,
        concat!("Size of: ", stringify!(timespec64))
    );
    assert_eq!(
        ::core::mem::align_of::<timespec64>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec64))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timespec64>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec64),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timespec64>())).tv_nsec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec64),
            "::",
            stringify!(tv_nsec)
        )
    );
}
pub const timespec_type_TT_NONE: timespec_type = 0;
pub const timespec_type_TT_NATIVE: timespec_type = 1;
pub const timespec_type_TT_COMPAT: timespec_type = 2;
pub type timespec_type = c_types::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct restart_block {
    pub fn_:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut restart_block) -> c_types::c_long>,
    pub __bindgen_anon_1: restart_block__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union restart_block__bindgen_ty_1 {
    pub futex: restart_block__bindgen_ty_1__bindgen_ty_1,
    pub nanosleep: restart_block__bindgen_ty_1__bindgen_ty_2,
    pub poll: restart_block__bindgen_ty_1__bindgen_ty_3,
    _bindgen_union_align: [u64; 5usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct restart_block__bindgen_ty_1__bindgen_ty_1 {
    pub uaddr: *mut u32_,
    pub val: u32_,
    pub flags: u32_,
    pub bitset: u32_,
    pub time: u64_,
    pub uaddr2: *mut u32_,
}
#[test]
fn bindgen_test_layout_restart_block__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<restart_block__bindgen_ty_1__bindgen_ty_1>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(restart_block__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<restart_block__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(restart_block__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<restart_block__bindgen_ty_1__bindgen_ty_1>())).uaddr as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(restart_block__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(uaddr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<restart_block__bindgen_ty_1__bindgen_ty_1>())).val as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(restart_block__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(val)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<restart_block__bindgen_ty_1__bindgen_ty_1>())).flags as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(restart_block__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<restart_block__bindgen_ty_1__bindgen_ty_1>())).bitset
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(restart_block__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(bitset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<restart_block__bindgen_ty_1__bindgen_ty_1>())).time as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(restart_block__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<restart_block__bindgen_ty_1__bindgen_ty_1>())).uaddr2
                as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(restart_block__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(uaddr2)
        )
    );
}
impl Default for restart_block__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct restart_block__bindgen_ty_1__bindgen_ty_2 {
    pub clockid: clockid_t,
    pub type_: timespec_type,
    pub __bindgen_anon_1: restart_block__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1,
    pub expires: u64_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union restart_block__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 {
    pub rmtp: *mut __kernel_timespec,
    pub compat_rmtp: *mut old_timespec32,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_restart_block__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<restart_block__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(restart_block__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<restart_block__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(restart_block__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<restart_block__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1>()))
                .rmtp as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(restart_block__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(rmtp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<restart_block__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1>()))
                .compat_rmtp as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(restart_block__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(compat_rmtp)
        )
    );
}
impl Default for restart_block__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_restart_block__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<restart_block__bindgen_ty_1__bindgen_ty_2>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(restart_block__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<restart_block__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(restart_block__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<restart_block__bindgen_ty_1__bindgen_ty_2>())).clockid
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(restart_block__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(clockid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<restart_block__bindgen_ty_1__bindgen_ty_2>())).type_ as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(restart_block__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<restart_block__bindgen_ty_1__bindgen_ty_2>())).expires
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(restart_block__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(expires)
        )
    );
}
impl Default for restart_block__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct restart_block__bindgen_ty_1__bindgen_ty_3 {
    pub ufds: *mut pollfd,
    pub nfds: c_types::c_int,
    pub has_timeout: c_types::c_int,
    pub tv_sec: c_types::c_ulong,
    pub tv_nsec: c_types::c_ulong,
}
#[test]
fn bindgen_test_layout_restart_block__bindgen_ty_1__bindgen_ty_3() {
    assert_eq!(
        ::core::mem::size_of::<restart_block__bindgen_ty_1__bindgen_ty_3>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(restart_block__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<restart_block__bindgen_ty_1__bindgen_ty_3>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(restart_block__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<restart_block__bindgen_ty_1__bindgen_ty_3>())).ufds as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(restart_block__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(ufds)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<restart_block__bindgen_ty_1__bindgen_ty_3>())).nfds as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(restart_block__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(nfds)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<restart_block__bindgen_ty_1__bindgen_ty_3>())).has_timeout
                as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(restart_block__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(has_timeout)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<restart_block__bindgen_ty_1__bindgen_ty_3>())).tv_sec
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(restart_block__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<restart_block__bindgen_ty_1__bindgen_ty_3>())).tv_nsec
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(restart_block__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(tv_nsec)
        )
    );
}
impl Default for restart_block__bindgen_ty_1__bindgen_ty_3 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_restart_block__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<restart_block__bindgen_ty_1>(),
        40usize,
        concat!("Size of: ", stringify!(restart_block__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<restart_block__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(restart_block__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<restart_block__bindgen_ty_1>())).futex as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(restart_block__bindgen_ty_1),
            "::",
            stringify!(futex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<restart_block__bindgen_ty_1>())).nanosleep as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(restart_block__bindgen_ty_1),
            "::",
            stringify!(nanosleep)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<restart_block__bindgen_ty_1>())).poll as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(restart_block__bindgen_ty_1),
            "::",
            stringify!(poll)
        )
    );
}
impl Default for restart_block__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_restart_block() {
    assert_eq!(
        ::core::mem::size_of::<restart_block>(),
        48usize,
        concat!("Size of: ", stringify!(restart_block))
    );
    assert_eq!(
        ::core::mem::align_of::<restart_block>(),
        8usize,
        concat!("Alignment of ", stringify!(restart_block))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<restart_block>())).fn_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(restart_block),
            "::",
            stringify!(fn_)
        )
    );
}
impl Default for restart_block {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct pt_regs {
    pub r15: c_types::c_ulong,
    pub r14: c_types::c_ulong,
    pub r13: c_types::c_ulong,
    pub r12: c_types::c_ulong,
    pub bp: c_types::c_ulong,
    pub bx: c_types::c_ulong,
    pub r11: c_types::c_ulong,
    pub r10: c_types::c_ulong,
    pub r9: c_types::c_ulong,
    pub r8: c_types::c_ulong,
    pub ax: c_types::c_ulong,
    pub cx: c_types::c_ulong,
    pub dx: c_types::c_ulong,
    pub si: c_types::c_ulong,
    pub di: c_types::c_ulong,
    pub orig_ax: c_types::c_ulong,
    pub ip: c_types::c_ulong,
    pub cs: c_types::c_ulong,
    pub flags: c_types::c_ulong,
    pub sp: c_types::c_ulong,
    pub ss: c_types::c_ulong,
}
#[test]
fn bindgen_test_layout_pt_regs() {
    assert_eq!(
        ::core::mem::size_of::<pt_regs>(),
        168usize,
        concat!("Size of: ", stringify!(pt_regs))
    );
    assert_eq!(
        ::core::mem::align_of::<pt_regs>(),
        8usize,
        concat!("Alignment of ", stringify!(pt_regs))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pt_regs>())).r15 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(r15)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pt_regs>())).r14 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(r14)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pt_regs>())).r13 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(r13)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pt_regs>())).r12 as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(r12)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pt_regs>())).bp as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(bp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pt_regs>())).bx as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(bx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pt_regs>())).r11 as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(r11)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pt_regs>())).r10 as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(r10)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pt_regs>())).r9 as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(r9)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pt_regs>())).r8 as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(r8)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pt_regs>())).ax as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(ax)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pt_regs>())).cx as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(cx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pt_regs>())).dx as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(dx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pt_regs>())).si as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(si)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pt_regs>())).di as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(di)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pt_regs>())).orig_ax as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(orig_ax)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pt_regs>())).ip as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(ip)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pt_regs>())).cs as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(cs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pt_regs>())).flags as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pt_regs>())).sp as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(sp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pt_regs>())).ss as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(ss)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct desc_struct {
    pub limit0: u16_,
    pub base0: u16_,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
#[test]
fn bindgen_test_layout_desc_struct() {
    assert_eq!(
        ::core::mem::size_of::<desc_struct>(),
        8usize,
        concat!("Size of: ", stringify!(desc_struct))
    );
    assert_eq!(
        ::core::mem::align_of::<desc_struct>(),
        1usize,
        concat!("Alignment of ", stringify!(desc_struct))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<desc_struct>())).limit0 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(desc_struct),
            "::",
            stringify!(limit0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<desc_struct>())).base0 as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(desc_struct),
            "::",
            stringify!(base0)
        )
    );
}
impl desc_struct {
    #[inline]
    pub fn base1(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u16) }
    }
    #[inline]
    pub fn set_base1(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn type_(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_type(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn s(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_s(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dpl(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_dpl(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn p(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_p(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn limit1(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_limit1(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn avl(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_avl(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn l(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_l(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn d(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_d(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn g(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_g(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn base2(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u16) }
    }
    #[inline]
    pub fn set_base2(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        base1: u16_,
        type_: u16_,
        s: u16_,
        dpl: u16_,
        p: u16_,
        limit1: u16_,
        avl: u16_,
        l: u16_,
        d: u16_,
        g: u16_,
        base2: u16_,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let base1: u16 = unsafe { ::core::mem::transmute(base1) };
            base1 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let type_: u16 = unsafe { ::core::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let s: u16 = unsafe { ::core::mem::transmute(s) };
            s as u64
        });
        __bindgen_bitfield_unit.set(13usize, 2u8, {
            let dpl: u16 = unsafe { ::core::mem::transmute(dpl) };
            dpl as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let p: u16 = unsafe { ::core::mem::transmute(p) };
            p as u64
        });
        __bindgen_bitfield_unit.set(16usize, 4u8, {
            let limit1: u16 = unsafe { ::core::mem::transmute(limit1) };
            limit1 as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let avl: u16 = unsafe { ::core::mem::transmute(avl) };
            avl as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let l: u16 = unsafe { ::core::mem::transmute(l) };
            l as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let d: u16 = unsafe { ::core::mem::transmute(d) };
            d as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let g: u16 = unsafe { ::core::mem::transmute(g) };
            g as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let base2: u16 = unsafe { ::core::mem::transmute(base2) };
            base2 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type pteval_t = c_types::c_ulong;
pub type pmdval_t = c_types::c_ulong;
pub type pudval_t = c_types::c_ulong;
pub type pgdval_t = c_types::c_ulong;
pub type pgprotval_t = c_types::c_ulong;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct pte_t {
    pub pte: pteval_t,
}
#[test]
fn bindgen_test_layout_pte_t() {
    assert_eq!(
        ::core::mem::size_of::<pte_t>(),
        8usize,
        concat!("Size of: ", stringify!(pte_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pte_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pte_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pte_t>())).pte as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pte_t),
            "::",
            stringify!(pte)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct pgprot {
    pub pgprot: pgprotval_t,
}
#[test]
fn bindgen_test_layout_pgprot() {
    assert_eq!(
        ::core::mem::size_of::<pgprot>(),
        8usize,
        concat!("Size of: ", stringify!(pgprot))
    );
    assert_eq!(
        ::core::mem::align_of::<pgprot>(),
        8usize,
        concat!("Alignment of ", stringify!(pgprot))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pgprot>())).pgprot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pgprot),
            "::",
            stringify!(pgprot)
        )
    );
}
pub type pgprot_t = pgprot;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct pgd_t {
    pub pgd: pgdval_t,
}
#[test]
fn bindgen_test_layout_pgd_t() {
    assert_eq!(
        ::core::mem::size_of::<pgd_t>(),
        8usize,
        concat!("Size of: ", stringify!(pgd_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pgd_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pgd_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pgd_t>())).pgd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pgd_t),
            "::",
            stringify!(pgd)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct pud_t {
    pub pud: pudval_t,
}
#[test]
fn bindgen_test_layout_pud_t() {
    assert_eq!(
        ::core::mem::size_of::<pud_t>(),
        8usize,
        concat!("Size of: ", stringify!(pud_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pud_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pud_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pud_t>())).pud as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pud_t),
            "::",
            stringify!(pud)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct pmd_t {
    pub pmd: pmdval_t,
}
#[test]
fn bindgen_test_layout_pmd_t() {
    assert_eq!(
        ::core::mem::size_of::<pmd_t>(),
        8usize,
        concat!("Size of: ", stringify!(pmd_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pmd_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pmd_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pmd_t>())).pmd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pmd_t),
            "::",
            stringify!(pmd)
        )
    );
}
pub type pgtable_t = *mut page;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct qspinlock {
    pub __bindgen_anon_1: qspinlock__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union qspinlock__bindgen_ty_1 {
    pub val: atomic_t,
    pub __bindgen_anon_1: qspinlock__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: qspinlock__bindgen_ty_1__bindgen_ty_2,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct qspinlock__bindgen_ty_1__bindgen_ty_1 {
    pub locked: u8_,
    pub pending: u8_,
}
#[test]
fn bindgen_test_layout_qspinlock__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<qspinlock__bindgen_ty_1__bindgen_ty_1>(),
        2usize,
        concat!(
            "Size of: ",
            stringify!(qspinlock__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<qspinlock__bindgen_ty_1__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(qspinlock__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<qspinlock__bindgen_ty_1__bindgen_ty_1>())).locked as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qspinlock__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(locked)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<qspinlock__bindgen_ty_1__bindgen_ty_1>())).pending as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(qspinlock__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(pending)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct qspinlock__bindgen_ty_1__bindgen_ty_2 {
    pub locked_pending: u16_,
    pub tail: u16_,
}
#[test]
fn bindgen_test_layout_qspinlock__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<qspinlock__bindgen_ty_1__bindgen_ty_2>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(qspinlock__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<qspinlock__bindgen_ty_1__bindgen_ty_2>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(qspinlock__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<qspinlock__bindgen_ty_1__bindgen_ty_2>())).locked_pending
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qspinlock__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(locked_pending)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<qspinlock__bindgen_ty_1__bindgen_ty_2>())).tail as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(qspinlock__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(tail)
        )
    );
}
#[test]
fn bindgen_test_layout_qspinlock__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<qspinlock__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(qspinlock__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<qspinlock__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(qspinlock__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<qspinlock__bindgen_ty_1>())).val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qspinlock__bindgen_ty_1),
            "::",
            stringify!(val)
        )
    );
}
impl Default for qspinlock__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_qspinlock() {
    assert_eq!(
        ::core::mem::size_of::<qspinlock>(),
        4usize,
        concat!("Size of: ", stringify!(qspinlock))
    );
    assert_eq!(
        ::core::mem::align_of::<qspinlock>(),
        4usize,
        concat!("Alignment of ", stringify!(qspinlock))
    );
}
impl Default for qspinlock {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type arch_spinlock_t = qspinlock;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct qrwlock {
    pub __bindgen_anon_1: qrwlock__bindgen_ty_1,
    pub wait_lock: arch_spinlock_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union qrwlock__bindgen_ty_1 {
    pub cnts: atomic_t,
    pub __bindgen_anon_1: qrwlock__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct qrwlock__bindgen_ty_1__bindgen_ty_1 {
    pub wlocked: u8_,
    pub __lstate: [u8_; 3usize],
}
#[test]
fn bindgen_test_layout_qrwlock__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<qrwlock__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(qrwlock__bindgen_ty_1__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<qrwlock__bindgen_ty_1__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(qrwlock__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<qrwlock__bindgen_ty_1__bindgen_ty_1>())).wlocked as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qrwlock__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(wlocked)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<qrwlock__bindgen_ty_1__bindgen_ty_1>())).__lstate as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(qrwlock__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(__lstate)
        )
    );
}
#[test]
fn bindgen_test_layout_qrwlock__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<qrwlock__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(qrwlock__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<qrwlock__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(qrwlock__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<qrwlock__bindgen_ty_1>())).cnts as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qrwlock__bindgen_ty_1),
            "::",
            stringify!(cnts)
        )
    );
}
impl Default for qrwlock__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_qrwlock() {
    assert_eq!(
        ::core::mem::size_of::<qrwlock>(),
        8usize,
        concat!("Size of: ", stringify!(qrwlock))
    );
    assert_eq!(
        ::core::mem::align_of::<qrwlock>(),
        4usize,
        concat!("Alignment of ", stringify!(qrwlock))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<qrwlock>())).wait_lock as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(qrwlock),
            "::",
            stringify!(wait_lock)
        )
    );
}
impl Default for qrwlock {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type arch_rwlock_t = qrwlock;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct math_emu_info {
    pub ___orig_eip: c_types::c_long,
    pub regs: *mut pt_regs,
}
#[test]
fn bindgen_test_layout_math_emu_info() {
    assert_eq!(
        ::core::mem::size_of::<math_emu_info>(),
        16usize,
        concat!("Size of: ", stringify!(math_emu_info))
    );
    assert_eq!(
        ::core::mem::align_of::<math_emu_info>(),
        8usize,
        concat!("Alignment of ", stringify!(math_emu_info))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<math_emu_info>())).___orig_eip as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(math_emu_info),
            "::",
            stringify!(___orig_eip)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<math_emu_info>())).regs as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(math_emu_info),
            "::",
            stringify!(regs)
        )
    );
}
impl Default for math_emu_info {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type atomic_long_t = atomic64_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cpumask {
    pub bits: [c_types::c_ulong; 128usize],
}
#[test]
fn bindgen_test_layout_cpumask() {
    assert_eq!(
        ::core::mem::size_of::<cpumask>(),
        1024usize,
        concat!("Size of: ", stringify!(cpumask))
    );
    assert_eq!(
        ::core::mem::align_of::<cpumask>(),
        8usize,
        concat!("Alignment of ", stringify!(cpumask))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cpumask>())).bits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cpumask),
            "::",
            stringify!(bits)
        )
    );
}
impl Default for cpumask {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type cpumask_t = cpumask;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tracepoint_func {
    pub func: *mut c_types::c_void,
    pub data: *mut c_types::c_void,
    pub prio: c_types::c_int,
}
#[test]
fn bindgen_test_layout_tracepoint_func() {
    assert_eq!(
        ::core::mem::size_of::<tracepoint_func>(),
        24usize,
        concat!("Size of: ", stringify!(tracepoint_func))
    );
    assert_eq!(
        ::core::mem::align_of::<tracepoint_func>(),
        8usize,
        concat!("Alignment of ", stringify!(tracepoint_func))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tracepoint_func>())).func as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tracepoint_func),
            "::",
            stringify!(func)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tracepoint_func>())).data as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tracepoint_func),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tracepoint_func>())).prio as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tracepoint_func),
            "::",
            stringify!(prio)
        )
    );
}
impl Default for tracepoint_func {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tracepoint {
    pub name: *const c_types::c_char,
    pub key: static_key,
    pub regfunc: ::core::option::Option<unsafe extern "C" fn() -> c_types::c_int>,
    pub unregfunc: ::core::option::Option<unsafe extern "C" fn()>,
    pub funcs: *mut tracepoint_func,
}
#[test]
fn bindgen_test_layout_tracepoint() {
    assert_eq!(
        ::core::mem::size_of::<tracepoint>(),
        48usize,
        concat!("Size of: ", stringify!(tracepoint))
    );
    assert_eq!(
        ::core::mem::align_of::<tracepoint>(),
        8usize,
        concat!("Alignment of ", stringify!(tracepoint))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tracepoint>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tracepoint),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tracepoint>())).key as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tracepoint),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tracepoint>())).regfunc as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(tracepoint),
            "::",
            stringify!(regfunc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tracepoint>())).unregfunc as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(tracepoint),
            "::",
            stringify!(unregfunc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tracepoint>())).funcs as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(tracepoint),
            "::",
            stringify!(funcs)
        )
    );
}
impl Default for tracepoint {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type tracepoint_ptr_t = c_types::c_int;
#[repr(C)]
#[repr(align(32))]
#[derive(Debug, Copy, Clone)]
pub struct bpf_raw_event_map {
    pub tp: *mut tracepoint,
    pub bpf_func: *mut c_types::c_void,
    pub num_args: u32_,
    pub writable_size: u32_,
}
#[test]
fn bindgen_test_layout_bpf_raw_event_map() {
    assert_eq!(
        ::core::mem::size_of::<bpf_raw_event_map>(),
        32usize,
        concat!("Size of: ", stringify!(bpf_raw_event_map))
    );
    assert_eq!(
        ::core::mem::align_of::<bpf_raw_event_map>(),
        32usize,
        concat!("Alignment of ", stringify!(bpf_raw_event_map))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_raw_event_map>())).tp as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_raw_event_map),
            "::",
            stringify!(tp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_raw_event_map>())).bpf_func as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_raw_event_map),
            "::",
            stringify!(bpf_func)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_raw_event_map>())).num_args as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_raw_event_map),
            "::",
            stringify!(num_args)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bpf_raw_event_map>())).writable_size as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_raw_event_map),
            "::",
            stringify!(writable_size)
        )
    );
}
impl Default for bpf_raw_event_map {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct fregs_state {
    pub cwd: u32_,
    pub swd: u32_,
    pub twd: u32_,
    pub fip: u32_,
    pub fcs: u32_,
    pub foo: u32_,
    pub fos: u32_,
    pub st_space: [u32_; 20usize],
    pub status: u32_,
}
#[test]
fn bindgen_test_layout_fregs_state() {
    assert_eq!(
        ::core::mem::size_of::<fregs_state>(),
        112usize,
        concat!("Size of: ", stringify!(fregs_state))
    );
    assert_eq!(
        ::core::mem::align_of::<fregs_state>(),
        4usize,
        concat!("Alignment of ", stringify!(fregs_state))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fregs_state>())).cwd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fregs_state),
            "::",
            stringify!(cwd)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fregs_state>())).swd as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(fregs_state),
            "::",
            stringify!(swd)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fregs_state>())).twd as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(fregs_state),
            "::",
            stringify!(twd)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fregs_state>())).fip as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(fregs_state),
            "::",
            stringify!(fip)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fregs_state>())).fcs as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(fregs_state),
            "::",
            stringify!(fcs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fregs_state>())).foo as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(fregs_state),
            "::",
            stringify!(foo)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fregs_state>())).fos as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(fregs_state),
            "::",
            stringify!(fos)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fregs_state>())).st_space as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(fregs_state),
            "::",
            stringify!(st_space)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fregs_state>())).status as *const _ as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(fregs_state),
            "::",
            stringify!(status)
        )
    );
}
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct fxregs_state {
    pub cwd: u16_,
    pub swd: u16_,
    pub twd: u16_,
    pub fop: u16_,
    pub __bindgen_anon_1: fxregs_state__bindgen_ty_1,
    pub mxcsr: u32_,
    pub mxcsr_mask: u32_,
    pub st_space: [u32_; 32usize],
    pub xmm_space: [u32_; 64usize],
    pub padding: [u32_; 12usize],
    pub __bindgen_anon_2: fxregs_state__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union fxregs_state__bindgen_ty_1 {
    pub __bindgen_anon_1: fxregs_state__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: fxregs_state__bindgen_ty_1__bindgen_ty_2,
    _bindgen_union_align: [u64; 2usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct fxregs_state__bindgen_ty_1__bindgen_ty_1 {
    pub rip: u64_,
    pub rdp: u64_,
}
#[test]
fn bindgen_test_layout_fxregs_state__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<fxregs_state__bindgen_ty_1__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(fxregs_state__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<fxregs_state__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(fxregs_state__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<fxregs_state__bindgen_ty_1__bindgen_ty_1>())).rip as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fxregs_state__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(rip)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<fxregs_state__bindgen_ty_1__bindgen_ty_1>())).rdp as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(fxregs_state__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(rdp)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct fxregs_state__bindgen_ty_1__bindgen_ty_2 {
    pub fip: u32_,
    pub fcs: u32_,
    pub foo: u32_,
    pub fos: u32_,
}
#[test]
fn bindgen_test_layout_fxregs_state__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<fxregs_state__bindgen_ty_1__bindgen_ty_2>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(fxregs_state__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<fxregs_state__bindgen_ty_1__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(fxregs_state__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<fxregs_state__bindgen_ty_1__bindgen_ty_2>())).fip as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fxregs_state__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(fip)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<fxregs_state__bindgen_ty_1__bindgen_ty_2>())).fcs as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(fxregs_state__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(fcs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<fxregs_state__bindgen_ty_1__bindgen_ty_2>())).foo as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(fxregs_state__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(foo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<fxregs_state__bindgen_ty_1__bindgen_ty_2>())).fos as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(fxregs_state__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(fos)
        )
    );
}
#[test]
fn bindgen_test_layout_fxregs_state__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<fxregs_state__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(fxregs_state__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<fxregs_state__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(fxregs_state__bindgen_ty_1))
    );
}
impl Default for fxregs_state__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union fxregs_state__bindgen_ty_2 {
    pub padding1: [u32_; 12usize],
    pub sw_reserved: [u32_; 12usize],
    _bindgen_union_align: [u32; 12usize],
}
#[test]
fn bindgen_test_layout_fxregs_state__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<fxregs_state__bindgen_ty_2>(),
        48usize,
        concat!("Size of: ", stringify!(fxregs_state__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<fxregs_state__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(fxregs_state__bindgen_ty_2))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<fxregs_state__bindgen_ty_2>())).padding1 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fxregs_state__bindgen_ty_2),
            "::",
            stringify!(padding1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<fxregs_state__bindgen_ty_2>())).sw_reserved as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fxregs_state__bindgen_ty_2),
            "::",
            stringify!(sw_reserved)
        )
    );
}
impl Default for fxregs_state__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_fxregs_state() {
    assert_eq!(
        ::core::mem::size_of::<fxregs_state>(),
        512usize,
        concat!("Size of: ", stringify!(fxregs_state))
    );
    assert_eq!(
        ::core::mem::align_of::<fxregs_state>(),
        16usize,
        concat!("Alignment of ", stringify!(fxregs_state))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fxregs_state>())).cwd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fxregs_state),
            "::",
            stringify!(cwd)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fxregs_state>())).swd as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(fxregs_state),
            "::",
            stringify!(swd)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fxregs_state>())).twd as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(fxregs_state),
            "::",
            stringify!(twd)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fxregs_state>())).fop as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(fxregs_state),
            "::",
            stringify!(fop)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fxregs_state>())).mxcsr as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(fxregs_state),
            "::",
            stringify!(mxcsr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fxregs_state>())).mxcsr_mask as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(fxregs_state),
            "::",
            stringify!(mxcsr_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fxregs_state>())).st_space as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(fxregs_state),
            "::",
            stringify!(st_space)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fxregs_state>())).xmm_space as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(fxregs_state),
            "::",
            stringify!(xmm_space)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fxregs_state>())).padding as *const _ as usize },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(fxregs_state),
            "::",
            stringify!(padding)
        )
    );
}
impl Default for fxregs_state {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct swregs_state {
    pub cwd: u32_,
    pub swd: u32_,
    pub twd: u32_,
    pub fip: u32_,
    pub fcs: u32_,
    pub foo: u32_,
    pub fos: u32_,
    pub st_space: [u32_; 20usize],
    pub ftop: u8_,
    pub changed: u8_,
    pub lookahead: u8_,
    pub no_update: u8_,
    pub rm: u8_,
    pub alimit: u8_,
    pub info: *mut math_emu_info,
    pub entry_eip: u32_,
}
#[test]
fn bindgen_test_layout_swregs_state() {
    assert_eq!(
        ::core::mem::size_of::<swregs_state>(),
        136usize,
        concat!("Size of: ", stringify!(swregs_state))
    );
    assert_eq!(
        ::core::mem::align_of::<swregs_state>(),
        8usize,
        concat!("Alignment of ", stringify!(swregs_state))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<swregs_state>())).cwd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(swregs_state),
            "::",
            stringify!(cwd)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<swregs_state>())).swd as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(swregs_state),
            "::",
            stringify!(swd)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<swregs_state>())).twd as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(swregs_state),
            "::",
            stringify!(twd)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<swregs_state>())).fip as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(swregs_state),
            "::",
            stringify!(fip)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<swregs_state>())).fcs as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(swregs_state),
            "::",
            stringify!(fcs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<swregs_state>())).foo as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(swregs_state),
            "::",
            stringify!(foo)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<swregs_state>())).fos as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(swregs_state),
            "::",
            stringify!(fos)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<swregs_state>())).st_space as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(swregs_state),
            "::",
            stringify!(st_space)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<swregs_state>())).ftop as *const _ as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(swregs_state),
            "::",
            stringify!(ftop)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<swregs_state>())).changed as *const _ as usize },
        109usize,
        concat!(
            "Offset of field: ",
            stringify!(swregs_state),
            "::",
            stringify!(changed)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<swregs_state>())).lookahead as *const _ as usize },
        110usize,
        concat!(
            "Offset of field: ",
            stringify!(swregs_state),
            "::",
            stringify!(lookahead)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<swregs_state>())).no_update as *const _ as usize },
        111usize,
        concat!(
            "Offset of field: ",
            stringify!(swregs_state),
            "::",
            stringify!(no_update)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<swregs_state>())).rm as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(swregs_state),
            "::",
            stringify!(rm)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<swregs_state>())).alimit as *const _ as usize },
        113usize,
        concat!(
            "Offset of field: ",
            stringify!(swregs_state),
            "::",
            stringify!(alimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<swregs_state>())).info as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(swregs_state),
            "::",
            stringify!(info)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<swregs_state>())).entry_eip as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(swregs_state),
            "::",
            stringify!(entry_eip)
        )
    );
}
impl Default for swregs_state {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[repr(align(64))]
pub struct xregs_state {
    pub _bindgen_opaque_blob: [u8; 576usize],
}
#[test]
fn bindgen_test_layout_xregs_state() {
    assert_eq!(
        ::core::mem::size_of::<xregs_state>(),
        576usize,
        concat!("Size of: ", stringify!(xregs_state))
    );
    assert_eq!(
        ::core::mem::align_of::<xregs_state>(),
        64usize,
        concat!("Alignment of ", stringify!(xregs_state))
    );
}
impl Default for xregs_state {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[repr(align(64))]
pub struct fpregs_state {
    pub fsave: __BindgenUnionField<fregs_state>,
    pub fxsave: __BindgenUnionField<fxregs_state>,
    pub soft: __BindgenUnionField<swregs_state>,
    pub xsave: __BindgenUnionField<xregs_state>,
    pub __padding: __BindgenUnionField<[u8_; 4096usize]>,
    pub bindgen_union_field: [u8; 4096usize],
}
#[test]
fn bindgen_test_layout_fpregs_state() {
    assert_eq!(
        ::core::mem::size_of::<fpregs_state>(),
        4096usize,
        concat!("Size of: ", stringify!(fpregs_state))
    );
    assert_eq!(
        ::core::mem::align_of::<fpregs_state>(),
        64usize,
        concat!("Alignment of ", stringify!(fpregs_state))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fpregs_state>())).fsave as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fpregs_state),
            "::",
            stringify!(fsave)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fpregs_state>())).fxsave as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fpregs_state),
            "::",
            stringify!(fxsave)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fpregs_state>())).soft as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fpregs_state),
            "::",
            stringify!(soft)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fpregs_state>())).xsave as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fpregs_state),
            "::",
            stringify!(xsave)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fpregs_state>())).__padding as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fpregs_state),
            "::",
            stringify!(__padding)
        )
    );
}
impl Default for fpregs_state {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[repr(align(64))]
pub struct fpu {
    pub last_cpu: c_types::c_uint,
    pub avx512_timestamp: c_types::c_ulong,
    pub __bindgen_padding_0: [u64; 6usize],
    pub state: fpregs_state,
}
#[test]
fn bindgen_test_layout_fpu() {
    assert_eq!(
        ::core::mem::size_of::<fpu>(),
        4160usize,
        concat!("Size of: ", stringify!(fpu))
    );
    assert_eq!(
        ::core::mem::align_of::<fpu>(),
        64usize,
        concat!("Alignment of ", stringify!(fpu))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fpu>())).last_cpu as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fpu),
            "::",
            stringify!(last_cpu)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fpu>())).avx512_timestamp as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(fpu),
            "::",
            stringify!(avx512_timestamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fpu>())).state as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(fpu),
            "::",
            stringify!(state)
        )
    );
}
impl Default for fpu {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct seq_operations {
    pub start: ::core::option::Option<
        unsafe extern "C" fn(m: *mut seq_file, pos: *mut loff_t) -> *mut c_types::c_void,
    >,
    pub stop:
        ::core::option::Option<unsafe extern "C" fn(m: *mut seq_file, v: *mut c_types::c_void)>,
    pub next: ::core::option::Option<
        unsafe extern "C" fn(
            m: *mut seq_file,
            v: *mut c_types::c_void,
            pos: *mut loff_t,
        ) -> *mut c_types::c_void,
    >,
    pub show: ::core::option::Option<
        unsafe extern "C" fn(m: *mut seq_file, v: *mut c_types::c_void) -> c_types::c_int,
    >,
}
#[test]
fn bindgen_test_layout_seq_operations() {
    assert_eq!(
        ::core::mem::size_of::<seq_operations>(),
        32usize,
        concat!("Size of: ", stringify!(seq_operations))
    );
    assert_eq!(
        ::core::mem::align_of::<seq_operations>(),
        8usize,
        concat!("Alignment of ", stringify!(seq_operations))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<seq_operations>())).start as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(seq_operations),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<seq_operations>())).stop as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(seq_operations),
            "::",
            stringify!(stop)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<seq_operations>())).next as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(seq_operations),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<seq_operations>())).show as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(seq_operations),
            "::",
            stringify!(show)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct perf_event {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct mm_segment_t {
    pub seg: c_types::c_ulong,
}
#[test]
fn bindgen_test_layout_mm_segment_t() {
    assert_eq!(
        ::core::mem::size_of::<mm_segment_t>(),
        8usize,
        concat!("Size of: ", stringify!(mm_segment_t))
    );
    assert_eq!(
        ::core::mem::align_of::<mm_segment_t>(),
        8usize,
        concat!("Alignment of ", stringify!(mm_segment_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mm_segment_t>())).seg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_segment_t),
            "::",
            stringify!(seg)
        )
    );
}
#[repr(C)]
#[repr(align(64))]
pub struct thread_struct {
    pub tls_array: [desc_struct; 3usize],
    pub sp: c_types::c_ulong,
    pub es: c_types::c_ushort,
    pub ds: c_types::c_ushort,
    pub fsindex: c_types::c_ushort,
    pub gsindex: c_types::c_ushort,
    pub fsbase: c_types::c_ulong,
    pub gsbase: c_types::c_ulong,
    pub ptrace_bps: [*mut perf_event; 4usize],
    pub debugreg6: c_types::c_ulong,
    pub ptrace_dr7: c_types::c_ulong,
    pub cr2: c_types::c_ulong,
    pub trap_nr: c_types::c_ulong,
    pub error_code: c_types::c_ulong,
    pub io_bitmap_ptr: *mut c_types::c_ulong,
    pub iopl: c_types::c_ulong,
    pub io_bitmap_max: c_types::c_uint,
    pub addr_limit: mm_segment_t,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u64; 3usize],
    pub fpu: fpu,
}
#[test]
fn bindgen_test_layout_thread_struct() {
    assert_eq!(
        ::core::mem::size_of::<thread_struct>(),
        4352usize,
        concat!("Size of: ", stringify!(thread_struct))
    );
    assert_eq!(
        ::core::mem::align_of::<thread_struct>(),
        64usize,
        concat!("Alignment of ", stringify!(thread_struct))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<thread_struct>())).tls_array as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_struct),
            "::",
            stringify!(tls_array)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<thread_struct>())).sp as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_struct),
            "::",
            stringify!(sp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<thread_struct>())).es as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_struct),
            "::",
            stringify!(es)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<thread_struct>())).ds as *const _ as usize },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_struct),
            "::",
            stringify!(ds)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<thread_struct>())).fsindex as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_struct),
            "::",
            stringify!(fsindex)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<thread_struct>())).gsindex as *const _ as usize },
        38usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_struct),
            "::",
            stringify!(gsindex)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<thread_struct>())).fsbase as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_struct),
            "::",
            stringify!(fsbase)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<thread_struct>())).gsbase as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_struct),
            "::",
            stringify!(gsbase)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<thread_struct>())).ptrace_bps as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_struct),
            "::",
            stringify!(ptrace_bps)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<thread_struct>())).debugreg6 as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_struct),
            "::",
            stringify!(debugreg6)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<thread_struct>())).ptrace_dr7 as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_struct),
            "::",
            stringify!(ptrace_dr7)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<thread_struct>())).cr2 as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_struct),
            "::",
            stringify!(cr2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<thread_struct>())).trap_nr as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_struct),
            "::",
            stringify!(trap_nr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<thread_struct>())).error_code as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_struct),
            "::",
            stringify!(error_code)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<thread_struct>())).io_bitmap_ptr as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_struct),
            "::",
            stringify!(io_bitmap_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<thread_struct>())).iopl as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_struct),
            "::",
            stringify!(iopl)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<thread_struct>())).io_bitmap_max as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_struct),
            "::",
            stringify!(io_bitmap_max)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<thread_struct>())).addr_limit as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_struct),
            "::",
            stringify!(addr_limit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<thread_struct>())).fpu as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_struct),
            "::",
            stringify!(fpu)
        )
    );
}
impl Default for thread_struct {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl thread_struct {
    #[inline]
    pub fn sig_on_uaccess_err(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sig_on_uaccess_err(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn uaccess_err(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_uaccess_err(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        sig_on_uaccess_err: c_types::c_uint,
        uaccess_err: c_types::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let sig_on_uaccess_err: u32 = unsafe { ::core::mem::transmute(sig_on_uaccess_err) };
            sig_on_uaccess_err as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let uaccess_err: u32 = unsafe { ::core::mem::transmute(uaccess_err) };
            uaccess_err as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct thread_info {
    pub flags: c_types::c_ulong,
    pub status: u32_,
}
#[test]
fn bindgen_test_layout_thread_info() {
    assert_eq!(
        ::core::mem::size_of::<thread_info>(),
        16usize,
        concat!("Size of: ", stringify!(thread_info))
    );
    assert_eq!(
        ::core::mem::align_of::<thread_info>(),
        8usize,
        concat!("Alignment of ", stringify!(thread_info))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<thread_info>())).flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_info),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<thread_info>())).status as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_info),
            "::",
            stringify!(status)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct lock_class_key {}
#[test]
fn bindgen_test_layout_lock_class_key() {
    assert_eq!(
        ::core::mem::size_of::<lock_class_key>(),
        0usize,
        concat!("Size of: ", stringify!(lock_class_key))
    );
    assert_eq!(
        ::core::mem::align_of::<lock_class_key>(),
        1usize,
        concat!("Alignment of ", stringify!(lock_class_key))
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct lockdep_map {}
#[test]
fn bindgen_test_layout_lockdep_map() {
    assert_eq!(
        ::core::mem::size_of::<lockdep_map>(),
        0usize,
        concat!("Size of: ", stringify!(lockdep_map))
    );
    assert_eq!(
        ::core::mem::align_of::<lockdep_map>(),
        1usize,
        concat!("Alignment of ", stringify!(lockdep_map))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct raw_spinlock {
    pub raw_lock: arch_spinlock_t,
}
#[test]
fn bindgen_test_layout_raw_spinlock() {
    assert_eq!(
        ::core::mem::size_of::<raw_spinlock>(),
        4usize,
        concat!("Size of: ", stringify!(raw_spinlock))
    );
    assert_eq!(
        ::core::mem::align_of::<raw_spinlock>(),
        4usize,
        concat!("Alignment of ", stringify!(raw_spinlock))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<raw_spinlock>())).raw_lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(raw_spinlock),
            "::",
            stringify!(raw_lock)
        )
    );
}
impl Default for raw_spinlock {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type raw_spinlock_t = raw_spinlock;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct spinlock {
    pub __bindgen_anon_1: spinlock__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spinlock__bindgen_ty_1 {
    pub rlock: raw_spinlock,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_spinlock__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<spinlock__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(spinlock__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<spinlock__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(spinlock__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<spinlock__bindgen_ty_1>())).rlock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spinlock__bindgen_ty_1),
            "::",
            stringify!(rlock)
        )
    );
}
impl Default for spinlock__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_spinlock() {
    assert_eq!(
        ::core::mem::size_of::<spinlock>(),
        4usize,
        concat!("Size of: ", stringify!(spinlock))
    );
    assert_eq!(
        ::core::mem::align_of::<spinlock>(),
        4usize,
        concat!("Alignment of ", stringify!(spinlock))
    );
}
impl Default for spinlock {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type spinlock_t = spinlock;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rwlock_t {
    pub raw_lock: arch_rwlock_t,
}
#[test]
fn bindgen_test_layout_rwlock_t() {
    assert_eq!(
        ::core::mem::size_of::<rwlock_t>(),
        8usize,
        concat!("Size of: ", stringify!(rwlock_t))
    );
    assert_eq!(
        ::core::mem::align_of::<rwlock_t>(),
        4usize,
        concat!("Alignment of ", stringify!(rwlock_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rwlock_t>())).raw_lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rwlock_t),
            "::",
            stringify!(raw_lock)
        )
    );
}
impl Default for rwlock_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct seqcount {
    pub sequence: c_types::c_uint,
}
#[test]
fn bindgen_test_layout_seqcount() {
    assert_eq!(
        ::core::mem::size_of::<seqcount>(),
        4usize,
        concat!("Size of: ", stringify!(seqcount))
    );
    assert_eq!(
        ::core::mem::align_of::<seqcount>(),
        4usize,
        concat!("Alignment of ", stringify!(seqcount))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<seqcount>())).sequence as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(seqcount),
            "::",
            stringify!(sequence)
        )
    );
}
pub type seqcount_t = seqcount;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct seqlock_t {
    pub seqcount: seqcount,
    pub lock: spinlock_t,
}
#[test]
fn bindgen_test_layout_seqlock_t() {
    assert_eq!(
        ::core::mem::size_of::<seqlock_t>(),
        8usize,
        concat!("Size of: ", stringify!(seqlock_t))
    );
    assert_eq!(
        ::core::mem::align_of::<seqlock_t>(),
        4usize,
        concat!("Alignment of ", stringify!(seqlock_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<seqlock_t>())).seqcount as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(seqlock_t),
            "::",
            stringify!(seqcount)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<seqlock_t>())).lock as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(seqlock_t),
            "::",
            stringify!(lock)
        )
    );
}
impl Default for seqlock_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type old_time32_t = s32;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct old_timespec32 {
    pub tv_sec: old_time32_t,
    pub tv_nsec: s32,
}
#[test]
fn bindgen_test_layout_old_timespec32() {
    assert_eq!(
        ::core::mem::size_of::<old_timespec32>(),
        8usize,
        concat!("Size of: ", stringify!(old_timespec32))
    );
    assert_eq!(
        ::core::mem::align_of::<old_timespec32>(),
        4usize,
        concat!("Alignment of ", stringify!(old_timespec32))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<old_timespec32>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(old_timespec32),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<old_timespec32>())).tv_nsec as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(old_timespec32),
            "::",
            stringify!(tv_nsec)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wait_queue_head {
    pub lock: spinlock_t,
    pub head: list_head,
}
#[test]
fn bindgen_test_layout_wait_queue_head() {
    assert_eq!(
        ::core::mem::size_of::<wait_queue_head>(),
        24usize,
        concat!("Size of: ", stringify!(wait_queue_head))
    );
    assert_eq!(
        ::core::mem::align_of::<wait_queue_head>(),
        8usize,
        concat!("Alignment of ", stringify!(wait_queue_head))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<wait_queue_head>())).lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wait_queue_head),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<wait_queue_head>())).head as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wait_queue_head),
            "::",
            stringify!(head)
        )
    );
}
impl Default for wait_queue_head {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type wait_queue_head_t = wait_queue_head;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct nodemask_t {
    pub bits: [c_types::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout_nodemask_t() {
    assert_eq!(
        ::core::mem::size_of::<nodemask_t>(),
        128usize,
        concat!("Size of: ", stringify!(nodemask_t))
    );
    assert_eq!(
        ::core::mem::align_of::<nodemask_t>(),
        8usize,
        concat!("Alignment of ", stringify!(nodemask_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nodemask_t>())).bits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nodemask_t),
            "::",
            stringify!(bits)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct arch_tlbflush_unmap_batch {
    pub cpumask: cpumask,
}
#[test]
fn bindgen_test_layout_arch_tlbflush_unmap_batch() {
    assert_eq!(
        ::core::mem::size_of::<arch_tlbflush_unmap_batch>(),
        1024usize,
        concat!("Size of: ", stringify!(arch_tlbflush_unmap_batch))
    );
    assert_eq!(
        ::core::mem::align_of::<arch_tlbflush_unmap_batch>(),
        8usize,
        concat!("Alignment of ", stringify!(arch_tlbflush_unmap_batch))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arch_tlbflush_unmap_batch>())).cpumask as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arch_tlbflush_unmap_batch),
            "::",
            stringify!(cpumask)
        )
    );
}
impl Default for arch_tlbflush_unmap_batch {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vmacache {
    pub seqnum: u64_,
    pub vmas: [*mut vm_area_struct; 4usize],
}
#[test]
fn bindgen_test_layout_vmacache() {
    assert_eq!(
        ::core::mem::size_of::<vmacache>(),
        40usize,
        concat!("Size of: ", stringify!(vmacache))
    );
    assert_eq!(
        ::core::mem::align_of::<vmacache>(),
        8usize,
        concat!("Alignment of ", stringify!(vmacache))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vmacache>())).seqnum as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vmacache),
            "::",
            stringify!(seqnum)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vmacache>())).vmas as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vmacache),
            "::",
            stringify!(vmas)
        )
    );
}
impl Default for vmacache {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct task_rss_stat {
    pub events: c_types::c_int,
    pub count: [c_types::c_int; 4usize],
}
#[test]
fn bindgen_test_layout_task_rss_stat() {
    assert_eq!(
        ::core::mem::size_of::<task_rss_stat>(),
        20usize,
        concat!("Size of: ", stringify!(task_rss_stat))
    );
    assert_eq!(
        ::core::mem::align_of::<task_rss_stat>(),
        4usize,
        concat!("Alignment of ", stringify!(task_rss_stat))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_rss_stat>())).events as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(task_rss_stat),
            "::",
            stringify!(events)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_rss_stat>())).count as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(task_rss_stat),
            "::",
            stringify!(count)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct mm_rss_stat {
    pub count: [atomic_long_t; 4usize],
}
#[test]
fn bindgen_test_layout_mm_rss_stat() {
    assert_eq!(
        ::core::mem::size_of::<mm_rss_stat>(),
        32usize,
        concat!("Size of: ", stringify!(mm_rss_stat))
    );
    assert_eq!(
        ::core::mem::align_of::<mm_rss_stat>(),
        8usize,
        concat!("Alignment of ", stringify!(mm_rss_stat))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mm_rss_stat>())).count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_rss_stat),
            "::",
            stringify!(count)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct page_frag {
    pub page: *mut page,
    pub offset: __u32,
    pub size: __u32,
}
#[test]
fn bindgen_test_layout_page_frag() {
    assert_eq!(
        ::core::mem::size_of::<page_frag>(),
        16usize,
        concat!("Size of: ", stringify!(page_frag))
    );
    assert_eq!(
        ::core::mem::align_of::<page_frag>(),
        8usize,
        concat!("Alignment of ", stringify!(page_frag))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<page_frag>())).page as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(page_frag),
            "::",
            stringify!(page)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<page_frag>())).offset as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(page_frag),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<page_frag>())).size as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(page_frag),
            "::",
            stringify!(size)
        )
    );
}
impl Default for page_frag {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tlbflush_unmap_batch {
    pub arch: arch_tlbflush_unmap_batch,
    pub flush_required: bool_,
    pub writable: bool_,
}
#[test]
fn bindgen_test_layout_tlbflush_unmap_batch() {
    assert_eq!(
        ::core::mem::size_of::<tlbflush_unmap_batch>(),
        1032usize,
        concat!("Size of: ", stringify!(tlbflush_unmap_batch))
    );
    assert_eq!(
        ::core::mem::align_of::<tlbflush_unmap_batch>(),
        8usize,
        concat!("Alignment of ", stringify!(tlbflush_unmap_batch))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tlbflush_unmap_batch>())).arch as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tlbflush_unmap_batch),
            "::",
            stringify!(arch)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<tlbflush_unmap_batch>())).flush_required as *const _ as usize
        },
        1024usize,
        concat!(
            "Offset of field: ",
            stringify!(tlbflush_unmap_batch),
            "::",
            stringify!(flush_required)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tlbflush_unmap_batch>())).writable as *const _ as usize },
        1025usize,
        concat!(
            "Offset of field: ",
            stringify!(tlbflush_unmap_batch),
            "::",
            stringify!(writable)
        )
    );
}
impl Default for tlbflush_unmap_batch {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rb_node {
    pub __rb_parent_color: c_types::c_ulong,
    pub rb_right: *mut rb_node,
    pub rb_left: *mut rb_node,
}
#[test]
fn bindgen_test_layout_rb_node() {
    assert_eq!(
        ::core::mem::size_of::<rb_node>(),
        24usize,
        concat!("Size of: ", stringify!(rb_node))
    );
    assert_eq!(
        ::core::mem::align_of::<rb_node>(),
        8usize,
        concat!("Alignment of ", stringify!(rb_node))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rb_node>())).__rb_parent_color as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rb_node),
            "::",
            stringify!(__rb_parent_color)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rb_node>())).rb_right as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rb_node),
            "::",
            stringify!(rb_right)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rb_node>())).rb_left as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rb_node),
            "::",
            stringify!(rb_left)
        )
    );
}
impl Default for rb_node {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rb_root {
    pub rb_node: *mut rb_node,
}
#[test]
fn bindgen_test_layout_rb_root() {
    assert_eq!(
        ::core::mem::size_of::<rb_root>(),
        8usize,
        concat!("Size of: ", stringify!(rb_root))
    );
    assert_eq!(
        ::core::mem::align_of::<rb_root>(),
        8usize,
        concat!("Alignment of ", stringify!(rb_root))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rb_root>())).rb_node as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rb_root),
            "::",
            stringify!(rb_node)
        )
    );
}
impl Default for rb_root {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rb_root_cached {
    pub rb_root: rb_root,
    pub rb_leftmost: *mut rb_node,
}
#[test]
fn bindgen_test_layout_rb_root_cached() {
    assert_eq!(
        ::core::mem::size_of::<rb_root_cached>(),
        16usize,
        concat!("Size of: ", stringify!(rb_root_cached))
    );
    assert_eq!(
        ::core::mem::align_of::<rb_root_cached>(),
        8usize,
        concat!("Alignment of ", stringify!(rb_root_cached))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rb_root_cached>())).rb_root as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rb_root_cached),
            "::",
            stringify!(rb_root)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rb_root_cached>())).rb_leftmost as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rb_root_cached),
            "::",
            stringify!(rb_leftmost)
        )
    );
}
impl Default for rb_root_cached {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct optimistic_spin_queue {
    pub tail: atomic_t,
}
#[test]
fn bindgen_test_layout_optimistic_spin_queue() {
    assert_eq!(
        ::core::mem::size_of::<optimistic_spin_queue>(),
        4usize,
        concat!("Size of: ", stringify!(optimistic_spin_queue))
    );
    assert_eq!(
        ::core::mem::align_of::<optimistic_spin_queue>(),
        4usize,
        concat!("Alignment of ", stringify!(optimistic_spin_queue))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<optimistic_spin_queue>())).tail as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(optimistic_spin_queue),
            "::",
            stringify!(tail)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rw_semaphore {
    pub count: atomic_long_t,
    pub owner: atomic_long_t,
    pub osq: optimistic_spin_queue,
    pub wait_lock: raw_spinlock_t,
    pub wait_list: list_head,
}
#[test]
fn bindgen_test_layout_rw_semaphore() {
    assert_eq!(
        ::core::mem::size_of::<rw_semaphore>(),
        40usize,
        concat!("Size of: ", stringify!(rw_semaphore))
    );
    assert_eq!(
        ::core::mem::align_of::<rw_semaphore>(),
        8usize,
        concat!("Alignment of ", stringify!(rw_semaphore))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rw_semaphore>())).count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rw_semaphore),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rw_semaphore>())).owner as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rw_semaphore),
            "::",
            stringify!(owner)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rw_semaphore>())).osq as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rw_semaphore),
            "::",
            stringify!(osq)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rw_semaphore>())).wait_lock as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(rw_semaphore),
            "::",
            stringify!(wait_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rw_semaphore>())).wait_list as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rw_semaphore),
            "::",
            stringify!(wait_list)
        )
    );
}
impl Default for rw_semaphore {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct completion {
    pub done: c_types::c_uint,
    pub wait: wait_queue_head_t,
}
#[test]
fn bindgen_test_layout_completion() {
    assert_eq!(
        ::core::mem::size_of::<completion>(),
        32usize,
        concat!("Size of: ", stringify!(completion))
    );
    assert_eq!(
        ::core::mem::align_of::<completion>(),
        8usize,
        concat!("Alignment of ", stringify!(completion))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<completion>())).done as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(completion),
            "::",
            stringify!(done)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<completion>())).wait as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(completion),
            "::",
            stringify!(wait)
        )
    );
}
impl Default for completion {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mutex {
    pub owner: atomic_long_t,
    pub wait_lock: spinlock_t,
    pub osq: optimistic_spin_queue,
    pub wait_list: list_head,
}
#[test]
fn bindgen_test_layout_mutex() {
    assert_eq!(
        ::core::mem::size_of::<mutex>(),
        32usize,
        concat!("Size of: ", stringify!(mutex))
    );
    assert_eq!(
        ::core::mem::align_of::<mutex>(),
        8usize,
        concat!("Alignment of ", stringify!(mutex))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mutex>())).owner as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mutex),
            "::",
            stringify!(owner)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mutex>())).wait_lock as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mutex),
            "::",
            stringify!(wait_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mutex>())).osq as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(mutex),
            "::",
            stringify!(osq)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mutex>())).wait_list as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(mutex),
            "::",
            stringify!(wait_list)
        )
    );
}
impl Default for mutex {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type ktime_t = s64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timer_list {
    pub entry: hlist_node,
    pub expires: c_types::c_ulong,
    pub function: ::core::option::Option<unsafe extern "C" fn(arg1: *mut timer_list)>,
    pub flags: u32_,
}
#[test]
fn bindgen_test_layout_timer_list() {
    assert_eq!(
        ::core::mem::size_of::<timer_list>(),
        40usize,
        concat!("Size of: ", stringify!(timer_list))
    );
    assert_eq!(
        ::core::mem::align_of::<timer_list>(),
        8usize,
        concat!("Alignment of ", stringify!(timer_list))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timer_list>())).entry as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timer_list),
            "::",
            stringify!(entry)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timer_list>())).expires as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(timer_list),
            "::",
            stringify!(expires)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timer_list>())).function as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(timer_list),
            "::",
            stringify!(function)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timer_list>())).flags as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(timer_list),
            "::",
            stringify!(flags)
        )
    );
}
impl Default for timer_list {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct workqueue_struct {
    _unused: [u8; 0],
}
pub type work_func_t = ::core::option::Option<unsafe extern "C" fn(work: *mut work_struct)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct work_struct {
    pub data: atomic_long_t,
    pub entry: list_head,
    pub func: work_func_t,
}
#[test]
fn bindgen_test_layout_work_struct() {
    assert_eq!(
        ::core::mem::size_of::<work_struct>(),
        32usize,
        concat!("Size of: ", stringify!(work_struct))
    );
    assert_eq!(
        ::core::mem::align_of::<work_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(work_struct))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<work_struct>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(work_struct),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<work_struct>())).entry as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(work_struct),
            "::",
            stringify!(entry)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<work_struct>())).func as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(work_struct),
            "::",
            stringify!(func)
        )
    );
}
impl Default for work_struct {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct delayed_work {
    pub work: work_struct,
    pub timer: timer_list,
    pub wq: *mut workqueue_struct,
    pub cpu: c_types::c_int,
}
#[test]
fn bindgen_test_layout_delayed_work() {
    assert_eq!(
        ::core::mem::size_of::<delayed_work>(),
        88usize,
        concat!("Size of: ", stringify!(delayed_work))
    );
    assert_eq!(
        ::core::mem::align_of::<delayed_work>(),
        8usize,
        concat!("Alignment of ", stringify!(delayed_work))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<delayed_work>())).work as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(delayed_work),
            "::",
            stringify!(work)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<delayed_work>())).timer as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(delayed_work),
            "::",
            stringify!(timer)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<delayed_work>())).wq as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(delayed_work),
            "::",
            stringify!(wq)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<delayed_work>())).cpu as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(delayed_work),
            "::",
            stringify!(cpu)
        )
    );
}
impl Default for delayed_work {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcu_work {
    pub work: work_struct,
    pub rcu: callback_head,
    pub wq: *mut workqueue_struct,
}
#[test]
fn bindgen_test_layout_rcu_work() {
    assert_eq!(
        ::core::mem::size_of::<rcu_work>(),
        56usize,
        concat!("Size of: ", stringify!(rcu_work))
    );
    assert_eq!(
        ::core::mem::align_of::<rcu_work>(),
        8usize,
        concat!("Alignment of ", stringify!(rcu_work))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rcu_work>())).work as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rcu_work),
            "::",
            stringify!(work)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rcu_work>())).rcu as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rcu_work),
            "::",
            stringify!(rcu)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rcu_work>())).wq as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rcu_work),
            "::",
            stringify!(wq)
        )
    );
}
impl Default for rcu_work {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcu_segcblist {
    pub head: *mut callback_head,
    pub tails: [*mut *mut callback_head; 4usize],
    pub gp_seq: [c_types::c_ulong; 4usize],
    pub len: c_types::c_long,
    pub len_lazy: c_types::c_long,
    pub enabled: u8_,
    pub offloaded: u8_,
}
#[test]
fn bindgen_test_layout_rcu_segcblist() {
    assert_eq!(
        ::core::mem::size_of::<rcu_segcblist>(),
        96usize,
        concat!("Size of: ", stringify!(rcu_segcblist))
    );
    assert_eq!(
        ::core::mem::align_of::<rcu_segcblist>(),
        8usize,
        concat!("Alignment of ", stringify!(rcu_segcblist))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rcu_segcblist>())).head as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rcu_segcblist),
            "::",
            stringify!(head)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rcu_segcblist>())).tails as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rcu_segcblist),
            "::",
            stringify!(tails)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rcu_segcblist>())).gp_seq as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rcu_segcblist),
            "::",
            stringify!(gp_seq)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rcu_segcblist>())).len as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rcu_segcblist),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rcu_segcblist>())).len_lazy as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rcu_segcblist),
            "::",
            stringify!(len_lazy)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rcu_segcblist>())).enabled as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rcu_segcblist),
            "::",
            stringify!(enabled)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rcu_segcblist>())).offloaded as *const _ as usize },
        89usize,
        concat!(
            "Offset of field: ",
            stringify!(rcu_segcblist),
            "::",
            stringify!(offloaded)
        )
    );
}
impl Default for rcu_segcblist {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct srcu_data {
    pub srcu_lock_count: [c_types::c_ulong; 2usize],
    pub srcu_unlock_count: [c_types::c_ulong; 2usize],
    pub __bindgen_padding_0: [u32; 8usize],
    pub lock: spinlock_t,
    pub srcu_cblist: rcu_segcblist,
    pub srcu_gp_seq_needed: c_types::c_ulong,
    pub srcu_gp_seq_needed_exp: c_types::c_ulong,
    pub srcu_cblist_invoking: bool_,
    pub delay_work: timer_list,
    pub work: work_struct,
    pub srcu_barrier_head: callback_head,
    pub mynode: *mut srcu_node,
    pub grpmask: c_types::c_ulong,
    pub cpu: c_types::c_int,
    pub ssp: *mut srcu_struct,
}
#[test]
fn bindgen_test_layout_srcu_data() {
    assert_eq!(
        ::core::mem::size_of::<srcu_data>(),
        320usize,
        concat!("Size of: ", stringify!(srcu_data))
    );
    assert_eq!(
        ::core::mem::align_of::<srcu_data>(),
        64usize,
        concat!("Alignment of ", stringify!(srcu_data))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<srcu_data>())).srcu_lock_count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_data),
            "::",
            stringify!(srcu_lock_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<srcu_data>())).srcu_unlock_count as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_data),
            "::",
            stringify!(srcu_unlock_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<srcu_data>())).lock as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_data),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<srcu_data>())).srcu_cblist as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_data),
            "::",
            stringify!(srcu_cblist)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<srcu_data>())).srcu_gp_seq_needed as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_data),
            "::",
            stringify!(srcu_gp_seq_needed)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<srcu_data>())).srcu_gp_seq_needed_exp as *const _ as usize
        },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_data),
            "::",
            stringify!(srcu_gp_seq_needed_exp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<srcu_data>())).srcu_cblist_invoking as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_data),
            "::",
            stringify!(srcu_cblist_invoking)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<srcu_data>())).delay_work as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_data),
            "::",
            stringify!(delay_work)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<srcu_data>())).work as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_data),
            "::",
            stringify!(work)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<srcu_data>())).srcu_barrier_head as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_data),
            "::",
            stringify!(srcu_barrier_head)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<srcu_data>())).mynode as *const _ as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_data),
            "::",
            stringify!(mynode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<srcu_data>())).grpmask as *const _ as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_data),
            "::",
            stringify!(grpmask)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<srcu_data>())).cpu as *const _ as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_data),
            "::",
            stringify!(cpu)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<srcu_data>())).ssp as *const _ as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_data),
            "::",
            stringify!(ssp)
        )
    );
}
impl Default for srcu_data {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct srcu_node {
    pub lock: spinlock_t,
    pub srcu_have_cbs: [c_types::c_ulong; 4usize],
    pub srcu_data_have_cbs: [c_types::c_ulong; 4usize],
    pub srcu_gp_seq_needed_exp: c_types::c_ulong,
    pub srcu_parent: *mut srcu_node,
    pub grplo: c_types::c_int,
    pub grphi: c_types::c_int,
}
#[test]
fn bindgen_test_layout_srcu_node() {
    assert_eq!(
        ::core::mem::size_of::<srcu_node>(),
        96usize,
        concat!("Size of: ", stringify!(srcu_node))
    );
    assert_eq!(
        ::core::mem::align_of::<srcu_node>(),
        8usize,
        concat!("Alignment of ", stringify!(srcu_node))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<srcu_node>())).lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_node),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<srcu_node>())).srcu_have_cbs as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_node),
            "::",
            stringify!(srcu_have_cbs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<srcu_node>())).srcu_data_have_cbs as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_node),
            "::",
            stringify!(srcu_data_have_cbs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<srcu_node>())).srcu_gp_seq_needed_exp as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_node),
            "::",
            stringify!(srcu_gp_seq_needed_exp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<srcu_node>())).srcu_parent as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_node),
            "::",
            stringify!(srcu_parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<srcu_node>())).grplo as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_node),
            "::",
            stringify!(grplo)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<srcu_node>())).grphi as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_node),
            "::",
            stringify!(grphi)
        )
    );
}
impl Default for srcu_node {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct srcu_struct {
    pub node: [srcu_node; 521usize],
    pub level: [*mut srcu_node; 4usize],
    pub srcu_cb_mutex: mutex,
    pub lock: spinlock_t,
    pub srcu_gp_mutex: mutex,
    pub srcu_idx: c_types::c_uint,
    pub srcu_gp_seq: c_types::c_ulong,
    pub srcu_gp_seq_needed: c_types::c_ulong,
    pub srcu_gp_seq_needed_exp: c_types::c_ulong,
    pub srcu_last_gp_end: c_types::c_ulong,
    pub sda: *mut srcu_data,
    pub srcu_barrier_seq: c_types::c_ulong,
    pub srcu_barrier_mutex: mutex,
    pub srcu_barrier_completion: completion,
    pub srcu_barrier_cpu_cnt: atomic_t,
    pub work: delayed_work,
}
#[test]
fn bindgen_test_layout_srcu_struct() {
    assert_eq!(
        ::core::mem::size_of::<srcu_struct>(),
        50336usize,
        concat!("Size of: ", stringify!(srcu_struct))
    );
    assert_eq!(
        ::core::mem::align_of::<srcu_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(srcu_struct))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<srcu_struct>())).node as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_struct),
            "::",
            stringify!(node)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<srcu_struct>())).level as *const _ as usize },
        50016usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_struct),
            "::",
            stringify!(level)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<srcu_struct>())).srcu_cb_mutex as *const _ as usize },
        50048usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_struct),
            "::",
            stringify!(srcu_cb_mutex)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<srcu_struct>())).lock as *const _ as usize },
        50080usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_struct),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<srcu_struct>())).srcu_gp_mutex as *const _ as usize },
        50088usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_struct),
            "::",
            stringify!(srcu_gp_mutex)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<srcu_struct>())).srcu_idx as *const _ as usize },
        50120usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_struct),
            "::",
            stringify!(srcu_idx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<srcu_struct>())).srcu_gp_seq as *const _ as usize },
        50128usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_struct),
            "::",
            stringify!(srcu_gp_seq)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<srcu_struct>())).srcu_gp_seq_needed as *const _ as usize },
        50136usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_struct),
            "::",
            stringify!(srcu_gp_seq_needed)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<srcu_struct>())).srcu_gp_seq_needed_exp as *const _ as usize
        },
        50144usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_struct),
            "::",
            stringify!(srcu_gp_seq_needed_exp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<srcu_struct>())).srcu_last_gp_end as *const _ as usize },
        50152usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_struct),
            "::",
            stringify!(srcu_last_gp_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<srcu_struct>())).sda as *const _ as usize },
        50160usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_struct),
            "::",
            stringify!(sda)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<srcu_struct>())).srcu_barrier_seq as *const _ as usize },
        50168usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_struct),
            "::",
            stringify!(srcu_barrier_seq)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<srcu_struct>())).srcu_barrier_mutex as *const _ as usize },
        50176usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_struct),
            "::",
            stringify!(srcu_barrier_mutex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<srcu_struct>())).srcu_barrier_completion as *const _ as usize
        },
        50208usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_struct),
            "::",
            stringify!(srcu_barrier_completion)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<srcu_struct>())).srcu_barrier_cpu_cnt as *const _ as usize
        },
        50240usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_struct),
            "::",
            stringify!(srcu_barrier_cpu_cnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<srcu_struct>())).work as *const _ as usize },
        50248usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_struct),
            "::",
            stringify!(work)
        )
    );
}
impl Default for srcu_struct {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type notifier_fn_t = ::core::option::Option<
    unsafe extern "C" fn(
        nb: *mut notifier_block,
        action: c_types::c_ulong,
        data: *mut c_types::c_void,
    ) -> c_types::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct notifier_block {
    pub notifier_call: notifier_fn_t,
    pub next: *mut notifier_block,
    pub priority: c_types::c_int,
}
#[test]
fn bindgen_test_layout_notifier_block() {
    assert_eq!(
        ::core::mem::size_of::<notifier_block>(),
        24usize,
        concat!("Size of: ", stringify!(notifier_block))
    );
    assert_eq!(
        ::core::mem::align_of::<notifier_block>(),
        8usize,
        concat!("Alignment of ", stringify!(notifier_block))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<notifier_block>())).notifier_call as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(notifier_block),
            "::",
            stringify!(notifier_call)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<notifier_block>())).next as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(notifier_block),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<notifier_block>())).priority as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(notifier_block),
            "::",
            stringify!(priority)
        )
    );
}
impl Default for notifier_block {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct arch_uprobe_task {
    pub saved_scratch_register: c_types::c_ulong,
    pub saved_trap_nr: c_types::c_uint,
    pub saved_tf: c_types::c_uint,
}
#[test]
fn bindgen_test_layout_arch_uprobe_task() {
    assert_eq!(
        ::core::mem::size_of::<arch_uprobe_task>(),
        16usize,
        concat!("Size of: ", stringify!(arch_uprobe_task))
    );
    assert_eq!(
        ::core::mem::align_of::<arch_uprobe_task>(),
        8usize,
        concat!("Alignment of ", stringify!(arch_uprobe_task))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arch_uprobe_task>())).saved_scratch_register as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arch_uprobe_task),
            "::",
            stringify!(saved_scratch_register)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arch_uprobe_task>())).saved_trap_nr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arch_uprobe_task),
            "::",
            stringify!(saved_trap_nr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arch_uprobe_task>())).saved_tf as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(arch_uprobe_task),
            "::",
            stringify!(saved_tf)
        )
    );
}
pub const uprobe_task_state_UTASK_RUNNING: uprobe_task_state = 0;
pub const uprobe_task_state_UTASK_SSTEP: uprobe_task_state = 1;
pub const uprobe_task_state_UTASK_SSTEP_ACK: uprobe_task_state = 2;
pub const uprobe_task_state_UTASK_SSTEP_TRAPPED: uprobe_task_state = 3;
pub type uprobe_task_state = c_types::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct uprobe_task {
    pub state: uprobe_task_state,
    pub __bindgen_anon_1: uprobe_task__bindgen_ty_1,
    pub active_uprobe: *mut uprobe,
    pub xol_vaddr: c_types::c_ulong,
    pub return_instances: *mut return_instance,
    pub depth: c_types::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union uprobe_task__bindgen_ty_1 {
    pub __bindgen_anon_1: uprobe_task__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: uprobe_task__bindgen_ty_1__bindgen_ty_2,
    _bindgen_union_align: [u64; 3usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct uprobe_task__bindgen_ty_1__bindgen_ty_1 {
    pub autask: arch_uprobe_task,
    pub vaddr: c_types::c_ulong,
}
#[test]
fn bindgen_test_layout_uprobe_task__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<uprobe_task__bindgen_ty_1__bindgen_ty_1>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(uprobe_task__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<uprobe_task__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(uprobe_task__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<uprobe_task__bindgen_ty_1__bindgen_ty_1>())).autask as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uprobe_task__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(autask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<uprobe_task__bindgen_ty_1__bindgen_ty_1>())).vaddr as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(uprobe_task__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(vaddr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uprobe_task__bindgen_ty_1__bindgen_ty_2 {
    pub dup_xol_work: callback_head,
    pub dup_xol_addr: c_types::c_ulong,
}
#[test]
fn bindgen_test_layout_uprobe_task__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<uprobe_task__bindgen_ty_1__bindgen_ty_2>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(uprobe_task__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<uprobe_task__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(uprobe_task__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<uprobe_task__bindgen_ty_1__bindgen_ty_2>())).dup_xol_work
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uprobe_task__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(dup_xol_work)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<uprobe_task__bindgen_ty_1__bindgen_ty_2>())).dup_xol_addr
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(uprobe_task__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(dup_xol_addr)
        )
    );
}
impl Default for uprobe_task__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_uprobe_task__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<uprobe_task__bindgen_ty_1>(),
        24usize,
        concat!("Size of: ", stringify!(uprobe_task__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<uprobe_task__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(uprobe_task__bindgen_ty_1))
    );
}
impl Default for uprobe_task__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_uprobe_task() {
    assert_eq!(
        ::core::mem::size_of::<uprobe_task>(),
        64usize,
        concat!("Size of: ", stringify!(uprobe_task))
    );
    assert_eq!(
        ::core::mem::align_of::<uprobe_task>(),
        8usize,
        concat!("Alignment of ", stringify!(uprobe_task))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<uprobe_task>())).state as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uprobe_task),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<uprobe_task>())).active_uprobe as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(uprobe_task),
            "::",
            stringify!(active_uprobe)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<uprobe_task>())).xol_vaddr as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(uprobe_task),
            "::",
            stringify!(xol_vaddr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<uprobe_task>())).return_instances as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(uprobe_task),
            "::",
            stringify!(return_instances)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<uprobe_task>())).depth as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(uprobe_task),
            "::",
            stringify!(depth)
        )
    );
}
impl Default for uprobe_task {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct return_instance {
    pub uprobe: *mut uprobe,
    pub func: c_types::c_ulong,
    pub stack: c_types::c_ulong,
    pub orig_ret_vaddr: c_types::c_ulong,
    pub chained: bool_,
    pub next: *mut return_instance,
}
#[test]
fn bindgen_test_layout_return_instance() {
    assert_eq!(
        ::core::mem::size_of::<return_instance>(),
        48usize,
        concat!("Size of: ", stringify!(return_instance))
    );
    assert_eq!(
        ::core::mem::align_of::<return_instance>(),
        8usize,
        concat!("Alignment of ", stringify!(return_instance))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<return_instance>())).uprobe as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(return_instance),
            "::",
            stringify!(uprobe)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<return_instance>())).func as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(return_instance),
            "::",
            stringify!(func)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<return_instance>())).stack as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(return_instance),
            "::",
            stringify!(stack)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<return_instance>())).orig_ret_vaddr as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(return_instance),
            "::",
            stringify!(orig_ret_vaddr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<return_instance>())).chained as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(return_instance),
            "::",
            stringify!(chained)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<return_instance>())).next as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(return_instance),
            "::",
            stringify!(next)
        )
    );
}
impl Default for return_instance {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xol_area {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uprobes_state {
    pub xol_area: *mut xol_area,
}
#[test]
fn bindgen_test_layout_uprobes_state() {
    assert_eq!(
        ::core::mem::size_of::<uprobes_state>(),
        8usize,
        concat!("Size of: ", stringify!(uprobes_state))
    );
    assert_eq!(
        ::core::mem::align_of::<uprobes_state>(),
        8usize,
        concat!("Alignment of ", stringify!(uprobes_state))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<uprobes_state>())).xol_area as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uprobes_state),
            "::",
            stringify!(xol_area)
        )
    );
}
impl Default for uprobes_state {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mm_context_t {
    pub ctx_id: u64_,
    pub tlb_gen: atomic64_t,
    pub ldt_usr_sem: rw_semaphore,
    pub ldt: *mut ldt_struct,
    pub ia32_compat: c_types::c_ushort,
    pub lock: mutex,
    pub vdso: *mut c_types::c_void,
    pub vdso_image: *const vdso_image,
    pub perf_rdpmc_allowed: atomic_t,
    pub pkey_allocation_map: u16_,
    pub execute_only_pkey: s16,
    pub bd_addr: *mut c_types::c_void,
}
#[test]
fn bindgen_test_layout_mm_context_t() {
    assert_eq!(
        ::core::mem::size_of::<mm_context_t>(),
        136usize,
        concat!("Size of: ", stringify!(mm_context_t))
    );
    assert_eq!(
        ::core::mem::align_of::<mm_context_t>(),
        8usize,
        concat!("Alignment of ", stringify!(mm_context_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mm_context_t>())).ctx_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_context_t),
            "::",
            stringify!(ctx_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mm_context_t>())).tlb_gen as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_context_t),
            "::",
            stringify!(tlb_gen)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mm_context_t>())).ldt_usr_sem as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_context_t),
            "::",
            stringify!(ldt_usr_sem)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mm_context_t>())).ldt as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_context_t),
            "::",
            stringify!(ldt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mm_context_t>())).ia32_compat as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_context_t),
            "::",
            stringify!(ia32_compat)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mm_context_t>())).lock as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_context_t),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mm_context_t>())).vdso as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_context_t),
            "::",
            stringify!(vdso)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mm_context_t>())).vdso_image as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_context_t),
            "::",
            stringify!(vdso_image)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<mm_context_t>())).perf_rdpmc_allowed as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_context_t),
            "::",
            stringify!(perf_rdpmc_allowed)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<mm_context_t>())).pkey_allocation_map as *const _ as usize
        },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_context_t),
            "::",
            stringify!(pkey_allocation_map)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mm_context_t>())).execute_only_pkey as *const _ as usize },
        126usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_context_t),
            "::",
            stringify!(execute_only_pkey)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mm_context_t>())).bd_addr as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_context_t),
            "::",
            stringify!(bd_addr)
        )
    );
}
impl Default for mm_context_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct page {
    pub flags: c_types::c_ulong,
    pub __bindgen_anon_1: page__bindgen_ty_1,
    pub __bindgen_anon_2: page__bindgen_ty_2,
    pub _refcount: atomic_t,
    pub mem_cgroup: *mut mem_cgroup,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union page__bindgen_ty_1 {
    pub __bindgen_anon_1: page__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: page__bindgen_ty_1__bindgen_ty_2,
    pub __bindgen_anon_3: page__bindgen_ty_1__bindgen_ty_3,
    pub __bindgen_anon_4: page__bindgen_ty_1__bindgen_ty_4,
    pub __bindgen_anon_5: page__bindgen_ty_1__bindgen_ty_5,
    pub __bindgen_anon_6: page__bindgen_ty_1__bindgen_ty_6,
    pub __bindgen_anon_7: page__bindgen_ty_1__bindgen_ty_7,
    pub callback_head: callback_head,
    _bindgen_union_align: [u64; 5usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct page__bindgen_ty_1__bindgen_ty_1 {
    #[doc = " @lru: Pageout list, eg. active_list protected by"]
    #[doc = " pgdat->lru_lock.  Sometimes used as a generic list"]
    #[doc = " by the page owner."]
    pub lru: list_head,
    pub mapping: *mut address_space,
    pub index: c_types::c_ulong,
    #[doc = " @private: Mapping-private opaque data."]
    #[doc = " Usually used for buffer_heads if PagePrivate."]
    #[doc = " Used for swp_entry_t if PageSwapCache."]
    #[doc = " Indicates order in the buddy system if PageBuddy."]
    pub private: c_types::c_ulong,
}
#[test]
fn bindgen_test_layout_page__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<page__bindgen_ty_1__bindgen_ty_1>(),
        40usize,
        concat!("Size of: ", stringify!(page__bindgen_ty_1__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<page__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(page__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<page__bindgen_ty_1__bindgen_ty_1>())).lru as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(page__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(lru)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<page__bindgen_ty_1__bindgen_ty_1>())).mapping as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(page__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(mapping)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<page__bindgen_ty_1__bindgen_ty_1>())).index as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(page__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<page__bindgen_ty_1__bindgen_ty_1>())).private as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(page__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(private)
        )
    );
}
impl Default for page__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct page__bindgen_ty_1__bindgen_ty_2 {
    #[doc = " @dma_addr: might require a 64-bit value even on"]
    #[doc = " 32-bit architectures."]
    pub dma_addr: dma_addr_t,
}
#[test]
fn bindgen_test_layout_page__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<page__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(page__bindgen_ty_1__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<page__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(page__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<page__bindgen_ty_1__bindgen_ty_2>())).dma_addr as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(page__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(dma_addr)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct page__bindgen_ty_1__bindgen_ty_3 {
    pub __bindgen_anon_1: page__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1,
    pub slab_cache: *mut kmem_cache,
    pub freelist: *mut c_types::c_void,
    pub __bindgen_anon_2: page__bindgen_ty_1__bindgen_ty_3__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union page__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1 {
    pub slab_list: list_head,
    pub __bindgen_anon_1: page__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: [u64; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct page__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1 {
    pub next: *mut page,
    pub pages: c_types::c_int,
    pub pobjects: c_types::c_int,
}
#[test]
fn bindgen_test_layout_page__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<page__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(page__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<page__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(page__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<page__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1>(
            )))
            .next as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(page__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<page__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1>(
            )))
            .pages as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(page__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(pages)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<page__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1>(
            )))
            .pobjects as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(page__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(pobjects)
        )
    );
}
impl Default for page__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_page__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<page__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(page__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<page__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(page__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<page__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1>())).slab_list
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(page__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1),
            "::",
            stringify!(slab_list)
        )
    );
}
impl Default for page__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union page__bindgen_ty_1__bindgen_ty_3__bindgen_ty_2 {
    pub s_mem: *mut c_types::c_void,
    pub counters: c_types::c_ulong,
    pub __bindgen_anon_1: page__bindgen_ty_1__bindgen_ty_3__bindgen_ty_2__bindgen_ty_1,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct page__bindgen_ty_1__bindgen_ty_3__bindgen_ty_2__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
#[test]
fn bindgen_test_layout_page__bindgen_ty_1__bindgen_ty_3__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<page__bindgen_ty_1__bindgen_ty_3__bindgen_ty_2__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(page__bindgen_ty_1__bindgen_ty_3__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<page__bindgen_ty_1__bindgen_ty_3__bindgen_ty_2__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(page__bindgen_ty_1__bindgen_ty_3__bindgen_ty_2__bindgen_ty_1)
        )
    );
}
impl page__bindgen_ty_1__bindgen_ty_3__bindgen_ty_2__bindgen_ty_1 {
    #[inline]
    pub fn inuse(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_inuse(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn objects(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 15u8) as u32) }
    }
    #[inline]
    pub fn set_objects(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 15u8, val as u64)
        }
    }
    #[inline]
    pub fn frozen(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_frozen(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        inuse: c_types::c_uint,
        objects: c_types::c_uint,
        frozen: c_types::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let inuse: u32 = unsafe { ::core::mem::transmute(inuse) };
            inuse as u64
        });
        __bindgen_bitfield_unit.set(16usize, 15u8, {
            let objects: u32 = unsafe { ::core::mem::transmute(objects) };
            objects as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let frozen: u32 = unsafe { ::core::mem::transmute(frozen) };
            frozen as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_page__bindgen_ty_1__bindgen_ty_3__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<page__bindgen_ty_1__bindgen_ty_3__bindgen_ty_2>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(page__bindgen_ty_1__bindgen_ty_3__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<page__bindgen_ty_1__bindgen_ty_3__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(page__bindgen_ty_1__bindgen_ty_3__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<page__bindgen_ty_1__bindgen_ty_3__bindgen_ty_2>())).s_mem
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(page__bindgen_ty_1__bindgen_ty_3__bindgen_ty_2),
            "::",
            stringify!(s_mem)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<page__bindgen_ty_1__bindgen_ty_3__bindgen_ty_2>())).counters
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(page__bindgen_ty_1__bindgen_ty_3__bindgen_ty_2),
            "::",
            stringify!(counters)
        )
    );
}
impl Default for page__bindgen_ty_1__bindgen_ty_3__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_page__bindgen_ty_1__bindgen_ty_3() {
    assert_eq!(
        ::core::mem::size_of::<page__bindgen_ty_1__bindgen_ty_3>(),
        40usize,
        concat!("Size of: ", stringify!(page__bindgen_ty_1__bindgen_ty_3))
    );
    assert_eq!(
        ::core::mem::align_of::<page__bindgen_ty_1__bindgen_ty_3>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(page__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<page__bindgen_ty_1__bindgen_ty_3>())).slab_cache as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(page__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(slab_cache)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<page__bindgen_ty_1__bindgen_ty_3>())).freelist as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(page__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(freelist)
        )
    );
}
impl Default for page__bindgen_ty_1__bindgen_ty_3 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct page__bindgen_ty_1__bindgen_ty_4 {
    pub compound_head: c_types::c_ulong,
    pub compound_dtor: c_types::c_uchar,
    pub compound_order: c_types::c_uchar,
    pub compound_mapcount: atomic_t,
}
#[test]
fn bindgen_test_layout_page__bindgen_ty_1__bindgen_ty_4() {
    assert_eq!(
        ::core::mem::size_of::<page__bindgen_ty_1__bindgen_ty_4>(),
        16usize,
        concat!("Size of: ", stringify!(page__bindgen_ty_1__bindgen_ty_4))
    );
    assert_eq!(
        ::core::mem::align_of::<page__bindgen_ty_1__bindgen_ty_4>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(page__bindgen_ty_1__bindgen_ty_4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<page__bindgen_ty_1__bindgen_ty_4>())).compound_head as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(page__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(compound_head)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<page__bindgen_ty_1__bindgen_ty_4>())).compound_dtor as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(page__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(compound_dtor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<page__bindgen_ty_1__bindgen_ty_4>())).compound_order as *const _
                as usize
        },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(page__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(compound_order)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<page__bindgen_ty_1__bindgen_ty_4>())).compound_mapcount
                as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(page__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(compound_mapcount)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct page__bindgen_ty_1__bindgen_ty_5 {
    pub _compound_pad_1: c_types::c_ulong,
    pub _compound_pad_2: c_types::c_ulong,
    pub deferred_list: list_head,
}
#[test]
fn bindgen_test_layout_page__bindgen_ty_1__bindgen_ty_5() {
    assert_eq!(
        ::core::mem::size_of::<page__bindgen_ty_1__bindgen_ty_5>(),
        32usize,
        concat!("Size of: ", stringify!(page__bindgen_ty_1__bindgen_ty_5))
    );
    assert_eq!(
        ::core::mem::align_of::<page__bindgen_ty_1__bindgen_ty_5>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(page__bindgen_ty_1__bindgen_ty_5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<page__bindgen_ty_1__bindgen_ty_5>()))._compound_pad_1
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(page__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(_compound_pad_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<page__bindgen_ty_1__bindgen_ty_5>()))._compound_pad_2
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(page__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(_compound_pad_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<page__bindgen_ty_1__bindgen_ty_5>())).deferred_list as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(page__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(deferred_list)
        )
    );
}
impl Default for page__bindgen_ty_1__bindgen_ty_5 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct page__bindgen_ty_1__bindgen_ty_6 {
    pub _pt_pad_1: c_types::c_ulong,
    pub pmd_huge_pte: pgtable_t,
    pub _pt_pad_2: c_types::c_ulong,
    pub __bindgen_anon_1: page__bindgen_ty_1__bindgen_ty_6__bindgen_ty_1,
    pub ptl: spinlock_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union page__bindgen_ty_1__bindgen_ty_6__bindgen_ty_1 {
    pub pt_mm: *mut mm_struct,
    pub pt_frag_refcount: atomic_t,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_page__bindgen_ty_1__bindgen_ty_6__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<page__bindgen_ty_1__bindgen_ty_6__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(page__bindgen_ty_1__bindgen_ty_6__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<page__bindgen_ty_1__bindgen_ty_6__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(page__bindgen_ty_1__bindgen_ty_6__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<page__bindgen_ty_1__bindgen_ty_6__bindgen_ty_1>())).pt_mm
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(page__bindgen_ty_1__bindgen_ty_6__bindgen_ty_1),
            "::",
            stringify!(pt_mm)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<page__bindgen_ty_1__bindgen_ty_6__bindgen_ty_1>()))
                .pt_frag_refcount as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(page__bindgen_ty_1__bindgen_ty_6__bindgen_ty_1),
            "::",
            stringify!(pt_frag_refcount)
        )
    );
}
impl Default for page__bindgen_ty_1__bindgen_ty_6__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_page__bindgen_ty_1__bindgen_ty_6() {
    assert_eq!(
        ::core::mem::size_of::<page__bindgen_ty_1__bindgen_ty_6>(),
        40usize,
        concat!("Size of: ", stringify!(page__bindgen_ty_1__bindgen_ty_6))
    );
    assert_eq!(
        ::core::mem::align_of::<page__bindgen_ty_1__bindgen_ty_6>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(page__bindgen_ty_1__bindgen_ty_6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<page__bindgen_ty_1__bindgen_ty_6>()))._pt_pad_1 as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(page__bindgen_ty_1__bindgen_ty_6),
            "::",
            stringify!(_pt_pad_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<page__bindgen_ty_1__bindgen_ty_6>())).pmd_huge_pte as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(page__bindgen_ty_1__bindgen_ty_6),
            "::",
            stringify!(pmd_huge_pte)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<page__bindgen_ty_1__bindgen_ty_6>()))._pt_pad_2 as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(page__bindgen_ty_1__bindgen_ty_6),
            "::",
            stringify!(_pt_pad_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<page__bindgen_ty_1__bindgen_ty_6>())).ptl as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(page__bindgen_ty_1__bindgen_ty_6),
            "::",
            stringify!(ptl)
        )
    );
}
impl Default for page__bindgen_ty_1__bindgen_ty_6 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct page__bindgen_ty_1__bindgen_ty_7 {
    #[doc = " @pgmap: Points to the hosting device page map."]
    pub pgmap: *mut dev_pagemap,
    pub zone_device_data: *mut c_types::c_void,
}
#[test]
fn bindgen_test_layout_page__bindgen_ty_1__bindgen_ty_7() {
    assert_eq!(
        ::core::mem::size_of::<page__bindgen_ty_1__bindgen_ty_7>(),
        16usize,
        concat!("Size of: ", stringify!(page__bindgen_ty_1__bindgen_ty_7))
    );
    assert_eq!(
        ::core::mem::align_of::<page__bindgen_ty_1__bindgen_ty_7>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(page__bindgen_ty_1__bindgen_ty_7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<page__bindgen_ty_1__bindgen_ty_7>())).pgmap as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(page__bindgen_ty_1__bindgen_ty_7),
            "::",
            stringify!(pgmap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<page__bindgen_ty_1__bindgen_ty_7>())).zone_device_data
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(page__bindgen_ty_1__bindgen_ty_7),
            "::",
            stringify!(zone_device_data)
        )
    );
}
impl Default for page__bindgen_ty_1__bindgen_ty_7 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_page__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<page__bindgen_ty_1>(),
        40usize,
        concat!("Size of: ", stringify!(page__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<page__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(page__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<page__bindgen_ty_1>())).callback_head as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(page__bindgen_ty_1),
            "::",
            stringify!(callback_head)
        )
    );
}
impl Default for page__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union page__bindgen_ty_2 {
    pub _mapcount: atomic_t,
    pub page_type: c_types::c_uint,
    pub active: c_types::c_uint,
    pub units: c_types::c_int,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_page__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<page__bindgen_ty_2>(),
        4usize,
        concat!("Size of: ", stringify!(page__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<page__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(page__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<page__bindgen_ty_2>()))._mapcount as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(page__bindgen_ty_2),
            "::",
            stringify!(_mapcount)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<page__bindgen_ty_2>())).page_type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(page__bindgen_ty_2),
            "::",
            stringify!(page_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<page__bindgen_ty_2>())).active as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(page__bindgen_ty_2),
            "::",
            stringify!(active)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<page__bindgen_ty_2>())).units as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(page__bindgen_ty_2),
            "::",
            stringify!(units)
        )
    );
}
impl Default for page__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_page() {
    assert_eq!(
        ::core::mem::size_of::<page>(),
        64usize,
        concat!("Size of: ", stringify!(page))
    );
    assert_eq!(
        ::core::mem::align_of::<page>(),
        16usize,
        concat!("Alignment of ", stringify!(page))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<page>())).flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(page),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<page>()))._refcount as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(page),
            "::",
            stringify!(_refcount)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<page>())).mem_cgroup as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(page),
            "::",
            stringify!(mem_cgroup)
        )
    );
}
impl Default for page {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vm_userfaultfd_ctx {
    pub ctx: *mut userfaultfd_ctx,
}
#[test]
fn bindgen_test_layout_vm_userfaultfd_ctx() {
    assert_eq!(
        ::core::mem::size_of::<vm_userfaultfd_ctx>(),
        8usize,
        concat!("Size of: ", stringify!(vm_userfaultfd_ctx))
    );
    assert_eq!(
        ::core::mem::align_of::<vm_userfaultfd_ctx>(),
        8usize,
        concat!("Alignment of ", stringify!(vm_userfaultfd_ctx))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vm_userfaultfd_ctx>())).ctx as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_userfaultfd_ctx),
            "::",
            stringify!(ctx)
        )
    );
}
impl Default for vm_userfaultfd_ctx {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vm_area_struct {
    pub vm_start: c_types::c_ulong,
    pub vm_end: c_types::c_ulong,
    pub vm_next: *mut vm_area_struct,
    pub vm_prev: *mut vm_area_struct,
    pub vm_rb: rb_node,
    pub rb_subtree_gap: c_types::c_ulong,
    pub vm_mm: *mut mm_struct,
    pub vm_page_prot: pgprot_t,
    pub vm_flags: c_types::c_ulong,
    pub shared: vm_area_struct__bindgen_ty_1,
    pub anon_vma_chain: list_head,
    pub anon_vma: *mut anon_vma,
    pub vm_ops: *const vm_operations_struct,
    pub vm_pgoff: c_types::c_ulong,
    pub vm_file: *mut file,
    pub vm_prfile: *mut file,
    pub vm_private_data: *mut c_types::c_void,
    pub swap_readahead_info: atomic_long_t,
    pub vm_policy: *mut mempolicy,
    pub vm_userfaultfd_ctx: vm_userfaultfd_ctx,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vm_area_struct__bindgen_ty_1 {
    pub rb: rb_node,
    pub rb_subtree_last: c_types::c_ulong,
}
#[test]
fn bindgen_test_layout_vm_area_struct__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<vm_area_struct__bindgen_ty_1>(),
        32usize,
        concat!("Size of: ", stringify!(vm_area_struct__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<vm_area_struct__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(vm_area_struct__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<vm_area_struct__bindgen_ty_1>())).rb as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_area_struct__bindgen_ty_1),
            "::",
            stringify!(rb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<vm_area_struct__bindgen_ty_1>())).rb_subtree_last as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_area_struct__bindgen_ty_1),
            "::",
            stringify!(rb_subtree_last)
        )
    );
}
impl Default for vm_area_struct__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_vm_area_struct() {
    assert_eq!(
        ::core::mem::size_of::<vm_area_struct>(),
        208usize,
        concat!("Size of: ", stringify!(vm_area_struct))
    );
    assert_eq!(
        ::core::mem::align_of::<vm_area_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(vm_area_struct))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vm_area_struct>())).vm_start as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_area_struct),
            "::",
            stringify!(vm_start)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vm_area_struct>())).vm_end as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_area_struct),
            "::",
            stringify!(vm_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vm_area_struct>())).vm_next as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_area_struct),
            "::",
            stringify!(vm_next)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vm_area_struct>())).vm_prev as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_area_struct),
            "::",
            stringify!(vm_prev)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vm_area_struct>())).vm_rb as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_area_struct),
            "::",
            stringify!(vm_rb)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vm_area_struct>())).rb_subtree_gap as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_area_struct),
            "::",
            stringify!(rb_subtree_gap)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vm_area_struct>())).vm_mm as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_area_struct),
            "::",
            stringify!(vm_mm)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vm_area_struct>())).vm_page_prot as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_area_struct),
            "::",
            stringify!(vm_page_prot)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vm_area_struct>())).vm_flags as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_area_struct),
            "::",
            stringify!(vm_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vm_area_struct>())).shared as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_area_struct),
            "::",
            stringify!(shared)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vm_area_struct>())).anon_vma_chain as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_area_struct),
            "::",
            stringify!(anon_vma_chain)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vm_area_struct>())).anon_vma as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_area_struct),
            "::",
            stringify!(anon_vma)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vm_area_struct>())).vm_ops as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_area_struct),
            "::",
            stringify!(vm_ops)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vm_area_struct>())).vm_pgoff as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_area_struct),
            "::",
            stringify!(vm_pgoff)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vm_area_struct>())).vm_file as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_area_struct),
            "::",
            stringify!(vm_file)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vm_area_struct>())).vm_prfile as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_area_struct),
            "::",
            stringify!(vm_prfile)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vm_area_struct>())).vm_private_data as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_area_struct),
            "::",
            stringify!(vm_private_data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<vm_area_struct>())).swap_readahead_info as *const _ as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_area_struct),
            "::",
            stringify!(swap_readahead_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vm_area_struct>())).vm_policy as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_area_struct),
            "::",
            stringify!(vm_policy)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<vm_area_struct>())).vm_userfaultfd_ctx as *const _ as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_area_struct),
            "::",
            stringify!(vm_userfaultfd_ctx)
        )
    );
}
impl Default for vm_area_struct {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct core_thread {
    pub task: *mut task_struct,
    pub next: *mut core_thread,
}
#[test]
fn bindgen_test_layout_core_thread() {
    assert_eq!(
        ::core::mem::size_of::<core_thread>(),
        16usize,
        concat!("Size of: ", stringify!(core_thread))
    );
    assert_eq!(
        ::core::mem::align_of::<core_thread>(),
        8usize,
        concat!("Alignment of ", stringify!(core_thread))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<core_thread>())).task as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(core_thread),
            "::",
            stringify!(task)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<core_thread>())).next as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(core_thread),
            "::",
            stringify!(next)
        )
    );
}
impl Default for core_thread {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct core_state {
    pub nr_threads: atomic_t,
    pub dumper: core_thread,
    pub startup: completion,
}
#[test]
fn bindgen_test_layout_core_state() {
    assert_eq!(
        ::core::mem::size_of::<core_state>(),
        56usize,
        concat!("Size of: ", stringify!(core_state))
    );
    assert_eq!(
        ::core::mem::align_of::<core_state>(),
        8usize,
        concat!("Alignment of ", stringify!(core_state))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<core_state>())).nr_threads as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(core_state),
            "::",
            stringify!(nr_threads)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<core_state>())).dumper as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(core_state),
            "::",
            stringify!(dumper)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<core_state>())).startup as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(core_state),
            "::",
            stringify!(startup)
        )
    );
}
impl Default for core_state {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kioctx_table {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct mm_struct {
    pub __bindgen_anon_1: mm_struct__bindgen_ty_1,
    pub cpu_bitmap: __IncompleteArrayField<c_types::c_ulong>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mm_struct__bindgen_ty_1 {
    pub mmap: *mut vm_area_struct,
    pub mm_rb: rb_root,
    pub vmacache_seqnum: u64_,
    pub get_unmapped_area: ::core::option::Option<
        unsafe extern "C" fn(
            filp: *mut file,
            addr: c_types::c_ulong,
            len: c_types::c_ulong,
            pgoff: c_types::c_ulong,
            flags: c_types::c_ulong,
        ) -> c_types::c_ulong,
    >,
    pub mmap_base: c_types::c_ulong,
    pub mmap_legacy_base: c_types::c_ulong,
    pub mmap_compat_base: c_types::c_ulong,
    pub mmap_compat_legacy_base: c_types::c_ulong,
    pub task_size: c_types::c_ulong,
    pub highest_vm_end: c_types::c_ulong,
    pub pgd: *mut pgd_t,
    #[doc = " @membarrier_state: Flags controlling membarrier behavior."]
    #[doc = ""]
    #[doc = " This field is close to @pgd to hopefully fit in the same"]
    #[doc = " cache-line, which needs to be touched by switch_mm()."]
    pub membarrier_state: atomic_t,
    #[doc = " @mm_users: The number of users including userspace."]
    #[doc = ""]
    #[doc = " Use mmget()/mmget_not_zero()/mmput() to modify. When this"]
    #[doc = " drops to 0 (i.e. when the task exits and there are no other"]
    #[doc = " temporary reference holders), we also release a reference on"]
    #[doc = " @mm_count (which may then free the &struct mm_struct if"]
    #[doc = " @mm_count also drops to 0)."]
    pub mm_users: atomic_t,
    #[doc = " @mm_count: The number of references to &struct mm_struct"]
    #[doc = " (@mm_users count as 1)."]
    #[doc = ""]
    #[doc = " Use mmgrab()/mmdrop() to modify. When this drops to 0, the"]
    #[doc = " &struct mm_struct is freed."]
    pub mm_count: atomic_t,
    pub pgtables_bytes: atomic_long_t,
    pub map_count: c_types::c_int,
    pub page_table_lock: spinlock_t,
    pub mmap_sem: rw_semaphore,
    pub mmlist: list_head,
    pub hiwater_rss: c_types::c_ulong,
    pub hiwater_vm: c_types::c_ulong,
    pub total_vm: c_types::c_ulong,
    pub locked_vm: c_types::c_ulong,
    pub pinned_vm: atomic64_t,
    pub data_vm: c_types::c_ulong,
    pub exec_vm: c_types::c_ulong,
    pub stack_vm: c_types::c_ulong,
    pub def_flags: c_types::c_ulong,
    pub arg_lock: spinlock_t,
    pub start_code: c_types::c_ulong,
    pub end_code: c_types::c_ulong,
    pub start_data: c_types::c_ulong,
    pub end_data: c_types::c_ulong,
    pub start_brk: c_types::c_ulong,
    pub brk: c_types::c_ulong,
    pub start_stack: c_types::c_ulong,
    pub arg_start: c_types::c_ulong,
    pub arg_end: c_types::c_ulong,
    pub env_start: c_types::c_ulong,
    pub env_end: c_types::c_ulong,
    pub saved_auxv: [c_types::c_ulong; 46usize],
    pub rss_stat: mm_rss_stat,
    pub binfmt: *mut linux_binfmt,
    pub context: mm_context_t,
    pub flags: c_types::c_ulong,
    pub core_state: *mut core_state,
    pub ioctx_lock: spinlock_t,
    pub ioctx_table: *mut kioctx_table,
    pub owner: *mut task_struct,
    pub user_ns: *mut user_namespace,
    pub exe_file: *mut file,
    pub mmu_notifier_mm: *mut mmu_notifier_mm,
    pub numa_next_scan: c_types::c_ulong,
    pub numa_scan_offset: c_types::c_ulong,
    pub numa_scan_seq: c_types::c_int,
    pub tlb_flush_pending: atomic_t,
    pub tlb_flush_batched: bool_,
    pub uprobes_state: uprobes_state,
    pub hugetlb_usage: atomic_long_t,
    pub async_put_work: work_struct,
}
#[test]
fn bindgen_test_layout_mm_struct__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<mm_struct__bindgen_ty_1>(),
        1032usize,
        concat!("Size of: ", stringify!(mm_struct__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<mm_struct__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(mm_struct__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).mmap as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(mmap)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).mm_rb as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(mm_rb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).vmacache_seqnum as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(vmacache_seqnum)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).get_unmapped_area as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(get_unmapped_area)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).mmap_base as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(mmap_base)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).mmap_legacy_base as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(mmap_legacy_base)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).mmap_compat_base as *const _
                as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(mmap_compat_base)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).mmap_compat_legacy_base as *const _
                as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(mmap_compat_legacy_base)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).task_size as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(task_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).highest_vm_end as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(highest_vm_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).pgd as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(pgd)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).membarrier_state as *const _
                as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(membarrier_state)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).mm_users as *const _ as usize
        },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(mm_users)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).mm_count as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(mm_count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).pgtables_bytes as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(pgtables_bytes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).map_count as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(map_count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).page_table_lock as *const _
                as usize
        },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(page_table_lock)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).mmap_sem as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(mmap_sem)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).mmlist as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(mmlist)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).hiwater_rss as *const _ as usize
        },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(hiwater_rss)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).hiwater_vm as *const _ as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(hiwater_vm)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).total_vm as *const _ as usize
        },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(total_vm)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).locked_vm as *const _ as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(locked_vm)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).pinned_vm as *const _ as usize
        },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(pinned_vm)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).data_vm as *const _ as usize
        },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(data_vm)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).exec_vm as *const _ as usize
        },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(exec_vm)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).stack_vm as *const _ as usize
        },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(stack_vm)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).def_flags as *const _ as usize
        },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(def_flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).arg_lock as *const _ as usize
        },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(arg_lock)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).start_code as *const _ as usize
        },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(start_code)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).end_code as *const _ as usize
        },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(end_code)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).start_data as *const _ as usize
        },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(start_data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).end_data as *const _ as usize
        },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(end_data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).start_brk as *const _ as usize
        },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(start_brk)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).brk as *const _ as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(brk)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).start_stack as *const _ as usize
        },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(start_stack)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).arg_start as *const _ as usize
        },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(arg_start)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).arg_end as *const _ as usize
        },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(arg_end)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).env_start as *const _ as usize
        },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(env_start)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).env_end as *const _ as usize
        },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(env_end)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).saved_auxv as *const _ as usize
        },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(saved_auxv)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).rss_stat as *const _ as usize
        },
        712usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(rss_stat)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).binfmt as *const _ as usize },
        744usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(binfmt)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).context as *const _ as usize
        },
        752usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(context)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).flags as *const _ as usize },
        888usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).core_state as *const _ as usize
        },
        896usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(core_state)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).ioctx_lock as *const _ as usize
        },
        904usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(ioctx_lock)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).ioctx_table as *const _ as usize
        },
        912usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(ioctx_table)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).owner as *const _ as usize },
        920usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(owner)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).user_ns as *const _ as usize
        },
        928usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(user_ns)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).exe_file as *const _ as usize
        },
        936usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(exe_file)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).mmu_notifier_mm as *const _
                as usize
        },
        944usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(mmu_notifier_mm)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).numa_next_scan as *const _ as usize
        },
        952usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(numa_next_scan)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).numa_scan_offset as *const _
                as usize
        },
        960usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(numa_scan_offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).numa_scan_seq as *const _ as usize
        },
        968usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(numa_scan_seq)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).tlb_flush_pending as *const _
                as usize
        },
        972usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(tlb_flush_pending)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).tlb_flush_batched as *const _
                as usize
        },
        976usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(tlb_flush_batched)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).uprobes_state as *const _ as usize
        },
        984usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(uprobes_state)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).hugetlb_usage as *const _ as usize
        },
        992usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(hugetlb_usage)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).async_put_work as *const _ as usize
        },
        1000usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(async_put_work)
        )
    );
}
impl Default for mm_struct__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_mm_struct() {
    assert_eq!(
        ::core::mem::size_of::<mm_struct>(),
        1032usize,
        concat!("Size of: ", stringify!(mm_struct))
    );
    assert_eq!(
        ::core::mem::align_of::<mm_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(mm_struct))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mm_struct>())).cpu_bitmap as *const _ as usize },
        1032usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct),
            "::",
            stringify!(cpu_bitmap)
        )
    );
}
impl Default for mm_struct {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[doc = " typedef vm_fault_t - Return type for page fault handlers."]
#[doc = ""]
#[doc = " Page fault handlers return a bitmask of %VM_FAULT values."]
pub type vm_fault_t = c_types::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct free_area {
    pub free_list: [list_head; 6usize],
    pub nr_free: c_types::c_ulong,
}
#[test]
fn bindgen_test_layout_free_area() {
    assert_eq!(
        ::core::mem::size_of::<free_area>(),
        104usize,
        concat!("Size of: ", stringify!(free_area))
    );
    assert_eq!(
        ::core::mem::align_of::<free_area>(),
        8usize,
        concat!("Alignment of ", stringify!(free_area))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<free_area>())).free_list as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(free_area),
            "::",
            stringify!(free_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<free_area>())).nr_free as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(free_area),
            "::",
            stringify!(nr_free)
        )
    );
}
impl Default for free_area {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[repr(align(64))]
pub struct zone_padding {
    pub x: __IncompleteArrayField<c_types::c_char>,
}
#[test]
fn bindgen_test_layout_zone_padding() {
    assert_eq!(
        ::core::mem::size_of::<zone_padding>(),
        0usize,
        concat!("Size of: ", stringify!(zone_padding))
    );
    assert_eq!(
        ::core::mem::align_of::<zone_padding>(),
        64usize,
        concat!("Alignment of ", stringify!(zone_padding))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<zone_padding>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(zone_padding),
            "::",
            stringify!(x)
        )
    );
}
impl Default for zone_padding {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct zone_reclaim_stat {
    pub recent_rotated: [c_types::c_ulong; 2usize],
    pub recent_scanned: [c_types::c_ulong; 2usize],
}
#[test]
fn bindgen_test_layout_zone_reclaim_stat() {
    assert_eq!(
        ::core::mem::size_of::<zone_reclaim_stat>(),
        32usize,
        concat!("Size of: ", stringify!(zone_reclaim_stat))
    );
    assert_eq!(
        ::core::mem::align_of::<zone_reclaim_stat>(),
        8usize,
        concat!("Alignment of ", stringify!(zone_reclaim_stat))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<zone_reclaim_stat>())).recent_rotated as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(zone_reclaim_stat),
            "::",
            stringify!(recent_rotated)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<zone_reclaim_stat>())).recent_scanned as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(zone_reclaim_stat),
            "::",
            stringify!(recent_scanned)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lruvec {
    pub lists: [list_head; 5usize],
    pub reclaim_stat: zone_reclaim_stat,
    pub inactive_age: atomic_long_t,
    pub refaults: c_types::c_ulong,
    pub pgdat: *mut pglist_data,
}
#[test]
fn bindgen_test_layout_lruvec() {
    assert_eq!(
        ::core::mem::size_of::<lruvec>(),
        136usize,
        concat!("Size of: ", stringify!(lruvec))
    );
    assert_eq!(
        ::core::mem::align_of::<lruvec>(),
        8usize,
        concat!("Alignment of ", stringify!(lruvec))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<lruvec>())).lists as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lruvec),
            "::",
            stringify!(lists)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<lruvec>())).reclaim_stat as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(lruvec),
            "::",
            stringify!(reclaim_stat)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<lruvec>())).inactive_age as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(lruvec),
            "::",
            stringify!(inactive_age)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<lruvec>())).refaults as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(lruvec),
            "::",
            stringify!(refaults)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<lruvec>())).pgdat as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(lruvec),
            "::",
            stringify!(pgdat)
        )
    );
}
impl Default for lruvec {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type isolate_mode_t = c_types::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct per_cpu_pages {
    pub count: c_types::c_int,
    pub high: c_types::c_int,
    pub batch: c_types::c_int,
    pub lists: [list_head; 3usize],
}
#[test]
fn bindgen_test_layout_per_cpu_pages() {
    assert_eq!(
        ::core::mem::size_of::<per_cpu_pages>(),
        64usize,
        concat!("Size of: ", stringify!(per_cpu_pages))
    );
    assert_eq!(
        ::core::mem::align_of::<per_cpu_pages>(),
        8usize,
        concat!("Alignment of ", stringify!(per_cpu_pages))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<per_cpu_pages>())).count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(per_cpu_pages),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<per_cpu_pages>())).high as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(per_cpu_pages),
            "::",
            stringify!(high)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<per_cpu_pages>())).batch as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(per_cpu_pages),
            "::",
            stringify!(batch)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<per_cpu_pages>())).lists as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(per_cpu_pages),
            "::",
            stringify!(lists)
        )
    );
}
impl Default for per_cpu_pages {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct per_cpu_pageset {
    pub pcp: per_cpu_pages,
    pub expire: s8,
    pub vm_numa_stat_diff: [u16_; 6usize],
    pub stat_threshold: s8,
    pub vm_stat_diff: [s8; 13usize],
}
#[test]
fn bindgen_test_layout_per_cpu_pageset() {
    assert_eq!(
        ::core::mem::size_of::<per_cpu_pageset>(),
        96usize,
        concat!("Size of: ", stringify!(per_cpu_pageset))
    );
    assert_eq!(
        ::core::mem::align_of::<per_cpu_pageset>(),
        8usize,
        concat!("Alignment of ", stringify!(per_cpu_pageset))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<per_cpu_pageset>())).pcp as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(per_cpu_pageset),
            "::",
            stringify!(pcp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<per_cpu_pageset>())).expire as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(per_cpu_pageset),
            "::",
            stringify!(expire)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<per_cpu_pageset>())).vm_numa_stat_diff as *const _ as usize
        },
        66usize,
        concat!(
            "Offset of field: ",
            stringify!(per_cpu_pageset),
            "::",
            stringify!(vm_numa_stat_diff)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<per_cpu_pageset>())).stat_threshold as *const _ as usize },
        78usize,
        concat!(
            "Offset of field: ",
            stringify!(per_cpu_pageset),
            "::",
            stringify!(stat_threshold)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<per_cpu_pageset>())).vm_stat_diff as *const _ as usize },
        79usize,
        concat!(
            "Offset of field: ",
            stringify!(per_cpu_pageset),
            "::",
            stringify!(vm_stat_diff)
        )
    );
}
impl Default for per_cpu_pageset {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct per_cpu_nodestat {
    pub stat_threshold: s8,
    pub vm_node_stat_diff: [s8; 32usize],
}
#[test]
fn bindgen_test_layout_per_cpu_nodestat() {
    assert_eq!(
        ::core::mem::size_of::<per_cpu_nodestat>(),
        33usize,
        concat!("Size of: ", stringify!(per_cpu_nodestat))
    );
    assert_eq!(
        ::core::mem::align_of::<per_cpu_nodestat>(),
        1usize,
        concat!("Alignment of ", stringify!(per_cpu_nodestat))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<per_cpu_nodestat>())).stat_threshold as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(per_cpu_nodestat),
            "::",
            stringify!(stat_threshold)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<per_cpu_nodestat>())).vm_node_stat_diff as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(per_cpu_nodestat),
            "::",
            stringify!(vm_node_stat_diff)
        )
    );
}
pub const zone_type_ZONE_DMA: zone_type = 0;
pub const zone_type_ZONE_DMA32: zone_type = 1;
pub const zone_type_ZONE_NORMAL: zone_type = 2;
pub const zone_type_ZONE_MOVABLE: zone_type = 3;
pub const zone_type_ZONE_DEVICE: zone_type = 4;
pub const zone_type___MAX_NR_ZONES: zone_type = 5;
pub type zone_type = c_types::c_uint;
#[repr(C)]
#[repr(align(64))]
pub struct zone {
    pub _watermark: [c_types::c_ulong; 3usize],
    pub watermark_boost: c_types::c_ulong,
    pub nr_reserved_highatomic: c_types::c_ulong,
    pub lowmem_reserve: [c_types::c_long; 5usize],
    pub node: c_types::c_int,
    pub zone_pgdat: *mut pglist_data,
    pub pageset: *mut per_cpu_pageset,
    pub zone_start_pfn: c_types::c_ulong,
    pub managed_pages: atomic_long_t,
    pub spanned_pages: c_types::c_ulong,
    pub present_pages: c_types::c_ulong,
    pub name: *const c_types::c_char,
    pub nr_isolate_pageblock: c_types::c_ulong,
    pub span_seqlock: seqlock_t,
    pub initialized: c_types::c_int,
    pub __bindgen_padding_0: [u64; 3usize],
    pub _pad1_: zone_padding,
    pub free_area: [free_area; 11usize],
    pub flags: c_types::c_ulong,
    pub lock: spinlock_t,
    pub __bindgen_padding_1: [u64; 7usize],
    pub _pad2_: zone_padding,
    pub percpu_drift_mark: c_types::c_ulong,
    pub compact_cached_free_pfn: c_types::c_ulong,
    pub compact_cached_migrate_pfn: [c_types::c_ulong; 2usize],
    pub compact_init_migrate_pfn: c_types::c_ulong,
    pub compact_init_free_pfn: c_types::c_ulong,
    pub compact_considered: c_types::c_uint,
    pub compact_defer_shift: c_types::c_uint,
    pub compact_order_failed: c_types::c_int,
    pub compact_blockskip_flush: bool_,
    pub contiguous: bool_,
    pub __bindgen_padding_2: [u64; 0usize],
    pub _pad3_: zone_padding,
    pub vm_stat: [atomic_long_t; 13usize],
    pub vm_numa_stat: [atomic_long_t; 6usize],
}
#[test]
fn bindgen_test_layout_zone() {
    assert_eq!(
        ::core::mem::size_of::<zone>(),
        1664usize,
        concat!("Size of: ", stringify!(zone))
    );
    assert_eq!(
        ::core::mem::align_of::<zone>(),
        64usize,
        concat!("Alignment of ", stringify!(zone))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<zone>()))._watermark as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(zone),
            "::",
            stringify!(_watermark)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<zone>())).watermark_boost as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(zone),
            "::",
            stringify!(watermark_boost)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<zone>())).nr_reserved_highatomic as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(zone),
            "::",
            stringify!(nr_reserved_highatomic)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<zone>())).lowmem_reserve as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(zone),
            "::",
            stringify!(lowmem_reserve)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<zone>())).node as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(zone),
            "::",
            stringify!(node)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<zone>())).zone_pgdat as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(zone),
            "::",
            stringify!(zone_pgdat)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<zone>())).pageset as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(zone),
            "::",
            stringify!(pageset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<zone>())).zone_start_pfn as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(zone),
            "::",
            stringify!(zone_start_pfn)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<zone>())).managed_pages as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(zone),
            "::",
            stringify!(managed_pages)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<zone>())).spanned_pages as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(zone),
            "::",
            stringify!(spanned_pages)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<zone>())).present_pages as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(zone),
            "::",
            stringify!(present_pages)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<zone>())).name as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(zone),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<zone>())).nr_isolate_pageblock as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(zone),
            "::",
            stringify!(nr_isolate_pageblock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<zone>())).span_seqlock as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(zone),
            "::",
            stringify!(span_seqlock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<zone>())).initialized as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(zone),
            "::",
            stringify!(initialized)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<zone>()))._pad1_ as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(zone),
            "::",
            stringify!(_pad1_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<zone>())).free_area as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(zone),
            "::",
            stringify!(free_area)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<zone>())).flags as *const _ as usize },
        1336usize,
        concat!(
            "Offset of field: ",
            stringify!(zone),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<zone>())).lock as *const _ as usize },
        1344usize,
        concat!(
            "Offset of field: ",
            stringify!(zone),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<zone>()))._pad2_ as *const _ as usize },
        1408usize,
        concat!(
            "Offset of field: ",
            stringify!(zone),
            "::",
            stringify!(_pad2_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<zone>())).percpu_drift_mark as *const _ as usize },
        1408usize,
        concat!(
            "Offset of field: ",
            stringify!(zone),
            "::",
            stringify!(percpu_drift_mark)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<zone>())).compact_cached_free_pfn as *const _ as usize },
        1416usize,
        concat!(
            "Offset of field: ",
            stringify!(zone),
            "::",
            stringify!(compact_cached_free_pfn)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<zone>())).compact_cached_migrate_pfn as *const _ as usize
        },
        1424usize,
        concat!(
            "Offset of field: ",
            stringify!(zone),
            "::",
            stringify!(compact_cached_migrate_pfn)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<zone>())).compact_init_migrate_pfn as *const _ as usize },
        1440usize,
        concat!(
            "Offset of field: ",
            stringify!(zone),
            "::",
            stringify!(compact_init_migrate_pfn)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<zone>())).compact_init_free_pfn as *const _ as usize },
        1448usize,
        concat!(
            "Offset of field: ",
            stringify!(zone),
            "::",
            stringify!(compact_init_free_pfn)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<zone>())).compact_considered as *const _ as usize },
        1456usize,
        concat!(
            "Offset of field: ",
            stringify!(zone),
            "::",
            stringify!(compact_considered)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<zone>())).compact_defer_shift as *const _ as usize },
        1460usize,
        concat!(
            "Offset of field: ",
            stringify!(zone),
            "::",
            stringify!(compact_defer_shift)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<zone>())).compact_order_failed as *const _ as usize },
        1464usize,
        concat!(
            "Offset of field: ",
            stringify!(zone),
            "::",
            stringify!(compact_order_failed)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<zone>())).compact_blockskip_flush as *const _ as usize },
        1468usize,
        concat!(
            "Offset of field: ",
            stringify!(zone),
            "::",
            stringify!(compact_blockskip_flush)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<zone>())).contiguous as *const _ as usize },
        1469usize,
        concat!(
            "Offset of field: ",
            stringify!(zone),
            "::",
            stringify!(contiguous)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<zone>()))._pad3_ as *const _ as usize },
        1472usize,
        concat!(
            "Offset of field: ",
            stringify!(zone),
            "::",
            stringify!(_pad3_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<zone>())).vm_stat as *const _ as usize },
        1472usize,
        concat!(
            "Offset of field: ",
            stringify!(zone),
            "::",
            stringify!(vm_stat)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<zone>())).vm_numa_stat as *const _ as usize },
        1576usize,
        concat!(
            "Offset of field: ",
            stringify!(zone),
            "::",
            stringify!(vm_numa_stat)
        )
    );
}
impl Default for zone {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct zoneref {
    pub zone: *mut zone,
    pub zone_idx: c_types::c_int,
}
#[test]
fn bindgen_test_layout_zoneref() {
    assert_eq!(
        ::core::mem::size_of::<zoneref>(),
        16usize,
        concat!("Size of: ", stringify!(zoneref))
    );
    assert_eq!(
        ::core::mem::align_of::<zoneref>(),
        8usize,
        concat!("Alignment of ", stringify!(zoneref))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<zoneref>())).zone as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(zoneref),
            "::",
            stringify!(zone)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<zoneref>())).zone_idx as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(zoneref),
            "::",
            stringify!(zone_idx)
        )
    );
}
impl Default for zoneref {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct zonelist {
    pub _zonerefs: [zoneref; 5121usize],
}
#[test]
fn bindgen_test_layout_zonelist() {
    assert_eq!(
        ::core::mem::size_of::<zonelist>(),
        81936usize,
        concat!("Size of: ", stringify!(zonelist))
    );
    assert_eq!(
        ::core::mem::align_of::<zonelist>(),
        8usize,
        concat!("Alignment of ", stringify!(zonelist))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<zonelist>()))._zonerefs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(zonelist),
            "::",
            stringify!(_zonerefs)
        )
    );
}
impl Default for zonelist {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct deferred_split {
    pub split_queue_lock: spinlock_t,
    pub split_queue: list_head,
    pub split_queue_len: c_types::c_ulong,
}
#[test]
fn bindgen_test_layout_deferred_split() {
    assert_eq!(
        ::core::mem::size_of::<deferred_split>(),
        32usize,
        concat!("Size of: ", stringify!(deferred_split))
    );
    assert_eq!(
        ::core::mem::align_of::<deferred_split>(),
        8usize,
        concat!("Alignment of ", stringify!(deferred_split))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<deferred_split>())).split_queue_lock as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(deferred_split),
            "::",
            stringify!(split_queue_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<deferred_split>())).split_queue as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(deferred_split),
            "::",
            stringify!(split_queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<deferred_split>())).split_queue_len as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(deferred_split),
            "::",
            stringify!(split_queue_len)
        )
    );
}
impl Default for deferred_split {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[repr(align(64))]
pub struct pglist_data {
    pub node_zones: [zone; 5usize],
    pub node_zonelists: [zonelist; 2usize],
    pub nr_zones: c_types::c_int,
    pub node_size_lock: spinlock_t,
    pub node_start_pfn: c_types::c_ulong,
    pub node_present_pages: c_types::c_ulong,
    pub node_spanned_pages: c_types::c_ulong,
    pub node_id: c_types::c_int,
    pub kswapd_wait: wait_queue_head_t,
    pub pfmemalloc_wait: wait_queue_head_t,
    pub kswapd: *mut task_struct,
    pub kswapd_order: c_types::c_int,
    pub kswapd_classzone_idx: zone_type,
    pub kswapd_failures: c_types::c_int,
    pub kcompactd_max_order: c_types::c_int,
    pub kcompactd_classzone_idx: zone_type,
    pub kcompactd_wait: wait_queue_head_t,
    pub kcompactd: *mut task_struct,
    pub totalreserve_pages: c_types::c_ulong,
    pub min_unmapped_pages: c_types::c_ulong,
    pub min_slab_pages: c_types::c_ulong,
    pub __bindgen_padding_0: [u64; 6usize],
    pub _pad1_: zone_padding,
    pub lru_lock: spinlock_t,
    pub deferred_split_queue: deferred_split,
    pub lruvec: lruvec,
    pub flags: c_types::c_ulong,
    pub __bindgen_padding_1: u64,
    pub _pad2_: zone_padding,
    pub per_cpu_nodestats: *mut per_cpu_nodestat,
    pub vm_stat: [atomic_long_t; 32usize],
}
#[test]
fn bindgen_test_layout_pglist_data() {
    assert_eq!(
        ::core::mem::size_of::<pglist_data>(),
        172928usize,
        concat!("Size of: ", stringify!(pglist_data))
    );
    assert_eq!(
        ::core::mem::align_of::<pglist_data>(),
        64usize,
        concat!("Alignment of ", stringify!(pglist_data))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pglist_data>())).node_zones as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pglist_data),
            "::",
            stringify!(node_zones)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pglist_data>())).node_zonelists as *const _ as usize },
        8320usize,
        concat!(
            "Offset of field: ",
            stringify!(pglist_data),
            "::",
            stringify!(node_zonelists)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pglist_data>())).nr_zones as *const _ as usize },
        172192usize,
        concat!(
            "Offset of field: ",
            stringify!(pglist_data),
            "::",
            stringify!(nr_zones)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pglist_data>())).node_size_lock as *const _ as usize },
        172196usize,
        concat!(
            "Offset of field: ",
            stringify!(pglist_data),
            "::",
            stringify!(node_size_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pglist_data>())).node_start_pfn as *const _ as usize },
        172200usize,
        concat!(
            "Offset of field: ",
            stringify!(pglist_data),
            "::",
            stringify!(node_start_pfn)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pglist_data>())).node_present_pages as *const _ as usize },
        172208usize,
        concat!(
            "Offset of field: ",
            stringify!(pglist_data),
            "::",
            stringify!(node_present_pages)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pglist_data>())).node_spanned_pages as *const _ as usize },
        172216usize,
        concat!(
            "Offset of field: ",
            stringify!(pglist_data),
            "::",
            stringify!(node_spanned_pages)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pglist_data>())).node_id as *const _ as usize },
        172224usize,
        concat!(
            "Offset of field: ",
            stringify!(pglist_data),
            "::",
            stringify!(node_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pglist_data>())).kswapd_wait as *const _ as usize },
        172232usize,
        concat!(
            "Offset of field: ",
            stringify!(pglist_data),
            "::",
            stringify!(kswapd_wait)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pglist_data>())).pfmemalloc_wait as *const _ as usize },
        172256usize,
        concat!(
            "Offset of field: ",
            stringify!(pglist_data),
            "::",
            stringify!(pfmemalloc_wait)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pglist_data>())).kswapd as *const _ as usize },
        172280usize,
        concat!(
            "Offset of field: ",
            stringify!(pglist_data),
            "::",
            stringify!(kswapd)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pglist_data>())).kswapd_order as *const _ as usize },
        172288usize,
        concat!(
            "Offset of field: ",
            stringify!(pglist_data),
            "::",
            stringify!(kswapd_order)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<pglist_data>())).kswapd_classzone_idx as *const _ as usize
        },
        172292usize,
        concat!(
            "Offset of field: ",
            stringify!(pglist_data),
            "::",
            stringify!(kswapd_classzone_idx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pglist_data>())).kswapd_failures as *const _ as usize },
        172296usize,
        concat!(
            "Offset of field: ",
            stringify!(pglist_data),
            "::",
            stringify!(kswapd_failures)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<pglist_data>())).kcompactd_max_order as *const _ as usize
        },
        172300usize,
        concat!(
            "Offset of field: ",
            stringify!(pglist_data),
            "::",
            stringify!(kcompactd_max_order)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<pglist_data>())).kcompactd_classzone_idx as *const _ as usize
        },
        172304usize,
        concat!(
            "Offset of field: ",
            stringify!(pglist_data),
            "::",
            stringify!(kcompactd_classzone_idx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pglist_data>())).kcompactd_wait as *const _ as usize },
        172312usize,
        concat!(
            "Offset of field: ",
            stringify!(pglist_data),
            "::",
            stringify!(kcompactd_wait)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pglist_data>())).kcompactd as *const _ as usize },
        172336usize,
        concat!(
            "Offset of field: ",
            stringify!(pglist_data),
            "::",
            stringify!(kcompactd)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pglist_data>())).totalreserve_pages as *const _ as usize },
        172344usize,
        concat!(
            "Offset of field: ",
            stringify!(pglist_data),
            "::",
            stringify!(totalreserve_pages)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pglist_data>())).min_unmapped_pages as *const _ as usize },
        172352usize,
        concat!(
            "Offset of field: ",
            stringify!(pglist_data),
            "::",
            stringify!(min_unmapped_pages)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pglist_data>())).min_slab_pages as *const _ as usize },
        172360usize,
        concat!(
            "Offset of field: ",
            stringify!(pglist_data),
            "::",
            stringify!(min_slab_pages)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pglist_data>()))._pad1_ as *const _ as usize },
        172416usize,
        concat!(
            "Offset of field: ",
            stringify!(pglist_data),
            "::",
            stringify!(_pad1_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pglist_data>())).lru_lock as *const _ as usize },
        172416usize,
        concat!(
            "Offset of field: ",
            stringify!(pglist_data),
            "::",
            stringify!(lru_lock)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<pglist_data>())).deferred_split_queue as *const _ as usize
        },
        172424usize,
        concat!(
            "Offset of field: ",
            stringify!(pglist_data),
            "::",
            stringify!(deferred_split_queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pglist_data>())).lruvec as *const _ as usize },
        172456usize,
        concat!(
            "Offset of field: ",
            stringify!(pglist_data),
            "::",
            stringify!(lruvec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pglist_data>())).flags as *const _ as usize },
        172592usize,
        concat!(
            "Offset of field: ",
            stringify!(pglist_data),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pglist_data>()))._pad2_ as *const _ as usize },
        172608usize,
        concat!(
            "Offset of field: ",
            stringify!(pglist_data),
            "::",
            stringify!(_pad2_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pglist_data>())).per_cpu_nodestats as *const _ as usize },
        172608usize,
        concat!(
            "Offset of field: ",
            stringify!(pglist_data),
            "::",
            stringify!(per_cpu_nodestats)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pglist_data>())).vm_stat as *const _ as usize },
        172616usize,
        concat!(
            "Offset of field: ",
            stringify!(pglist_data),
            "::",
            stringify!(vm_stat)
        )
    );
}
impl Default for pglist_data {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fwnode_handle {
    pub secondary: *mut fwnode_handle,
    pub ops: *const fwnode_operations,
}
#[test]
fn bindgen_test_layout_fwnode_handle() {
    assert_eq!(
        ::core::mem::size_of::<fwnode_handle>(),
        16usize,
        concat!("Size of: ", stringify!(fwnode_handle))
    );
    assert_eq!(
        ::core::mem::align_of::<fwnode_handle>(),
        8usize,
        concat!("Alignment of ", stringify!(fwnode_handle))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fwnode_handle>())).secondary as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fwnode_handle),
            "::",
            stringify!(secondary)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fwnode_handle>())).ops as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(fwnode_handle),
            "::",
            stringify!(ops)
        )
    );
}
impl Default for fwnode_handle {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[doc = " struct fwnode_endpoint - Fwnode graph endpoint"]
#[doc = " @port: Port number"]
#[doc = " @id: Endpoint id"]
#[doc = " @local_fwnode: reference to the related fwnode"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fwnode_endpoint {
    pub port: c_types::c_uint,
    pub id: c_types::c_uint,
    pub local_fwnode: *const fwnode_handle,
}
#[test]
fn bindgen_test_layout_fwnode_endpoint() {
    assert_eq!(
        ::core::mem::size_of::<fwnode_endpoint>(),
        16usize,
        concat!("Size of: ", stringify!(fwnode_endpoint))
    );
    assert_eq!(
        ::core::mem::align_of::<fwnode_endpoint>(),
        8usize,
        concat!("Alignment of ", stringify!(fwnode_endpoint))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fwnode_endpoint>())).port as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fwnode_endpoint),
            "::",
            stringify!(port)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fwnode_endpoint>())).id as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(fwnode_endpoint),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fwnode_endpoint>())).local_fwnode as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(fwnode_endpoint),
            "::",
            stringify!(local_fwnode)
        )
    );
}
impl Default for fwnode_endpoint {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[doc = " struct fwnode_reference_args - Fwnode reference with additional arguments"]
#[doc = " @fwnode:- A reference to the base fwnode"]
#[doc = " @nargs: Number of elements in @args array"]
#[doc = " @args: Integer arguments on the fwnode"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fwnode_reference_args {
    pub fwnode: *mut fwnode_handle,
    pub nargs: c_types::c_uint,
    pub args: [u64_; 8usize],
}
#[test]
fn bindgen_test_layout_fwnode_reference_args() {
    assert_eq!(
        ::core::mem::size_of::<fwnode_reference_args>(),
        80usize,
        concat!("Size of: ", stringify!(fwnode_reference_args))
    );
    assert_eq!(
        ::core::mem::align_of::<fwnode_reference_args>(),
        8usize,
        concat!("Alignment of ", stringify!(fwnode_reference_args))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fwnode_reference_args>())).fwnode as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fwnode_reference_args),
            "::",
            stringify!(fwnode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fwnode_reference_args>())).nargs as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(fwnode_reference_args),
            "::",
            stringify!(nargs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fwnode_reference_args>())).args as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(fwnode_reference_args),
            "::",
            stringify!(args)
        )
    );
}
impl Default for fwnode_reference_args {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[doc = " struct fwnode_operations - Operations for fwnode interface"]
#[doc = " @get: Get a reference to an fwnode."]
#[doc = " @put: Put a reference to an fwnode."]
#[doc = " @device_get_match_data: Return the device driver match data."]
#[doc = " @property_present: Return true if a property is present."]
#[doc = " @property_read_integer_array: Read an array of integer properties. Return"]
#[doc = "\t\t\t\t zero on success, a negative error code"]
#[doc = "\t\t\t\t otherwise."]
#[doc = " @property_read_string_array: Read an array of string properties. Return zero"]
#[doc = "\t\t\t\ton success, a negative error code otherwise."]
#[doc = " @get_parent: Return the parent of an fwnode."]
#[doc = " @get_next_child_node: Return the next child node in an iteration."]
#[doc = " @get_named_child_node: Return a child node with a given name."]
#[doc = " @get_reference_args: Return a reference pointed to by a property, with args"]
#[doc = " @graph_get_next_endpoint: Return an endpoint node in an iteration."]
#[doc = " @graph_get_remote_endpoint: Return the remote endpoint node of a local"]
#[doc = "\t\t\t       endpoint node."]
#[doc = " @graph_get_port_parent: Return the parent node of a port node."]
#[doc = " @graph_parse_endpoint: Parse endpoint for port and endpoint id."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct fwnode_operations {
    pub get: ::core::option::Option<
        unsafe extern "C" fn(fwnode: *mut fwnode_handle) -> *mut fwnode_handle,
    >,
    pub put: ::core::option::Option<unsafe extern "C" fn(fwnode: *mut fwnode_handle)>,
    pub device_is_available:
        ::core::option::Option<unsafe extern "C" fn(fwnode: *const fwnode_handle) -> bool_>,
    pub device_get_match_data: ::core::option::Option<
        unsafe extern "C" fn(
            fwnode: *const fwnode_handle,
            dev: *const device,
        ) -> *const c_types::c_void,
    >,
    pub property_present: ::core::option::Option<
        unsafe extern "C" fn(
            fwnode: *const fwnode_handle,
            propname: *const c_types::c_char,
        ) -> bool_,
    >,
    pub property_read_int_array: ::core::option::Option<
        unsafe extern "C" fn(
            fwnode: *const fwnode_handle,
            propname: *const c_types::c_char,
            elem_size: c_types::c_uint,
            val: *mut c_types::c_void,
            nval: usize,
        ) -> c_types::c_int,
    >,
    pub property_read_string_array: ::core::option::Option<
        unsafe extern "C" fn(
            fwnode_handle: *const fwnode_handle,
            propname: *const c_types::c_char,
            val: *mut *const c_types::c_char,
            nval: usize,
        ) -> c_types::c_int,
    >,
    pub get_parent: ::core::option::Option<
        unsafe extern "C" fn(fwnode: *const fwnode_handle) -> *mut fwnode_handle,
    >,
    pub get_next_child_node: ::core::option::Option<
        unsafe extern "C" fn(
            fwnode: *const fwnode_handle,
            child: *mut fwnode_handle,
        ) -> *mut fwnode_handle,
    >,
    pub get_named_child_node: ::core::option::Option<
        unsafe extern "C" fn(
            fwnode: *const fwnode_handle,
            name: *const c_types::c_char,
        ) -> *mut fwnode_handle,
    >,
    pub get_reference_args: ::core::option::Option<
        unsafe extern "C" fn(
            fwnode: *const fwnode_handle,
            prop: *const c_types::c_char,
            nargs_prop: *const c_types::c_char,
            nargs: c_types::c_uint,
            index: c_types::c_uint,
            args: *mut fwnode_reference_args,
        ) -> c_types::c_int,
    >,
    pub graph_get_next_endpoint: ::core::option::Option<
        unsafe extern "C" fn(
            fwnode: *const fwnode_handle,
            prev: *mut fwnode_handle,
        ) -> *mut fwnode_handle,
    >,
    pub graph_get_remote_endpoint: ::core::option::Option<
        unsafe extern "C" fn(fwnode: *const fwnode_handle) -> *mut fwnode_handle,
    >,
    pub graph_get_port_parent: ::core::option::Option<
        unsafe extern "C" fn(fwnode: *mut fwnode_handle) -> *mut fwnode_handle,
    >,
    pub graph_parse_endpoint: ::core::option::Option<
        unsafe extern "C" fn(
            fwnode: *const fwnode_handle,
            endpoint: *mut fwnode_endpoint,
        ) -> c_types::c_int,
    >,
}
#[test]
fn bindgen_test_layout_fwnode_operations() {
    assert_eq!(
        ::core::mem::size_of::<fwnode_operations>(),
        120usize,
        concat!("Size of: ", stringify!(fwnode_operations))
    );
    assert_eq!(
        ::core::mem::align_of::<fwnode_operations>(),
        8usize,
        concat!("Alignment of ", stringify!(fwnode_operations))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fwnode_operations>())).get as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fwnode_operations),
            "::",
            stringify!(get)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fwnode_operations>())).put as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(fwnode_operations),
            "::",
            stringify!(put)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<fwnode_operations>())).device_is_available as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(fwnode_operations),
            "::",
            stringify!(device_is_available)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<fwnode_operations>())).device_get_match_data as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(fwnode_operations),
            "::",
            stringify!(device_get_match_data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<fwnode_operations>())).property_present as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(fwnode_operations),
            "::",
            stringify!(property_present)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<fwnode_operations>())).property_read_int_array as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(fwnode_operations),
            "::",
            stringify!(property_read_int_array)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<fwnode_operations>())).property_read_string_array as *const _
                as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(fwnode_operations),
            "::",
            stringify!(property_read_string_array)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fwnode_operations>())).get_parent as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(fwnode_operations),
            "::",
            stringify!(get_parent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<fwnode_operations>())).get_next_child_node as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(fwnode_operations),
            "::",
            stringify!(get_next_child_node)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<fwnode_operations>())).get_named_child_node as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(fwnode_operations),
            "::",
            stringify!(get_named_child_node)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<fwnode_operations>())).get_reference_args as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(fwnode_operations),
            "::",
            stringify!(get_reference_args)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<fwnode_operations>())).graph_get_next_endpoint as *const _
                as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(fwnode_operations),
            "::",
            stringify!(graph_get_next_endpoint)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<fwnode_operations>())).graph_get_remote_endpoint as *const _
                as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(fwnode_operations),
            "::",
            stringify!(graph_get_remote_endpoint)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<fwnode_operations>())).graph_get_port_parent as *const _
                as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(fwnode_operations),
            "::",
            stringify!(graph_get_port_parent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<fwnode_operations>())).graph_parse_endpoint as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(fwnode_operations),
            "::",
            stringify!(graph_parse_endpoint)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llist_node {
    pub next: *mut llist_node,
}
#[test]
fn bindgen_test_layout_llist_node() {
    assert_eq!(
        ::core::mem::size_of::<llist_node>(),
        8usize,
        concat!("Size of: ", stringify!(llist_node))
    );
    assert_eq!(
        ::core::mem::align_of::<llist_node>(),
        8usize,
        concat!("Alignment of ", stringify!(llist_node))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<llist_node>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llist_node),
            "::",
            stringify!(next)
        )
    );
}
impl Default for llist_node {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vm_struct {
    pub next: *mut vm_struct,
    pub addr: *mut c_types::c_void,
    pub size: c_types::c_ulong,
    pub flags: c_types::c_ulong,
    pub pages: *mut *mut page,
    pub nr_pages: c_types::c_uint,
    pub phys_addr: phys_addr_t,
    pub caller: *const c_types::c_void,
}
#[test]
fn bindgen_test_layout_vm_struct() {
    assert_eq!(
        ::core::mem::size_of::<vm_struct>(),
        64usize,
        concat!("Size of: ", stringify!(vm_struct))
    );
    assert_eq!(
        ::core::mem::align_of::<vm_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(vm_struct))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vm_struct>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_struct),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vm_struct>())).addr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_struct),
            "::",
            stringify!(addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vm_struct>())).size as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_struct),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vm_struct>())).flags as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_struct),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vm_struct>())).pages as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_struct),
            "::",
            stringify!(pages)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vm_struct>())).nr_pages as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_struct),
            "::",
            stringify!(nr_pages)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vm_struct>())).phys_addr as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_struct),
            "::",
            stringify!(phys_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vm_struct>())).caller as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_struct),
            "::",
            stringify!(caller)
        )
    );
}
impl Default for vm_struct {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type smp_call_func_t = ::core::option::Option<unsafe extern "C" fn(info: *mut c_types::c_void)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __call_single_data {
    pub llist: llist_node,
    pub func: smp_call_func_t,
    pub info: *mut c_types::c_void,
    pub flags: c_types::c_uint,
}
#[test]
fn bindgen_test_layout___call_single_data() {
    assert_eq!(
        ::core::mem::size_of::<__call_single_data>(),
        32usize,
        concat!("Size of: ", stringify!(__call_single_data))
    );
    assert_eq!(
        ::core::mem::align_of::<__call_single_data>(),
        8usize,
        concat!("Alignment of ", stringify!(__call_single_data))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__call_single_data>())).llist as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__call_single_data),
            "::",
            stringify!(llist)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__call_single_data>())).func as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__call_single_data),
            "::",
            stringify!(func)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__call_single_data>())).info as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__call_single_data),
            "::",
            stringify!(info)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__call_single_data>())).flags as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__call_single_data),
            "::",
            stringify!(flags)
        )
    );
}
impl Default for __call_single_data {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct device_node {
    _unused: [u8; 0],
}
pub type percpu_ref_func_t = ::core::option::Option<unsafe extern "C" fn(arg1: *mut percpu_ref)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct percpu_ref {
    pub count: atomic_long_t,
    pub percpu_count_ptr: c_types::c_ulong,
    pub release: percpu_ref_func_t,
    pub confirm_switch: percpu_ref_func_t,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub rcu: callback_head,
}
#[test]
fn bindgen_test_layout_percpu_ref() {
    assert_eq!(
        ::core::mem::size_of::<percpu_ref>(),
        56usize,
        concat!("Size of: ", stringify!(percpu_ref))
    );
    assert_eq!(
        ::core::mem::align_of::<percpu_ref>(),
        8usize,
        concat!("Alignment of ", stringify!(percpu_ref))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<percpu_ref>())).count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(percpu_ref),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<percpu_ref>())).percpu_count_ptr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(percpu_ref),
            "::",
            stringify!(percpu_count_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<percpu_ref>())).release as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(percpu_ref),
            "::",
            stringify!(release)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<percpu_ref>())).confirm_switch as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(percpu_ref),
            "::",
            stringify!(confirm_switch)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<percpu_ref>())).rcu as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(percpu_ref),
            "::",
            stringify!(rcu)
        )
    );
}
impl Default for percpu_ref {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl percpu_ref {
    #[inline]
    pub fn force_atomic(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_force_atomic(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn allow_reinit(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_allow_reinit(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        force_atomic: bool_,
        allow_reinit: bool_,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let force_atomic: u8 = unsafe { ::core::mem::transmute(force_atomic) };
            force_atomic as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let allow_reinit: u8 = unsafe { ::core::mem::transmute(allow_reinit) };
            allow_reinit as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct shrink_control {
    pub gfp_mask: gfp_t,
    pub nid: c_types::c_int,
    pub nr_to_scan: c_types::c_ulong,
    pub nr_scanned: c_types::c_ulong,
    pub memcg: *mut mem_cgroup,
}
#[test]
fn bindgen_test_layout_shrink_control() {
    assert_eq!(
        ::core::mem::size_of::<shrink_control>(),
        32usize,
        concat!("Size of: ", stringify!(shrink_control))
    );
    assert_eq!(
        ::core::mem::align_of::<shrink_control>(),
        8usize,
        concat!("Alignment of ", stringify!(shrink_control))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<shrink_control>())).gfp_mask as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(shrink_control),
            "::",
            stringify!(gfp_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<shrink_control>())).nid as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(shrink_control),
            "::",
            stringify!(nid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<shrink_control>())).nr_to_scan as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(shrink_control),
            "::",
            stringify!(nr_to_scan)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<shrink_control>())).nr_scanned as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(shrink_control),
            "::",
            stringify!(nr_scanned)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<shrink_control>())).memcg as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(shrink_control),
            "::",
            stringify!(memcg)
        )
    );
}
impl Default for shrink_control {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct shrinker {
    pub count_objects: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut shrinker, sc: *mut shrink_control) -> c_types::c_ulong,
    >,
    pub scan_objects: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut shrinker, sc: *mut shrink_control) -> c_types::c_ulong,
    >,
    pub batch: c_types::c_long,
    pub seeks: c_types::c_int,
    pub flags: c_types::c_uint,
    pub list: list_head,
    pub id: c_types::c_int,
    pub nr_deferred: *mut atomic_long_t,
}
#[test]
fn bindgen_test_layout_shrinker() {
    assert_eq!(
        ::core::mem::size_of::<shrinker>(),
        64usize,
        concat!("Size of: ", stringify!(shrinker))
    );
    assert_eq!(
        ::core::mem::align_of::<shrinker>(),
        8usize,
        concat!("Alignment of ", stringify!(shrinker))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<shrinker>())).count_objects as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(shrinker),
            "::",
            stringify!(count_objects)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<shrinker>())).scan_objects as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(shrinker),
            "::",
            stringify!(scan_objects)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<shrinker>())).batch as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(shrinker),
            "::",
            stringify!(batch)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<shrinker>())).seeks as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(shrinker),
            "::",
            stringify!(seeks)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<shrinker>())).flags as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(shrinker),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<shrinker>())).list as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(shrinker),
            "::",
            stringify!(list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<shrinker>())).id as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(shrinker),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<shrinker>())).nr_deferred as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(shrinker),
            "::",
            stringify!(nr_deferred)
        )
    );
}
impl Default for shrinker {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlimit {
    pub rlim_cur: __kernel_ulong_t,
    pub rlim_max: __kernel_ulong_t,
}
#[test]
fn bindgen_test_layout_rlimit() {
    assert_eq!(
        ::core::mem::size_of::<rlimit>(),
        16usize,
        concat!("Size of: ", stringify!(rlimit))
    );
    assert_eq!(
        ::core::mem::align_of::<rlimit>(),
        8usize,
        concat!("Alignment of ", stringify!(rlimit))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlimit>())).rlim_cur as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlimit),
            "::",
            stringify!(rlim_cur)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlimit>())).rlim_max as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rlimit),
            "::",
            stringify!(rlim_max)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct resource {
    pub start: resource_size_t,
    pub end: resource_size_t,
    pub name: *const c_types::c_char,
    pub flags: c_types::c_ulong,
    pub desc: c_types::c_ulong,
    pub parent: *mut resource,
    pub sibling: *mut resource,
    pub child: *mut resource,
}
#[test]
fn bindgen_test_layout_resource() {
    assert_eq!(
        ::core::mem::size_of::<resource>(),
        64usize,
        concat!("Size of: ", stringify!(resource))
    );
    assert_eq!(
        ::core::mem::align_of::<resource>(),
        8usize,
        concat!("Alignment of ", stringify!(resource))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<resource>())).start as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(resource),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<resource>())).end as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(resource),
            "::",
            stringify!(end)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<resource>())).name as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(resource),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<resource>())).flags as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(resource),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<resource>())).desc as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(resource),
            "::",
            stringify!(desc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<resource>())).parent as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(resource),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<resource>())).sibling as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(resource),
            "::",
            stringify!(sibling)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<resource>())).child as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(resource),
            "::",
            stringify!(child)
        )
    );
}
impl Default for resource {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[doc = " struct vmem_altmap - pre-allocated storage for vmemmap_populate"]
#[doc = " @base_pfn: base of the entire dev_pagemap mapping"]
#[doc = " @reserve: pages mapped, but reserved for driver use (relative to @base)"]
#[doc = " @free: free pages set aside in the mapping for memmap storage"]
#[doc = " @align: pages reserved to meet allocation alignments"]
#[doc = " @alloc: track pages consumed, private to vmemmap_populate()"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct vmem_altmap {
    pub base_pfn: c_types::c_ulong,
    pub end_pfn: c_types::c_ulong,
    pub reserve: c_types::c_ulong,
    pub free: c_types::c_ulong,
    pub align: c_types::c_ulong,
    pub alloc: c_types::c_ulong,
}
#[test]
fn bindgen_test_layout_vmem_altmap() {
    assert_eq!(
        ::core::mem::size_of::<vmem_altmap>(),
        48usize,
        concat!("Size of: ", stringify!(vmem_altmap))
    );
    assert_eq!(
        ::core::mem::align_of::<vmem_altmap>(),
        8usize,
        concat!("Alignment of ", stringify!(vmem_altmap))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vmem_altmap>())).base_pfn as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vmem_altmap),
            "::",
            stringify!(base_pfn)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vmem_altmap>())).end_pfn as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vmem_altmap),
            "::",
            stringify!(end_pfn)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vmem_altmap>())).reserve as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vmem_altmap),
            "::",
            stringify!(reserve)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vmem_altmap>())).free as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(vmem_altmap),
            "::",
            stringify!(free)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vmem_altmap>())).align as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(vmem_altmap),
            "::",
            stringify!(align)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vmem_altmap>())).alloc as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(vmem_altmap),
            "::",
            stringify!(alloc)
        )
    );
}
pub const memory_type_MEMORY_DEVICE_PRIVATE: memory_type = 1;
pub const memory_type_MEMORY_DEVICE_FS_DAX: memory_type = 2;
pub const memory_type_MEMORY_DEVICE_DEVDAX: memory_type = 3;
pub const memory_type_MEMORY_DEVICE_PCI_P2PDMA: memory_type = 4;
pub type memory_type = c_types::c_uint;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct dev_pagemap_ops {
    pub page_free: ::core::option::Option<unsafe extern "C" fn(page: *mut page)>,
    pub kill: ::core::option::Option<unsafe extern "C" fn(pgmap: *mut dev_pagemap)>,
    pub cleanup: ::core::option::Option<unsafe extern "C" fn(pgmap: *mut dev_pagemap)>,
    pub migrate_to_ram:
        ::core::option::Option<unsafe extern "C" fn(vmf: *mut vm_fault) -> vm_fault_t>,
}
#[test]
fn bindgen_test_layout_dev_pagemap_ops() {
    assert_eq!(
        ::core::mem::size_of::<dev_pagemap_ops>(),
        32usize,
        concat!("Size of: ", stringify!(dev_pagemap_ops))
    );
    assert_eq!(
        ::core::mem::align_of::<dev_pagemap_ops>(),
        8usize,
        concat!("Alignment of ", stringify!(dev_pagemap_ops))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dev_pagemap_ops>())).page_free as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_pagemap_ops),
            "::",
            stringify!(page_free)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dev_pagemap_ops>())).kill as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_pagemap_ops),
            "::",
            stringify!(kill)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dev_pagemap_ops>())).cleanup as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_pagemap_ops),
            "::",
            stringify!(cleanup)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dev_pagemap_ops>())).migrate_to_ram as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_pagemap_ops),
            "::",
            stringify!(migrate_to_ram)
        )
    );
}
#[doc = " struct dev_pagemap - metadata for ZONE_DEVICE mappings"]
#[doc = " @altmap: pre-allocated/reserved memory for vmemmap allocations"]
#[doc = " @res: physical address range covered by @ref"]
#[doc = " @ref: reference count that pins the devm_memremap_pages() mapping"]
#[doc = " @internal_ref: internal reference if @ref is not provided by the caller"]
#[doc = " @done: completion for @internal_ref"]
#[doc = " @dev: host device of the mapping for debug"]
#[doc = " @data: private data pointer for page_free()"]
#[doc = " @type: memory type: see MEMORY_* in memory_hotplug.h"]
#[doc = " @flags: PGMAP_* flags to specify defailed behavior"]
#[doc = " @ops: method table"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct dev_pagemap {
    pub altmap: vmem_altmap,
    pub res: resource,
    pub ref_: *mut percpu_ref,
    pub internal_ref: percpu_ref,
    pub done: completion,
    pub type_: memory_type,
    pub flags: c_types::c_uint,
    pub ops: *const dev_pagemap_ops,
}
#[test]
fn bindgen_test_layout_dev_pagemap() {
    assert_eq!(
        ::core::mem::size_of::<dev_pagemap>(),
        224usize,
        concat!("Size of: ", stringify!(dev_pagemap))
    );
    assert_eq!(
        ::core::mem::align_of::<dev_pagemap>(),
        8usize,
        concat!("Alignment of ", stringify!(dev_pagemap))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dev_pagemap>())).altmap as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_pagemap),
            "::",
            stringify!(altmap)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dev_pagemap>())).res as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_pagemap),
            "::",
            stringify!(res)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dev_pagemap>())).ref_ as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_pagemap),
            "::",
            stringify!(ref_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dev_pagemap>())).internal_ref as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_pagemap),
            "::",
            stringify!(internal_ref)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dev_pagemap>())).done as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_pagemap),
            "::",
            stringify!(done)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dev_pagemap>())).type_ as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_pagemap),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dev_pagemap>())).flags as *const _ as usize },
        212usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_pagemap),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dev_pagemap>())).ops as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_pagemap),
            "::",
            stringify!(ops)
        )
    );
}
impl Default for dev_pagemap {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mempolicy {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct anon_vma {
    _unused: [u8; 0],
}
#[doc = " struct refcount_t - variant of atomic_t specialized for reference counts"]
#[doc = " @refs: atomic_t counter field"]
#[doc = ""]
#[doc = " The counter saturates at UINT_MAX and will not move once"]
#[doc = " there. This avoids wrapping the counter and causing 'spurious'"]
#[doc = " use-after-free bugs."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct refcount_struct {
    pub refs: atomic_t,
}
#[test]
fn bindgen_test_layout_refcount_struct() {
    assert_eq!(
        ::core::mem::size_of::<refcount_struct>(),
        4usize,
        concat!("Size of: ", stringify!(refcount_struct))
    );
    assert_eq!(
        ::core::mem::align_of::<refcount_struct>(),
        4usize,
        concat!("Alignment of ", stringify!(refcount_struct))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<refcount_struct>())).refs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(refcount_struct),
            "::",
            stringify!(refs)
        )
    );
}
#[doc = " struct refcount_t - variant of atomic_t specialized for reference counts"]
#[doc = " @refs: atomic_t counter field"]
#[doc = ""]
#[doc = " The counter saturates at UINT_MAX and will not move once"]
#[doc = " there. This avoids wrapping the counter and causing 'spurious'"]
#[doc = " use-after-free bugs."]
pub type refcount_t = refcount_struct;
pub const pid_type_PIDTYPE_PID: pid_type = 0;
pub const pid_type_PIDTYPE_TGID: pid_type = 1;
pub const pid_type_PIDTYPE_PGID: pid_type = 2;
pub const pid_type_PIDTYPE_SID: pid_type = 3;
pub const pid_type_PIDTYPE_MAX: pid_type = 4;
pub type pid_type = c_types::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct upid {
    pub nr: c_types::c_int,
    pub ns: *mut pid_namespace,
}
#[test]
fn bindgen_test_layout_upid() {
    assert_eq!(
        ::core::mem::size_of::<upid>(),
        16usize,
        concat!("Size of: ", stringify!(upid))
    );
    assert_eq!(
        ::core::mem::align_of::<upid>(),
        8usize,
        concat!("Alignment of ", stringify!(upid))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<upid>())).nr as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(upid), "::", stringify!(nr))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<upid>())).ns as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(upid), "::", stringify!(ns))
    );
}
impl Default for upid {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pid {
    pub count: refcount_t,
    pub level: c_types::c_uint,
    pub tasks: [hlist_head; 4usize],
    pub wait_pidfd: wait_queue_head_t,
    pub rcu: callback_head,
    pub numbers: [upid; 1usize],
}
#[test]
fn bindgen_test_layout_pid() {
    assert_eq!(
        ::core::mem::size_of::<pid>(),
        96usize,
        concat!("Size of: ", stringify!(pid))
    );
    assert_eq!(
        ::core::mem::align_of::<pid>(),
        8usize,
        concat!("Alignment of ", stringify!(pid))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pid>())).count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pid),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pid>())).level as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(pid),
            "::",
            stringify!(level)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pid>())).tasks as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pid),
            "::",
            stringify!(tasks)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pid>())).wait_pidfd as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(pid),
            "::",
            stringify!(wait_pidfd)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pid>())).rcu as *const _ as usize },
        64usize,
        concat!("Offset of field: ", stringify!(pid), "::", stringify!(rcu))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pid>())).numbers as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(pid),
            "::",
            stringify!(numbers)
        )
    );
}
impl Default for pid {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pid_namespace {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rhash_head {
    pub next: *mut rhash_head,
}
#[test]
fn bindgen_test_layout_rhash_head() {
    assert_eq!(
        ::core::mem::size_of::<rhash_head>(),
        8usize,
        concat!("Size of: ", stringify!(rhash_head))
    );
    assert_eq!(
        ::core::mem::align_of::<rhash_head>(),
        8usize,
        concat!("Alignment of ", stringify!(rhash_head))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rhash_head>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rhash_head),
            "::",
            stringify!(next)
        )
    );
}
impl Default for rhash_head {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[doc = " struct rhashtable_compare_arg - Key for the function rhashtable_compare"]
#[doc = " @ht: Hash table"]
#[doc = " @key: Key to compare against"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rhashtable_compare_arg {
    pub ht: *mut rhashtable,
    pub key: *const c_types::c_void,
}
#[test]
fn bindgen_test_layout_rhashtable_compare_arg() {
    assert_eq!(
        ::core::mem::size_of::<rhashtable_compare_arg>(),
        16usize,
        concat!("Size of: ", stringify!(rhashtable_compare_arg))
    );
    assert_eq!(
        ::core::mem::align_of::<rhashtable_compare_arg>(),
        8usize,
        concat!("Alignment of ", stringify!(rhashtable_compare_arg))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rhashtable_compare_arg>())).ht as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rhashtable_compare_arg),
            "::",
            stringify!(ht)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rhashtable_compare_arg>())).key as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rhashtable_compare_arg),
            "::",
            stringify!(key)
        )
    );
}
impl Default for rhashtable_compare_arg {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type rht_hashfn_t = ::core::option::Option<
    unsafe extern "C" fn(data: *const c_types::c_void, len: u32_, seed: u32_) -> u32_,
>;
pub type rht_obj_hashfn_t = ::core::option::Option<
    unsafe extern "C" fn(data: *const c_types::c_void, len: u32_, seed: u32_) -> u32_,
>;
pub type rht_obj_cmpfn_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg: *mut rhashtable_compare_arg,
        obj: *const c_types::c_void,
    ) -> c_types::c_int,
>;
#[doc = " struct rhashtable_params - Hash table construction parameters"]
#[doc = " @nelem_hint: Hint on number of elements, should be 75% of desired size"]
#[doc = " @key_len: Length of key"]
#[doc = " @key_offset: Offset of key in struct to be hashed"]
#[doc = " @head_offset: Offset of rhash_head in struct to be hashed"]
#[doc = " @max_size: Maximum size while expanding"]
#[doc = " @min_size: Minimum size while shrinking"]
#[doc = " @automatic_shrinking: Enable automatic shrinking of tables"]
#[doc = " @hashfn: Hash function (default: jhash2 if !(key_len % 4), or jhash)"]
#[doc = " @obj_hashfn: Function to hash object"]
#[doc = " @obj_cmpfn: Function to compare key with object"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rhashtable_params {
    pub nelem_hint: u16_,
    pub key_len: u16_,
    pub key_offset: u16_,
    pub head_offset: u16_,
    pub max_size: c_types::c_uint,
    pub min_size: u16_,
    pub automatic_shrinking: bool_,
    pub hashfn: rht_hashfn_t,
    pub obj_hashfn: rht_obj_hashfn_t,
    pub obj_cmpfn: rht_obj_cmpfn_t,
}
#[test]
fn bindgen_test_layout_rhashtable_params() {
    assert_eq!(
        ::core::mem::size_of::<rhashtable_params>(),
        40usize,
        concat!("Size of: ", stringify!(rhashtable_params))
    );
    assert_eq!(
        ::core::mem::align_of::<rhashtable_params>(),
        8usize,
        concat!("Alignment of ", stringify!(rhashtable_params))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rhashtable_params>())).nelem_hint as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rhashtable_params),
            "::",
            stringify!(nelem_hint)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rhashtable_params>())).key_len as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rhashtable_params),
            "::",
            stringify!(key_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rhashtable_params>())).key_offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rhashtable_params),
            "::",
            stringify!(key_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rhashtable_params>())).head_offset as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(rhashtable_params),
            "::",
            stringify!(head_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rhashtable_params>())).max_size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rhashtable_params),
            "::",
            stringify!(max_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rhashtable_params>())).min_size as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rhashtable_params),
            "::",
            stringify!(min_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rhashtable_params>())).automatic_shrinking as *const _ as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(rhashtable_params),
            "::",
            stringify!(automatic_shrinking)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rhashtable_params>())).hashfn as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rhashtable_params),
            "::",
            stringify!(hashfn)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rhashtable_params>())).obj_hashfn as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rhashtable_params),
            "::",
            stringify!(obj_hashfn)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rhashtable_params>())).obj_cmpfn as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rhashtable_params),
            "::",
            stringify!(obj_cmpfn)
        )
    );
}
#[doc = " struct rhashtable - Hash table handle"]
#[doc = " @tbl: Bucket table"]
#[doc = " @key_len: Key length for hashfn"]
#[doc = " @max_elems: Maximum number of elements in table"]
#[doc = " @p: Configuration parameters"]
#[doc = " @rhlist: True if this is an rhltable"]
#[doc = " @run_work: Deferred worker to expand/shrink asynchronously"]
#[doc = " @mutex: Mutex to protect current/future table swapping"]
#[doc = " @lock: Spin lock to protect walker list"]
#[doc = " @nelems: Number of elements in table"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rhashtable {
    pub tbl: *mut bucket_table,
    pub key_len: c_types::c_uint,
    pub max_elems: c_types::c_uint,
    pub p: rhashtable_params,
    pub rhlist: bool_,
    pub run_work: work_struct,
    pub mutex: mutex,
    pub lock: spinlock_t,
    pub nelems: atomic_t,
}
#[test]
fn bindgen_test_layout_rhashtable() {
    assert_eq!(
        ::core::mem::size_of::<rhashtable>(),
        136usize,
        concat!("Size of: ", stringify!(rhashtable))
    );
    assert_eq!(
        ::core::mem::align_of::<rhashtable>(),
        8usize,
        concat!("Alignment of ", stringify!(rhashtable))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rhashtable>())).tbl as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rhashtable),
            "::",
            stringify!(tbl)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rhashtable>())).key_len as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rhashtable),
            "::",
            stringify!(key_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rhashtable>())).max_elems as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rhashtable),
            "::",
            stringify!(max_elems)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rhashtable>())).p as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rhashtable),
            "::",
            stringify!(p)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rhashtable>())).rhlist as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rhashtable),
            "::",
            stringify!(rhlist)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rhashtable>())).run_work as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rhashtable),
            "::",
            stringify!(run_work)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rhashtable>())).mutex as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rhashtable),
            "::",
            stringify!(mutex)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rhashtable>())).lock as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(rhashtable),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rhashtable>())).nelems as *const _ as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(rhashtable),
            "::",
            stringify!(nelems)
        )
    );
}
impl Default for rhashtable {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sem_undo_list {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sysv_sem {
    pub undo_list: *mut sem_undo_list,
}
#[test]
fn bindgen_test_layout_sysv_sem() {
    assert_eq!(
        ::core::mem::size_of::<sysv_sem>(),
        8usize,
        concat!("Size of: ", stringify!(sysv_sem))
    );
    assert_eq!(
        ::core::mem::align_of::<sysv_sem>(),
        8usize,
        concat!("Alignment of ", stringify!(sysv_sem))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sysv_sem>())).undo_list as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sysv_sem),
            "::",
            stringify!(undo_list)
        )
    );
}
impl Default for sysv_sem {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sysv_shm {
    pub shm_clist: list_head,
}
#[test]
fn bindgen_test_layout_sysv_shm() {
    assert_eq!(
        ::core::mem::size_of::<sysv_shm>(),
        16usize,
        concat!("Size of: ", stringify!(sysv_shm))
    );
    assert_eq!(
        ::core::mem::align_of::<sysv_shm>(),
        8usize,
        concat!("Alignment of ", stringify!(sysv_shm))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sysv_shm>())).shm_clist as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sysv_shm),
            "::",
            stringify!(shm_clist)
        )
    );
}
impl Default for sysv_shm {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct plist_node {
    pub prio: c_types::c_int,
    pub prio_list: list_head,
    pub node_list: list_head,
}
#[test]
fn bindgen_test_layout_plist_node() {
    assert_eq!(
        ::core::mem::size_of::<plist_node>(),
        40usize,
        concat!("Size of: ", stringify!(plist_node))
    );
    assert_eq!(
        ::core::mem::align_of::<plist_node>(),
        8usize,
        concat!("Alignment of ", stringify!(plist_node))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<plist_node>())).prio as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(plist_node),
            "::",
            stringify!(prio)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<plist_node>())).prio_list as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(plist_node),
            "::",
            stringify!(prio_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<plist_node>())).node_list as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(plist_node),
            "::",
            stringify!(node_list)
        )
    );
}
impl Default for plist_node {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timerqueue_node {
    pub node: rb_node,
    pub expires: ktime_t,
}
#[test]
fn bindgen_test_layout_timerqueue_node() {
    assert_eq!(
        ::core::mem::size_of::<timerqueue_node>(),
        32usize,
        concat!("Size of: ", stringify!(timerqueue_node))
    );
    assert_eq!(
        ::core::mem::align_of::<timerqueue_node>(),
        8usize,
        concat!("Alignment of ", stringify!(timerqueue_node))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timerqueue_node>())).node as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timerqueue_node),
            "::",
            stringify!(node)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timerqueue_node>())).expires as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(timerqueue_node),
            "::",
            stringify!(expires)
        )
    );
}
impl Default for timerqueue_node {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timerqueue_head {
    pub rb_root: rb_root_cached,
}
#[test]
fn bindgen_test_layout_timerqueue_head() {
    assert_eq!(
        ::core::mem::size_of::<timerqueue_head>(),
        16usize,
        concat!("Size of: ", stringify!(timerqueue_head))
    );
    assert_eq!(
        ::core::mem::align_of::<timerqueue_head>(),
        8usize,
        concat!("Alignment of ", stringify!(timerqueue_head))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timerqueue_head>())).rb_root as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timerqueue_head),
            "::",
            stringify!(rb_root)
        )
    );
}
impl Default for timerqueue_head {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub const hrtimer_restart_HRTIMER_NORESTART: hrtimer_restart = 0;
pub const hrtimer_restart_HRTIMER_RESTART: hrtimer_restart = 1;
pub type hrtimer_restart = i32;
#[doc = " struct hrtimer - the basic hrtimer structure"]
#[doc = " @node:\ttimerqueue node, which also manages node.expires,"]
#[doc = "\t\tthe absolute expiry time in the hrtimers internal"]
#[doc = "\t\trepresentation. The time is related to the clock on"]
#[doc = "\t\twhich the timer is based. Is setup by adding"]
#[doc = "\t\tslack to the _softexpires value. For non range timers"]
#[doc = "\t\tidentical to _softexpires."]
#[doc = " @_softexpires: the absolute earliest expiry time of the hrtimer."]
#[doc = "\t\tThe time which was given as expiry time when the timer"]
#[doc = "\t\twas armed."]
#[doc = " @function:\ttimer expiry callback function"]
#[doc = " @base:\tpointer to the timer base (per cpu and per clock)"]
#[doc = " @state:\tstate information (See bit values above)"]
#[doc = " @is_rel:\tSet if the timer was armed relative"]
#[doc = " @is_soft:\tSet if hrtimer will be expired in soft interrupt context."]
#[doc = " @is_hard:\tSet if hrtimer will be expired in hard interrupt context"]
#[doc = "\t\teven on RT."]
#[doc = ""]
#[doc = " The hrtimer structure must be initialized by hrtimer_init()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hrtimer {
    pub node: timerqueue_node,
    pub _softexpires: ktime_t,
    pub function:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut hrtimer) -> hrtimer_restart>,
    pub base: *mut hrtimer_clock_base,
    pub state: u8_,
    pub is_rel: u8_,
    pub is_soft: u8_,
    pub is_hard: u8_,
}
#[test]
fn bindgen_test_layout_hrtimer() {
    assert_eq!(
        ::core::mem::size_of::<hrtimer>(),
        64usize,
        concat!("Size of: ", stringify!(hrtimer))
    );
    assert_eq!(
        ::core::mem::align_of::<hrtimer>(),
        8usize,
        concat!("Alignment of ", stringify!(hrtimer))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hrtimer>())).node as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hrtimer),
            "::",
            stringify!(node)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hrtimer>()))._softexpires as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(hrtimer),
            "::",
            stringify!(_softexpires)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hrtimer>())).function as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(hrtimer),
            "::",
            stringify!(function)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hrtimer>())).base as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(hrtimer),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hrtimer>())).state as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(hrtimer),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hrtimer>())).is_rel as *const _ as usize },
        57usize,
        concat!(
            "Offset of field: ",
            stringify!(hrtimer),
            "::",
            stringify!(is_rel)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hrtimer>())).is_soft as *const _ as usize },
        58usize,
        concat!(
            "Offset of field: ",
            stringify!(hrtimer),
            "::",
            stringify!(is_soft)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hrtimer>())).is_hard as *const _ as usize },
        59usize,
        concat!(
            "Offset of field: ",
            stringify!(hrtimer),
            "::",
            stringify!(is_hard)
        )
    );
}
impl Default for hrtimer {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[doc = " struct hrtimer_clock_base - the timer base for a specific clock"]
#[doc = " @cpu_base:\t\tper cpu clock base"]
#[doc = " @index:\t\tclock type index for per_cpu support when moving a"]
#[doc = "\t\t\ttimer to a base on another cpu."]
#[doc = " @clockid:\t\tclock id for per_cpu support"]
#[doc = " @seq:\t\tseqcount around __run_hrtimer"]
#[doc = " @running:\t\tpointer to the currently running hrtimer"]
#[doc = " @active:\t\tred black tree root node for the active timers"]
#[doc = " @get_time:\t\tfunction to retrieve the current time of the clock"]
#[doc = " @offset:\t\toffset of this clock to the monotonic base"]
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct hrtimer_clock_base {
    pub cpu_base: *mut hrtimer_cpu_base,
    pub index: c_types::c_uint,
    pub clockid: clockid_t,
    pub seq: seqcount_t,
    pub running: *mut hrtimer,
    pub active: timerqueue_head,
    pub get_time: ::core::option::Option<unsafe extern "C" fn() -> ktime_t>,
    pub offset: ktime_t,
}
#[test]
fn bindgen_test_layout_hrtimer_clock_base() {
    assert_eq!(
        ::core::mem::size_of::<hrtimer_clock_base>(),
        64usize,
        concat!("Size of: ", stringify!(hrtimer_clock_base))
    );
    assert_eq!(
        ::core::mem::align_of::<hrtimer_clock_base>(),
        64usize,
        concat!("Alignment of ", stringify!(hrtimer_clock_base))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hrtimer_clock_base>())).cpu_base as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hrtimer_clock_base),
            "::",
            stringify!(cpu_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hrtimer_clock_base>())).index as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hrtimer_clock_base),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hrtimer_clock_base>())).clockid as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(hrtimer_clock_base),
            "::",
            stringify!(clockid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hrtimer_clock_base>())).seq as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hrtimer_clock_base),
            "::",
            stringify!(seq)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hrtimer_clock_base>())).running as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(hrtimer_clock_base),
            "::",
            stringify!(running)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hrtimer_clock_base>())).active as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(hrtimer_clock_base),
            "::",
            stringify!(active)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hrtimer_clock_base>())).get_time as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(hrtimer_clock_base),
            "::",
            stringify!(get_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hrtimer_clock_base>())).offset as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(hrtimer_clock_base),
            "::",
            stringify!(offset)
        )
    );
}
impl Default for hrtimer_clock_base {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[doc = " struct hrtimer_cpu_base - the per cpu clock bases"]
#[doc = " @lock:\t\tlock protecting the base and associated clock bases"]
#[doc = "\t\t\tand timers"]
#[doc = " @cpu:\t\tcpu number"]
#[doc = " @active_bases:\tBitfield to mark bases with active timers"]
#[doc = " @clock_was_set_seq:\tSequence counter of clock was set events"]
#[doc = " @hres_active:\tState of high resolution mode"]
#[doc = " @in_hrtirq:\t\thrtimer_interrupt() is currently executing"]
#[doc = " @hang_detected:\tThe last hrtimer interrupt detected a hang"]
#[doc = " @softirq_activated:\tdisplays, if the softirq is raised - update of softirq"]
#[doc = "\t\t\trelated settings is not required then."]
#[doc = " @nr_events:\t\tTotal number of hrtimer interrupt events"]
#[doc = " @nr_retries:\t\tTotal number of hrtimer interrupt retries"]
#[doc = " @nr_hangs:\t\tTotal number of hrtimer interrupt hangs"]
#[doc = " @max_hang_time:\tMaximum time spent in hrtimer_interrupt"]
#[doc = " @softirq_expiry_lock: Lock which is taken while softirq based hrtimer are"]
#[doc = "\t\t\t expired"]
#[doc = " @timer_waiters:\tA hrtimer_cancel() invocation waits for the timer"]
#[doc = "\t\t\tcallback to finish."]
#[doc = " @expires_next:\tabsolute time of the next event, is required for remote"]
#[doc = "\t\t\thrtimer enqueue; it is the total first expiry time (hard"]
#[doc = "\t\t\tand soft hrtimer are taken into account)"]
#[doc = " @next_timer:\t\tPointer to the first expiring timer"]
#[doc = " @softirq_expires_next: Time to check, if soft queues needs also to be expired"]
#[doc = " @softirq_next_timer: Pointer to the first expiring softirq based timer"]
#[doc = " @clock_base:\t\tarray of clock bases for this cpu"]
#[doc = ""]
#[doc = " Note: next_timer is just an optimization for __remove_hrtimer()."]
#[doc = "\t Do not dereference the pointer because it is not reliable on"]
#[doc = "\t cross cpu removals."]
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct hrtimer_cpu_base {
    pub lock: raw_spinlock_t,
    pub cpu: c_types::c_uint,
    pub active_bases: c_types::c_uint,
    pub clock_was_set_seq: c_types::c_uint,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub nr_events: c_types::c_uint,
    pub nr_retries: c_types::c_ushort,
    pub nr_hangs: c_types::c_ushort,
    pub max_hang_time: c_types::c_uint,
    pub expires_next: ktime_t,
    pub next_timer: *mut hrtimer,
    pub softirq_expires_next: ktime_t,
    pub softirq_next_timer: *mut hrtimer,
    pub clock_base: [hrtimer_clock_base; 8usize],
}
#[test]
fn bindgen_test_layout_hrtimer_cpu_base() {
    assert_eq!(
        ::core::mem::size_of::<hrtimer_cpu_base>(),
        576usize,
        concat!("Size of: ", stringify!(hrtimer_cpu_base))
    );
    assert_eq!(
        ::core::mem::align_of::<hrtimer_cpu_base>(),
        64usize,
        concat!("Alignment of ", stringify!(hrtimer_cpu_base))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hrtimer_cpu_base>())).lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hrtimer_cpu_base),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hrtimer_cpu_base>())).cpu as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(hrtimer_cpu_base),
            "::",
            stringify!(cpu)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hrtimer_cpu_base>())).active_bases as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hrtimer_cpu_base),
            "::",
            stringify!(active_bases)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<hrtimer_cpu_base>())).clock_was_set_seq as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(hrtimer_cpu_base),
            "::",
            stringify!(clock_was_set_seq)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hrtimer_cpu_base>())).nr_events as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(hrtimer_cpu_base),
            "::",
            stringify!(nr_events)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hrtimer_cpu_base>())).nr_retries as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(hrtimer_cpu_base),
            "::",
            stringify!(nr_retries)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hrtimer_cpu_base>())).nr_hangs as *const _ as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(hrtimer_cpu_base),
            "::",
            stringify!(nr_hangs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hrtimer_cpu_base>())).max_hang_time as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(hrtimer_cpu_base),
            "::",
            stringify!(max_hang_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hrtimer_cpu_base>())).expires_next as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(hrtimer_cpu_base),
            "::",
            stringify!(expires_next)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hrtimer_cpu_base>())).next_timer as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(hrtimer_cpu_base),
            "::",
            stringify!(next_timer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<hrtimer_cpu_base>())).softirq_expires_next as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(hrtimer_cpu_base),
            "::",
            stringify!(softirq_expires_next)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<hrtimer_cpu_base>())).softirq_next_timer as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(hrtimer_cpu_base),
            "::",
            stringify!(softirq_next_timer)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hrtimer_cpu_base>())).clock_base as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(hrtimer_cpu_base),
            "::",
            stringify!(clock_base)
        )
    );
}
impl Default for hrtimer_cpu_base {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl hrtimer_cpu_base {
    #[inline]
    pub fn hres_active(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hres_active(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_hrtirq(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_hrtirq(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hang_detected(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hang_detected(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn softirq_activated(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_softirq_activated(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        hres_active: c_types::c_uint,
        in_hrtirq: c_types::c_uint,
        hang_detected: c_types::c_uint,
        softirq_activated: c_types::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let hres_active: u32 = unsafe { ::core::mem::transmute(hres_active) };
            hres_active as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let in_hrtirq: u32 = unsafe { ::core::mem::transmute(in_hrtirq) };
            in_hrtirq as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let hang_detected: u32 = unsafe { ::core::mem::transmute(hang_detected) };
            hang_detected as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let softirq_activated: u32 = unsafe { ::core::mem::transmute(softirq_activated) };
            softirq_activated as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct seccomp_filter {
    _unused: [u8; 0],
}
#[doc = " struct seccomp - the state of a seccomp'ed process"]
#[doc = ""]
#[doc = " @mode:  indicates one of the valid values above for controlled"]
#[doc = "         system calls available to a process."]
#[doc = " @filter: must always point to a valid seccomp-filter or NULL as it is"]
#[doc = "          accessed without locking during system call entry."]
#[doc = ""]
#[doc = "          @filter must only be accessed from the context of current as there"]
#[doc = "          is no read locking."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct seccomp {
    pub mode: c_types::c_int,
    pub filter: *mut seccomp_filter,
}
#[test]
fn bindgen_test_layout_seccomp() {
    assert_eq!(
        ::core::mem::size_of::<seccomp>(),
        16usize,
        concat!("Size of: ", stringify!(seccomp))
    );
    assert_eq!(
        ::core::mem::align_of::<seccomp>(),
        8usize,
        concat!("Alignment of ", stringify!(seccomp))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<seccomp>())).mode as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(seccomp),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<seccomp>())).filter as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(seccomp),
            "::",
            stringify!(filter)
        )
    );
}
impl Default for seccomp {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[doc = " struct task_cputime - collected CPU time counts"]
#[doc = " @stime:\t\ttime spent in kernel mode, in nanoseconds"]
#[doc = " @utime:\t\ttime spent in user mode, in nanoseconds"]
#[doc = " @sum_exec_runtime:\ttotal time spent on the CPU, in nanoseconds"]
#[doc = ""]
#[doc = " This structure groups together three kinds of CPU time that are tracked for"]
#[doc = " threads and thread groups.  Most things considering CPU time want to group"]
#[doc = " these counts together and treat all three of them in parallel."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct task_cputime {
    pub stime: u64_,
    pub utime: u64_,
    pub sum_exec_runtime: c_types::c_ulonglong,
}
#[test]
fn bindgen_test_layout_task_cputime() {
    assert_eq!(
        ::core::mem::size_of::<task_cputime>(),
        24usize,
        concat!("Size of: ", stringify!(task_cputime))
    );
    assert_eq!(
        ::core::mem::align_of::<task_cputime>(),
        8usize,
        concat!("Alignment of ", stringify!(task_cputime))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_cputime>())).stime as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(task_cputime),
            "::",
            stringify!(stime)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_cputime>())).utime as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(task_cputime),
            "::",
            stringify!(utime)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_cputime>())).sum_exec_runtime as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(task_cputime),
            "::",
            stringify!(sum_exec_runtime)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct sigset_t {
    pub sig: [c_types::c_ulong; 1usize],
}
#[test]
fn bindgen_test_layout_sigset_t() {
    assert_eq!(
        ::core::mem::size_of::<sigset_t>(),
        8usize,
        concat!("Size of: ", stringify!(sigset_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sigset_t>(),
        8usize,
        concat!("Alignment of ", stringify!(sigset_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sigset_t>())).sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigset_t),
            "::",
            stringify!(sig)
        )
    );
}
pub type __signalfn_t = ::core::option::Option<unsafe extern "C" fn(arg1: c_types::c_int)>;
pub type __sighandler_t = __signalfn_t;
pub type __restorefn_t = ::core::option::Option<unsafe extern "C" fn()>;
pub type __sigrestore_t = __restorefn_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigval {
    pub sival_int: c_types::c_int,
    pub sival_ptr: *mut c_types::c_void,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_sigval() {
    assert_eq!(
        ::core::mem::size_of::<sigval>(),
        8usize,
        concat!("Size of: ", stringify!(sigval))
    );
    assert_eq!(
        ::core::mem::align_of::<sigval>(),
        8usize,
        concat!("Alignment of ", stringify!(sigval))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sigval>())).sival_int as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigval),
            "::",
            stringify!(sival_int)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sigval>())).sival_ptr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigval),
            "::",
            stringify!(sival_ptr)
        )
    );
}
impl Default for sigval {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type sigval_t = sigval;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __sifields {
    pub _kill: __sifields__bindgen_ty_1,
    pub _timer: __sifields__bindgen_ty_2,
    pub _rt: __sifields__bindgen_ty_3,
    pub _sigchld: __sifields__bindgen_ty_4,
    pub _sigfault: __sifields__bindgen_ty_5,
    pub _sigpoll: __sifields__bindgen_ty_6,
    pub _sigsys: __sifields__bindgen_ty_7,
    _bindgen_union_align: [u64; 4usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __sifields__bindgen_ty_1 {
    pub _pid: __kernel_pid_t,
    pub _uid: __kernel_uid32_t,
}
#[test]
fn bindgen_test_layout___sifields__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<__sifields__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(__sifields__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<__sifields__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(__sifields__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sifields__bindgen_ty_1>()))._pid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_1),
            "::",
            stringify!(_pid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sifields__bindgen_ty_1>()))._uid as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_1),
            "::",
            stringify!(_uid)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __sifields__bindgen_ty_2 {
    pub _tid: __kernel_timer_t,
    pub _overrun: c_types::c_int,
    pub _sigval: sigval_t,
    pub _sys_private: c_types::c_int,
}
#[test]
fn bindgen_test_layout___sifields__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<__sifields__bindgen_ty_2>(),
        24usize,
        concat!("Size of: ", stringify!(__sifields__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<__sifields__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(__sifields__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sifields__bindgen_ty_2>()))._tid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_2),
            "::",
            stringify!(_tid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__sifields__bindgen_ty_2>()))._overrun as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_2),
            "::",
            stringify!(_overrun)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__sifields__bindgen_ty_2>()))._sigval as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_2),
            "::",
            stringify!(_sigval)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__sifields__bindgen_ty_2>()))._sys_private as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_2),
            "::",
            stringify!(_sys_private)
        )
    );
}
impl Default for __sifields__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __sifields__bindgen_ty_3 {
    pub _pid: __kernel_pid_t,
    pub _uid: __kernel_uid32_t,
    pub _sigval: sigval_t,
}
#[test]
fn bindgen_test_layout___sifields__bindgen_ty_3() {
    assert_eq!(
        ::core::mem::size_of::<__sifields__bindgen_ty_3>(),
        16usize,
        concat!("Size of: ", stringify!(__sifields__bindgen_ty_3))
    );
    assert_eq!(
        ::core::mem::align_of::<__sifields__bindgen_ty_3>(),
        8usize,
        concat!("Alignment of ", stringify!(__sifields__bindgen_ty_3))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sifields__bindgen_ty_3>()))._pid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_3),
            "::",
            stringify!(_pid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sifields__bindgen_ty_3>()))._uid as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_3),
            "::",
            stringify!(_uid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__sifields__bindgen_ty_3>()))._sigval as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_3),
            "::",
            stringify!(_sigval)
        )
    );
}
impl Default for __sifields__bindgen_ty_3 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __sifields__bindgen_ty_4 {
    pub _pid: __kernel_pid_t,
    pub _uid: __kernel_uid32_t,
    pub _status: c_types::c_int,
    pub _utime: __kernel_clock_t,
    pub _stime: __kernel_clock_t,
}
#[test]
fn bindgen_test_layout___sifields__bindgen_ty_4() {
    assert_eq!(
        ::core::mem::size_of::<__sifields__bindgen_ty_4>(),
        32usize,
        concat!("Size of: ", stringify!(__sifields__bindgen_ty_4))
    );
    assert_eq!(
        ::core::mem::align_of::<__sifields__bindgen_ty_4>(),
        8usize,
        concat!("Alignment of ", stringify!(__sifields__bindgen_ty_4))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sifields__bindgen_ty_4>()))._pid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_4),
            "::",
            stringify!(_pid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sifields__bindgen_ty_4>()))._uid as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_4),
            "::",
            stringify!(_uid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__sifields__bindgen_ty_4>()))._status as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_4),
            "::",
            stringify!(_status)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__sifields__bindgen_ty_4>()))._utime as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_4),
            "::",
            stringify!(_utime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__sifields__bindgen_ty_4>()))._stime as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_4),
            "::",
            stringify!(_stime)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __sifields__bindgen_ty_5 {
    pub _addr: *mut c_types::c_void,
    pub __bindgen_anon_1: __sifields__bindgen_ty_5__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __sifields__bindgen_ty_5__bindgen_ty_1 {
    pub _addr_lsb: c_types::c_short,
    pub _addr_bnd: __sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1,
    pub _addr_pkey: __sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_2,
    _bindgen_union_align: [u64; 3usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1 {
    pub _dummy_bnd: [c_types::c_char; 8usize],
    pub _lower: *mut c_types::c_void,
    pub _upper: *mut c_types::c_void,
}
#[test]
fn bindgen_test_layout___sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1>()))
                ._dummy_bnd as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_dummy_bnd)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1>()))._lower
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_lower)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1>()))._upper
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_upper)
        )
    );
}
impl Default for __sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_2 {
    pub _dummy_pkey: [c_types::c_char; 8usize],
    pub _pkey: __u32,
}
#[test]
fn bindgen_test_layout___sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_2>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_2>()))
                ._dummy_pkey as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(_dummy_pkey)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_2>()))._pkey
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(_pkey)
        )
    );
}
#[test]
fn bindgen_test_layout___sifields__bindgen_ty_5__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<__sifields__bindgen_ty_5__bindgen_ty_1>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(__sifields__bindgen_ty_5__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<__sifields__bindgen_ty_5__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(__sifields__bindgen_ty_5__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__sifields__bindgen_ty_5__bindgen_ty_1>()))._addr_lsb
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_5__bindgen_ty_1),
            "::",
            stringify!(_addr_lsb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__sifields__bindgen_ty_5__bindgen_ty_1>()))._addr_bnd
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_5__bindgen_ty_1),
            "::",
            stringify!(_addr_bnd)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__sifields__bindgen_ty_5__bindgen_ty_1>()))._addr_pkey
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_5__bindgen_ty_1),
            "::",
            stringify!(_addr_pkey)
        )
    );
}
impl Default for __sifields__bindgen_ty_5__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout___sifields__bindgen_ty_5() {
    assert_eq!(
        ::core::mem::size_of::<__sifields__bindgen_ty_5>(),
        32usize,
        concat!("Size of: ", stringify!(__sifields__bindgen_ty_5))
    );
    assert_eq!(
        ::core::mem::align_of::<__sifields__bindgen_ty_5>(),
        8usize,
        concat!("Alignment of ", stringify!(__sifields__bindgen_ty_5))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sifields__bindgen_ty_5>()))._addr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_5),
            "::",
            stringify!(_addr)
        )
    );
}
impl Default for __sifields__bindgen_ty_5 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __sifields__bindgen_ty_6 {
    pub _band: c_types::c_long,
    pub _fd: c_types::c_int,
}
#[test]
fn bindgen_test_layout___sifields__bindgen_ty_6() {
    assert_eq!(
        ::core::mem::size_of::<__sifields__bindgen_ty_6>(),
        16usize,
        concat!("Size of: ", stringify!(__sifields__bindgen_ty_6))
    );
    assert_eq!(
        ::core::mem::align_of::<__sifields__bindgen_ty_6>(),
        8usize,
        concat!("Alignment of ", stringify!(__sifields__bindgen_ty_6))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sifields__bindgen_ty_6>()))._band as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_6),
            "::",
            stringify!(_band)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sifields__bindgen_ty_6>()))._fd as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_6),
            "::",
            stringify!(_fd)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sifields__bindgen_ty_7 {
    pub _call_addr: *mut c_types::c_void,
    pub _syscall: c_types::c_int,
    pub _arch: c_types::c_uint,
}
#[test]
fn bindgen_test_layout___sifields__bindgen_ty_7() {
    assert_eq!(
        ::core::mem::size_of::<__sifields__bindgen_ty_7>(),
        16usize,
        concat!("Size of: ", stringify!(__sifields__bindgen_ty_7))
    );
    assert_eq!(
        ::core::mem::align_of::<__sifields__bindgen_ty_7>(),
        8usize,
        concat!("Alignment of ", stringify!(__sifields__bindgen_ty_7))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__sifields__bindgen_ty_7>()))._call_addr as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_7),
            "::",
            stringify!(_call_addr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__sifields__bindgen_ty_7>()))._syscall as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_7),
            "::",
            stringify!(_syscall)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sifields__bindgen_ty_7>()))._arch as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_7),
            "::",
            stringify!(_arch)
        )
    );
}
impl Default for __sifields__bindgen_ty_7 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout___sifields() {
    assert_eq!(
        ::core::mem::size_of::<__sifields>(),
        32usize,
        concat!("Size of: ", stringify!(__sifields))
    );
    assert_eq!(
        ::core::mem::align_of::<__sifields>(),
        8usize,
        concat!("Alignment of ", stringify!(__sifields))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sifields>()))._kill as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields),
            "::",
            stringify!(_kill)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sifields>()))._timer as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields),
            "::",
            stringify!(_timer)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sifields>()))._rt as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields),
            "::",
            stringify!(_rt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sifields>()))._sigchld as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields),
            "::",
            stringify!(_sigchld)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sifields>()))._sigfault as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields),
            "::",
            stringify!(_sigfault)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sifields>()))._sigpoll as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields),
            "::",
            stringify!(_sigpoll)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sifields>()))._sigsys as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields),
            "::",
            stringify!(_sigsys)
        )
    );
}
impl Default for __sifields {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kernel_siginfo {
    pub __bindgen_anon_1: kernel_siginfo__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kernel_siginfo__bindgen_ty_1 {
    pub si_signo: c_types::c_int,
    pub si_errno: c_types::c_int,
    pub si_code: c_types::c_int,
    pub _sifields: __sifields,
}
#[test]
fn bindgen_test_layout_kernel_siginfo__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<kernel_siginfo__bindgen_ty_1>(),
        48usize,
        concat!("Size of: ", stringify!(kernel_siginfo__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<kernel_siginfo__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(kernel_siginfo__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<kernel_siginfo__bindgen_ty_1>())).si_signo as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kernel_siginfo__bindgen_ty_1),
            "::",
            stringify!(si_signo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<kernel_siginfo__bindgen_ty_1>())).si_errno as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(kernel_siginfo__bindgen_ty_1),
            "::",
            stringify!(si_errno)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<kernel_siginfo__bindgen_ty_1>())).si_code as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(kernel_siginfo__bindgen_ty_1),
            "::",
            stringify!(si_code)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<kernel_siginfo__bindgen_ty_1>()))._sifields as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(kernel_siginfo__bindgen_ty_1),
            "::",
            stringify!(_sifields)
        )
    );
}
impl Default for kernel_siginfo__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_kernel_siginfo() {
    assert_eq!(
        ::core::mem::size_of::<kernel_siginfo>(),
        48usize,
        concat!("Size of: ", stringify!(kernel_siginfo))
    );
    assert_eq!(
        ::core::mem::align_of::<kernel_siginfo>(),
        8usize,
        concat!("Alignment of ", stringify!(kernel_siginfo))
    );
}
impl Default for kernel_siginfo {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type kernel_siginfo_t = kernel_siginfo;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigpending {
    pub list: list_head,
    pub signal: sigset_t,
}
#[test]
fn bindgen_test_layout_sigpending() {
    assert_eq!(
        ::core::mem::size_of::<sigpending>(),
        24usize,
        concat!("Size of: ", stringify!(sigpending))
    );
    assert_eq!(
        ::core::mem::align_of::<sigpending>(),
        8usize,
        concat!("Alignment of ", stringify!(sigpending))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sigpending>())).list as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigpending),
            "::",
            stringify!(list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sigpending>())).signal as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sigpending),
            "::",
            stringify!(signal)
        )
    );
}
impl Default for sigpending {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct sigaction {
    pub sa_handler: __sighandler_t,
    pub sa_flags: c_types::c_ulong,
    pub sa_restorer: __sigrestore_t,
    pub sa_mask: sigset_t,
}
#[test]
fn bindgen_test_layout_sigaction() {
    assert_eq!(
        ::core::mem::size_of::<sigaction>(),
        32usize,
        concat!("Size of: ", stringify!(sigaction))
    );
    assert_eq!(
        ::core::mem::align_of::<sigaction>(),
        8usize,
        concat!("Alignment of ", stringify!(sigaction))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sigaction>())).sa_handler as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction),
            "::",
            stringify!(sa_handler)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sigaction>())).sa_flags as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction),
            "::",
            stringify!(sa_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sigaction>())).sa_restorer as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction),
            "::",
            stringify!(sa_restorer)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sigaction>())).sa_mask as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction),
            "::",
            stringify!(sa_mask)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct k_sigaction {
    pub sa: sigaction,
}
#[test]
fn bindgen_test_layout_k_sigaction() {
    assert_eq!(
        ::core::mem::size_of::<k_sigaction>(),
        32usize,
        concat!("Size of: ", stringify!(k_sigaction))
    );
    assert_eq!(
        ::core::mem::align_of::<k_sigaction>(),
        8usize,
        concat!("Alignment of ", stringify!(k_sigaction))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<k_sigaction>())).sa as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(k_sigaction),
            "::",
            stringify!(sa)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct task_io_accounting {
    pub rchar: u64_,
    pub wchar: u64_,
    pub syscr: u64_,
    pub syscw: u64_,
    pub read_bytes: u64_,
    pub write_bytes: u64_,
    pub cancelled_write_bytes: u64_,
}
#[test]
fn bindgen_test_layout_task_io_accounting() {
    assert_eq!(
        ::core::mem::size_of::<task_io_accounting>(),
        56usize,
        concat!("Size of: ", stringify!(task_io_accounting))
    );
    assert_eq!(
        ::core::mem::align_of::<task_io_accounting>(),
        8usize,
        concat!("Alignment of ", stringify!(task_io_accounting))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_io_accounting>())).rchar as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(task_io_accounting),
            "::",
            stringify!(rchar)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_io_accounting>())).wchar as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(task_io_accounting),
            "::",
            stringify!(wchar)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_io_accounting>())).syscr as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(task_io_accounting),
            "::",
            stringify!(syscr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_io_accounting>())).syscw as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(task_io_accounting),
            "::",
            stringify!(syscw)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_io_accounting>())).read_bytes as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(task_io_accounting),
            "::",
            stringify!(read_bytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_io_accounting>())).write_bytes as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(task_io_accounting),
            "::",
            stringify!(write_bytes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<task_io_accounting>())).cancelled_write_bytes as *const _
                as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(task_io_accounting),
            "::",
            stringify!(cancelled_write_bytes)
        )
    );
}
#[doc = " posix_cputimer_base - Container per posix CPU clock"]
#[doc = " @nextevt:\t\tEarliest-expiration cache"]
#[doc = " @tqhead:\t\ttimerqueue head for cpu_timers"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct posix_cputimer_base {
    pub nextevt: u64_,
    pub tqhead: timerqueue_head,
}
#[test]
fn bindgen_test_layout_posix_cputimer_base() {
    assert_eq!(
        ::core::mem::size_of::<posix_cputimer_base>(),
        24usize,
        concat!("Size of: ", stringify!(posix_cputimer_base))
    );
    assert_eq!(
        ::core::mem::align_of::<posix_cputimer_base>(),
        8usize,
        concat!("Alignment of ", stringify!(posix_cputimer_base))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<posix_cputimer_base>())).nextevt as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(posix_cputimer_base),
            "::",
            stringify!(nextevt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<posix_cputimer_base>())).tqhead as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(posix_cputimer_base),
            "::",
            stringify!(tqhead)
        )
    );
}
impl Default for posix_cputimer_base {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[doc = " posix_cputimers - Container for posix CPU timer related data"]
#[doc = " @bases:\t\tBase container for posix CPU clocks"]
#[doc = " @timers_active:\tTimers are queued."]
#[doc = " @expiry_active:\tTimer expiry is active. Used for"]
#[doc = "\t\t\tprocess wide timers to avoid multiple"]
#[doc = "\t\t\ttask trying to handle expiry concurrently"]
#[doc = ""]
#[doc = " Used in task_struct and signal_struct"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct posix_cputimers {
    pub bases: [posix_cputimer_base; 3usize],
    pub timers_active: c_types::c_uint,
    pub expiry_active: c_types::c_uint,
}
#[test]
fn bindgen_test_layout_posix_cputimers() {
    assert_eq!(
        ::core::mem::size_of::<posix_cputimers>(),
        80usize,
        concat!("Size of: ", stringify!(posix_cputimers))
    );
    assert_eq!(
        ::core::mem::align_of::<posix_cputimers>(),
        8usize,
        concat!("Alignment of ", stringify!(posix_cputimers))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<posix_cputimers>())).bases as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(posix_cputimers),
            "::",
            stringify!(bases)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<posix_cputimers>())).timers_active as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(posix_cputimers),
            "::",
            stringify!(timers_active)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<posix_cputimers>())).expiry_active as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(posix_cputimers),
            "::",
            stringify!(expiry_active)
        )
    );
}
impl Default for posix_cputimers {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[repr(align(32))]
#[derive(Copy, Clone)]
pub struct rseq {
    pub cpu_id_start: __u32,
    pub cpu_id: __u32,
    pub rseq_cs: rseq__bindgen_ty_1,
    pub flags: __u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rseq__bindgen_ty_1 {
    pub ptr64: __u64,
    pub ptr: __u64,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_rseq__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<rseq__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(rseq__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<rseq__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(rseq__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rseq__bindgen_ty_1>())).ptr64 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rseq__bindgen_ty_1),
            "::",
            stringify!(ptr64)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rseq__bindgen_ty_1>())).ptr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rseq__bindgen_ty_1),
            "::",
            stringify!(ptr)
        )
    );
}
impl Default for rseq__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_rseq() {
    assert_eq!(
        ::core::mem::size_of::<rseq>(),
        32usize,
        concat!("Size of: ", stringify!(rseq))
    );
    assert_eq!(
        ::core::mem::align_of::<rseq>(),
        32usize,
        concat!("Alignment of ", stringify!(rseq))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rseq>())).cpu_id_start as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rseq),
            "::",
            stringify!(cpu_id_start)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rseq>())).cpu_id as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rseq),
            "::",
            stringify!(cpu_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rseq>())).rseq_cs as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rseq),
            "::",
            stringify!(rseq_cs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rseq>())).flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rseq),
            "::",
            stringify!(flags)
        )
    );
}
impl Default for rseq {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct audit_context {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct capture_control {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cfs_rq {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fs_struct {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct futex_pi_state {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nameidata {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct perf_event_context {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct reclaim_state {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct robust_list_head {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct task_delay_info {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct task_group {
    _unused: [u8; 0],
}
#[doc = " struct prev_cputime - snapshot of system and user cputime"]
#[doc = " @utime: time spent in user mode"]
#[doc = " @stime: time spent in system mode"]
#[doc = " @lock: protects the above two fields"]
#[doc = ""]
#[doc = " Stores previous user/system time values such that we can guarantee"]
#[doc = " monotonicity."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct prev_cputime {
    pub utime: u64_,
    pub stime: u64_,
    pub lock: raw_spinlock_t,
}
#[test]
fn bindgen_test_layout_prev_cputime() {
    assert_eq!(
        ::core::mem::size_of::<prev_cputime>(),
        24usize,
        concat!("Size of: ", stringify!(prev_cputime))
    );
    assert_eq!(
        ::core::mem::align_of::<prev_cputime>(),
        8usize,
        concat!("Alignment of ", stringify!(prev_cputime))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<prev_cputime>())).utime as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(prev_cputime),
            "::",
            stringify!(utime)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<prev_cputime>())).stime as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(prev_cputime),
            "::",
            stringify!(stime)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<prev_cputime>())).lock as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(prev_cputime),
            "::",
            stringify!(lock)
        )
    );
}
impl Default for prev_cputime {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct sched_info {
    pub pcount: c_types::c_ulong,
    pub run_delay: c_types::c_ulonglong,
    pub last_arrival: c_types::c_ulonglong,
    pub last_queued: c_types::c_ulonglong,
}
#[test]
fn bindgen_test_layout_sched_info() {
    assert_eq!(
        ::core::mem::size_of::<sched_info>(),
        32usize,
        concat!("Size of: ", stringify!(sched_info))
    );
    assert_eq!(
        ::core::mem::align_of::<sched_info>(),
        8usize,
        concat!("Alignment of ", stringify!(sched_info))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_info>())).pcount as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_info),
            "::",
            stringify!(pcount)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_info>())).run_delay as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_info),
            "::",
            stringify!(run_delay)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_info>())).last_arrival as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_info),
            "::",
            stringify!(last_arrival)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_info>())).last_queued as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_info),
            "::",
            stringify!(last_queued)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct load_weight {
    pub weight: c_types::c_ulong,
    pub inv_weight: u32_,
}
#[test]
fn bindgen_test_layout_load_weight() {
    assert_eq!(
        ::core::mem::size_of::<load_weight>(),
        16usize,
        concat!("Size of: ", stringify!(load_weight))
    );
    assert_eq!(
        ::core::mem::align_of::<load_weight>(),
        8usize,
        concat!("Alignment of ", stringify!(load_weight))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<load_weight>())).weight as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(load_weight),
            "::",
            stringify!(weight)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<load_weight>())).inv_weight as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(load_weight),
            "::",
            stringify!(inv_weight)
        )
    );
}
#[doc = " struct util_est - Estimation utilization of FAIR tasks"]
#[doc = " @enqueued: instantaneous estimated utilization of a task/cpu"]
#[doc = " @ewma:     the Exponential Weighted Moving Average (EWMA)"]
#[doc = "            utilization of a task"]
#[doc = ""]
#[doc = " Support data structure to track an Exponential Weighted Moving Average"]
#[doc = " (EWMA) of a FAIR task's utilization. New samples are added to the moving"]
#[doc = " average each time a task completes an activation. Sample's weight is chosen"]
#[doc = " so that the EWMA will be relatively insensitive to transient changes to the"]
#[doc = " task's workload."]
#[doc = ""]
#[doc = " The enqueued attribute has a slightly different meaning for tasks and cpus:"]
#[doc = " - task:   the task's util_avg at last task dequeue time"]
#[doc = " - cfs_rq: the sum of util_est.enqueued for each RUNNABLE task on that CPU"]
#[doc = " Thus, the util_est.enqueued of a task represents the contribution on the"]
#[doc = " estimated utilization of the CPU where that task is currently enqueued."]
#[doc = ""]
#[doc = " Only for tasks we track a moving average of the past instantaneous"]
#[doc = " estimated utilization. This allows to absorb sporadic drops in utilization"]
#[doc = " of an otherwise almost periodic task."]
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Default, Copy, Clone)]
pub struct util_est {
    pub enqueued: c_types::c_uint,
    pub ewma: c_types::c_uint,
}
#[test]
fn bindgen_test_layout_util_est() {
    assert_eq!(
        ::core::mem::size_of::<util_est>(),
        8usize,
        concat!("Size of: ", stringify!(util_est))
    );
    assert_eq!(
        ::core::mem::align_of::<util_est>(),
        8usize,
        concat!("Alignment of ", stringify!(util_est))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<util_est>())).enqueued as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(util_est),
            "::",
            stringify!(enqueued)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<util_est>())).ewma as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(util_est),
            "::",
            stringify!(ewma)
        )
    );
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct sched_avg {
    pub last_update_time: u64_,
    pub load_sum: u64_,
    pub runnable_load_sum: u64_,
    pub util_sum: u32_,
    pub period_contrib: u32_,
    pub load_avg: c_types::c_ulong,
    pub runnable_load_avg: c_types::c_ulong,
    pub util_avg: c_types::c_ulong,
    pub util_est: util_est,
}
#[test]
fn bindgen_test_layout_sched_avg() {
    assert_eq!(
        ::core::mem::size_of::<sched_avg>(),
        64usize,
        concat!("Size of: ", stringify!(sched_avg))
    );
    assert_eq!(
        ::core::mem::align_of::<sched_avg>(),
        64usize,
        concat!("Alignment of ", stringify!(sched_avg))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_avg>())).last_update_time as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_avg),
            "::",
            stringify!(last_update_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_avg>())).load_sum as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_avg),
            "::",
            stringify!(load_sum)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_avg>())).runnable_load_sum as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_avg),
            "::",
            stringify!(runnable_load_sum)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_avg>())).util_sum as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_avg),
            "::",
            stringify!(util_sum)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_avg>())).period_contrib as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_avg),
            "::",
            stringify!(period_contrib)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_avg>())).load_avg as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_avg),
            "::",
            stringify!(load_avg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_avg>())).runnable_load_avg as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_avg),
            "::",
            stringify!(runnable_load_avg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_avg>())).util_avg as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_avg),
            "::",
            stringify!(util_avg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_avg>())).util_est as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_avg),
            "::",
            stringify!(util_est)
        )
    );
}
impl Default for sched_avg {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct sched_statistics {
    pub wait_start: u64_,
    pub wait_max: u64_,
    pub wait_count: u64_,
    pub wait_sum: u64_,
    pub iowait_count: u64_,
    pub iowait_sum: u64_,
    pub sleep_start: u64_,
    pub sleep_max: u64_,
    pub sum_sleep_runtime: s64,
    pub block_start: u64_,
    pub block_max: u64_,
    pub exec_max: u64_,
    pub slice_max: u64_,
    pub nr_migrations_cold: u64_,
    pub nr_failed_migrations_affine: u64_,
    pub nr_failed_migrations_running: u64_,
    pub nr_failed_migrations_hot: u64_,
    pub nr_forced_migrations: u64_,
    pub nr_wakeups: u64_,
    pub nr_wakeups_sync: u64_,
    pub nr_wakeups_migrate: u64_,
    pub nr_wakeups_local: u64_,
    pub nr_wakeups_remote: u64_,
    pub nr_wakeups_affine: u64_,
    pub nr_wakeups_affine_attempts: u64_,
    pub nr_wakeups_passive: u64_,
    pub nr_wakeups_idle: u64_,
}
#[test]
fn bindgen_test_layout_sched_statistics() {
    assert_eq!(
        ::core::mem::size_of::<sched_statistics>(),
        216usize,
        concat!("Size of: ", stringify!(sched_statistics))
    );
    assert_eq!(
        ::core::mem::align_of::<sched_statistics>(),
        8usize,
        concat!("Alignment of ", stringify!(sched_statistics))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_statistics>())).wait_start as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_statistics),
            "::",
            stringify!(wait_start)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_statistics>())).wait_max as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_statistics),
            "::",
            stringify!(wait_max)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_statistics>())).wait_count as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_statistics),
            "::",
            stringify!(wait_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_statistics>())).wait_sum as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_statistics),
            "::",
            stringify!(wait_sum)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_statistics>())).iowait_count as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_statistics),
            "::",
            stringify!(iowait_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_statistics>())).iowait_sum as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_statistics),
            "::",
            stringify!(iowait_sum)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_statistics>())).sleep_start as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_statistics),
            "::",
            stringify!(sleep_start)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_statistics>())).sleep_max as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_statistics),
            "::",
            stringify!(sleep_max)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sched_statistics>())).sum_sleep_runtime as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_statistics),
            "::",
            stringify!(sum_sleep_runtime)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_statistics>())).block_start as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_statistics),
            "::",
            stringify!(block_start)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_statistics>())).block_max as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_statistics),
            "::",
            stringify!(block_max)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_statistics>())).exec_max as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_statistics),
            "::",
            stringify!(exec_max)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_statistics>())).slice_max as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_statistics),
            "::",
            stringify!(slice_max)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sched_statistics>())).nr_migrations_cold as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_statistics),
            "::",
            stringify!(nr_migrations_cold)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sched_statistics>())).nr_failed_migrations_affine as *const _
                as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_statistics),
            "::",
            stringify!(nr_failed_migrations_affine)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sched_statistics>())).nr_failed_migrations_running as *const _
                as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_statistics),
            "::",
            stringify!(nr_failed_migrations_running)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sched_statistics>())).nr_failed_migrations_hot as *const _
                as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_statistics),
            "::",
            stringify!(nr_failed_migrations_hot)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sched_statistics>())).nr_forced_migrations as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_statistics),
            "::",
            stringify!(nr_forced_migrations)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_statistics>())).nr_wakeups as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_statistics),
            "::",
            stringify!(nr_wakeups)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sched_statistics>())).nr_wakeups_sync as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_statistics),
            "::",
            stringify!(nr_wakeups_sync)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sched_statistics>())).nr_wakeups_migrate as *const _ as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_statistics),
            "::",
            stringify!(nr_wakeups_migrate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sched_statistics>())).nr_wakeups_local as *const _ as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_statistics),
            "::",
            stringify!(nr_wakeups_local)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sched_statistics>())).nr_wakeups_remote as *const _ as usize
        },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_statistics),
            "::",
            stringify!(nr_wakeups_remote)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sched_statistics>())).nr_wakeups_affine as *const _ as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_statistics),
            "::",
            stringify!(nr_wakeups_affine)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sched_statistics>())).nr_wakeups_affine_attempts as *const _
                as usize
        },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_statistics),
            "::",
            stringify!(nr_wakeups_affine_attempts)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sched_statistics>())).nr_wakeups_passive as *const _ as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_statistics),
            "::",
            stringify!(nr_wakeups_passive)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sched_statistics>())).nr_wakeups_idle as *const _ as usize
        },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_statistics),
            "::",
            stringify!(nr_wakeups_idle)
        )
    );
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct sched_entity {
    pub load: load_weight,
    pub runnable_weight: c_types::c_ulong,
    pub run_node: rb_node,
    pub group_node: list_head,
    pub on_rq: c_types::c_uint,
    pub exec_start: u64_,
    pub sum_exec_runtime: u64_,
    pub vruntime: u64_,
    pub prev_sum_exec_runtime: u64_,
    pub nr_migrations: u64_,
    pub statistics: sched_statistics,
    pub depth: c_types::c_int,
    pub parent: *mut sched_entity,
    pub cfs_rq: *mut cfs_rq,
    pub my_q: *mut cfs_rq,
    pub __bindgen_padding_0: [u64; 3usize],
    pub avg: sched_avg,
}
#[test]
fn bindgen_test_layout_sched_entity() {
    assert_eq!(
        ::core::mem::size_of::<sched_entity>(),
        448usize,
        concat!("Size of: ", stringify!(sched_entity))
    );
    assert_eq!(
        ::core::mem::align_of::<sched_entity>(),
        64usize,
        concat!("Alignment of ", stringify!(sched_entity))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_entity>())).load as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_entity),
            "::",
            stringify!(load)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_entity>())).runnable_weight as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_entity),
            "::",
            stringify!(runnable_weight)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_entity>())).run_node as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_entity),
            "::",
            stringify!(run_node)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_entity>())).group_node as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_entity),
            "::",
            stringify!(group_node)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_entity>())).on_rq as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_entity),
            "::",
            stringify!(on_rq)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_entity>())).exec_start as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_entity),
            "::",
            stringify!(exec_start)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_entity>())).sum_exec_runtime as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_entity),
            "::",
            stringify!(sum_exec_runtime)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_entity>())).vruntime as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_entity),
            "::",
            stringify!(vruntime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sched_entity>())).prev_sum_exec_runtime as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_entity),
            "::",
            stringify!(prev_sum_exec_runtime)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_entity>())).nr_migrations as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_entity),
            "::",
            stringify!(nr_migrations)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_entity>())).statistics as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_entity),
            "::",
            stringify!(statistics)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_entity>())).depth as *const _ as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_entity),
            "::",
            stringify!(depth)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_entity>())).parent as *const _ as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_entity),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_entity>())).cfs_rq as *const _ as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_entity),
            "::",
            stringify!(cfs_rq)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_entity>())).my_q as *const _ as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_entity),
            "::",
            stringify!(my_q)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_entity>())).avg as *const _ as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_entity),
            "::",
            stringify!(avg)
        )
    );
}
impl Default for sched_entity {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sched_rt_entity {
    pub run_list: list_head,
    pub timeout: c_types::c_ulong,
    pub watchdog_stamp: c_types::c_ulong,
    pub time_slice: c_types::c_uint,
    pub on_rq: c_types::c_ushort,
    pub on_list: c_types::c_ushort,
    pub back: *mut sched_rt_entity,
    pub parent: *mut sched_rt_entity,
    pub rt_rq: *mut rt_rq,
    pub my_q: *mut rt_rq,
}
#[test]
fn bindgen_test_layout_sched_rt_entity() {
    assert_eq!(
        ::core::mem::size_of::<sched_rt_entity>(),
        72usize,
        concat!("Size of: ", stringify!(sched_rt_entity))
    );
    assert_eq!(
        ::core::mem::align_of::<sched_rt_entity>(),
        8usize,
        concat!("Alignment of ", stringify!(sched_rt_entity))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_rt_entity>())).run_list as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_rt_entity),
            "::",
            stringify!(run_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_rt_entity>())).timeout as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_rt_entity),
            "::",
            stringify!(timeout)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_rt_entity>())).watchdog_stamp as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_rt_entity),
            "::",
            stringify!(watchdog_stamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_rt_entity>())).time_slice as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_rt_entity),
            "::",
            stringify!(time_slice)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_rt_entity>())).on_rq as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_rt_entity),
            "::",
            stringify!(on_rq)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_rt_entity>())).on_list as *const _ as usize },
        38usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_rt_entity),
            "::",
            stringify!(on_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_rt_entity>())).back as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_rt_entity),
            "::",
            stringify!(back)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_rt_entity>())).parent as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_rt_entity),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_rt_entity>())).rt_rq as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_rt_entity),
            "::",
            stringify!(rt_rq)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_rt_entity>())).my_q as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_rt_entity),
            "::",
            stringify!(my_q)
        )
    );
}
impl Default for sched_rt_entity {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sched_dl_entity {
    pub rb_node: rb_node,
    pub dl_runtime: u64_,
    pub dl_deadline: u64_,
    pub dl_period: u64_,
    pub dl_bw: u64_,
    pub dl_density: u64_,
    pub runtime: s64,
    pub deadline: u64_,
    pub flags: c_types::c_uint,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub dl_timer: hrtimer,
    pub inactive_timer: hrtimer,
}
#[test]
fn bindgen_test_layout_sched_dl_entity() {
    assert_eq!(
        ::core::mem::size_of::<sched_dl_entity>(),
        216usize,
        concat!("Size of: ", stringify!(sched_dl_entity))
    );
    assert_eq!(
        ::core::mem::align_of::<sched_dl_entity>(),
        8usize,
        concat!("Alignment of ", stringify!(sched_dl_entity))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_dl_entity>())).rb_node as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_dl_entity),
            "::",
            stringify!(rb_node)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_dl_entity>())).dl_runtime as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_dl_entity),
            "::",
            stringify!(dl_runtime)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_dl_entity>())).dl_deadline as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_dl_entity),
            "::",
            stringify!(dl_deadline)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_dl_entity>())).dl_period as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_dl_entity),
            "::",
            stringify!(dl_period)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_dl_entity>())).dl_bw as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_dl_entity),
            "::",
            stringify!(dl_bw)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_dl_entity>())).dl_density as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_dl_entity),
            "::",
            stringify!(dl_density)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_dl_entity>())).runtime as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_dl_entity),
            "::",
            stringify!(runtime)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_dl_entity>())).deadline as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_dl_entity),
            "::",
            stringify!(deadline)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_dl_entity>())).flags as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_dl_entity),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_dl_entity>())).dl_timer as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_dl_entity),
            "::",
            stringify!(dl_timer)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_dl_entity>())).inactive_timer as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_dl_entity),
            "::",
            stringify!(inactive_timer)
        )
    );
}
impl Default for sched_dl_entity {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl sched_dl_entity {
    #[inline]
    pub fn dl_throttled(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dl_throttled(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dl_boosted(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dl_boosted(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dl_yielded(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dl_yielded(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dl_non_contending(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dl_non_contending(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dl_overrun(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dl_overrun(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        dl_throttled: c_types::c_uint,
        dl_boosted: c_types::c_uint,
        dl_yielded: c_types::c_uint,
        dl_non_contending: c_types::c_uint,
        dl_overrun: c_types::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let dl_throttled: u32 = unsafe { ::core::mem::transmute(dl_throttled) };
            dl_throttled as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let dl_boosted: u32 = unsafe { ::core::mem::transmute(dl_boosted) };
            dl_boosted as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let dl_yielded: u32 = unsafe { ::core::mem::transmute(dl_yielded) };
            dl_yielded as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let dl_non_contending: u32 = unsafe { ::core::mem::transmute(dl_non_contending) };
            dl_non_contending as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let dl_overrun: u32 = unsafe { ::core::mem::transmute(dl_overrun) };
            dl_overrun as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct uclamp_se {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u16>,
    pub __bindgen_padding_0: u16,
}
#[test]
fn bindgen_test_layout_uclamp_se() {
    assert_eq!(
        ::core::mem::size_of::<uclamp_se>(),
        4usize,
        concat!("Size of: ", stringify!(uclamp_se))
    );
    assert_eq!(
        ::core::mem::align_of::<uclamp_se>(),
        4usize,
        concat!("Alignment of ", stringify!(uclamp_se))
    );
}
impl uclamp_se {
    #[inline]
    pub fn value(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 11u8) as u32) }
    }
    #[inline]
    pub fn set_value(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub fn bucket_id(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_bucket_id(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn active(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_active(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn user_defined(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_user_defined(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        value: c_types::c_uint,
        bucket_id: c_types::c_uint,
        active: c_types::c_uint,
        user_defined: c_types::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 11u8, {
            let value: u32 = unsafe { ::core::mem::transmute(value) };
            value as u64
        });
        __bindgen_bitfield_unit.set(11usize, 3u8, {
            let bucket_id: u32 = unsafe { ::core::mem::transmute(bucket_id) };
            bucket_id as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let active: u32 = unsafe { ::core::mem::transmute(active) };
            active as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let user_defined: u32 = unsafe { ::core::mem::transmute(user_defined) };
            user_defined as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wake_q_node {
    pub next: *mut wake_q_node,
}
#[test]
fn bindgen_test_layout_wake_q_node() {
    assert_eq!(
        ::core::mem::size_of::<wake_q_node>(),
        8usize,
        concat!("Size of: ", stringify!(wake_q_node))
    );
    assert_eq!(
        ::core::mem::align_of::<wake_q_node>(),
        8usize,
        concat!("Alignment of ", stringify!(wake_q_node))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<wake_q_node>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wake_q_node),
            "::",
            stringify!(next)
        )
    );
}
impl Default for wake_q_node {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[repr(align(64))]
pub struct task_struct {
    pub thread_info: thread_info,
    pub state: c_types::c_long,
    pub stack: *mut c_types::c_void,
    pub usage: refcount_t,
    pub flags: c_types::c_uint,
    pub ptrace: c_types::c_uint,
    pub wake_entry: llist_node,
    pub on_cpu: c_types::c_int,
    pub cpu: c_types::c_uint,
    pub wakee_flips: c_types::c_uint,
    pub wakee_flip_decay_ts: c_types::c_ulong,
    pub last_wakee: *mut task_struct,
    pub recent_used_cpu: c_types::c_int,
    pub wake_cpu: c_types::c_int,
    pub on_rq: c_types::c_int,
    pub prio: c_types::c_int,
    pub static_prio: c_types::c_int,
    pub normal_prio: c_types::c_int,
    pub rt_priority: c_types::c_uint,
    pub sched_class: *mut sched_class,
    pub se: sched_entity,
    pub rt: sched_rt_entity,
    pub sched_task_group: *mut task_group,
    pub dl: sched_dl_entity,
    pub uclamp_req: [uclamp_se; 2usize],
    pub uclamp: [uclamp_se; 2usize],
    pub preempt_notifiers: hlist_head,
    pub btrace_seq: c_types::c_uint,
    pub policy: c_types::c_uint,
    pub nr_cpus_allowed: c_types::c_int,
    pub cpus_ptr: *const cpumask_t,
    pub cpus_mask: cpumask_t,
    pub rcu_tasks_nvcsw: c_types::c_ulong,
    pub rcu_tasks_holdout: u8_,
    pub rcu_tasks_idx: u8_,
    pub rcu_tasks_idle_cpu: c_types::c_int,
    pub rcu_tasks_holdout_list: list_head,
    pub sched_info: sched_info,
    pub tasks: list_head,
    pub pushable_tasks: plist_node,
    pub pushable_dl_tasks: rb_node,
    pub mm: *mut mm_struct,
    pub active_mm: *mut mm_struct,
    pub vmacache: vmacache,
    pub rss_stat: task_rss_stat,
    pub exit_state: c_types::c_int,
    pub exit_code: c_types::c_int,
    pub exit_signal: c_types::c_int,
    pub pdeath_signal: c_types::c_int,
    pub jobctl: c_types::c_ulong,
    pub personality: c_types::c_uint,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 5usize], u8>,
    pub atomic_flags: c_types::c_ulong,
    pub restart_block: restart_block,
    pub pid: pid_t,
    pub tgid: pid_t,
    pub stack_canary: c_types::c_ulong,
    pub real_parent: *mut task_struct,
    pub parent: *mut task_struct,
    pub children: list_head,
    pub sibling: list_head,
    pub group_leader: *mut task_struct,
    pub ptraced: list_head,
    pub ptrace_entry: list_head,
    pub thread_pid: *mut pid,
    pub pid_links: [hlist_node; 4usize],
    pub thread_group: list_head,
    pub thread_node: list_head,
    pub vfork_done: *mut completion,
    pub set_child_tid: *mut c_types::c_int,
    pub clear_child_tid: *mut c_types::c_int,
    pub utime: u64_,
    pub stime: u64_,
    pub gtime: u64_,
    pub prev_cputime: prev_cputime,
    pub nvcsw: c_types::c_ulong,
    pub nivcsw: c_types::c_ulong,
    pub start_time: u64_,
    pub real_start_time: u64_,
    pub min_flt: c_types::c_ulong,
    pub maj_flt: c_types::c_ulong,
    pub posix_cputimers: posix_cputimers,
    pub ptracer_cred: *const cred,
    pub real_cred: *const cred,
    pub cred: *const cred,
    pub cached_requested_key: *mut key,
    pub comm: [c_types::c_char; 16usize],
    pub nameidata: *mut nameidata,
    pub sysvsem: sysv_sem,
    pub sysvshm: sysv_shm,
    pub last_switch_count: c_types::c_ulong,
    pub last_switch_time: c_types::c_ulong,
    pub fs: *mut fs_struct,
    pub files: *mut files_struct,
    pub nsproxy: *mut nsproxy,
    pub signal: *mut signal_struct,
    pub sighand: *mut sighand_struct,
    pub blocked: sigset_t,
    pub real_blocked: sigset_t,
    pub saved_sigmask: sigset_t,
    pub pending: sigpending,
    pub sas_ss_sp: c_types::c_ulong,
    pub sas_ss_size: usize,
    pub sas_ss_flags: c_types::c_uint,
    pub task_works: *mut callback_head,
    pub audit_context: *mut audit_context,
    pub loginuid: kuid_t,
    pub sessionid: c_types::c_uint,
    pub seccomp: seccomp,
    pub parent_exec_id: u32_,
    pub self_exec_id: u32_,
    pub alloc_lock: spinlock_t,
    pub pi_lock: raw_spinlock_t,
    pub wake_q: wake_q_node,
    pub pi_waiters: rb_root_cached,
    pub pi_top_task: *mut task_struct,
    pub pi_blocked_on: *mut rt_mutex_waiter,
    pub journal_info: *mut c_types::c_void,
    pub bio_list: *mut bio_list,
    pub plug: *mut blk_plug,
    pub reclaim_state: *mut reclaim_state,
    pub backing_dev_info: *mut backing_dev_info,
    pub io_context: *mut io_context,
    pub capture_control: *mut capture_control,
    pub ptrace_message: c_types::c_ulong,
    pub last_siginfo: *mut kernel_siginfo_t,
    pub ioac: task_io_accounting,
    pub psi_flags: c_types::c_uint,
    pub acct_rss_mem1: u64_,
    pub acct_vm_mem1: u64_,
    pub acct_timexpd: u64_,
    pub mems_allowed: nodemask_t,
    pub mems_allowed_seq: seqcount_t,
    pub cpuset_mem_spread_rotor: c_types::c_int,
    pub cpuset_slab_spread_rotor: c_types::c_int,
    pub cgroups: *mut css_set,
    pub cg_list: list_head,
    pub closid: u32_,
    pub rmid: u32_,
    pub robust_list: *mut robust_list_head,
    pub compat_robust_list: *mut compat_robust_list_head,
    pub pi_state_list: list_head,
    pub pi_state_cache: *mut futex_pi_state,
    pub futex_exit_mutex: mutex,
    pub futex_state: c_types::c_uint,
    pub perf_event_ctxp: [*mut perf_event_context; 2usize],
    pub perf_event_mutex: mutex,
    pub perf_event_list: list_head,
    pub mempolicy: *mut mempolicy,
    pub il_prev: c_types::c_short,
    pub pref_node_fork: c_types::c_short,
    pub numa_scan_seq: c_types::c_int,
    pub numa_scan_period: c_types::c_uint,
    pub numa_scan_period_max: c_types::c_uint,
    pub numa_preferred_nid: c_types::c_int,
    pub numa_migrate_retry: c_types::c_ulong,
    pub node_stamp: u64_,
    pub last_task_numa_placement: u64_,
    pub last_sum_exec_runtime: u64_,
    pub numa_work: callback_head,
    pub numa_group: *mut numa_group,
    pub numa_faults: *mut c_types::c_ulong,
    pub total_numa_faults: c_types::c_ulong,
    pub numa_faults_locality: [c_types::c_ulong; 3usize],
    pub numa_pages_migrated: c_types::c_ulong,
    pub rseq: *mut rseq,
    pub rseq_sig: u32_,
    pub rseq_event_mask: c_types::c_ulong,
    pub tlb_ubc: tlbflush_unmap_batch,
    pub __bindgen_anon_1: task_struct__bindgen_ty_1,
    pub splice_pipe: *mut pipe_inode_info,
    pub task_frag: page_frag,
    pub delays: *mut task_delay_info,
    pub nr_dirtied: c_types::c_int,
    pub nr_dirtied_pause: c_types::c_int,
    pub dirty_paused_when: c_types::c_ulong,
    pub timer_slack_ns: u64_,
    pub default_timer_slack_ns: u64_,
    pub curr_ret_stack: c_types::c_int,
    pub curr_ret_depth: c_types::c_int,
    pub ret_stack: *mut ftrace_ret_stack,
    pub ftrace_timestamp: c_types::c_ulonglong,
    pub trace_overrun: atomic_t,
    pub tracing_graph_pause: atomic_t,
    pub trace: c_types::c_ulong,
    pub trace_recursion: c_types::c_ulong,
    pub memcg_in_oom: *mut mem_cgroup,
    pub memcg_oom_gfp_mask: gfp_t,
    pub memcg_oom_order: c_types::c_int,
    pub memcg_nr_pages_over_high: c_types::c_uint,
    pub active_memcg: *mut mem_cgroup,
    pub throttle_queue: *mut request_queue,
    pub utask: *mut uprobe_task,
    pub sequential_io: c_types::c_uint,
    pub sequential_io_avg: c_types::c_uint,
    pub pagefault_disabled: c_types::c_int,
    pub oom_reaper_list: *mut task_struct,
    pub stack_vm_area: *mut vm_struct,
    pub stack_refcount: refcount_t,
    pub patch_state: c_types::c_int,
    pub security: *mut c_types::c_void,
    pub __bindgen_padding_0: [u64; 7usize],
    pub thread: thread_struct,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union task_struct__bindgen_ty_1 {
    pub rcu_users: refcount_t,
    pub rcu: callback_head,
    _bindgen_union_align: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_task_struct__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<task_struct__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(task_struct__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<task_struct__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(task_struct__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<task_struct__bindgen_ty_1>())).rcu_users as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct__bindgen_ty_1),
            "::",
            stringify!(rcu_users)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct__bindgen_ty_1>())).rcu as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct__bindgen_ty_1),
            "::",
            stringify!(rcu)
        )
    );
}
impl Default for task_struct__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_task_struct() {
    assert_eq!(
        ::core::mem::size_of::<task_struct>(),
        9280usize,
        concat!("Size of: ", stringify!(task_struct))
    );
    assert_eq!(
        ::core::mem::align_of::<task_struct>(),
        64usize,
        concat!("Alignment of ", stringify!(task_struct))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).thread_info as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(thread_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).state as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).stack as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(stack)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).usage as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(usage)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).flags as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).ptrace as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(ptrace)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).wake_entry as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(wake_entry)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).on_cpu as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(on_cpu)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).cpu as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(cpu)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).wakee_flips as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(wakee_flips)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<task_struct>())).wakee_flip_decay_ts as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(wakee_flip_decay_ts)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).last_wakee as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(last_wakee)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).recent_used_cpu as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(recent_used_cpu)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).wake_cpu as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(wake_cpu)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).on_rq as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(on_rq)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).prio as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(prio)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).static_prio as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(static_prio)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).normal_prio as *const _ as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(normal_prio)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).rt_priority as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(rt_priority)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).sched_class as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(sched_class)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).se as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(se)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).rt as *const _ as usize },
        576usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(rt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).sched_task_group as *const _ as usize },
        648usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(sched_task_group)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).dl as *const _ as usize },
        656usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(dl)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).uclamp_req as *const _ as usize },
        872usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(uclamp_req)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).uclamp as *const _ as usize },
        880usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(uclamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).preempt_notifiers as *const _ as usize },
        888usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(preempt_notifiers)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).btrace_seq as *const _ as usize },
        896usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(btrace_seq)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).policy as *const _ as usize },
        900usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(policy)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).nr_cpus_allowed as *const _ as usize },
        904usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(nr_cpus_allowed)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).cpus_ptr as *const _ as usize },
        912usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(cpus_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).cpus_mask as *const _ as usize },
        920usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(cpus_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).rcu_tasks_nvcsw as *const _ as usize },
        1944usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(rcu_tasks_nvcsw)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).rcu_tasks_holdout as *const _ as usize },
        1952usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(rcu_tasks_holdout)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).rcu_tasks_idx as *const _ as usize },
        1953usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(rcu_tasks_idx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).rcu_tasks_idle_cpu as *const _ as usize },
        1956usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(rcu_tasks_idle_cpu)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<task_struct>())).rcu_tasks_holdout_list as *const _ as usize
        },
        1960usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(rcu_tasks_holdout_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).sched_info as *const _ as usize },
        1976usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(sched_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).tasks as *const _ as usize },
        2008usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(tasks)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).pushable_tasks as *const _ as usize },
        2024usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(pushable_tasks)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).pushable_dl_tasks as *const _ as usize },
        2064usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(pushable_dl_tasks)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).mm as *const _ as usize },
        2088usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(mm)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).active_mm as *const _ as usize },
        2096usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(active_mm)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).vmacache as *const _ as usize },
        2104usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(vmacache)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).rss_stat as *const _ as usize },
        2144usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(rss_stat)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).exit_state as *const _ as usize },
        2164usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(exit_state)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).exit_code as *const _ as usize },
        2168usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(exit_code)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).exit_signal as *const _ as usize },
        2172usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(exit_signal)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).pdeath_signal as *const _ as usize },
        2176usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(pdeath_signal)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).jobctl as *const _ as usize },
        2184usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(jobctl)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).personality as *const _ as usize },
        2192usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(personality)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).atomic_flags as *const _ as usize },
        2208usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(atomic_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).restart_block as *const _ as usize },
        2216usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(restart_block)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).pid as *const _ as usize },
        2264usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(pid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).tgid as *const _ as usize },
        2268usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(tgid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).stack_canary as *const _ as usize },
        2272usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(stack_canary)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).real_parent as *const _ as usize },
        2280usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(real_parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).parent as *const _ as usize },
        2288usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).children as *const _ as usize },
        2296usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(children)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).sibling as *const _ as usize },
        2312usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(sibling)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).group_leader as *const _ as usize },
        2328usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(group_leader)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).ptraced as *const _ as usize },
        2336usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(ptraced)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).ptrace_entry as *const _ as usize },
        2352usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(ptrace_entry)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).thread_pid as *const _ as usize },
        2368usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(thread_pid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).pid_links as *const _ as usize },
        2376usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(pid_links)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).thread_group as *const _ as usize },
        2440usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(thread_group)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).thread_node as *const _ as usize },
        2456usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(thread_node)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).vfork_done as *const _ as usize },
        2472usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(vfork_done)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).set_child_tid as *const _ as usize },
        2480usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(set_child_tid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).clear_child_tid as *const _ as usize },
        2488usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(clear_child_tid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).utime as *const _ as usize },
        2496usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(utime)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).stime as *const _ as usize },
        2504usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(stime)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).gtime as *const _ as usize },
        2512usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(gtime)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).prev_cputime as *const _ as usize },
        2520usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(prev_cputime)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).nvcsw as *const _ as usize },
        2544usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(nvcsw)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).nivcsw as *const _ as usize },
        2552usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(nivcsw)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).start_time as *const _ as usize },
        2560usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(start_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).real_start_time as *const _ as usize },
        2568usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(real_start_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).min_flt as *const _ as usize },
        2576usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(min_flt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).maj_flt as *const _ as usize },
        2584usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(maj_flt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).posix_cputimers as *const _ as usize },
        2592usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(posix_cputimers)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).ptracer_cred as *const _ as usize },
        2672usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(ptracer_cred)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).real_cred as *const _ as usize },
        2680usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(real_cred)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).cred as *const _ as usize },
        2688usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(cred)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<task_struct>())).cached_requested_key as *const _ as usize
        },
        2696usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(cached_requested_key)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).comm as *const _ as usize },
        2704usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(comm)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).nameidata as *const _ as usize },
        2720usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(nameidata)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).sysvsem as *const _ as usize },
        2728usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(sysvsem)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).sysvshm as *const _ as usize },
        2736usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(sysvshm)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).last_switch_count as *const _ as usize },
        2752usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(last_switch_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).last_switch_time as *const _ as usize },
        2760usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(last_switch_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).fs as *const _ as usize },
        2768usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(fs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).files as *const _ as usize },
        2776usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(files)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).nsproxy as *const _ as usize },
        2784usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(nsproxy)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).signal as *const _ as usize },
        2792usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(signal)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).sighand as *const _ as usize },
        2800usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(sighand)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).blocked as *const _ as usize },
        2808usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(blocked)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).real_blocked as *const _ as usize },
        2816usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(real_blocked)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).saved_sigmask as *const _ as usize },
        2824usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(saved_sigmask)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).pending as *const _ as usize },
        2832usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(pending)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).sas_ss_sp as *const _ as usize },
        2856usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(sas_ss_sp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).sas_ss_size as *const _ as usize },
        2864usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(sas_ss_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).sas_ss_flags as *const _ as usize },
        2872usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(sas_ss_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).task_works as *const _ as usize },
        2880usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(task_works)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).audit_context as *const _ as usize },
        2888usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(audit_context)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).loginuid as *const _ as usize },
        2896usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(loginuid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).sessionid as *const _ as usize },
        2900usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(sessionid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).seccomp as *const _ as usize },
        2904usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(seccomp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).parent_exec_id as *const _ as usize },
        2920usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(parent_exec_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).self_exec_id as *const _ as usize },
        2924usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(self_exec_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).alloc_lock as *const _ as usize },
        2928usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(alloc_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).pi_lock as *const _ as usize },
        2932usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(pi_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).wake_q as *const _ as usize },
        2936usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(wake_q)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).pi_waiters as *const _ as usize },
        2944usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(pi_waiters)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).pi_top_task as *const _ as usize },
        2960usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(pi_top_task)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).pi_blocked_on as *const _ as usize },
        2968usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(pi_blocked_on)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).journal_info as *const _ as usize },
        2976usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(journal_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).bio_list as *const _ as usize },
        2984usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(bio_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).plug as *const _ as usize },
        2992usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(plug)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).reclaim_state as *const _ as usize },
        3000usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(reclaim_state)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).backing_dev_info as *const _ as usize },
        3008usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(backing_dev_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).io_context as *const _ as usize },
        3016usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(io_context)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).capture_control as *const _ as usize },
        3024usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(capture_control)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).ptrace_message as *const _ as usize },
        3032usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(ptrace_message)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).last_siginfo as *const _ as usize },
        3040usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(last_siginfo)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).ioac as *const _ as usize },
        3048usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(ioac)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).psi_flags as *const _ as usize },
        3104usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(psi_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).acct_rss_mem1 as *const _ as usize },
        3112usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(acct_rss_mem1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).acct_vm_mem1 as *const _ as usize },
        3120usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(acct_vm_mem1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).acct_timexpd as *const _ as usize },
        3128usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(acct_timexpd)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).mems_allowed as *const _ as usize },
        3136usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(mems_allowed)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).mems_allowed_seq as *const _ as usize },
        3264usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(mems_allowed_seq)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<task_struct>())).cpuset_mem_spread_rotor as *const _ as usize
        },
        3268usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(cpuset_mem_spread_rotor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<task_struct>())).cpuset_slab_spread_rotor as *const _ as usize
        },
        3272usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(cpuset_slab_spread_rotor)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).cgroups as *const _ as usize },
        3280usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(cgroups)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).cg_list as *const _ as usize },
        3288usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(cg_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).closid as *const _ as usize },
        3304usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(closid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).rmid as *const _ as usize },
        3308usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(rmid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).robust_list as *const _ as usize },
        3312usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(robust_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).compat_robust_list as *const _ as usize },
        3320usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(compat_robust_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).pi_state_list as *const _ as usize },
        3328usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(pi_state_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).pi_state_cache as *const _ as usize },
        3344usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(pi_state_cache)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).futex_exit_mutex as *const _ as usize },
        3352usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(futex_exit_mutex)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).futex_state as *const _ as usize },
        3384usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(futex_state)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).perf_event_ctxp as *const _ as usize },
        3392usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(perf_event_ctxp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).perf_event_mutex as *const _ as usize },
        3408usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(perf_event_mutex)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).perf_event_list as *const _ as usize },
        3440usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(perf_event_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).mempolicy as *const _ as usize },
        3456usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(mempolicy)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).il_prev as *const _ as usize },
        3464usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(il_prev)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).pref_node_fork as *const _ as usize },
        3466usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(pref_node_fork)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).numa_scan_seq as *const _ as usize },
        3468usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(numa_scan_seq)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).numa_scan_period as *const _ as usize },
        3472usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(numa_scan_period)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<task_struct>())).numa_scan_period_max as *const _ as usize
        },
        3476usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(numa_scan_period_max)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).numa_preferred_nid as *const _ as usize },
        3480usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(numa_preferred_nid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).numa_migrate_retry as *const _ as usize },
        3488usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(numa_migrate_retry)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).node_stamp as *const _ as usize },
        3496usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(node_stamp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<task_struct>())).last_task_numa_placement as *const _ as usize
        },
        3504usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(last_task_numa_placement)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<task_struct>())).last_sum_exec_runtime as *const _ as usize
        },
        3512usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(last_sum_exec_runtime)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).numa_work as *const _ as usize },
        3520usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(numa_work)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).numa_group as *const _ as usize },
        3536usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(numa_group)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).numa_faults as *const _ as usize },
        3544usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(numa_faults)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).total_numa_faults as *const _ as usize },
        3552usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(total_numa_faults)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<task_struct>())).numa_faults_locality as *const _ as usize
        },
        3560usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(numa_faults_locality)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<task_struct>())).numa_pages_migrated as *const _ as usize
        },
        3584usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(numa_pages_migrated)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).rseq as *const _ as usize },
        3592usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(rseq)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).rseq_sig as *const _ as usize },
        3600usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(rseq_sig)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).rseq_event_mask as *const _ as usize },
        3608usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(rseq_event_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).tlb_ubc as *const _ as usize },
        3616usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(tlb_ubc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).splice_pipe as *const _ as usize },
        4664usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(splice_pipe)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).task_frag as *const _ as usize },
        4672usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(task_frag)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).delays as *const _ as usize },
        4688usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(delays)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).nr_dirtied as *const _ as usize },
        4696usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(nr_dirtied)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).nr_dirtied_pause as *const _ as usize },
        4700usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(nr_dirtied_pause)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).dirty_paused_when as *const _ as usize },
        4704usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(dirty_paused_when)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).timer_slack_ns as *const _ as usize },
        4712usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(timer_slack_ns)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<task_struct>())).default_timer_slack_ns as *const _ as usize
        },
        4720usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(default_timer_slack_ns)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).curr_ret_stack as *const _ as usize },
        4728usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(curr_ret_stack)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).curr_ret_depth as *const _ as usize },
        4732usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(curr_ret_depth)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).ret_stack as *const _ as usize },
        4736usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(ret_stack)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).ftrace_timestamp as *const _ as usize },
        4744usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(ftrace_timestamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).trace_overrun as *const _ as usize },
        4752usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(trace_overrun)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<task_struct>())).tracing_graph_pause as *const _ as usize
        },
        4756usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(tracing_graph_pause)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).trace as *const _ as usize },
        4760usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(trace)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).trace_recursion as *const _ as usize },
        4768usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(trace_recursion)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).memcg_in_oom as *const _ as usize },
        4776usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(memcg_in_oom)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).memcg_oom_gfp_mask as *const _ as usize },
        4784usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(memcg_oom_gfp_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).memcg_oom_order as *const _ as usize },
        4788usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(memcg_oom_order)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<task_struct>())).memcg_nr_pages_over_high as *const _ as usize
        },
        4792usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(memcg_nr_pages_over_high)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).active_memcg as *const _ as usize },
        4800usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(active_memcg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).throttle_queue as *const _ as usize },
        4808usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(throttle_queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).utask as *const _ as usize },
        4816usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(utask)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).sequential_io as *const _ as usize },
        4824usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(sequential_io)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).sequential_io_avg as *const _ as usize },
        4828usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(sequential_io_avg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).pagefault_disabled as *const _ as usize },
        4832usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(pagefault_disabled)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).oom_reaper_list as *const _ as usize },
        4840usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(oom_reaper_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).stack_vm_area as *const _ as usize },
        4848usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(stack_vm_area)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).stack_refcount as *const _ as usize },
        4856usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(stack_refcount)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).patch_state as *const _ as usize },
        4860usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(patch_state)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).security as *const _ as usize },
        4864usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(security)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).thread as *const _ as usize },
        4928usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(thread)
        )
    );
}
impl Default for task_struct {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl task_struct {
    #[inline]
    pub fn sched_reset_on_fork(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sched_reset_on_fork(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sched_contributes_to_load(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sched_contributes_to_load(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sched_migrated(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sched_migrated(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sched_remote_wakeup(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sched_remote_wakeup(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sched_psi_wake_requeue(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sched_psi_wake_requeue(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_execve(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(32usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_execve(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(32usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_iowait(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(33usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_iowait(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(33usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn restore_sigmask(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(34usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_restore_sigmask(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(34usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_user_fault(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(35usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_user_fault(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(35usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn no_cgroup_migration(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(36usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_no_cgroup_migration(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(36usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn frozen(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(37usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_frozen(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(37usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn use_memdelay(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(38usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_use_memdelay(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(38usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        sched_reset_on_fork: c_types::c_uint,
        sched_contributes_to_load: c_types::c_uint,
        sched_migrated: c_types::c_uint,
        sched_remote_wakeup: c_types::c_uint,
        sched_psi_wake_requeue: c_types::c_uint,
        in_execve: c_types::c_uint,
        in_iowait: c_types::c_uint,
        restore_sigmask: c_types::c_uint,
        in_user_fault: c_types::c_uint,
        no_cgroup_migration: c_types::c_uint,
        frozen: c_types::c_uint,
        use_memdelay: c_types::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 5usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 5usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let sched_reset_on_fork: u32 = unsafe { ::core::mem::transmute(sched_reset_on_fork) };
            sched_reset_on_fork as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let sched_contributes_to_load: u32 =
                unsafe { ::core::mem::transmute(sched_contributes_to_load) };
            sched_contributes_to_load as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let sched_migrated: u32 = unsafe { ::core::mem::transmute(sched_migrated) };
            sched_migrated as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let sched_remote_wakeup: u32 = unsafe { ::core::mem::transmute(sched_remote_wakeup) };
            sched_remote_wakeup as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let sched_psi_wake_requeue: u32 =
                unsafe { ::core::mem::transmute(sched_psi_wake_requeue) };
            sched_psi_wake_requeue as u64
        });
        __bindgen_bitfield_unit.set(32usize, 1u8, {
            let in_execve: u32 = unsafe { ::core::mem::transmute(in_execve) };
            in_execve as u64
        });
        __bindgen_bitfield_unit.set(33usize, 1u8, {
            let in_iowait: u32 = unsafe { ::core::mem::transmute(in_iowait) };
            in_iowait as u64
        });
        __bindgen_bitfield_unit.set(34usize, 1u8, {
            let restore_sigmask: u32 = unsafe { ::core::mem::transmute(restore_sigmask) };
            restore_sigmask as u64
        });
        __bindgen_bitfield_unit.set(35usize, 1u8, {
            let in_user_fault: u32 = unsafe { ::core::mem::transmute(in_user_fault) };
            in_user_fault as u64
        });
        __bindgen_bitfield_unit.set(36usize, 1u8, {
            let no_cgroup_migration: u32 = unsafe { ::core::mem::transmute(no_cgroup_migration) };
            no_cgroup_migration as u64
        });
        __bindgen_bitfield_unit.set(37usize, 1u8, {
            let frozen: u32 = unsafe { ::core::mem::transmute(frozen) };
            frozen as u64
        });
        __bindgen_bitfield_unit.set(38usize, 1u8, {
            let use_memdelay: u32 = unsafe { ::core::mem::transmute(use_memdelay) };
            use_memdelay as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct exception_table_entry {
    pub insn: c_types::c_int,
    pub fixup: c_types::c_int,
    pub handler: c_types::c_int,
}
#[test]
fn bindgen_test_layout_exception_table_entry() {
    assert_eq!(
        ::core::mem::size_of::<exception_table_entry>(),
        12usize,
        concat!("Size of: ", stringify!(exception_table_entry))
    );
    assert_eq!(
        ::core::mem::align_of::<exception_table_entry>(),
        4usize,
        concat!("Alignment of ", stringify!(exception_table_entry))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<exception_table_entry>())).insn as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(exception_table_entry),
            "::",
            stringify!(insn)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<exception_table_entry>())).fixup as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(exception_table_entry),
            "::",
            stringify!(fixup)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<exception_table_entry>())).handler as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(exception_table_entry),
            "::",
            stringify!(handler)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vm_fault {
    pub vma: *mut vm_area_struct,
    pub flags: c_types::c_uint,
    pub gfp_mask: gfp_t,
    pub pgoff: c_types::c_ulong,
    pub address: c_types::c_ulong,
    pub pmd: *mut pmd_t,
    pub pud: *mut pud_t,
    pub orig_pte: pte_t,
    pub cow_page: *mut page,
    pub memcg: *mut mem_cgroup,
    pub page: *mut page,
    pub pte: *mut pte_t,
    pub ptl: *mut spinlock_t,
    pub prealloc_pte: pgtable_t,
}
#[test]
fn bindgen_test_layout_vm_fault() {
    assert_eq!(
        ::core::mem::size_of::<vm_fault>(),
        104usize,
        concat!("Size of: ", stringify!(vm_fault))
    );
    assert_eq!(
        ::core::mem::align_of::<vm_fault>(),
        8usize,
        concat!("Alignment of ", stringify!(vm_fault))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vm_fault>())).vma as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_fault),
            "::",
            stringify!(vma)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vm_fault>())).flags as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_fault),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vm_fault>())).gfp_mask as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_fault),
            "::",
            stringify!(gfp_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vm_fault>())).pgoff as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_fault),
            "::",
            stringify!(pgoff)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vm_fault>())).address as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_fault),
            "::",
            stringify!(address)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vm_fault>())).pmd as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_fault),
            "::",
            stringify!(pmd)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vm_fault>())).pud as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_fault),
            "::",
            stringify!(pud)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vm_fault>())).orig_pte as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_fault),
            "::",
            stringify!(orig_pte)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vm_fault>())).cow_page as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_fault),
            "::",
            stringify!(cow_page)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vm_fault>())).memcg as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_fault),
            "::",
            stringify!(memcg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vm_fault>())).page as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_fault),
            "::",
            stringify!(page)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vm_fault>())).pte as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_fault),
            "::",
            stringify!(pte)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vm_fault>())).ptl as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_fault),
            "::",
            stringify!(ptl)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vm_fault>())).prealloc_pte as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_fault),
            "::",
            stringify!(prealloc_pte)
        )
    );
}
impl Default for vm_fault {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub const page_entry_size_PE_SIZE_PTE: page_entry_size = 0;
pub const page_entry_size_PE_SIZE_PMD: page_entry_size = 1;
pub const page_entry_size_PE_SIZE_PUD: page_entry_size = 2;
pub type page_entry_size = c_types::c_uint;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct vm_operations_struct {
    pub open: ::core::option::Option<unsafe extern "C" fn(area: *mut vm_area_struct)>,
    pub close: ::core::option::Option<unsafe extern "C" fn(area: *mut vm_area_struct)>,
    pub split: ::core::option::Option<
        unsafe extern "C" fn(area: *mut vm_area_struct, addr: c_types::c_ulong) -> c_types::c_int,
    >,
    pub mremap:
        ::core::option::Option<unsafe extern "C" fn(area: *mut vm_area_struct) -> c_types::c_int>,
    pub fault: ::core::option::Option<unsafe extern "C" fn(vmf: *mut vm_fault) -> vm_fault_t>,
    pub huge_fault: ::core::option::Option<
        unsafe extern "C" fn(vmf: *mut vm_fault, pe_size: page_entry_size) -> vm_fault_t,
    >,
    pub map_pages: ::core::option::Option<
        unsafe extern "C" fn(
            vmf: *mut vm_fault,
            start_pgoff: c_types::c_ulong,
            end_pgoff: c_types::c_ulong,
        ),
    >,
    pub pagesize:
        ::core::option::Option<unsafe extern "C" fn(area: *mut vm_area_struct) -> c_types::c_ulong>,
    pub page_mkwrite:
        ::core::option::Option<unsafe extern "C" fn(vmf: *mut vm_fault) -> vm_fault_t>,
    pub pfn_mkwrite: ::core::option::Option<unsafe extern "C" fn(vmf: *mut vm_fault) -> vm_fault_t>,
    pub access: ::core::option::Option<
        unsafe extern "C" fn(
            vma: *mut vm_area_struct,
            addr: c_types::c_ulong,
            buf: *mut c_types::c_void,
            len: c_types::c_int,
            write: c_types::c_int,
        ) -> c_types::c_int,
    >,
    pub name: ::core::option::Option<
        unsafe extern "C" fn(vma: *mut vm_area_struct) -> *const c_types::c_char,
    >,
    pub set_policy: ::core::option::Option<
        unsafe extern "C" fn(vma: *mut vm_area_struct, new: *mut mempolicy) -> c_types::c_int,
    >,
    pub get_policy: ::core::option::Option<
        unsafe extern "C" fn(vma: *mut vm_area_struct, addr: c_types::c_ulong) -> *mut mempolicy,
    >,
    pub find_special_page: ::core::option::Option<
        unsafe extern "C" fn(vma: *mut vm_area_struct, addr: c_types::c_ulong) -> *mut page,
    >,
}
#[test]
fn bindgen_test_layout_vm_operations_struct() {
    assert_eq!(
        ::core::mem::size_of::<vm_operations_struct>(),
        120usize,
        concat!("Size of: ", stringify!(vm_operations_struct))
    );
    assert_eq!(
        ::core::mem::align_of::<vm_operations_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(vm_operations_struct))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vm_operations_struct>())).open as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_operations_struct),
            "::",
            stringify!(open)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vm_operations_struct>())).close as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_operations_struct),
            "::",
            stringify!(close)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vm_operations_struct>())).split as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_operations_struct),
            "::",
            stringify!(split)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vm_operations_struct>())).mremap as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_operations_struct),
            "::",
            stringify!(mremap)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vm_operations_struct>())).fault as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_operations_struct),
            "::",
            stringify!(fault)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<vm_operations_struct>())).huge_fault as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_operations_struct),
            "::",
            stringify!(huge_fault)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vm_operations_struct>())).map_pages as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_operations_struct),
            "::",
            stringify!(map_pages)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vm_operations_struct>())).pagesize as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_operations_struct),
            "::",
            stringify!(pagesize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<vm_operations_struct>())).page_mkwrite as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_operations_struct),
            "::",
            stringify!(page_mkwrite)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<vm_operations_struct>())).pfn_mkwrite as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_operations_struct),
            "::",
            stringify!(pfn_mkwrite)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vm_operations_struct>())).access as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_operations_struct),
            "::",
            stringify!(access)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vm_operations_struct>())).name as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_operations_struct),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<vm_operations_struct>())).set_policy as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_operations_struct),
            "::",
            stringify!(set_policy)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<vm_operations_struct>())).get_policy as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_operations_struct),
            "::",
            stringify!(get_policy)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<vm_operations_struct>())).find_special_page as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_operations_struct),
            "::",
            stringify!(find_special_page)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hlist_bl_head {
    pub first: *mut hlist_bl_node,
}
#[test]
fn bindgen_test_layout_hlist_bl_head() {
    assert_eq!(
        ::core::mem::size_of::<hlist_bl_head>(),
        8usize,
        concat!("Size of: ", stringify!(hlist_bl_head))
    );
    assert_eq!(
        ::core::mem::align_of::<hlist_bl_head>(),
        8usize,
        concat!("Alignment of ", stringify!(hlist_bl_head))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hlist_bl_head>())).first as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hlist_bl_head),
            "::",
            stringify!(first)
        )
    );
}
impl Default for hlist_bl_head {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hlist_bl_node {
    pub next: *mut hlist_bl_node,
    pub pprev: *mut *mut hlist_bl_node,
}
#[test]
fn bindgen_test_layout_hlist_bl_node() {
    assert_eq!(
        ::core::mem::size_of::<hlist_bl_node>(),
        16usize,
        concat!("Size of: ", stringify!(hlist_bl_node))
    );
    assert_eq!(
        ::core::mem::align_of::<hlist_bl_node>(),
        8usize,
        concat!("Alignment of ", stringify!(hlist_bl_node))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hlist_bl_node>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hlist_bl_node),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hlist_bl_node>())).pprev as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hlist_bl_node),
            "::",
            stringify!(pprev)
        )
    );
}
impl Default for hlist_bl_node {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lockref {
    pub __bindgen_anon_1: lockref__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union lockref__bindgen_ty_1 {
    pub lock_count: __u64,
    pub __bindgen_anon_1: lockref__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lockref__bindgen_ty_1__bindgen_ty_1 {
    pub lock: spinlock_t,
    pub count: c_types::c_int,
}
#[test]
fn bindgen_test_layout_lockref__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<lockref__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(lockref__bindgen_ty_1__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<lockref__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(lockref__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<lockref__bindgen_ty_1__bindgen_ty_1>())).lock as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lockref__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<lockref__bindgen_ty_1__bindgen_ty_1>())).count as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lockref__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(count)
        )
    );
}
impl Default for lockref__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_lockref__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<lockref__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(lockref__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<lockref__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(lockref__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<lockref__bindgen_ty_1>())).lock_count as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lockref__bindgen_ty_1),
            "::",
            stringify!(lock_count)
        )
    );
}
impl Default for lockref__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_lockref() {
    assert_eq!(
        ::core::mem::size_of::<lockref>(),
        8usize,
        concat!("Size of: ", stringify!(lockref))
    );
    assert_eq!(
        ::core::mem::align_of::<lockref>(),
        8usize,
        concat!("Alignment of ", stringify!(lockref))
    );
}
impl Default for lockref {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vfsmount {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct qstr {
    pub __bindgen_anon_1: qstr__bindgen_ty_1,
    pub name: *const c_types::c_uchar,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union qstr__bindgen_ty_1 {
    pub __bindgen_anon_1: qstr__bindgen_ty_1__bindgen_ty_1,
    pub hash_len: u64_,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct qstr__bindgen_ty_1__bindgen_ty_1 {
    pub hash: u32_,
    pub len: u32_,
}
#[test]
fn bindgen_test_layout_qstr__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<qstr__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(qstr__bindgen_ty_1__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<qstr__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(qstr__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<qstr__bindgen_ty_1__bindgen_ty_1>())).hash as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qstr__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(hash)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<qstr__bindgen_ty_1__bindgen_ty_1>())).len as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(qstr__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(len)
        )
    );
}
#[test]
fn bindgen_test_layout_qstr__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<qstr__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(qstr__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<qstr__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(qstr__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<qstr__bindgen_ty_1>())).hash_len as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qstr__bindgen_ty_1),
            "::",
            stringify!(hash_len)
        )
    );
}
impl Default for qstr__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_qstr() {
    assert_eq!(
        ::core::mem::size_of::<qstr>(),
        16usize,
        concat!("Size of: ", stringify!(qstr))
    );
    assert_eq!(
        ::core::mem::align_of::<qstr>(),
        8usize,
        concat!("Alignment of ", stringify!(qstr))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<qstr>())).name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(qstr),
            "::",
            stringify!(name)
        )
    );
}
impl Default for qstr {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct dentry {
    pub d_flags: c_types::c_uint,
    pub d_seq: seqcount_t,
    pub d_hash: hlist_bl_node,
    pub d_parent: *mut dentry,
    pub d_name: qstr,
    pub d_inode: *mut inode,
    pub d_iname: [c_types::c_uchar; 32usize],
    pub d_lockref: lockref,
    pub d_op: *const dentry_operations,
    pub d_sb: *mut super_block,
    pub d_time: c_types::c_ulong,
    pub d_fsdata: *mut c_types::c_void,
    pub __bindgen_anon_1: dentry__bindgen_ty_1,
    pub d_child: list_head,
    pub d_subdirs: list_head,
    pub d_u: dentry__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union dentry__bindgen_ty_1 {
    pub d_lru: list_head,
    pub d_wait: *mut wait_queue_head_t,
    _bindgen_union_align: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_dentry__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<dentry__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(dentry__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<dentry__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(dentry__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dentry__bindgen_ty_1>())).d_lru as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dentry__bindgen_ty_1),
            "::",
            stringify!(d_lru)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dentry__bindgen_ty_1>())).d_wait as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dentry__bindgen_ty_1),
            "::",
            stringify!(d_wait)
        )
    );
}
impl Default for dentry__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union dentry__bindgen_ty_2 {
    pub d_alias: hlist_node,
    pub d_in_lookup_hash: hlist_bl_node,
    pub d_rcu: callback_head,
    _bindgen_union_align: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_dentry__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<dentry__bindgen_ty_2>(),
        16usize,
        concat!("Size of: ", stringify!(dentry__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<dentry__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(dentry__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dentry__bindgen_ty_2>())).d_alias as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dentry__bindgen_ty_2),
            "::",
            stringify!(d_alias)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<dentry__bindgen_ty_2>())).d_in_lookup_hash as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dentry__bindgen_ty_2),
            "::",
            stringify!(d_in_lookup_hash)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dentry__bindgen_ty_2>())).d_rcu as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dentry__bindgen_ty_2),
            "::",
            stringify!(d_rcu)
        )
    );
}
impl Default for dentry__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_dentry() {
    assert_eq!(
        ::core::mem::size_of::<dentry>(),
        192usize,
        concat!("Size of: ", stringify!(dentry))
    );
    assert_eq!(
        ::core::mem::align_of::<dentry>(),
        8usize,
        concat!("Alignment of ", stringify!(dentry))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dentry>())).d_flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dentry),
            "::",
            stringify!(d_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dentry>())).d_seq as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(dentry),
            "::",
            stringify!(d_seq)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dentry>())).d_hash as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(dentry),
            "::",
            stringify!(d_hash)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dentry>())).d_parent as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(dentry),
            "::",
            stringify!(d_parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dentry>())).d_name as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(dentry),
            "::",
            stringify!(d_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dentry>())).d_inode as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(dentry),
            "::",
            stringify!(d_inode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dentry>())).d_iname as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(dentry),
            "::",
            stringify!(d_iname)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dentry>())).d_lockref as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(dentry),
            "::",
            stringify!(d_lockref)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dentry>())).d_op as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(dentry),
            "::",
            stringify!(d_op)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dentry>())).d_sb as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(dentry),
            "::",
            stringify!(d_sb)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dentry>())).d_time as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(dentry),
            "::",
            stringify!(d_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dentry>())).d_fsdata as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(dentry),
            "::",
            stringify!(d_fsdata)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dentry>())).d_child as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(dentry),
            "::",
            stringify!(d_child)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dentry>())).d_subdirs as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(dentry),
            "::",
            stringify!(d_subdirs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dentry>())).d_u as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(dentry),
            "::",
            stringify!(d_u)
        )
    );
}
impl Default for dentry {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct dentry_operations {
    pub d_revalidate: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut dentry, arg2: c_types::c_uint) -> c_types::c_int,
    >,
    pub d_weak_revalidate: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut dentry, arg2: c_types::c_uint) -> c_types::c_int,
    >,
    pub d_hash: ::core::option::Option<
        unsafe extern "C" fn(arg1: *const dentry, arg2: *mut qstr) -> c_types::c_int,
    >,
    pub d_compare: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *const dentry,
            arg2: c_types::c_uint,
            arg3: *const c_types::c_char,
            arg4: *const qstr,
        ) -> c_types::c_int,
    >,
    pub d_delete:
        ::core::option::Option<unsafe extern "C" fn(arg1: *const dentry) -> c_types::c_int>,
    pub d_init: ::core::option::Option<unsafe extern "C" fn(arg1: *mut dentry) -> c_types::c_int>,
    pub d_release: ::core::option::Option<unsafe extern "C" fn(arg1: *mut dentry)>,
    pub d_prune: ::core::option::Option<unsafe extern "C" fn(arg1: *mut dentry)>,
    pub d_iput: ::core::option::Option<unsafe extern "C" fn(arg1: *mut dentry, arg2: *mut inode)>,
    pub d_dname: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dentry,
            arg2: *mut c_types::c_char,
            arg3: c_types::c_int,
        ) -> *mut c_types::c_char,
    >,
    pub d_automount: ::core::option::Option<unsafe extern "C" fn(arg1: *mut path) -> *mut vfsmount>,
    pub d_manage: ::core::option::Option<
        unsafe extern "C" fn(arg1: *const path, arg2: bool_) -> c_types::c_int,
    >,
    pub d_real: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut dentry, arg2: *const inode) -> *mut dentry,
    >,
}
#[test]
fn bindgen_test_layout_dentry_operations() {
    assert_eq!(
        ::core::mem::size_of::<dentry_operations>(),
        128usize,
        concat!("Size of: ", stringify!(dentry_operations))
    );
    assert_eq!(
        ::core::mem::align_of::<dentry_operations>(),
        64usize,
        concat!("Alignment of ", stringify!(dentry_operations))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dentry_operations>())).d_revalidate as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dentry_operations),
            "::",
            stringify!(d_revalidate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<dentry_operations>())).d_weak_revalidate as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(dentry_operations),
            "::",
            stringify!(d_weak_revalidate)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dentry_operations>())).d_hash as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(dentry_operations),
            "::",
            stringify!(d_hash)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dentry_operations>())).d_compare as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(dentry_operations),
            "::",
            stringify!(d_compare)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dentry_operations>())).d_delete as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(dentry_operations),
            "::",
            stringify!(d_delete)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dentry_operations>())).d_init as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(dentry_operations),
            "::",
            stringify!(d_init)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dentry_operations>())).d_release as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(dentry_operations),
            "::",
            stringify!(d_release)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dentry_operations>())).d_prune as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(dentry_operations),
            "::",
            stringify!(d_prune)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dentry_operations>())).d_iput as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(dentry_operations),
            "::",
            stringify!(d_iput)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dentry_operations>())).d_dname as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(dentry_operations),
            "::",
            stringify!(d_dname)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dentry_operations>())).d_automount as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(dentry_operations),
            "::",
            stringify!(d_automount)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dentry_operations>())).d_manage as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(dentry_operations),
            "::",
            stringify!(d_manage)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dentry_operations>())).d_real as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(dentry_operations),
            "::",
            stringify!(d_real)
        )
    );
}
impl Default for dentry_operations {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct path {
    pub mnt: *mut vfsmount,
    pub dentry: *mut dentry,
}
#[test]
fn bindgen_test_layout_path() {
    assert_eq!(
        ::core::mem::size_of::<path>(),
        16usize,
        concat!("Size of: ", stringify!(path))
    );
    assert_eq!(
        ::core::mem::align_of::<path>(),
        8usize,
        concat!("Alignment of ", stringify!(path))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<path>())).mnt as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(path), "::", stringify!(mnt))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<path>())).dentry as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(path),
            "::",
            stringify!(dentry)
        )
    );
}
impl Default for path {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kstat {
    pub result_mask: u32_,
    pub mode: umode_t,
    pub nlink: c_types::c_uint,
    pub blksize: u32,
    pub attributes: u64_,
    pub attributes_mask: u64_,
    pub ino: u64_,
    pub dev: dev_t,
    pub rdev: dev_t,
    pub uid: kuid_t,
    pub gid: kgid_t,
    pub size: loff_t,
    pub atime: timespec64,
    pub mtime: timespec64,
    pub ctime: timespec64,
    pub btime: timespec64,
    pub blocks: u64_,
}
#[test]
fn bindgen_test_layout_kstat() {
    assert_eq!(
        ::core::mem::size_of::<kstat>(),
        136usize,
        concat!("Size of: ", stringify!(kstat))
    );
    assert_eq!(
        ::core::mem::align_of::<kstat>(),
        8usize,
        concat!("Alignment of ", stringify!(kstat))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kstat>())).result_mask as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kstat),
            "::",
            stringify!(result_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kstat>())).mode as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(kstat),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kstat>())).nlink as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(kstat),
            "::",
            stringify!(nlink)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kstat>())).blksize as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(kstat),
            "::",
            stringify!(blksize)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kstat>())).attributes as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(kstat),
            "::",
            stringify!(attributes)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kstat>())).attributes_mask as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(kstat),
            "::",
            stringify!(attributes_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kstat>())).ino as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(kstat),
            "::",
            stringify!(ino)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kstat>())).dev as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(kstat),
            "::",
            stringify!(dev)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kstat>())).rdev as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(kstat),
            "::",
            stringify!(rdev)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kstat>())).uid as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(kstat),
            "::",
            stringify!(uid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kstat>())).gid as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(kstat),
            "::",
            stringify!(gid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kstat>())).size as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(kstat),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kstat>())).atime as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(kstat),
            "::",
            stringify!(atime)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kstat>())).mtime as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(kstat),
            "::",
            stringify!(mtime)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kstat>())).ctime as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(kstat),
            "::",
            stringify!(ctime)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kstat>())).btime as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(kstat),
            "::",
            stringify!(btime)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kstat>())).blocks as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(kstat),
            "::",
            stringify!(blocks)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct list_lru_one {
    pub list: list_head,
    pub nr_items: c_types::c_long,
}
#[test]
fn bindgen_test_layout_list_lru_one() {
    assert_eq!(
        ::core::mem::size_of::<list_lru_one>(),
        24usize,
        concat!("Size of: ", stringify!(list_lru_one))
    );
    assert_eq!(
        ::core::mem::align_of::<list_lru_one>(),
        8usize,
        concat!("Alignment of ", stringify!(list_lru_one))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<list_lru_one>())).list as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(list_lru_one),
            "::",
            stringify!(list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<list_lru_one>())).nr_items as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(list_lru_one),
            "::",
            stringify!(nr_items)
        )
    );
}
impl Default for list_lru_one {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct list_lru_memcg {
    pub rcu: callback_head,
    pub lru: __IncompleteArrayField<*mut list_lru_one>,
}
#[test]
fn bindgen_test_layout_list_lru_memcg() {
    assert_eq!(
        ::core::mem::size_of::<list_lru_memcg>(),
        16usize,
        concat!("Size of: ", stringify!(list_lru_memcg))
    );
    assert_eq!(
        ::core::mem::align_of::<list_lru_memcg>(),
        8usize,
        concat!("Alignment of ", stringify!(list_lru_memcg))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<list_lru_memcg>())).rcu as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(list_lru_memcg),
            "::",
            stringify!(rcu)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<list_lru_memcg>())).lru as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(list_lru_memcg),
            "::",
            stringify!(lru)
        )
    );
}
impl Default for list_lru_memcg {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct list_lru_node {
    pub lock: spinlock_t,
    pub lru: list_lru_one,
    pub memcg_lrus: *mut list_lru_memcg,
    pub nr_items: c_types::c_long,
}
#[test]
fn bindgen_test_layout_list_lru_node() {
    assert_eq!(
        ::core::mem::size_of::<list_lru_node>(),
        64usize,
        concat!("Size of: ", stringify!(list_lru_node))
    );
    assert_eq!(
        ::core::mem::align_of::<list_lru_node>(),
        64usize,
        concat!("Alignment of ", stringify!(list_lru_node))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<list_lru_node>())).lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(list_lru_node),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<list_lru_node>())).lru as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(list_lru_node),
            "::",
            stringify!(lru)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<list_lru_node>())).memcg_lrus as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(list_lru_node),
            "::",
            stringify!(memcg_lrus)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<list_lru_node>())).nr_items as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(list_lru_node),
            "::",
            stringify!(nr_items)
        )
    );
}
impl Default for list_lru_node {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct list_lru {
    pub node: *mut list_lru_node,
    pub list: list_head,
    pub shrinker_id: c_types::c_int,
    pub memcg_aware: bool_,
}
#[test]
fn bindgen_test_layout_list_lru() {
    assert_eq!(
        ::core::mem::size_of::<list_lru>(),
        32usize,
        concat!("Size of: ", stringify!(list_lru))
    );
    assert_eq!(
        ::core::mem::align_of::<list_lru>(),
        8usize,
        concat!("Alignment of ", stringify!(list_lru))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<list_lru>())).node as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(list_lru),
            "::",
            stringify!(node)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<list_lru>())).list as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(list_lru),
            "::",
            stringify!(list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<list_lru>())).shrinker_id as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(list_lru),
            "::",
            stringify!(shrinker_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<list_lru>())).memcg_aware as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(list_lru),
            "::",
            stringify!(memcg_aware)
        )
    );
}
impl Default for list_lru {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct xarray {
    pub xa_lock: spinlock_t,
    pub xa_flags: gfp_t,
    pub xa_head: *mut c_types::c_void,
}
#[test]
fn bindgen_test_layout_xarray() {
    assert_eq!(
        ::core::mem::size_of::<xarray>(),
        16usize,
        concat!("Size of: ", stringify!(xarray))
    );
    assert_eq!(
        ::core::mem::align_of::<xarray>(),
        8usize,
        concat!("Alignment of ", stringify!(xarray))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xarray>())).xa_lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xarray),
            "::",
            stringify!(xa_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xarray>())).xa_flags as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xarray),
            "::",
            stringify!(xa_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xarray>())).xa_head as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xarray),
            "::",
            stringify!(xa_head)
        )
    );
}
impl Default for xarray {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct fiemap_extent {
    pub fe_logical: __u64,
    pub fe_physical: __u64,
    pub fe_length: __u64,
    pub fe_reserved64: [__u64; 2usize],
    pub fe_flags: __u32,
    pub fe_reserved: [__u32; 3usize],
}
#[test]
fn bindgen_test_layout_fiemap_extent() {
    assert_eq!(
        ::core::mem::size_of::<fiemap_extent>(),
        56usize,
        concat!("Size of: ", stringify!(fiemap_extent))
    );
    assert_eq!(
        ::core::mem::align_of::<fiemap_extent>(),
        8usize,
        concat!("Alignment of ", stringify!(fiemap_extent))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fiemap_extent>())).fe_logical as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fiemap_extent),
            "::",
            stringify!(fe_logical)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fiemap_extent>())).fe_physical as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(fiemap_extent),
            "::",
            stringify!(fe_physical)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fiemap_extent>())).fe_length as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(fiemap_extent),
            "::",
            stringify!(fe_length)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fiemap_extent>())).fe_reserved64 as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(fiemap_extent),
            "::",
            stringify!(fe_reserved64)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fiemap_extent>())).fe_flags as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(fiemap_extent),
            "::",
            stringify!(fe_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fiemap_extent>())).fe_reserved as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(fiemap_extent),
            "::",
            stringify!(fe_reserved)
        )
    );
}
pub const migrate_mode_MIGRATE_ASYNC: migrate_mode = 0;
pub const migrate_mode_MIGRATE_SYNC_LIGHT: migrate_mode = 1;
pub const migrate_mode_MIGRATE_SYNC: migrate_mode = 2;
pub const migrate_mode_MIGRATE_SYNC_NO_COPY: migrate_mode = 3;
pub type migrate_mode = c_types::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcuwait {
    pub task: *mut task_struct,
}
#[test]
fn bindgen_test_layout_rcuwait() {
    assert_eq!(
        ::core::mem::size_of::<rcuwait>(),
        8usize,
        concat!("Size of: ", stringify!(rcuwait))
    );
    assert_eq!(
        ::core::mem::align_of::<rcuwait>(),
        8usize,
        concat!("Alignment of ", stringify!(rcuwait))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rcuwait>())).task as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rcuwait),
            "::",
            stringify!(task)
        )
    );
}
impl Default for rcuwait {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rcu_sync {
    pub gp_state: c_types::c_int,
    pub gp_count: c_types::c_int,
    pub gp_wait: wait_queue_head_t,
    pub cb_head: callback_head,
}
#[test]
fn bindgen_test_layout_rcu_sync() {
    assert_eq!(
        ::core::mem::size_of::<rcu_sync>(),
        48usize,
        concat!("Size of: ", stringify!(rcu_sync))
    );
    assert_eq!(
        ::core::mem::align_of::<rcu_sync>(),
        8usize,
        concat!("Alignment of ", stringify!(rcu_sync))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rcu_sync>())).gp_state as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rcu_sync),
            "::",
            stringify!(gp_state)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rcu_sync>())).gp_count as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rcu_sync),
            "::",
            stringify!(gp_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rcu_sync>())).gp_wait as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rcu_sync),
            "::",
            stringify!(gp_wait)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rcu_sync>())).cb_head as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rcu_sync),
            "::",
            stringify!(cb_head)
        )
    );
}
impl Default for rcu_sync {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct percpu_rw_semaphore {
    pub rss: rcu_sync,
    pub read_count: *mut c_types::c_uint,
    pub rw_sem: rw_semaphore,
    pub writer: rcuwait,
    pub readers_block: c_types::c_int,
}
#[test]
fn bindgen_test_layout_percpu_rw_semaphore() {
    assert_eq!(
        ::core::mem::size_of::<percpu_rw_semaphore>(),
        112usize,
        concat!("Size of: ", stringify!(percpu_rw_semaphore))
    );
    assert_eq!(
        ::core::mem::align_of::<percpu_rw_semaphore>(),
        8usize,
        concat!("Alignment of ", stringify!(percpu_rw_semaphore))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<percpu_rw_semaphore>())).rss as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(percpu_rw_semaphore),
            "::",
            stringify!(rss)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<percpu_rw_semaphore>())).read_count as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(percpu_rw_semaphore),
            "::",
            stringify!(read_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<percpu_rw_semaphore>())).rw_sem as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(percpu_rw_semaphore),
            "::",
            stringify!(rw_sem)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<percpu_rw_semaphore>())).writer as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(percpu_rw_semaphore),
            "::",
            stringify!(writer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<percpu_rw_semaphore>())).readers_block as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(percpu_rw_semaphore),
            "::",
            stringify!(readers_block)
        )
    );
}
impl Default for percpu_rw_semaphore {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct delayed_call {
    pub fn_: ::core::option::Option<unsafe extern "C" fn(arg1: *mut c_types::c_void)>,
    pub arg: *mut c_types::c_void,
}
#[test]
fn bindgen_test_layout_delayed_call() {
    assert_eq!(
        ::core::mem::size_of::<delayed_call>(),
        16usize,
        concat!("Size of: ", stringify!(delayed_call))
    );
    assert_eq!(
        ::core::mem::align_of::<delayed_call>(),
        8usize,
        concat!("Alignment of ", stringify!(delayed_call))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<delayed_call>())).fn_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(delayed_call),
            "::",
            stringify!(fn_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<delayed_call>())).arg as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(delayed_call),
            "::",
            stringify!(arg)
        )
    );
}
impl Default for delayed_call {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct uuid_t {
    pub b: [__u8; 16usize],
}
#[test]
fn bindgen_test_layout_uuid_t() {
    assert_eq!(
        ::core::mem::size_of::<uuid_t>(),
        16usize,
        concat!("Size of: ", stringify!(uuid_t))
    );
    assert_eq!(
        ::core::mem::align_of::<uuid_t>(),
        1usize,
        concat!("Alignment of ", stringify!(uuid_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<uuid_t>())).b as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(uuid_t), "::", stringify!(b))
    );
}
pub type errseq_t = u32_;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct io_cq {
    pub q: *mut request_queue,
    pub ioc: *mut io_context,
    pub __bindgen_anon_1: io_cq__bindgen_ty_1,
    pub __bindgen_anon_2: io_cq__bindgen_ty_2,
    pub flags: c_types::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union io_cq__bindgen_ty_1 {
    pub q_node: list_head,
    pub __rcu_icq_cache: *mut kmem_cache,
    _bindgen_union_align: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_io_cq__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<io_cq__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(io_cq__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<io_cq__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(io_cq__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<io_cq__bindgen_ty_1>())).q_node as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(io_cq__bindgen_ty_1),
            "::",
            stringify!(q_node)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<io_cq__bindgen_ty_1>())).__rcu_icq_cache as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(io_cq__bindgen_ty_1),
            "::",
            stringify!(__rcu_icq_cache)
        )
    );
}
impl Default for io_cq__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union io_cq__bindgen_ty_2 {
    pub ioc_node: hlist_node,
    pub __rcu_head: callback_head,
    _bindgen_union_align: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_io_cq__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<io_cq__bindgen_ty_2>(),
        16usize,
        concat!("Size of: ", stringify!(io_cq__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<io_cq__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(io_cq__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<io_cq__bindgen_ty_2>())).ioc_node as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(io_cq__bindgen_ty_2),
            "::",
            stringify!(ioc_node)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<io_cq__bindgen_ty_2>())).__rcu_head as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(io_cq__bindgen_ty_2),
            "::",
            stringify!(__rcu_head)
        )
    );
}
impl Default for io_cq__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_io_cq() {
    assert_eq!(
        ::core::mem::size_of::<io_cq>(),
        56usize,
        concat!("Size of: ", stringify!(io_cq))
    );
    assert_eq!(
        ::core::mem::align_of::<io_cq>(),
        8usize,
        concat!("Alignment of ", stringify!(io_cq))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<io_cq>())).q as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(io_cq), "::", stringify!(q))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<io_cq>())).ioc as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(io_cq),
            "::",
            stringify!(ioc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<io_cq>())).flags as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(io_cq),
            "::",
            stringify!(flags)
        )
    );
}
impl Default for io_cq {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct io_context {
    pub refcount: atomic_long_t,
    pub active_ref: atomic_t,
    pub nr_tasks: atomic_t,
    pub lock: spinlock_t,
    pub ioprio: c_types::c_ushort,
    pub nr_batch_requests: c_types::c_int,
    pub last_waited: c_types::c_ulong,
    pub icq_tree: xarray,
    pub icq_hint: *mut io_cq,
    pub icq_list: hlist_head,
    pub release_work: work_struct,
}
#[test]
fn bindgen_test_layout_io_context() {
    assert_eq!(
        ::core::mem::size_of::<io_context>(),
        104usize,
        concat!("Size of: ", stringify!(io_context))
    );
    assert_eq!(
        ::core::mem::align_of::<io_context>(),
        8usize,
        concat!("Alignment of ", stringify!(io_context))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<io_context>())).refcount as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(io_context),
            "::",
            stringify!(refcount)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<io_context>())).active_ref as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(io_context),
            "::",
            stringify!(active_ref)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<io_context>())).nr_tasks as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(io_context),
            "::",
            stringify!(nr_tasks)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<io_context>())).lock as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(io_context),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<io_context>())).ioprio as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(io_context),
            "::",
            stringify!(ioprio)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<io_context>())).nr_batch_requests as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(io_context),
            "::",
            stringify!(nr_batch_requests)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<io_context>())).last_waited as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(io_context),
            "::",
            stringify!(last_waited)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<io_context>())).icq_tree as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(io_context),
            "::",
            stringify!(icq_tree)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<io_context>())).icq_hint as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(io_context),
            "::",
            stringify!(icq_hint)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<io_context>())).icq_list as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(io_context),
            "::",
            stringify!(icq_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<io_context>())).release_work as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(io_context),
            "::",
            stringify!(release_work)
        )
    );
}
impl Default for io_context {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct export_operations {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hd_geometry {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kstatfs {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct swap_info_struct {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fscrypt_info {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fscrypt_operations {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fsverity_info {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fsverity_operations {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fs_context {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fs_parameter_description {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iattr {
    pub ia_valid: c_types::c_uint,
    pub ia_mode: umode_t,
    pub ia_uid: kuid_t,
    pub ia_gid: kgid_t,
    pub ia_size: loff_t,
    pub ia_atime: timespec64,
    pub ia_mtime: timespec64,
    pub ia_ctime: timespec64,
    pub ia_file: *mut file,
}
#[test]
fn bindgen_test_layout_iattr() {
    assert_eq!(
        ::core::mem::size_of::<iattr>(),
        80usize,
        concat!("Size of: ", stringify!(iattr))
    );
    assert_eq!(
        ::core::mem::align_of::<iattr>(),
        8usize,
        concat!("Alignment of ", stringify!(iattr))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<iattr>())).ia_valid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(iattr),
            "::",
            stringify!(ia_valid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<iattr>())).ia_mode as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(iattr),
            "::",
            stringify!(ia_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<iattr>())).ia_uid as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(iattr),
            "::",
            stringify!(ia_uid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<iattr>())).ia_gid as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(iattr),
            "::",
            stringify!(ia_gid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<iattr>())).ia_size as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(iattr),
            "::",
            stringify!(ia_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<iattr>())).ia_atime as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(iattr),
            "::",
            stringify!(ia_atime)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<iattr>())).ia_mtime as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(iattr),
            "::",
            stringify!(ia_mtime)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<iattr>())).ia_ctime as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(iattr),
            "::",
            stringify!(ia_ctime)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<iattr>())).ia_file as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(iattr),
            "::",
            stringify!(ia_file)
        )
    );
}
impl Default for iattr {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct percpu_counter {
    pub lock: raw_spinlock_t,
    pub count: s64,
    pub list: list_head,
    pub counters: *mut s32,
}
#[test]
fn bindgen_test_layout_percpu_counter() {
    assert_eq!(
        ::core::mem::size_of::<percpu_counter>(),
        40usize,
        concat!("Size of: ", stringify!(percpu_counter))
    );
    assert_eq!(
        ::core::mem::align_of::<percpu_counter>(),
        8usize,
        concat!("Alignment of ", stringify!(percpu_counter))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<percpu_counter>())).lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(percpu_counter),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<percpu_counter>())).count as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(percpu_counter),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<percpu_counter>())).list as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(percpu_counter),
            "::",
            stringify!(list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<percpu_counter>())).counters as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(percpu_counter),
            "::",
            stringify!(counters)
        )
    );
}
impl Default for percpu_counter {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type projid_t = __kernel_uid32_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kprojid_t {
    pub val: projid_t,
}
#[test]
fn bindgen_test_layout_kprojid_t() {
    assert_eq!(
        ::core::mem::size_of::<kprojid_t>(),
        4usize,
        concat!("Size of: ", stringify!(kprojid_t))
    );
    assert_eq!(
        ::core::mem::align_of::<kprojid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(kprojid_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kprojid_t>())).val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kprojid_t),
            "::",
            stringify!(val)
        )
    );
}
pub const quota_type_USRQUOTA: quota_type = 0;
pub const quota_type_GRPQUOTA: quota_type = 1;
pub const quota_type_PRJQUOTA: quota_type = 2;
pub type quota_type = c_types::c_uint;
pub type qsize_t = c_types::c_longlong;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kqid {
    pub __bindgen_anon_1: kqid__bindgen_ty_1,
    pub type_: quota_type,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union kqid__bindgen_ty_1 {
    pub uid: kuid_t,
    pub gid: kgid_t,
    pub projid: kprojid_t,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_kqid__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<kqid__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(kqid__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<kqid__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(kqid__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kqid__bindgen_ty_1>())).uid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kqid__bindgen_ty_1),
            "::",
            stringify!(uid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kqid__bindgen_ty_1>())).gid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kqid__bindgen_ty_1),
            "::",
            stringify!(gid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kqid__bindgen_ty_1>())).projid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kqid__bindgen_ty_1),
            "::",
            stringify!(projid)
        )
    );
}
impl Default for kqid__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_kqid() {
    assert_eq!(
        ::core::mem::size_of::<kqid>(),
        8usize,
        concat!("Size of: ", stringify!(kqid))
    );
    assert_eq!(
        ::core::mem::align_of::<kqid>(),
        4usize,
        concat!("Alignment of ", stringify!(kqid))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kqid>())).type_ as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(kqid),
            "::",
            stringify!(type_)
        )
    );
}
impl Default for kqid {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct mem_dqblk {
    pub dqb_bhardlimit: qsize_t,
    pub dqb_bsoftlimit: qsize_t,
    pub dqb_curspace: qsize_t,
    pub dqb_rsvspace: qsize_t,
    pub dqb_ihardlimit: qsize_t,
    pub dqb_isoftlimit: qsize_t,
    pub dqb_curinodes: qsize_t,
    pub dqb_btime: time64_t,
    pub dqb_itime: time64_t,
}
#[test]
fn bindgen_test_layout_mem_dqblk() {
    assert_eq!(
        ::core::mem::size_of::<mem_dqblk>(),
        72usize,
        concat!("Size of: ", stringify!(mem_dqblk))
    );
    assert_eq!(
        ::core::mem::align_of::<mem_dqblk>(),
        8usize,
        concat!("Alignment of ", stringify!(mem_dqblk))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mem_dqblk>())).dqb_bhardlimit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_dqblk),
            "::",
            stringify!(dqb_bhardlimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mem_dqblk>())).dqb_bsoftlimit as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_dqblk),
            "::",
            stringify!(dqb_bsoftlimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mem_dqblk>())).dqb_curspace as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_dqblk),
            "::",
            stringify!(dqb_curspace)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mem_dqblk>())).dqb_rsvspace as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_dqblk),
            "::",
            stringify!(dqb_rsvspace)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mem_dqblk>())).dqb_ihardlimit as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_dqblk),
            "::",
            stringify!(dqb_ihardlimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mem_dqblk>())).dqb_isoftlimit as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_dqblk),
            "::",
            stringify!(dqb_isoftlimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mem_dqblk>())).dqb_curinodes as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_dqblk),
            "::",
            stringify!(dqb_curinodes)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mem_dqblk>())).dqb_btime as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_dqblk),
            "::",
            stringify!(dqb_btime)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mem_dqblk>())).dqb_itime as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_dqblk),
            "::",
            stringify!(dqb_itime)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mem_dqinfo {
    pub dqi_format: *mut quota_format_type,
    pub dqi_fmt_id: c_types::c_int,
    pub dqi_dirty_list: list_head,
    pub dqi_flags: c_types::c_ulong,
    pub dqi_bgrace: c_types::c_uint,
    pub dqi_igrace: c_types::c_uint,
    pub dqi_max_spc_limit: qsize_t,
    pub dqi_max_ino_limit: qsize_t,
    pub dqi_priv: *mut c_types::c_void,
}
#[test]
fn bindgen_test_layout_mem_dqinfo() {
    assert_eq!(
        ::core::mem::size_of::<mem_dqinfo>(),
        72usize,
        concat!("Size of: ", stringify!(mem_dqinfo))
    );
    assert_eq!(
        ::core::mem::align_of::<mem_dqinfo>(),
        8usize,
        concat!("Alignment of ", stringify!(mem_dqinfo))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mem_dqinfo>())).dqi_format as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_dqinfo),
            "::",
            stringify!(dqi_format)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mem_dqinfo>())).dqi_fmt_id as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_dqinfo),
            "::",
            stringify!(dqi_fmt_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mem_dqinfo>())).dqi_dirty_list as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_dqinfo),
            "::",
            stringify!(dqi_dirty_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mem_dqinfo>())).dqi_flags as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_dqinfo),
            "::",
            stringify!(dqi_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mem_dqinfo>())).dqi_bgrace as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_dqinfo),
            "::",
            stringify!(dqi_bgrace)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mem_dqinfo>())).dqi_igrace as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_dqinfo),
            "::",
            stringify!(dqi_igrace)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mem_dqinfo>())).dqi_max_spc_limit as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_dqinfo),
            "::",
            stringify!(dqi_max_spc_limit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mem_dqinfo>())).dqi_max_ino_limit as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_dqinfo),
            "::",
            stringify!(dqi_max_ino_limit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mem_dqinfo>())).dqi_priv as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_dqinfo),
            "::",
            stringify!(dqi_priv)
        )
    );
}
impl Default for mem_dqinfo {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct dquot {
    pub dq_hash: hlist_node,
    pub dq_inuse: list_head,
    pub dq_free: list_head,
    pub dq_dirty: list_head,
    pub dq_lock: mutex,
    pub dq_dqb_lock: spinlock_t,
    pub dq_count: atomic_t,
    pub dq_sb: *mut super_block,
    pub dq_id: kqid,
    pub dq_off: loff_t,
    pub dq_flags: c_types::c_ulong,
    pub dq_dqb: mem_dqblk,
}
#[test]
fn bindgen_test_layout_dquot() {
    assert_eq!(
        ::core::mem::size_of::<dquot>(),
        208usize,
        concat!("Size of: ", stringify!(dquot))
    );
    assert_eq!(
        ::core::mem::align_of::<dquot>(),
        8usize,
        concat!("Alignment of ", stringify!(dquot))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dquot>())).dq_hash as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dquot),
            "::",
            stringify!(dq_hash)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dquot>())).dq_inuse as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(dquot),
            "::",
            stringify!(dq_inuse)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dquot>())).dq_free as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(dquot),
            "::",
            stringify!(dq_free)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dquot>())).dq_dirty as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(dquot),
            "::",
            stringify!(dq_dirty)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dquot>())).dq_lock as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(dquot),
            "::",
            stringify!(dq_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dquot>())).dq_dqb_lock as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(dquot),
            "::",
            stringify!(dq_dqb_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dquot>())).dq_count as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(dquot),
            "::",
            stringify!(dq_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dquot>())).dq_sb as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(dquot),
            "::",
            stringify!(dq_sb)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dquot>())).dq_id as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(dquot),
            "::",
            stringify!(dq_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dquot>())).dq_off as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(dquot),
            "::",
            stringify!(dq_off)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dquot>())).dq_flags as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(dquot),
            "::",
            stringify!(dq_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dquot>())).dq_dqb as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(dquot),
            "::",
            stringify!(dq_dqb)
        )
    );
}
impl Default for dquot {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct quota_format_ops {
    pub check_quota_file: ::core::option::Option<
        unsafe extern "C" fn(sb: *mut super_block, type_: c_types::c_int) -> c_types::c_int,
    >,
    pub read_file_info: ::core::option::Option<
        unsafe extern "C" fn(sb: *mut super_block, type_: c_types::c_int) -> c_types::c_int,
    >,
    pub write_file_info: ::core::option::Option<
        unsafe extern "C" fn(sb: *mut super_block, type_: c_types::c_int) -> c_types::c_int,
    >,
    pub free_file_info: ::core::option::Option<
        unsafe extern "C" fn(sb: *mut super_block, type_: c_types::c_int) -> c_types::c_int,
    >,
    pub read_dqblk:
        ::core::option::Option<unsafe extern "C" fn(dquot: *mut dquot) -> c_types::c_int>,
    pub commit_dqblk:
        ::core::option::Option<unsafe extern "C" fn(dquot: *mut dquot) -> c_types::c_int>,
    pub release_dqblk:
        ::core::option::Option<unsafe extern "C" fn(dquot: *mut dquot) -> c_types::c_int>,
    pub get_next_id: ::core::option::Option<
        unsafe extern "C" fn(sb: *mut super_block, qid: *mut kqid) -> c_types::c_int,
    >,
}
#[test]
fn bindgen_test_layout_quota_format_ops() {
    assert_eq!(
        ::core::mem::size_of::<quota_format_ops>(),
        64usize,
        concat!("Size of: ", stringify!(quota_format_ops))
    );
    assert_eq!(
        ::core::mem::align_of::<quota_format_ops>(),
        8usize,
        concat!("Alignment of ", stringify!(quota_format_ops))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<quota_format_ops>())).check_quota_file as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(quota_format_ops),
            "::",
            stringify!(check_quota_file)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<quota_format_ops>())).read_file_info as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(quota_format_ops),
            "::",
            stringify!(read_file_info)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<quota_format_ops>())).write_file_info as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(quota_format_ops),
            "::",
            stringify!(write_file_info)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<quota_format_ops>())).free_file_info as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(quota_format_ops),
            "::",
            stringify!(free_file_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<quota_format_ops>())).read_dqblk as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(quota_format_ops),
            "::",
            stringify!(read_dqblk)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<quota_format_ops>())).commit_dqblk as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(quota_format_ops),
            "::",
            stringify!(commit_dqblk)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<quota_format_ops>())).release_dqblk as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(quota_format_ops),
            "::",
            stringify!(release_dqblk)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<quota_format_ops>())).get_next_id as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(quota_format_ops),
            "::",
            stringify!(get_next_id)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct dquot_operations {
    pub write_dquot:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut dquot) -> c_types::c_int>,
    pub alloc_dquot: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut super_block, arg2: c_types::c_int) -> *mut dquot,
    >,
    pub destroy_dquot: ::core::option::Option<unsafe extern "C" fn(arg1: *mut dquot)>,
    pub acquire_dquot:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut dquot) -> c_types::c_int>,
    pub release_dquot:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut dquot) -> c_types::c_int>,
    pub mark_dirty:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut dquot) -> c_types::c_int>,
    pub write_info: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut super_block, arg2: c_types::c_int) -> c_types::c_int,
    >,
    pub get_reserved_space:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut inode) -> *mut qsize_t>,
    pub get_projid: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut inode, arg2: *mut kprojid_t) -> c_types::c_int,
    >,
    pub get_inode_usage: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut inode, arg2: *mut qsize_t) -> c_types::c_int,
    >,
    pub get_next_id: ::core::option::Option<
        unsafe extern "C" fn(sb: *mut super_block, qid: *mut kqid) -> c_types::c_int,
    >,
}
#[test]
fn bindgen_test_layout_dquot_operations() {
    assert_eq!(
        ::core::mem::size_of::<dquot_operations>(),
        88usize,
        concat!("Size of: ", stringify!(dquot_operations))
    );
    assert_eq!(
        ::core::mem::align_of::<dquot_operations>(),
        8usize,
        concat!("Alignment of ", stringify!(dquot_operations))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dquot_operations>())).write_dquot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dquot_operations),
            "::",
            stringify!(write_dquot)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dquot_operations>())).alloc_dquot as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(dquot_operations),
            "::",
            stringify!(alloc_dquot)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dquot_operations>())).destroy_dquot as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(dquot_operations),
            "::",
            stringify!(destroy_dquot)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dquot_operations>())).acquire_dquot as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(dquot_operations),
            "::",
            stringify!(acquire_dquot)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dquot_operations>())).release_dquot as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(dquot_operations),
            "::",
            stringify!(release_dquot)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dquot_operations>())).mark_dirty as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(dquot_operations),
            "::",
            stringify!(mark_dirty)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dquot_operations>())).write_info as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(dquot_operations),
            "::",
            stringify!(write_info)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<dquot_operations>())).get_reserved_space as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(dquot_operations),
            "::",
            stringify!(get_reserved_space)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dquot_operations>())).get_projid as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(dquot_operations),
            "::",
            stringify!(get_projid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<dquot_operations>())).get_inode_usage as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(dquot_operations),
            "::",
            stringify!(get_inode_usage)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dquot_operations>())).get_next_id as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(dquot_operations),
            "::",
            stringify!(get_next_id)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct qc_dqblk {
    pub d_fieldmask: c_types::c_int,
    pub d_spc_hardlimit: u64_,
    pub d_spc_softlimit: u64_,
    pub d_ino_hardlimit: u64_,
    pub d_ino_softlimit: u64_,
    pub d_space: u64_,
    pub d_ino_count: u64_,
    pub d_ino_timer: s64,
    pub d_spc_timer: s64,
    pub d_ino_warns: c_types::c_int,
    pub d_spc_warns: c_types::c_int,
    pub d_rt_spc_hardlimit: u64_,
    pub d_rt_spc_softlimit: u64_,
    pub d_rt_space: u64_,
    pub d_rt_spc_timer: s64,
    pub d_rt_spc_warns: c_types::c_int,
}
#[test]
fn bindgen_test_layout_qc_dqblk() {
    assert_eq!(
        ::core::mem::size_of::<qc_dqblk>(),
        120usize,
        concat!("Size of: ", stringify!(qc_dqblk))
    );
    assert_eq!(
        ::core::mem::align_of::<qc_dqblk>(),
        8usize,
        concat!("Alignment of ", stringify!(qc_dqblk))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<qc_dqblk>())).d_fieldmask as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qc_dqblk),
            "::",
            stringify!(d_fieldmask)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<qc_dqblk>())).d_spc_hardlimit as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(qc_dqblk),
            "::",
            stringify!(d_spc_hardlimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<qc_dqblk>())).d_spc_softlimit as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(qc_dqblk),
            "::",
            stringify!(d_spc_softlimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<qc_dqblk>())).d_ino_hardlimit as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(qc_dqblk),
            "::",
            stringify!(d_ino_hardlimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<qc_dqblk>())).d_ino_softlimit as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(qc_dqblk),
            "::",
            stringify!(d_ino_softlimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<qc_dqblk>())).d_space as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(qc_dqblk),
            "::",
            stringify!(d_space)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<qc_dqblk>())).d_ino_count as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(qc_dqblk),
            "::",
            stringify!(d_ino_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<qc_dqblk>())).d_ino_timer as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(qc_dqblk),
            "::",
            stringify!(d_ino_timer)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<qc_dqblk>())).d_spc_timer as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(qc_dqblk),
            "::",
            stringify!(d_spc_timer)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<qc_dqblk>())).d_ino_warns as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(qc_dqblk),
            "::",
            stringify!(d_ino_warns)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<qc_dqblk>())).d_spc_warns as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(qc_dqblk),
            "::",
            stringify!(d_spc_warns)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<qc_dqblk>())).d_rt_spc_hardlimit as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(qc_dqblk),
            "::",
            stringify!(d_rt_spc_hardlimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<qc_dqblk>())).d_rt_spc_softlimit as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(qc_dqblk),
            "::",
            stringify!(d_rt_spc_softlimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<qc_dqblk>())).d_rt_space as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(qc_dqblk),
            "::",
            stringify!(d_rt_space)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<qc_dqblk>())).d_rt_spc_timer as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(qc_dqblk),
            "::",
            stringify!(d_rt_spc_timer)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<qc_dqblk>())).d_rt_spc_warns as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(qc_dqblk),
            "::",
            stringify!(d_rt_spc_warns)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct qc_type_state {
    pub flags: c_types::c_uint,
    pub spc_timelimit: c_types::c_uint,
    pub ino_timelimit: c_types::c_uint,
    pub rt_spc_timelimit: c_types::c_uint,
    pub spc_warnlimit: c_types::c_uint,
    pub ino_warnlimit: c_types::c_uint,
    pub rt_spc_warnlimit: c_types::c_uint,
    pub ino: c_types::c_ulonglong,
    pub blocks: blkcnt_t,
    pub nextents: blkcnt_t,
}
#[test]
fn bindgen_test_layout_qc_type_state() {
    assert_eq!(
        ::core::mem::size_of::<qc_type_state>(),
        56usize,
        concat!("Size of: ", stringify!(qc_type_state))
    );
    assert_eq!(
        ::core::mem::align_of::<qc_type_state>(),
        8usize,
        concat!("Alignment of ", stringify!(qc_type_state))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<qc_type_state>())).flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qc_type_state),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<qc_type_state>())).spc_timelimit as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(qc_type_state),
            "::",
            stringify!(spc_timelimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<qc_type_state>())).ino_timelimit as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(qc_type_state),
            "::",
            stringify!(ino_timelimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<qc_type_state>())).rt_spc_timelimit as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(qc_type_state),
            "::",
            stringify!(rt_spc_timelimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<qc_type_state>())).spc_warnlimit as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(qc_type_state),
            "::",
            stringify!(spc_warnlimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<qc_type_state>())).ino_warnlimit as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(qc_type_state),
            "::",
            stringify!(ino_warnlimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<qc_type_state>())).rt_spc_warnlimit as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(qc_type_state),
            "::",
            stringify!(rt_spc_warnlimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<qc_type_state>())).ino as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(qc_type_state),
            "::",
            stringify!(ino)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<qc_type_state>())).blocks as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(qc_type_state),
            "::",
            stringify!(blocks)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<qc_type_state>())).nextents as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(qc_type_state),
            "::",
            stringify!(nextents)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct qc_state {
    pub s_incoredqs: c_types::c_uint,
    pub s_state: [qc_type_state; 3usize],
}
#[test]
fn bindgen_test_layout_qc_state() {
    assert_eq!(
        ::core::mem::size_of::<qc_state>(),
        176usize,
        concat!("Size of: ", stringify!(qc_state))
    );
    assert_eq!(
        ::core::mem::align_of::<qc_state>(),
        8usize,
        concat!("Alignment of ", stringify!(qc_state))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<qc_state>())).s_incoredqs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qc_state),
            "::",
            stringify!(s_incoredqs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<qc_state>())).s_state as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(qc_state),
            "::",
            stringify!(s_state)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct qc_info {
    pub i_fieldmask: c_types::c_int,
    pub i_flags: c_types::c_uint,
    pub i_spc_timelimit: c_types::c_uint,
    pub i_ino_timelimit: c_types::c_uint,
    pub i_rt_spc_timelimit: c_types::c_uint,
    pub i_spc_warnlimit: c_types::c_uint,
    pub i_ino_warnlimit: c_types::c_uint,
    pub i_rt_spc_warnlimit: c_types::c_uint,
}
#[test]
fn bindgen_test_layout_qc_info() {
    assert_eq!(
        ::core::mem::size_of::<qc_info>(),
        32usize,
        concat!("Size of: ", stringify!(qc_info))
    );
    assert_eq!(
        ::core::mem::align_of::<qc_info>(),
        4usize,
        concat!("Alignment of ", stringify!(qc_info))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<qc_info>())).i_fieldmask as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qc_info),
            "::",
            stringify!(i_fieldmask)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<qc_info>())).i_flags as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(qc_info),
            "::",
            stringify!(i_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<qc_info>())).i_spc_timelimit as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(qc_info),
            "::",
            stringify!(i_spc_timelimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<qc_info>())).i_ino_timelimit as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(qc_info),
            "::",
            stringify!(i_ino_timelimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<qc_info>())).i_rt_spc_timelimit as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(qc_info),
            "::",
            stringify!(i_rt_spc_timelimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<qc_info>())).i_spc_warnlimit as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(qc_info),
            "::",
            stringify!(i_spc_warnlimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<qc_info>())).i_ino_warnlimit as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(qc_info),
            "::",
            stringify!(i_ino_warnlimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<qc_info>())).i_rt_spc_warnlimit as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(qc_info),
            "::",
            stringify!(i_rt_spc_warnlimit)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct quotactl_ops {
    pub quota_on: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut super_block,
            arg2: c_types::c_int,
            arg3: c_types::c_int,
            arg4: *const path,
        ) -> c_types::c_int,
    >,
    pub quota_off: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut super_block, arg2: c_types::c_int) -> c_types::c_int,
    >,
    pub quota_enable: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut super_block, arg2: c_types::c_uint) -> c_types::c_int,
    >,
    pub quota_disable: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut super_block, arg2: c_types::c_uint) -> c_types::c_int,
    >,
    pub quota_sync: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut super_block, arg2: c_types::c_int) -> c_types::c_int,
    >,
    pub set_info: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut super_block,
            arg2: c_types::c_int,
            arg3: *mut qc_info,
        ) -> c_types::c_int,
    >,
    pub get_dqblk: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut super_block,
            arg2: kqid,
            arg3: *mut qc_dqblk,
        ) -> c_types::c_int,
    >,
    pub get_nextdqblk: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut super_block,
            arg2: *mut kqid,
            arg3: *mut qc_dqblk,
        ) -> c_types::c_int,
    >,
    pub set_dqblk: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut super_block,
            arg2: kqid,
            arg3: *mut qc_dqblk,
        ) -> c_types::c_int,
    >,
    pub get_state: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut super_block, arg2: *mut qc_state) -> c_types::c_int,
    >,
    pub rm_xquota: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut super_block, arg2: c_types::c_uint) -> c_types::c_int,
    >,
}
#[test]
fn bindgen_test_layout_quotactl_ops() {
    assert_eq!(
        ::core::mem::size_of::<quotactl_ops>(),
        88usize,
        concat!("Size of: ", stringify!(quotactl_ops))
    );
    assert_eq!(
        ::core::mem::align_of::<quotactl_ops>(),
        8usize,
        concat!("Alignment of ", stringify!(quotactl_ops))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<quotactl_ops>())).quota_on as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(quotactl_ops),
            "::",
            stringify!(quota_on)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<quotactl_ops>())).quota_off as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(quotactl_ops),
            "::",
            stringify!(quota_off)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<quotactl_ops>())).quota_enable as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(quotactl_ops),
            "::",
            stringify!(quota_enable)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<quotactl_ops>())).quota_disable as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(quotactl_ops),
            "::",
            stringify!(quota_disable)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<quotactl_ops>())).quota_sync as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(quotactl_ops),
            "::",
            stringify!(quota_sync)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<quotactl_ops>())).set_info as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(quotactl_ops),
            "::",
            stringify!(set_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<quotactl_ops>())).get_dqblk as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(quotactl_ops),
            "::",
            stringify!(get_dqblk)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<quotactl_ops>())).get_nextdqblk as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(quotactl_ops),
            "::",
            stringify!(get_nextdqblk)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<quotactl_ops>())).set_dqblk as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(quotactl_ops),
            "::",
            stringify!(set_dqblk)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<quotactl_ops>())).get_state as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(quotactl_ops),
            "::",
            stringify!(get_state)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<quotactl_ops>())).rm_xquota as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(quotactl_ops),
            "::",
            stringify!(rm_xquota)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct quota_format_type {
    pub qf_fmt_id: c_types::c_int,
    pub qf_ops: *const quota_format_ops,
    pub qf_owner: *mut module,
    pub qf_next: *mut quota_format_type,
}
#[test]
fn bindgen_test_layout_quota_format_type() {
    assert_eq!(
        ::core::mem::size_of::<quota_format_type>(),
        32usize,
        concat!("Size of: ", stringify!(quota_format_type))
    );
    assert_eq!(
        ::core::mem::align_of::<quota_format_type>(),
        8usize,
        concat!("Alignment of ", stringify!(quota_format_type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<quota_format_type>())).qf_fmt_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(quota_format_type),
            "::",
            stringify!(qf_fmt_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<quota_format_type>())).qf_ops as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(quota_format_type),
            "::",
            stringify!(qf_ops)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<quota_format_type>())).qf_owner as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(quota_format_type),
            "::",
            stringify!(qf_owner)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<quota_format_type>())).qf_next as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(quota_format_type),
            "::",
            stringify!(qf_next)
        )
    );
}
impl Default for quota_format_type {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct quota_info {
    pub flags: c_types::c_uint,
    pub dqio_sem: rw_semaphore,
    pub files: [*mut inode; 3usize],
    pub info: [mem_dqinfo; 3usize],
    pub ops: [*const quota_format_ops; 3usize],
}
#[test]
fn bindgen_test_layout_quota_info() {
    assert_eq!(
        ::core::mem::size_of::<quota_info>(),
        312usize,
        concat!("Size of: ", stringify!(quota_info))
    );
    assert_eq!(
        ::core::mem::align_of::<quota_info>(),
        8usize,
        concat!("Alignment of ", stringify!(quota_info))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<quota_info>())).flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(quota_info),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<quota_info>())).dqio_sem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(quota_info),
            "::",
            stringify!(dqio_sem)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<quota_info>())).files as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(quota_info),
            "::",
            stringify!(files)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<quota_info>())).info as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(quota_info),
            "::",
            stringify!(info)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<quota_info>())).ops as *const _ as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(quota_info),
            "::",
            stringify!(ops)
        )
    );
}
impl Default for quota_info {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub const rw_hint_WRITE_LIFE_NOT_SET: rw_hint = 0;
pub const rw_hint_WRITE_LIFE_NONE: rw_hint = 1;
pub const rw_hint_WRITE_LIFE_SHORT: rw_hint = 2;
pub const rw_hint_WRITE_LIFE_MEDIUM: rw_hint = 3;
pub const rw_hint_WRITE_LIFE_LONG: rw_hint = 4;
pub const rw_hint_WRITE_LIFE_EXTREME: rw_hint = 5;
pub type rw_hint = c_types::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kiocb {
    pub ki_filp: *mut file,
    pub ki_pos: loff_t,
    pub ki_complete: ::core::option::Option<
        unsafe extern "C" fn(iocb: *mut kiocb, ret: c_types::c_long, ret2: c_types::c_long),
    >,
    pub private: *mut c_types::c_void,
    pub ki_flags: c_types::c_int,
    pub ki_hint: u16_,
    pub ki_ioprio: u16_,
    pub ki_cookie: c_types::c_uint,
}
#[test]
fn bindgen_test_layout_kiocb() {
    assert_eq!(
        ::core::mem::size_of::<kiocb>(),
        48usize,
        concat!("Size of: ", stringify!(kiocb))
    );
    assert_eq!(
        ::core::mem::align_of::<kiocb>(),
        8usize,
        concat!("Alignment of ", stringify!(kiocb))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kiocb>())).ki_filp as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kiocb),
            "::",
            stringify!(ki_filp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kiocb>())).ki_pos as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(kiocb),
            "::",
            stringify!(ki_pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kiocb>())).ki_complete as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(kiocb),
            "::",
            stringify!(ki_complete)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kiocb>())).private as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(kiocb),
            "::",
            stringify!(private)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kiocb>())).ki_flags as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(kiocb),
            "::",
            stringify!(ki_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kiocb>())).ki_hint as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(kiocb),
            "::",
            stringify!(ki_hint)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kiocb>())).ki_ioprio as *const _ as usize },
        38usize,
        concat!(
            "Offset of field: ",
            stringify!(kiocb),
            "::",
            stringify!(ki_ioprio)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kiocb>())).ki_cookie as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(kiocb),
            "::",
            stringify!(ki_cookie)
        )
    );
}
impl Default for kiocb {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct read_descriptor_t {
    pub written: usize,
    pub count: usize,
    pub arg: read_descriptor_t__bindgen_ty_1,
    pub error: c_types::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union read_descriptor_t__bindgen_ty_1 {
    pub buf: *mut c_types::c_char,
    pub data: *mut c_types::c_void,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_read_descriptor_t__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<read_descriptor_t__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(read_descriptor_t__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<read_descriptor_t__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(read_descriptor_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<read_descriptor_t__bindgen_ty_1>())).buf as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(read_descriptor_t__bindgen_ty_1),
            "::",
            stringify!(buf)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<read_descriptor_t__bindgen_ty_1>())).data as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(read_descriptor_t__bindgen_ty_1),
            "::",
            stringify!(data)
        )
    );
}
impl Default for read_descriptor_t__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_read_descriptor_t() {
    assert_eq!(
        ::core::mem::size_of::<read_descriptor_t>(),
        32usize,
        concat!("Size of: ", stringify!(read_descriptor_t))
    );
    assert_eq!(
        ::core::mem::align_of::<read_descriptor_t>(),
        8usize,
        concat!("Alignment of ", stringify!(read_descriptor_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<read_descriptor_t>())).written as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(read_descriptor_t),
            "::",
            stringify!(written)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<read_descriptor_t>())).count as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(read_descriptor_t),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<read_descriptor_t>())).arg as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(read_descriptor_t),
            "::",
            stringify!(arg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<read_descriptor_t>())).error as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(read_descriptor_t),
            "::",
            stringify!(error)
        )
    );
}
impl Default for read_descriptor_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct address_space_operations {
    pub writepage: ::core::option::Option<
        unsafe extern "C" fn(page: *mut page, wbc: *mut writeback_control) -> c_types::c_int,
    >,
    pub readpage: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut file, arg2: *mut page) -> c_types::c_int,
    >,
    pub writepages: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut address_space,
            arg2: *mut writeback_control,
        ) -> c_types::c_int,
    >,
    pub set_page_dirty:
        ::core::option::Option<unsafe extern "C" fn(page: *mut page) -> c_types::c_int>,
    pub readpages: ::core::option::Option<
        unsafe extern "C" fn(
            filp: *mut file,
            mapping: *mut address_space,
            pages: *mut list_head,
            nr_pages: c_types::c_uint,
        ) -> c_types::c_int,
    >,
    pub write_begin: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            mapping: *mut address_space,
            pos: loff_t,
            len: c_types::c_uint,
            flags: c_types::c_uint,
            pagep: *mut *mut page,
            fsdata: *mut *mut c_types::c_void,
        ) -> c_types::c_int,
    >,
    pub write_end: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            mapping: *mut address_space,
            pos: loff_t,
            len: c_types::c_uint,
            copied: c_types::c_uint,
            page: *mut page,
            fsdata: *mut c_types::c_void,
        ) -> c_types::c_int,
    >,
    pub bmap: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut address_space, arg2: sector_t) -> sector_t,
    >,
    pub invalidatepage: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut page, arg2: c_types::c_uint, arg3: c_types::c_uint),
    >,
    pub releasepage: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut page, arg2: gfp_t) -> c_types::c_int,
    >,
    pub freepage: ::core::option::Option<unsafe extern "C" fn(arg1: *mut page)>,
    pub direct_IO: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut kiocb, iter: *mut iov_iter) -> isize,
    >,
    pub migratepage: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut address_space,
            arg2: *mut page,
            arg3: *mut page,
            arg4: migrate_mode,
        ) -> c_types::c_int,
    >,
    pub isolate_page: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut page, arg2: isolate_mode_t) -> bool_,
    >,
    pub putback_page: ::core::option::Option<unsafe extern "C" fn(arg1: *mut page)>,
    pub launder_page:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut page) -> c_types::c_int>,
    pub is_partially_uptodate: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut page,
            arg2: c_types::c_ulong,
            arg3: c_types::c_ulong,
        ) -> c_types::c_int,
    >,
    pub is_dirty_writeback: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut page, arg2: *mut bool_, arg3: *mut bool_),
    >,
    pub error_remove_page: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut address_space, arg2: *mut page) -> c_types::c_int,
    >,
    pub swap_activate: ::core::option::Option<
        unsafe extern "C" fn(
            sis: *mut swap_info_struct,
            file: *mut file,
            span: *mut sector_t,
        ) -> c_types::c_int,
    >,
    pub swap_deactivate: ::core::option::Option<unsafe extern "C" fn(file: *mut file)>,
}
#[test]
fn bindgen_test_layout_address_space_operations() {
    assert_eq!(
        ::core::mem::size_of::<address_space_operations>(),
        168usize,
        concat!("Size of: ", stringify!(address_space_operations))
    );
    assert_eq!(
        ::core::mem::align_of::<address_space_operations>(),
        8usize,
        concat!("Alignment of ", stringify!(address_space_operations))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<address_space_operations>())).writepage as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(address_space_operations),
            "::",
            stringify!(writepage)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<address_space_operations>())).readpage as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(address_space_operations),
            "::",
            stringify!(readpage)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<address_space_operations>())).writepages as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(address_space_operations),
            "::",
            stringify!(writepages)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<address_space_operations>())).set_page_dirty as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(address_space_operations),
            "::",
            stringify!(set_page_dirty)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<address_space_operations>())).readpages as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(address_space_operations),
            "::",
            stringify!(readpages)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<address_space_operations>())).write_begin as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(address_space_operations),
            "::",
            stringify!(write_begin)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<address_space_operations>())).write_end as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(address_space_operations),
            "::",
            stringify!(write_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<address_space_operations>())).bmap as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(address_space_operations),
            "::",
            stringify!(bmap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<address_space_operations>())).invalidatepage as *const _
                as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(address_space_operations),
            "::",
            stringify!(invalidatepage)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<address_space_operations>())).releasepage as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(address_space_operations),
            "::",
            stringify!(releasepage)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<address_space_operations>())).freepage as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(address_space_operations),
            "::",
            stringify!(freepage)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<address_space_operations>())).direct_IO as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(address_space_operations),
            "::",
            stringify!(direct_IO)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<address_space_operations>())).migratepage as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(address_space_operations),
            "::",
            stringify!(migratepage)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<address_space_operations>())).isolate_page as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(address_space_operations),
            "::",
            stringify!(isolate_page)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<address_space_operations>())).putback_page as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(address_space_operations),
            "::",
            stringify!(putback_page)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<address_space_operations>())).launder_page as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(address_space_operations),
            "::",
            stringify!(launder_page)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<address_space_operations>())).is_partially_uptodate as *const _
                as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(address_space_operations),
            "::",
            stringify!(is_partially_uptodate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<address_space_operations>())).is_dirty_writeback as *const _
                as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(address_space_operations),
            "::",
            stringify!(is_dirty_writeback)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<address_space_operations>())).error_remove_page as *const _
                as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(address_space_operations),
            "::",
            stringify!(error_remove_page)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<address_space_operations>())).swap_activate as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(address_space_operations),
            "::",
            stringify!(swap_activate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<address_space_operations>())).swap_deactivate as *const _
                as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(address_space_operations),
            "::",
            stringify!(swap_deactivate)
        )
    );
}
#[doc = " struct address_space - Contents of a cacheable, mappable object."]
#[doc = " @host: Owner, either the inode or the block_device."]
#[doc = " @i_pages: Cached pages."]
#[doc = " @gfp_mask: Memory allocation flags to use for allocating pages."]
#[doc = " @i_mmap_writable: Number of VM_SHARED mappings."]
#[doc = " @nr_thps: Number of THPs in the pagecache (non-shmem only)."]
#[doc = " @i_mmap: Tree of private and shared mappings."]
#[doc = " @i_mmap_rwsem: Protects @i_mmap and @i_mmap_writable."]
#[doc = " @nrpages: Number of page entries, protected by the i_pages lock."]
#[doc = " @nrexceptional: Shadow or DAX entries, protected by the i_pages lock."]
#[doc = " @writeback_index: Writeback starts here."]
#[doc = " @a_ops: Methods."]
#[doc = " @flags: Error bits and flags (AS_*)."]
#[doc = " @wb_err: The most recent error which has occurred."]
#[doc = " @private_lock: For use by the owner of the address_space."]
#[doc = " @private_list: For use by the owner of the address_space."]
#[doc = " @private_data: For use by the owner of the address_space."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct address_space {
    pub host: *mut inode,
    pub i_pages: xarray,
    pub gfp_mask: gfp_t,
    pub i_mmap_writable: atomic_t,
    pub i_mmap: rb_root_cached,
    pub i_mmap_rwsem: rw_semaphore,
    pub nrpages: c_types::c_ulong,
    pub nrexceptional: c_types::c_ulong,
    pub writeback_index: c_types::c_ulong,
    pub a_ops: *const address_space_operations,
    pub flags: c_types::c_ulong,
    pub wb_err: errseq_t,
    pub private_lock: spinlock_t,
    pub private_list: list_head,
    pub private_data: *mut c_types::c_void,
}
#[test]
fn bindgen_test_layout_address_space() {
    assert_eq!(
        ::core::mem::size_of::<address_space>(),
        160usize,
        concat!("Size of: ", stringify!(address_space))
    );
    assert_eq!(
        ::core::mem::align_of::<address_space>(),
        8usize,
        concat!("Alignment of ", stringify!(address_space))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<address_space>())).host as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(address_space),
            "::",
            stringify!(host)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<address_space>())).i_pages as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(address_space),
            "::",
            stringify!(i_pages)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<address_space>())).gfp_mask as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(address_space),
            "::",
            stringify!(gfp_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<address_space>())).i_mmap_writable as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(address_space),
            "::",
            stringify!(i_mmap_writable)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<address_space>())).i_mmap as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(address_space),
            "::",
            stringify!(i_mmap)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<address_space>())).i_mmap_rwsem as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(address_space),
            "::",
            stringify!(i_mmap_rwsem)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<address_space>())).nrpages as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(address_space),
            "::",
            stringify!(nrpages)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<address_space>())).nrexceptional as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(address_space),
            "::",
            stringify!(nrexceptional)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<address_space>())).writeback_index as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(address_space),
            "::",
            stringify!(writeback_index)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<address_space>())).a_ops as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(address_space),
            "::",
            stringify!(a_ops)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<address_space>())).flags as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(address_space),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<address_space>())).wb_err as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(address_space),
            "::",
            stringify!(wb_err)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<address_space>())).private_lock as *const _ as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(address_space),
            "::",
            stringify!(private_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<address_space>())).private_list as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(address_space),
            "::",
            stringify!(private_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<address_space>())).private_data as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(address_space),
            "::",
            stringify!(private_data)
        )
    );
}
impl Default for address_space {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct block_device {
    pub bd_dev: dev_t,
    pub bd_openers: c_types::c_int,
    pub bd_inode: *mut inode,
    pub bd_super: *mut super_block,
    pub bd_mutex: mutex,
    pub bd_claiming: *mut c_types::c_void,
    pub bd_holder: *mut c_types::c_void,
    pub bd_holders: c_types::c_int,
    pub bd_write_holder: bool_,
    pub bd_holder_disks: list_head,
    pub bd_contains: *mut block_device,
    pub bd_block_size: c_types::c_uint,
    pub bd_partno: u8_,
    pub bd_part: *mut hd_struct,
    pub bd_part_count: c_types::c_uint,
    pub bd_invalidated: c_types::c_int,
    pub bd_disk: *mut gendisk,
    pub bd_queue: *mut request_queue,
    pub bd_bdi: *mut backing_dev_info,
    pub bd_list: list_head,
    pub bd_private: c_types::c_ulong,
    pub bd_fsfreeze_count: c_types::c_int,
    pub bd_fsfreeze_mutex: mutex,
}
#[test]
fn bindgen_test_layout_block_device() {
    assert_eq!(
        ::core::mem::size_of::<block_device>(),
        216usize,
        concat!("Size of: ", stringify!(block_device))
    );
    assert_eq!(
        ::core::mem::align_of::<block_device>(),
        8usize,
        concat!("Alignment of ", stringify!(block_device))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<block_device>())).bd_dev as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(block_device),
            "::",
            stringify!(bd_dev)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<block_device>())).bd_openers as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(block_device),
            "::",
            stringify!(bd_openers)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<block_device>())).bd_inode as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(block_device),
            "::",
            stringify!(bd_inode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<block_device>())).bd_super as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(block_device),
            "::",
            stringify!(bd_super)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<block_device>())).bd_mutex as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(block_device),
            "::",
            stringify!(bd_mutex)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<block_device>())).bd_claiming as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(block_device),
            "::",
            stringify!(bd_claiming)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<block_device>())).bd_holder as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(block_device),
            "::",
            stringify!(bd_holder)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<block_device>())).bd_holders as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(block_device),
            "::",
            stringify!(bd_holders)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<block_device>())).bd_write_holder as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(block_device),
            "::",
            stringify!(bd_write_holder)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<block_device>())).bd_holder_disks as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(block_device),
            "::",
            stringify!(bd_holder_disks)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<block_device>())).bd_contains as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(block_device),
            "::",
            stringify!(bd_contains)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<block_device>())).bd_block_size as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(block_device),
            "::",
            stringify!(bd_block_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<block_device>())).bd_partno as *const _ as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(block_device),
            "::",
            stringify!(bd_partno)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<block_device>())).bd_part as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(block_device),
            "::",
            stringify!(bd_part)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<block_device>())).bd_part_count as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(block_device),
            "::",
            stringify!(bd_part_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<block_device>())).bd_invalidated as *const _ as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(block_device),
            "::",
            stringify!(bd_invalidated)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<block_device>())).bd_disk as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(block_device),
            "::",
            stringify!(bd_disk)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<block_device>())).bd_queue as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(block_device),
            "::",
            stringify!(bd_queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<block_device>())).bd_bdi as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(block_device),
            "::",
            stringify!(bd_bdi)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<block_device>())).bd_list as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(block_device),
            "::",
            stringify!(bd_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<block_device>())).bd_private as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(block_device),
            "::",
            stringify!(bd_private)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<block_device>())).bd_fsfreeze_count as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(block_device),
            "::",
            stringify!(bd_fsfreeze_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<block_device>())).bd_fsfreeze_mutex as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(block_device),
            "::",
            stringify!(bd_fsfreeze_mutex)
        )
    );
}
impl Default for block_device {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct posix_acl {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fsnotify_mark_connector {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct inode {
    pub i_mode: umode_t,
    pub i_opflags: c_types::c_ushort,
    pub i_uid: kuid_t,
    pub i_gid: kgid_t,
    pub i_flags: c_types::c_uint,
    pub i_acl: *mut posix_acl,
    pub i_default_acl: *mut posix_acl,
    pub i_op: *const inode_operations,
    pub i_sb: *mut super_block,
    pub i_mapping: *mut address_space,
    pub i_security: *mut c_types::c_void,
    pub i_ino: c_types::c_ulong,
    pub __bindgen_anon_1: inode__bindgen_ty_1,
    pub i_rdev: dev_t,
    pub i_size: loff_t,
    pub i_atime: timespec64,
    pub i_mtime: timespec64,
    pub i_ctime: timespec64,
    pub i_lock: spinlock_t,
    pub i_bytes: c_types::c_ushort,
    pub i_blkbits: u8_,
    pub i_write_hint: u8_,
    pub i_blocks: blkcnt_t,
    pub i_state: c_types::c_ulong,
    pub i_rwsem: rw_semaphore,
    pub dirtied_when: c_types::c_ulong,
    pub dirtied_time_when: c_types::c_ulong,
    pub i_hash: hlist_node,
    pub i_io_list: list_head,
    pub i_wb: *mut bdi_writeback,
    pub i_wb_frn_winner: c_types::c_int,
    pub i_wb_frn_avg_time: u16_,
    pub i_wb_frn_history: u16_,
    pub i_lru: list_head,
    pub i_sb_list: list_head,
    pub i_wb_list: list_head,
    pub __bindgen_anon_2: inode__bindgen_ty_2,
    pub i_version: atomic64_t,
    pub i_sequence: atomic64_t,
    pub i_count: atomic_t,
    pub i_dio_count: atomic_t,
    pub i_writecount: atomic_t,
    pub i_readcount: atomic_t,
    pub __bindgen_anon_3: inode__bindgen_ty_3,
    pub i_flctx: *mut file_lock_context,
    pub i_data: address_space,
    pub i_devices: list_head,
    pub __bindgen_anon_4: inode__bindgen_ty_4,
    pub i_generation: __u32,
    pub i_fsnotify_mask: __u32,
    pub i_fsnotify_marks: *mut fsnotify_mark_connector,
    pub i_crypt_info: *mut fscrypt_info,
    pub i_verity_info: *mut fsverity_info,
    pub i_private: *mut c_types::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union inode__bindgen_ty_1 {
    pub i_nlink: c_types::c_uint,
    pub __i_nlink: c_types::c_uint,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_inode__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<inode__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(inode__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<inode__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(inode__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode__bindgen_ty_1>())).i_nlink as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(inode__bindgen_ty_1),
            "::",
            stringify!(i_nlink)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode__bindgen_ty_1>())).__i_nlink as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(inode__bindgen_ty_1),
            "::",
            stringify!(__i_nlink)
        )
    );
}
impl Default for inode__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union inode__bindgen_ty_2 {
    pub i_dentry: hlist_head,
    pub i_rcu: callback_head,
    _bindgen_union_align: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_inode__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<inode__bindgen_ty_2>(),
        16usize,
        concat!("Size of: ", stringify!(inode__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<inode__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(inode__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode__bindgen_ty_2>())).i_dentry as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(inode__bindgen_ty_2),
            "::",
            stringify!(i_dentry)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode__bindgen_ty_2>())).i_rcu as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(inode__bindgen_ty_2),
            "::",
            stringify!(i_rcu)
        )
    );
}
impl Default for inode__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union inode__bindgen_ty_3 {
    pub i_fop: *const file_operations,
    pub free_inode: ::core::option::Option<unsafe extern "C" fn(arg1: *mut inode)>,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_inode__bindgen_ty_3() {
    assert_eq!(
        ::core::mem::size_of::<inode__bindgen_ty_3>(),
        8usize,
        concat!("Size of: ", stringify!(inode__bindgen_ty_3))
    );
    assert_eq!(
        ::core::mem::align_of::<inode__bindgen_ty_3>(),
        8usize,
        concat!("Alignment of ", stringify!(inode__bindgen_ty_3))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode__bindgen_ty_3>())).i_fop as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(inode__bindgen_ty_3),
            "::",
            stringify!(i_fop)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode__bindgen_ty_3>())).free_inode as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(inode__bindgen_ty_3),
            "::",
            stringify!(free_inode)
        )
    );
}
impl Default for inode__bindgen_ty_3 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union inode__bindgen_ty_4 {
    pub i_pipe: *mut pipe_inode_info,
    pub i_bdev: *mut block_device,
    pub i_cdev: *mut cdev,
    pub i_link: *mut c_types::c_char,
    pub i_dir_seq: c_types::c_uint,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_inode__bindgen_ty_4() {
    assert_eq!(
        ::core::mem::size_of::<inode__bindgen_ty_4>(),
        8usize,
        concat!("Size of: ", stringify!(inode__bindgen_ty_4))
    );
    assert_eq!(
        ::core::mem::align_of::<inode__bindgen_ty_4>(),
        8usize,
        concat!("Alignment of ", stringify!(inode__bindgen_ty_4))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode__bindgen_ty_4>())).i_pipe as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(inode__bindgen_ty_4),
            "::",
            stringify!(i_pipe)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode__bindgen_ty_4>())).i_bdev as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(inode__bindgen_ty_4),
            "::",
            stringify!(i_bdev)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode__bindgen_ty_4>())).i_cdev as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(inode__bindgen_ty_4),
            "::",
            stringify!(i_cdev)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode__bindgen_ty_4>())).i_link as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(inode__bindgen_ty_4),
            "::",
            stringify!(i_link)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode__bindgen_ty_4>())).i_dir_seq as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(inode__bindgen_ty_4),
            "::",
            stringify!(i_dir_seq)
        )
    );
}
impl Default for inode__bindgen_ty_4 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_inode() {
    assert_eq!(
        ::core::mem::size_of::<inode>(),
        600usize,
        concat!("Size of: ", stringify!(inode))
    );
    assert_eq!(
        ::core::mem::align_of::<inode>(),
        8usize,
        concat!("Alignment of ", stringify!(inode))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).i_mode as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).i_opflags as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_opflags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).i_uid as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_uid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).i_gid as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_gid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).i_flags as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).i_acl as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_acl)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).i_default_acl as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_default_acl)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).i_op as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_op)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).i_sb as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_sb)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).i_mapping as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_mapping)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).i_security as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_security)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).i_ino as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_ino)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).i_rdev as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_rdev)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).i_size as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).i_atime as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_atime)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).i_mtime as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_mtime)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).i_ctime as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_ctime)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).i_lock as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).i_bytes as *const _ as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_bytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).i_blkbits as *const _ as usize },
        142usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_blkbits)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).i_write_hint as *const _ as usize },
        143usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_write_hint)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).i_blocks as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_blocks)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).i_state as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_state)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).i_rwsem as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_rwsem)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).dirtied_when as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(dirtied_when)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).dirtied_time_when as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(dirtied_time_when)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).i_hash as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_hash)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).i_io_list as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_io_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).i_wb as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_wb)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).i_wb_frn_winner as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_wb_frn_winner)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).i_wb_frn_avg_time as *const _ as usize },
        260usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_wb_frn_avg_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).i_wb_frn_history as *const _ as usize },
        262usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_wb_frn_history)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).i_lru as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_lru)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).i_sb_list as *const _ as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_sb_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).i_wb_list as *const _ as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_wb_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).i_version as *const _ as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_version)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).i_sequence as *const _ as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_sequence)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).i_count as *const _ as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).i_dio_count as *const _ as usize },
        348usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_dio_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).i_writecount as *const _ as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_writecount)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).i_readcount as *const _ as usize },
        356usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_readcount)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).i_flctx as *const _ as usize },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_flctx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).i_data as *const _ as usize },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).i_devices as *const _ as usize },
        536usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_devices)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).i_generation as *const _ as usize },
        560usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_generation)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).i_fsnotify_mask as *const _ as usize },
        564usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_fsnotify_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).i_fsnotify_marks as *const _ as usize },
        568usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_fsnotify_marks)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).i_crypt_info as *const _ as usize },
        576usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_crypt_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).i_verity_info as *const _ as usize },
        584usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_verity_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).i_private as *const _ as usize },
        592usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_private)
        )
    );
}
impl Default for inode {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fown_struct {
    pub lock: rwlock_t,
    pub pid: *mut pid,
    pub pid_type: pid_type,
    pub uid: kuid_t,
    pub euid: kuid_t,
    pub signum: c_types::c_int,
}
#[test]
fn bindgen_test_layout_fown_struct() {
    assert_eq!(
        ::core::mem::size_of::<fown_struct>(),
        32usize,
        concat!("Size of: ", stringify!(fown_struct))
    );
    assert_eq!(
        ::core::mem::align_of::<fown_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(fown_struct))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fown_struct>())).lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fown_struct),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fown_struct>())).pid as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(fown_struct),
            "::",
            stringify!(pid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fown_struct>())).pid_type as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(fown_struct),
            "::",
            stringify!(pid_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fown_struct>())).uid as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(fown_struct),
            "::",
            stringify!(uid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fown_struct>())).euid as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(fown_struct),
            "::",
            stringify!(euid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fown_struct>())).signum as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(fown_struct),
            "::",
            stringify!(signum)
        )
    );
}
impl Default for fown_struct {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct file_ra_state {
    pub start: c_types::c_ulong,
    pub size: c_types::c_uint,
    pub async_size: c_types::c_uint,
    pub ra_pages: c_types::c_uint,
    pub mmap_miss: c_types::c_uint,
    pub prev_pos: loff_t,
}
#[test]
fn bindgen_test_layout_file_ra_state() {
    assert_eq!(
        ::core::mem::size_of::<file_ra_state>(),
        32usize,
        concat!("Size of: ", stringify!(file_ra_state))
    );
    assert_eq!(
        ::core::mem::align_of::<file_ra_state>(),
        8usize,
        concat!("Alignment of ", stringify!(file_ra_state))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_ra_state>())).start as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(file_ra_state),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_ra_state>())).size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(file_ra_state),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_ra_state>())).async_size as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(file_ra_state),
            "::",
            stringify!(async_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_ra_state>())).ra_pages as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(file_ra_state),
            "::",
            stringify!(ra_pages)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_ra_state>())).mmap_miss as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(file_ra_state),
            "::",
            stringify!(mmap_miss)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_ra_state>())).prev_pos as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(file_ra_state),
            "::",
            stringify!(prev_pos)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct file {
    pub f_u: file__bindgen_ty_1,
    pub f_path: path,
    pub f_inode: *mut inode,
    pub f_op: *const file_operations,
    pub f_lock: spinlock_t,
    pub f_write_hint: rw_hint,
    pub f_count: atomic_long_t,
    pub f_flags: c_types::c_uint,
    pub f_mode: fmode_t,
    pub f_pos_lock: mutex,
    pub f_pos: loff_t,
    pub f_owner: fown_struct,
    pub f_cred: *const cred,
    pub f_ra: file_ra_state,
    pub f_version: u64_,
    pub f_security: *mut c_types::c_void,
    pub private_data: *mut c_types::c_void,
    pub f_ep_links: list_head,
    pub f_tfile_llink: list_head,
    pub f_mapping: *mut address_space,
    pub f_wb_err: errseq_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union file__bindgen_ty_1 {
    pub fu_llist: llist_node,
    pub fu_rcuhead: callback_head,
    _bindgen_union_align: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_file__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<file__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(file__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<file__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(file__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file__bindgen_ty_1>())).fu_llist as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(file__bindgen_ty_1),
            "::",
            stringify!(fu_llist)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file__bindgen_ty_1>())).fu_rcuhead as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(file__bindgen_ty_1),
            "::",
            stringify!(fu_rcuhead)
        )
    );
}
impl Default for file__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_file() {
    assert_eq!(
        ::core::mem::size_of::<file>(),
        256usize,
        concat!("Size of: ", stringify!(file))
    );
    assert_eq!(
        ::core::mem::align_of::<file>(),
        8usize,
        concat!("Alignment of ", stringify!(file))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file>())).f_u as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(file), "::", stringify!(f_u))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file>())).f_path as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(file),
            "::",
            stringify!(f_path)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file>())).f_inode as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(file),
            "::",
            stringify!(f_inode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file>())).f_op as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(file),
            "::",
            stringify!(f_op)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file>())).f_lock as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(file),
            "::",
            stringify!(f_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file>())).f_write_hint as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(file),
            "::",
            stringify!(f_write_hint)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file>())).f_count as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(file),
            "::",
            stringify!(f_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file>())).f_flags as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(file),
            "::",
            stringify!(f_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file>())).f_mode as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(file),
            "::",
            stringify!(f_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file>())).f_pos_lock as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(file),
            "::",
            stringify!(f_pos_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file>())).f_pos as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(file),
            "::",
            stringify!(f_pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file>())).f_owner as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(file),
            "::",
            stringify!(f_owner)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file>())).f_cred as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(file),
            "::",
            stringify!(f_cred)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file>())).f_ra as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(file),
            "::",
            stringify!(f_ra)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file>())).f_version as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(file),
            "::",
            stringify!(f_version)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file>())).f_security as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(file),
            "::",
            stringify!(f_security)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file>())).private_data as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(file),
            "::",
            stringify!(private_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file>())).f_ep_links as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(file),
            "::",
            stringify!(f_ep_links)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file>())).f_tfile_llink as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(file),
            "::",
            stringify!(f_tfile_llink)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file>())).f_mapping as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(file),
            "::",
            stringify!(f_mapping)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file>())).f_wb_err as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(file),
            "::",
            stringify!(f_wb_err)
        )
    );
}
impl Default for file {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type fl_owner_t = *mut c_types::c_void;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct file_lock_operations {
    pub fl_copy_lock:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut file_lock, arg2: *mut file_lock)>,
    pub fl_release_private: ::core::option::Option<unsafe extern "C" fn(arg1: *mut file_lock)>,
}
#[test]
fn bindgen_test_layout_file_lock_operations() {
    assert_eq!(
        ::core::mem::size_of::<file_lock_operations>(),
        16usize,
        concat!("Size of: ", stringify!(file_lock_operations))
    );
    assert_eq!(
        ::core::mem::align_of::<file_lock_operations>(),
        8usize,
        concat!("Alignment of ", stringify!(file_lock_operations))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<file_lock_operations>())).fl_copy_lock as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(file_lock_operations),
            "::",
            stringify!(fl_copy_lock)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<file_lock_operations>())).fl_release_private as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(file_lock_operations),
            "::",
            stringify!(fl_release_private)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct lock_manager_operations {
    pub lm_get_owner: ::core::option::Option<unsafe extern "C" fn(arg1: fl_owner_t) -> fl_owner_t>,
    pub lm_put_owner: ::core::option::Option<unsafe extern "C" fn(arg1: fl_owner_t)>,
    pub lm_notify: ::core::option::Option<unsafe extern "C" fn(arg1: *mut file_lock)>,
    pub lm_grant: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut file_lock, arg2: c_types::c_int) -> c_types::c_int,
    >,
    pub lm_break: ::core::option::Option<unsafe extern "C" fn(arg1: *mut file_lock) -> bool_>,
    pub lm_change: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file_lock,
            arg2: c_types::c_int,
            arg3: *mut list_head,
        ) -> c_types::c_int,
    >,
    pub lm_setup: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut file_lock, arg2: *mut *mut c_types::c_void),
    >,
}
#[test]
fn bindgen_test_layout_lock_manager_operations() {
    assert_eq!(
        ::core::mem::size_of::<lock_manager_operations>(),
        56usize,
        concat!("Size of: ", stringify!(lock_manager_operations))
    );
    assert_eq!(
        ::core::mem::align_of::<lock_manager_operations>(),
        8usize,
        concat!("Alignment of ", stringify!(lock_manager_operations))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<lock_manager_operations>())).lm_get_owner as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lock_manager_operations),
            "::",
            stringify!(lm_get_owner)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<lock_manager_operations>())).lm_put_owner as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lock_manager_operations),
            "::",
            stringify!(lm_put_owner)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<lock_manager_operations>())).lm_notify as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lock_manager_operations),
            "::",
            stringify!(lm_notify)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<lock_manager_operations>())).lm_grant as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lock_manager_operations),
            "::",
            stringify!(lm_grant)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<lock_manager_operations>())).lm_break as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(lock_manager_operations),
            "::",
            stringify!(lm_break)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<lock_manager_operations>())).lm_change as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(lock_manager_operations),
            "::",
            stringify!(lm_change)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<lock_manager_operations>())).lm_setup as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(lock_manager_operations),
            "::",
            stringify!(lm_setup)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nlm_lockowner {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nfs_lock_info {
    pub state: u32_,
    pub owner: *mut nlm_lockowner,
    pub list: list_head,
}
#[test]
fn bindgen_test_layout_nfs_lock_info() {
    assert_eq!(
        ::core::mem::size_of::<nfs_lock_info>(),
        32usize,
        concat!("Size of: ", stringify!(nfs_lock_info))
    );
    assert_eq!(
        ::core::mem::align_of::<nfs_lock_info>(),
        8usize,
        concat!("Alignment of ", stringify!(nfs_lock_info))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nfs_lock_info>())).state as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nfs_lock_info),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nfs_lock_info>())).owner as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nfs_lock_info),
            "::",
            stringify!(owner)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nfs_lock_info>())).list as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nfs_lock_info),
            "::",
            stringify!(list)
        )
    );
}
impl Default for nfs_lock_info {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nfs4_lock_state {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nfs4_lock_info {
    pub owner: *mut nfs4_lock_state,
}
#[test]
fn bindgen_test_layout_nfs4_lock_info() {
    assert_eq!(
        ::core::mem::size_of::<nfs4_lock_info>(),
        8usize,
        concat!("Size of: ", stringify!(nfs4_lock_info))
    );
    assert_eq!(
        ::core::mem::align_of::<nfs4_lock_info>(),
        8usize,
        concat!("Alignment of ", stringify!(nfs4_lock_info))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nfs4_lock_info>())).owner as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nfs4_lock_info),
            "::",
            stringify!(owner)
        )
    );
}
impl Default for nfs4_lock_info {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct file_lock {
    pub fl_blocker: *mut file_lock,
    pub fl_list: list_head,
    pub fl_link: hlist_node,
    pub fl_blocked_requests: list_head,
    pub fl_blocked_member: list_head,
    pub fl_owner: fl_owner_t,
    pub fl_flags: c_types::c_uint,
    pub fl_type: c_types::c_uchar,
    pub fl_pid: c_types::c_uint,
    pub fl_link_cpu: c_types::c_int,
    pub fl_wait: wait_queue_head_t,
    pub fl_file: *mut file,
    pub fl_start: loff_t,
    pub fl_end: loff_t,
    pub fl_fasync: *mut fasync_struct,
    pub fl_break_time: c_types::c_ulong,
    pub fl_downgrade_time: c_types::c_ulong,
    pub fl_ops: *const file_lock_operations,
    pub fl_lmops: *const lock_manager_operations,
    pub fl_u: file_lock__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union file_lock__bindgen_ty_1 {
    pub nfs_fl: nfs_lock_info,
    pub nfs4_fl: nfs4_lock_info,
    pub afs: file_lock__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: [u64; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct file_lock__bindgen_ty_1__bindgen_ty_1 {
    pub link: list_head,
    pub state: c_types::c_int,
    pub debug_id: c_types::c_uint,
}
#[test]
fn bindgen_test_layout_file_lock__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<file_lock__bindgen_ty_1__bindgen_ty_1>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(file_lock__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<file_lock__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(file_lock__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<file_lock__bindgen_ty_1__bindgen_ty_1>())).link as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(file_lock__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(link)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<file_lock__bindgen_ty_1__bindgen_ty_1>())).state as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(file_lock__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<file_lock__bindgen_ty_1__bindgen_ty_1>())).debug_id as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(file_lock__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(debug_id)
        )
    );
}
impl Default for file_lock__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_file_lock__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<file_lock__bindgen_ty_1>(),
        32usize,
        concat!("Size of: ", stringify!(file_lock__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<file_lock__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(file_lock__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_lock__bindgen_ty_1>())).nfs_fl as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(file_lock__bindgen_ty_1),
            "::",
            stringify!(nfs_fl)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<file_lock__bindgen_ty_1>())).nfs4_fl as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(file_lock__bindgen_ty_1),
            "::",
            stringify!(nfs4_fl)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_lock__bindgen_ty_1>())).afs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(file_lock__bindgen_ty_1),
            "::",
            stringify!(afs)
        )
    );
}
impl Default for file_lock__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_file_lock() {
    assert_eq!(
        ::core::mem::size_of::<file_lock>(),
        216usize,
        concat!("Size of: ", stringify!(file_lock))
    );
    assert_eq!(
        ::core::mem::align_of::<file_lock>(),
        8usize,
        concat!("Alignment of ", stringify!(file_lock))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_lock>())).fl_blocker as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(file_lock),
            "::",
            stringify!(fl_blocker)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_lock>())).fl_list as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(file_lock),
            "::",
            stringify!(fl_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_lock>())).fl_link as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(file_lock),
            "::",
            stringify!(fl_link)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_lock>())).fl_blocked_requests as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(file_lock),
            "::",
            stringify!(fl_blocked_requests)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_lock>())).fl_blocked_member as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(file_lock),
            "::",
            stringify!(fl_blocked_member)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_lock>())).fl_owner as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(file_lock),
            "::",
            stringify!(fl_owner)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_lock>())).fl_flags as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(file_lock),
            "::",
            stringify!(fl_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_lock>())).fl_type as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(file_lock),
            "::",
            stringify!(fl_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_lock>())).fl_pid as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(file_lock),
            "::",
            stringify!(fl_pid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_lock>())).fl_link_cpu as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(file_lock),
            "::",
            stringify!(fl_link_cpu)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_lock>())).fl_wait as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(file_lock),
            "::",
            stringify!(fl_wait)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_lock>())).fl_file as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(file_lock),
            "::",
            stringify!(fl_file)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_lock>())).fl_start as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(file_lock),
            "::",
            stringify!(fl_start)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_lock>())).fl_end as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(file_lock),
            "::",
            stringify!(fl_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_lock>())).fl_fasync as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(file_lock),
            "::",
            stringify!(fl_fasync)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_lock>())).fl_break_time as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(file_lock),
            "::",
            stringify!(fl_break_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_lock>())).fl_downgrade_time as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(file_lock),
            "::",
            stringify!(fl_downgrade_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_lock>())).fl_ops as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(file_lock),
            "::",
            stringify!(fl_ops)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_lock>())).fl_lmops as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(file_lock),
            "::",
            stringify!(fl_lmops)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_lock>())).fl_u as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(file_lock),
            "::",
            stringify!(fl_u)
        )
    );
}
impl Default for file_lock {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct file_lock_context {
    pub flc_lock: spinlock_t,
    pub flc_flock: list_head,
    pub flc_posix: list_head,
    pub flc_lease: list_head,
}
#[test]
fn bindgen_test_layout_file_lock_context() {
    assert_eq!(
        ::core::mem::size_of::<file_lock_context>(),
        56usize,
        concat!("Size of: ", stringify!(file_lock_context))
    );
    assert_eq!(
        ::core::mem::align_of::<file_lock_context>(),
        8usize,
        concat!("Alignment of ", stringify!(file_lock_context))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_lock_context>())).flc_lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(file_lock_context),
            "::",
            stringify!(flc_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_lock_context>())).flc_flock as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(file_lock_context),
            "::",
            stringify!(flc_flock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_lock_context>())).flc_posix as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(file_lock_context),
            "::",
            stringify!(flc_posix)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_lock_context>())).flc_lease as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(file_lock_context),
            "::",
            stringify!(flc_lease)
        )
    );
}
impl Default for file_lock_context {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct files_struct {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fasync_struct {
    pub fa_lock: rwlock_t,
    pub magic: c_types::c_int,
    pub fa_fd: c_types::c_int,
    pub fa_next: *mut fasync_struct,
    pub fa_file: *mut file,
    pub fa_rcu: callback_head,
}
#[test]
fn bindgen_test_layout_fasync_struct() {
    assert_eq!(
        ::core::mem::size_of::<fasync_struct>(),
        48usize,
        concat!("Size of: ", stringify!(fasync_struct))
    );
    assert_eq!(
        ::core::mem::align_of::<fasync_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(fasync_struct))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fasync_struct>())).fa_lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fasync_struct),
            "::",
            stringify!(fa_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fasync_struct>())).magic as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(fasync_struct),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fasync_struct>())).fa_fd as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(fasync_struct),
            "::",
            stringify!(fa_fd)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fasync_struct>())).fa_next as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(fasync_struct),
            "::",
            stringify!(fa_next)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fasync_struct>())).fa_file as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(fasync_struct),
            "::",
            stringify!(fa_file)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fasync_struct>())).fa_rcu as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(fasync_struct),
            "::",
            stringify!(fa_rcu)
        )
    );
}
impl Default for fasync_struct {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sb_writers {
    pub frozen: c_types::c_int,
    pub wait_unfrozen: wait_queue_head_t,
    pub rw_sem: [percpu_rw_semaphore; 3usize],
}
#[test]
fn bindgen_test_layout_sb_writers() {
    assert_eq!(
        ::core::mem::size_of::<sb_writers>(),
        368usize,
        concat!("Size of: ", stringify!(sb_writers))
    );
    assert_eq!(
        ::core::mem::align_of::<sb_writers>(),
        8usize,
        concat!("Alignment of ", stringify!(sb_writers))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sb_writers>())).frozen as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sb_writers),
            "::",
            stringify!(frozen)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sb_writers>())).wait_unfrozen as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sb_writers),
            "::",
            stringify!(wait_unfrozen)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sb_writers>())).rw_sem as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sb_writers),
            "::",
            stringify!(rw_sem)
        )
    );
}
impl Default for sb_writers {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct super_block {
    pub s_list: list_head,
    pub s_dev: dev_t,
    pub s_blocksize_bits: c_types::c_uchar,
    pub s_blocksize: c_types::c_ulong,
    pub s_maxbytes: loff_t,
    pub s_type: *mut file_system_type,
    pub s_op: *const super_operations,
    pub dq_op: *const dquot_operations,
    pub s_qcop: *const quotactl_ops,
    pub s_export_op: *const export_operations,
    pub s_flags: c_types::c_ulong,
    pub s_iflags: c_types::c_ulong,
    pub s_magic: c_types::c_ulong,
    pub s_root: *mut dentry,
    pub s_umount: rw_semaphore,
    pub s_count: c_types::c_int,
    pub s_active: atomic_t,
    pub s_security: *mut c_types::c_void,
    pub s_xattr: *mut *mut xattr_handler,
    pub s_cop: *const fscrypt_operations,
    pub s_master_keys: *mut key,
    pub s_vop: *const fsverity_operations,
    pub s_roots: hlist_bl_head,
    pub s_mounts: list_head,
    pub s_bdev: *mut block_device,
    pub s_bdi: *mut backing_dev_info,
    pub s_mtd: *mut mtd_info,
    pub s_instances: hlist_node,
    pub s_quota_types: c_types::c_uint,
    pub s_dquot: quota_info,
    pub s_writers: sb_writers,
    pub s_fs_info: *mut c_types::c_void,
    pub s_time_gran: u32_,
    pub s_time_min: time64_t,
    pub s_time_max: time64_t,
    pub s_fsnotify_mask: __u32,
    pub s_fsnotify_marks: *mut fsnotify_mark_connector,
    pub s_id: [c_types::c_char; 32usize],
    pub s_uuid: uuid_t,
    pub s_max_links: c_types::c_uint,
    pub s_mode: fmode_t,
    pub s_vfs_rename_mutex: mutex,
    pub s_subtype: *const c_types::c_char,
    pub s_d_op: *const dentry_operations,
    pub cleancache_poolid: c_types::c_int,
    pub s_shrink: shrinker,
    pub s_remove_count: atomic_long_t,
    pub s_fsnotify_inode_refs: atomic_long_t,
    pub s_readonly_remount: c_types::c_int,
    pub s_dio_done_wq: *mut workqueue_struct,
    pub s_pins: hlist_head,
    pub s_user_ns: *mut user_namespace,
    pub s_dentry_lru: list_lru,
    pub s_inode_lru: list_lru,
    pub rcu: callback_head,
    pub destroy_work: work_struct,
    pub s_sync_lock: mutex,
    pub s_stack_depth: c_types::c_int,
    pub __bindgen_padding_0: [u32; 9usize],
    pub s_inode_list_lock: spinlock_t,
    pub s_inodes: list_head,
    pub s_inode_wblist_lock: spinlock_t,
    pub s_inodes_wb: list_head,
}
#[test]
fn bindgen_test_layout_super_block() {
    assert_eq!(
        ::core::mem::size_of::<super_block>(),
        1472usize,
        concat!("Size of: ", stringify!(super_block))
    );
    assert_eq!(
        ::core::mem::align_of::<super_block>(),
        64usize,
        concat!("Alignment of ", stringify!(super_block))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_list as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_dev as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_dev)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_blocksize_bits as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_blocksize_bits)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_blocksize as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_blocksize)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_maxbytes as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_maxbytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_type as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_op as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_op)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).dq_op as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(dq_op)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_qcop as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_qcop)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_export_op as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_export_op)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_flags as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_iflags as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_iflags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_magic as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_magic)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_root as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_root)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_umount as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_umount)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_count as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_active as *const _ as usize },
        156usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_active)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_security as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_security)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_xattr as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_xattr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_cop as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_cop)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_master_keys as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_master_keys)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_vop as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_vop)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_roots as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_roots)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_mounts as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_mounts)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_bdev as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_bdev)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_bdi as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_bdi)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_mtd as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_mtd)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_instances as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_instances)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_quota_types as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_quota_types)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_dquot as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_dquot)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_writers as *const _ as usize },
        584usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_writers)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_fs_info as *const _ as usize },
        952usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_fs_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_time_gran as *const _ as usize },
        960usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_time_gran)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_time_min as *const _ as usize },
        968usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_time_min)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_time_max as *const _ as usize },
        976usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_time_max)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_fsnotify_mask as *const _ as usize },
        984usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_fsnotify_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_fsnotify_marks as *const _ as usize },
        992usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_fsnotify_marks)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_id as *const _ as usize },
        1000usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_uuid as *const _ as usize },
        1032usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_uuid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_max_links as *const _ as usize },
        1048usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_max_links)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_mode as *const _ as usize },
        1052usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_vfs_rename_mutex as *const _ as usize },
        1056usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_vfs_rename_mutex)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_subtype as *const _ as usize },
        1088usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_subtype)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_d_op as *const _ as usize },
        1096usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_d_op)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).cleancache_poolid as *const _ as usize },
        1104usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(cleancache_poolid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_shrink as *const _ as usize },
        1112usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_shrink)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_remove_count as *const _ as usize },
        1176usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_remove_count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<super_block>())).s_fsnotify_inode_refs as *const _ as usize
        },
        1184usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_fsnotify_inode_refs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_readonly_remount as *const _ as usize },
        1192usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_readonly_remount)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_dio_done_wq as *const _ as usize },
        1200usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_dio_done_wq)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_pins as *const _ as usize },
        1208usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_pins)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_user_ns as *const _ as usize },
        1216usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_user_ns)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_dentry_lru as *const _ as usize },
        1224usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_dentry_lru)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_inode_lru as *const _ as usize },
        1256usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_inode_lru)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).rcu as *const _ as usize },
        1288usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(rcu)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).destroy_work as *const _ as usize },
        1304usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(destroy_work)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_sync_lock as *const _ as usize },
        1336usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_sync_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_stack_depth as *const _ as usize },
        1368usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_stack_depth)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_inode_list_lock as *const _ as usize },
        1408usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_inode_list_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_inodes as *const _ as usize },
        1416usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_inodes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<super_block>())).s_inode_wblist_lock as *const _ as usize
        },
        1432usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_inode_wblist_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_inodes_wb as *const _ as usize },
        1440usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_inodes_wb)
        )
    );
}
impl Default for super_block {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fiemap_extent_info {
    pub fi_flags: c_types::c_uint,
    pub fi_extents_mapped: c_types::c_uint,
    pub fi_extents_max: c_types::c_uint,
    pub fi_extents_start: *mut fiemap_extent,
}
#[test]
fn bindgen_test_layout_fiemap_extent_info() {
    assert_eq!(
        ::core::mem::size_of::<fiemap_extent_info>(),
        24usize,
        concat!("Size of: ", stringify!(fiemap_extent_info))
    );
    assert_eq!(
        ::core::mem::align_of::<fiemap_extent_info>(),
        8usize,
        concat!("Alignment of ", stringify!(fiemap_extent_info))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fiemap_extent_info>())).fi_flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fiemap_extent_info),
            "::",
            stringify!(fi_flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<fiemap_extent_info>())).fi_extents_mapped as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(fiemap_extent_info),
            "::",
            stringify!(fi_extents_mapped)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<fiemap_extent_info>())).fi_extents_max as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(fiemap_extent_info),
            "::",
            stringify!(fi_extents_max)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<fiemap_extent_info>())).fi_extents_start as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(fiemap_extent_info),
            "::",
            stringify!(fi_extents_start)
        )
    );
}
impl Default for fiemap_extent_info {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type filldir_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut dir_context,
        arg2: *const c_types::c_char,
        arg3: c_types::c_int,
        arg4: loff_t,
        arg5: u64_,
        arg6: c_types::c_uint,
    ) -> c_types::c_int,
>;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct dir_context {
    pub actor: filldir_t,
    pub pos: loff_t,
}
#[test]
fn bindgen_test_layout_dir_context() {
    assert_eq!(
        ::core::mem::size_of::<dir_context>(),
        16usize,
        concat!("Size of: ", stringify!(dir_context))
    );
    assert_eq!(
        ::core::mem::align_of::<dir_context>(),
        8usize,
        concat!("Alignment of ", stringify!(dir_context))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dir_context>())).actor as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dir_context),
            "::",
            stringify!(actor)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dir_context>())).pos as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(dir_context),
            "::",
            stringify!(pos)
        )
    );
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct inode_operations {
    pub lookup: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut inode,
            arg2: *mut dentry,
            arg3: c_types::c_uint,
        ) -> *mut dentry,
    >,
    pub get_link: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dentry,
            arg2: *mut inode,
            arg3: *mut delayed_call,
        ) -> *const c_types::c_char,
    >,
    pub permission: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut inode, arg2: c_types::c_int) -> c_types::c_int,
    >,
    pub get_acl: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut inode, arg2: c_types::c_int) -> *mut posix_acl,
    >,
    pub readlink: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dentry,
            arg2: *mut c_types::c_char,
            arg3: c_types::c_int,
        ) -> c_types::c_int,
    >,
    pub create: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut inode,
            arg2: *mut dentry,
            arg3: umode_t,
            arg4: bool_,
        ) -> c_types::c_int,
    >,
    pub link: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dentry,
            arg2: *mut inode,
            arg3: *mut dentry,
        ) -> c_types::c_int,
    >,
    pub unlink: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut inode, arg2: *mut dentry) -> c_types::c_int,
    >,
    pub symlink: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut inode,
            arg2: *mut dentry,
            arg3: *const c_types::c_char,
        ) -> c_types::c_int,
    >,
    pub mkdir: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut inode, arg2: *mut dentry, arg3: umode_t) -> c_types::c_int,
    >,
    pub rmdir: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut inode, arg2: *mut dentry) -> c_types::c_int,
    >,
    pub mknod: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut inode,
            arg2: *mut dentry,
            arg3: umode_t,
            arg4: dev_t,
        ) -> c_types::c_int,
    >,
    pub rename: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut inode,
            arg2: *mut dentry,
            arg3: *mut inode,
            arg4: *mut dentry,
            arg5: c_types::c_uint,
        ) -> c_types::c_int,
    >,
    pub setattr: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut dentry, arg2: *mut iattr) -> c_types::c_int,
    >,
    pub getattr: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *const path,
            arg2: *mut kstat,
            arg3: u32_,
            arg4: c_types::c_uint,
        ) -> c_types::c_int,
    >,
    pub listxattr: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut dentry, arg2: *mut c_types::c_char, arg3: usize) -> isize,
    >,
    pub fiemap: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut inode,
            arg2: *mut fiemap_extent_info,
            start: u64_,
            len: u64_,
        ) -> c_types::c_int,
    >,
    pub update_time: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut inode,
            arg2: *mut timespec64,
            arg3: c_types::c_int,
        ) -> c_types::c_int,
    >,
    pub atomic_open: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut inode,
            arg2: *mut dentry,
            arg3: *mut file,
            open_flag: c_types::c_uint,
            create_mode: umode_t,
        ) -> c_types::c_int,
    >,
    pub tmpfile: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut inode, arg2: *mut dentry, arg3: umode_t) -> c_types::c_int,
    >,
    pub set_acl: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut inode,
            arg2: *mut posix_acl,
            arg3: c_types::c_int,
        ) -> c_types::c_int,
    >,
}
#[test]
fn bindgen_test_layout_inode_operations() {
    assert_eq!(
        ::core::mem::size_of::<inode_operations>(),
        192usize,
        concat!("Size of: ", stringify!(inode_operations))
    );
    assert_eq!(
        ::core::mem::align_of::<inode_operations>(),
        64usize,
        concat!("Alignment of ", stringify!(inode_operations))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode_operations>())).lookup as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(inode_operations),
            "::",
            stringify!(lookup)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode_operations>())).get_link as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(inode_operations),
            "::",
            stringify!(get_link)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode_operations>())).permission as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(inode_operations),
            "::",
            stringify!(permission)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode_operations>())).get_acl as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(inode_operations),
            "::",
            stringify!(get_acl)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode_operations>())).readlink as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(inode_operations),
            "::",
            stringify!(readlink)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode_operations>())).create as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(inode_operations),
            "::",
            stringify!(create)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode_operations>())).link as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(inode_operations),
            "::",
            stringify!(link)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode_operations>())).unlink as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(inode_operations),
            "::",
            stringify!(unlink)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode_operations>())).symlink as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(inode_operations),
            "::",
            stringify!(symlink)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode_operations>())).mkdir as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(inode_operations),
            "::",
            stringify!(mkdir)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode_operations>())).rmdir as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(inode_operations),
            "::",
            stringify!(rmdir)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode_operations>())).mknod as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(inode_operations),
            "::",
            stringify!(mknod)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode_operations>())).rename as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(inode_operations),
            "::",
            stringify!(rename)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode_operations>())).setattr as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(inode_operations),
            "::",
            stringify!(setattr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode_operations>())).getattr as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(inode_operations),
            "::",
            stringify!(getattr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode_operations>())).listxattr as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(inode_operations),
            "::",
            stringify!(listxattr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode_operations>())).fiemap as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(inode_operations),
            "::",
            stringify!(fiemap)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode_operations>())).update_time as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(inode_operations),
            "::",
            stringify!(update_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode_operations>())).atomic_open as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(inode_operations),
            "::",
            stringify!(atomic_open)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode_operations>())).tmpfile as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(inode_operations),
            "::",
            stringify!(tmpfile)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode_operations>())).set_acl as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(inode_operations),
            "::",
            stringify!(set_acl)
        )
    );
}
impl Default for inode_operations {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct super_operations {
    pub alloc_inode:
        ::core::option::Option<unsafe extern "C" fn(sb: *mut super_block) -> *mut inode>,
    pub destroy_inode: ::core::option::Option<unsafe extern "C" fn(arg1: *mut inode)>,
    pub free_inode: ::core::option::Option<unsafe extern "C" fn(arg1: *mut inode)>,
    pub dirty_inode:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut inode, flags: c_types::c_int)>,
    pub write_inode: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut inode, wbc: *mut writeback_control) -> c_types::c_int,
    >,
    pub drop_inode:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut inode) -> c_types::c_int>,
    pub evict_inode: ::core::option::Option<unsafe extern "C" fn(arg1: *mut inode)>,
    pub put_super: ::core::option::Option<unsafe extern "C" fn(arg1: *mut super_block)>,
    pub sync_fs: ::core::option::Option<
        unsafe extern "C" fn(sb: *mut super_block, wait: c_types::c_int) -> c_types::c_int,
    >,
    pub freeze_super:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut super_block) -> c_types::c_int>,
    pub freeze_fs:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut super_block) -> c_types::c_int>,
    pub thaw_super:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut super_block) -> c_types::c_int>,
    pub unfreeze_fs:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut super_block) -> c_types::c_int>,
    pub statfs: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut dentry, arg2: *mut kstatfs) -> c_types::c_int,
    >,
    pub remount_fs: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut super_block,
            arg2: *mut c_types::c_int,
            arg3: *mut c_types::c_char,
        ) -> c_types::c_int,
    >,
    pub umount_begin: ::core::option::Option<unsafe extern "C" fn(arg1: *mut super_block)>,
    pub show_options: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut seq_file, arg2: *mut dentry) -> c_types::c_int,
    >,
    pub show_devname: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut seq_file, arg2: *mut dentry) -> c_types::c_int,
    >,
    pub show_path: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut seq_file, arg2: *mut dentry) -> c_types::c_int,
    >,
    pub show_stats: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut seq_file, arg2: *mut dentry) -> c_types::c_int,
    >,
    pub quota_read: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut super_block,
            arg2: c_types::c_int,
            arg3: *mut c_types::c_char,
            arg4: usize,
            arg5: loff_t,
        ) -> isize,
    >,
    pub quota_write: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut super_block,
            arg2: c_types::c_int,
            arg3: *const c_types::c_char,
            arg4: usize,
            arg5: loff_t,
        ) -> isize,
    >,
    pub get_dquots:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut inode) -> *mut *mut dquot>,
    pub bdev_try_to_free_page: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut super_block,
            arg2: *mut page,
            arg3: gfp_t,
        ) -> c_types::c_int,
    >,
    pub nr_cached_objects: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut super_block, arg2: *mut shrink_control) -> c_types::c_long,
    >,
    pub free_cached_objects: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut super_block, arg2: *mut shrink_control) -> c_types::c_long,
    >,
    pub real_loop: ::core::option::Option<unsafe extern "C" fn(arg1: *mut file) -> *mut file>,
}
#[test]
fn bindgen_test_layout_super_operations() {
    assert_eq!(
        ::core::mem::size_of::<super_operations>(),
        216usize,
        concat!("Size of: ", stringify!(super_operations))
    );
    assert_eq!(
        ::core::mem::align_of::<super_operations>(),
        8usize,
        concat!("Alignment of ", stringify!(super_operations))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_operations>())).alloc_inode as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(super_operations),
            "::",
            stringify!(alloc_inode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_operations>())).destroy_inode as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(super_operations),
            "::",
            stringify!(destroy_inode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_operations>())).free_inode as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(super_operations),
            "::",
            stringify!(free_inode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_operations>())).dirty_inode as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(super_operations),
            "::",
            stringify!(dirty_inode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_operations>())).write_inode as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(super_operations),
            "::",
            stringify!(write_inode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_operations>())).drop_inode as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(super_operations),
            "::",
            stringify!(drop_inode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_operations>())).evict_inode as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(super_operations),
            "::",
            stringify!(evict_inode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_operations>())).put_super as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(super_operations),
            "::",
            stringify!(put_super)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_operations>())).sync_fs as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(super_operations),
            "::",
            stringify!(sync_fs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_operations>())).freeze_super as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(super_operations),
            "::",
            stringify!(freeze_super)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_operations>())).freeze_fs as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(super_operations),
            "::",
            stringify!(freeze_fs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_operations>())).thaw_super as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(super_operations),
            "::",
            stringify!(thaw_super)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_operations>())).unfreeze_fs as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(super_operations),
            "::",
            stringify!(unfreeze_fs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_operations>())).statfs as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(super_operations),
            "::",
            stringify!(statfs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_operations>())).remount_fs as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(super_operations),
            "::",
            stringify!(remount_fs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_operations>())).umount_begin as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(super_operations),
            "::",
            stringify!(umount_begin)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_operations>())).show_options as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(super_operations),
            "::",
            stringify!(show_options)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_operations>())).show_devname as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(super_operations),
            "::",
            stringify!(show_devname)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_operations>())).show_path as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(super_operations),
            "::",
            stringify!(show_path)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_operations>())).show_stats as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(super_operations),
            "::",
            stringify!(show_stats)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_operations>())).quota_read as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(super_operations),
            "::",
            stringify!(quota_read)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_operations>())).quota_write as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(super_operations),
            "::",
            stringify!(quota_write)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_operations>())).get_dquots as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(super_operations),
            "::",
            stringify!(get_dquots)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<super_operations>())).bdev_try_to_free_page as *const _ as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(super_operations),
            "::",
            stringify!(bdev_try_to_free_page)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<super_operations>())).nr_cached_objects as *const _ as usize
        },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(super_operations),
            "::",
            stringify!(nr_cached_objects)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<super_operations>())).free_cached_objects as *const _ as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(super_operations),
            "::",
            stringify!(free_cached_objects)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_operations>())).real_loop as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(super_operations),
            "::",
            stringify!(real_loop)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bio_vec {
    pub bv_page: *mut page,
    pub bv_len: c_types::c_uint,
    pub bv_offset: c_types::c_uint,
}
#[test]
fn bindgen_test_layout_bio_vec() {
    assert_eq!(
        ::core::mem::size_of::<bio_vec>(),
        16usize,
        concat!("Size of: ", stringify!(bio_vec))
    );
    assert_eq!(
        ::core::mem::align_of::<bio_vec>(),
        8usize,
        concat!("Alignment of ", stringify!(bio_vec))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bio_vec>())).bv_page as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bio_vec),
            "::",
            stringify!(bv_page)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bio_vec>())).bv_len as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bio_vec),
            "::",
            stringify!(bv_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bio_vec>())).bv_offset as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(bio_vec),
            "::",
            stringify!(bv_offset)
        )
    );
}
impl Default for bio_vec {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct bvec_iter {
    pub bi_sector: sector_t,
    pub bi_size: c_types::c_uint,
    pub bi_idx: c_types::c_uint,
    pub bi_bvec_done: c_types::c_uint,
}
#[test]
fn bindgen_test_layout_bvec_iter() {
    assert_eq!(
        ::core::mem::size_of::<bvec_iter>(),
        24usize,
        concat!("Size of: ", stringify!(bvec_iter))
    );
    assert_eq!(
        ::core::mem::align_of::<bvec_iter>(),
        8usize,
        concat!("Alignment of ", stringify!(bvec_iter))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bvec_iter>())).bi_sector as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bvec_iter),
            "::",
            stringify!(bi_sector)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bvec_iter>())).bi_size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bvec_iter),
            "::",
            stringify!(bi_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bvec_iter>())).bi_idx as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(bvec_iter),
            "::",
            stringify!(bi_idx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bvec_iter>())).bi_bvec_done as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(bvec_iter),
            "::",
            stringify!(bi_bvec_done)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kmem_cache {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iovec {
    pub iov_base: *mut c_types::c_void,
    pub iov_len: __kernel_size_t,
}
#[test]
fn bindgen_test_layout_iovec() {
    assert_eq!(
        ::core::mem::size_of::<iovec>(),
        16usize,
        concat!("Size of: ", stringify!(iovec))
    );
    assert_eq!(
        ::core::mem::align_of::<iovec>(),
        8usize,
        concat!("Alignment of ", stringify!(iovec))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<iovec>())).iov_base as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(iovec),
            "::",
            stringify!(iov_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<iovec>())).iov_len as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(iovec),
            "::",
            stringify!(iov_len)
        )
    );
}
impl Default for iovec {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kvec {
    pub iov_base: *mut c_types::c_void,
    pub iov_len: usize,
}
#[test]
fn bindgen_test_layout_kvec() {
    assert_eq!(
        ::core::mem::size_of::<kvec>(),
        16usize,
        concat!("Size of: ", stringify!(kvec))
    );
    assert_eq!(
        ::core::mem::align_of::<kvec>(),
        8usize,
        concat!("Alignment of ", stringify!(kvec))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kvec>())).iov_base as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kvec),
            "::",
            stringify!(iov_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kvec>())).iov_len as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(kvec),
            "::",
            stringify!(iov_len)
        )
    );
}
impl Default for kvec {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct iov_iter {
    pub type_: c_types::c_uint,
    pub iov_offset: usize,
    pub count: usize,
    pub __bindgen_anon_1: iov_iter__bindgen_ty_1,
    pub __bindgen_anon_2: iov_iter__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union iov_iter__bindgen_ty_1 {
    pub iov: *const iovec,
    pub kvec: *const kvec,
    pub bvec: *const bio_vec,
    pub pipe: *mut pipe_inode_info,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_iov_iter__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<iov_iter__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(iov_iter__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<iov_iter__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(iov_iter__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<iov_iter__bindgen_ty_1>())).iov as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(iov_iter__bindgen_ty_1),
            "::",
            stringify!(iov)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<iov_iter__bindgen_ty_1>())).kvec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(iov_iter__bindgen_ty_1),
            "::",
            stringify!(kvec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<iov_iter__bindgen_ty_1>())).bvec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(iov_iter__bindgen_ty_1),
            "::",
            stringify!(bvec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<iov_iter__bindgen_ty_1>())).pipe as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(iov_iter__bindgen_ty_1),
            "::",
            stringify!(pipe)
        )
    );
}
impl Default for iov_iter__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union iov_iter__bindgen_ty_2 {
    pub nr_segs: c_types::c_ulong,
    pub __bindgen_anon_1: iov_iter__bindgen_ty_2__bindgen_ty_1,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct iov_iter__bindgen_ty_2__bindgen_ty_1 {
    pub idx: c_types::c_int,
    pub start_idx: c_types::c_int,
}
#[test]
fn bindgen_test_layout_iov_iter__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<iov_iter__bindgen_ty_2__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(iov_iter__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<iov_iter__bindgen_ty_2__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(iov_iter__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<iov_iter__bindgen_ty_2__bindgen_ty_1>())).idx as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(iov_iter__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(idx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<iov_iter__bindgen_ty_2__bindgen_ty_1>())).start_idx as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(iov_iter__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(start_idx)
        )
    );
}
#[test]
fn bindgen_test_layout_iov_iter__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<iov_iter__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(iov_iter__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<iov_iter__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(iov_iter__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<iov_iter__bindgen_ty_2>())).nr_segs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(iov_iter__bindgen_ty_2),
            "::",
            stringify!(nr_segs)
        )
    );
}
impl Default for iov_iter__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_iov_iter() {
    assert_eq!(
        ::core::mem::size_of::<iov_iter>(),
        40usize,
        concat!("Size of: ", stringify!(iov_iter))
    );
    assert_eq!(
        ::core::mem::align_of::<iov_iter>(),
        8usize,
        concat!("Alignment of ", stringify!(iov_iter))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<iov_iter>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(iov_iter),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<iov_iter>())).iov_offset as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(iov_iter),
            "::",
            stringify!(iov_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<iov_iter>())).count as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(iov_iter),
            "::",
            stringify!(count)
        )
    );
}
impl Default for iov_iter {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type __kernel_sa_family_t = c_types::c_ushort;
pub type sa_family_t = __kernel_sa_family_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct sockaddr {
    pub sa_family: sa_family_t,
    pub sa_data: [c_types::c_char; 14usize],
}
#[test]
fn bindgen_test_layout_sockaddr() {
    assert_eq!(
        ::core::mem::size_of::<sockaddr>(),
        16usize,
        concat!("Size of: ", stringify!(sockaddr))
    );
    assert_eq!(
        ::core::mem::align_of::<sockaddr>(),
        2usize,
        concat!("Alignment of ", stringify!(sockaddr))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sockaddr>())).sa_family as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr),
            "::",
            stringify!(sa_family)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sockaddr>())).sa_data as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr),
            "::",
            stringify!(sa_data)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct msghdr {
    pub msg_name: *mut c_types::c_void,
    pub msg_namelen: c_types::c_int,
    pub msg_iter: iov_iter,
    pub msg_control: *mut c_types::c_void,
    pub msg_controllen: __kernel_size_t,
    pub msg_flags: c_types::c_uint,
    pub msg_iocb: *mut kiocb,
}
#[test]
fn bindgen_test_layout_msghdr() {
    assert_eq!(
        ::core::mem::size_of::<msghdr>(),
        88usize,
        concat!("Size of: ", stringify!(msghdr))
    );
    assert_eq!(
        ::core::mem::align_of::<msghdr>(),
        8usize,
        concat!("Alignment of ", stringify!(msghdr))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<msghdr>())).msg_name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<msghdr>())).msg_namelen as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_namelen)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<msghdr>())).msg_iter as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_iter)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<msghdr>())).msg_control as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_control)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<msghdr>())).msg_controllen as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_controllen)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<msghdr>())).msg_flags as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<msghdr>())).msg_iocb as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_iocb)
        )
    );
}
impl Default for msghdr {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub const socket_state_SS_FREE: socket_state = 0;
pub const socket_state_SS_UNCONNECTED: socket_state = 1;
pub const socket_state_SS_CONNECTING: socket_state = 2;
pub const socket_state_SS_CONNECTED: socket_state = 3;
pub const socket_state_SS_DISCONNECTING: socket_state = 4;
pub type socket_state = c_types::c_uint;
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct socket_wq {
    pub wait: wait_queue_head_t,
    pub fasync_list: *mut fasync_struct,
    pub flags: c_types::c_ulong,
    pub rcu: callback_head,
}
#[test]
fn bindgen_test_layout_socket_wq() {
    assert_eq!(
        ::core::mem::size_of::<socket_wq>(),
        64usize,
        concat!("Size of: ", stringify!(socket_wq))
    );
    assert_eq!(
        ::core::mem::align_of::<socket_wq>(),
        64usize,
        concat!("Alignment of ", stringify!(socket_wq))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<socket_wq>())).wait as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(socket_wq),
            "::",
            stringify!(wait)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<socket_wq>())).fasync_list as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(socket_wq),
            "::",
            stringify!(fasync_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<socket_wq>())).flags as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(socket_wq),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<socket_wq>())).rcu as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(socket_wq),
            "::",
            stringify!(rcu)
        )
    );
}
impl Default for socket_wq {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[doc = "  struct socket - general BSD socket"]
#[doc = "  @state: socket state (%SS_CONNECTED, etc)"]
#[doc = "  @type: socket type (%SOCK_STREAM, etc)"]
#[doc = "  @flags: socket flags (%SOCK_NOSPACE, etc)"]
#[doc = "  @ops: protocol specific socket operations"]
#[doc = "  @file: File back pointer for gc"]
#[doc = "  @sk: internal networking protocol agnostic socket representation"]
#[doc = "  @wq: wait queue for several uses"]
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct socket {
    pub state: socket_state,
    pub type_: c_types::c_short,
    pub flags: c_types::c_ulong,
    pub file: *mut file,
    pub sk: *mut sock,
    pub ops: *const proto_ops,
    pub __bindgen_padding_0: [u64; 3usize],
    pub wq: socket_wq,
}
#[test]
fn bindgen_test_layout_socket() {
    assert_eq!(
        ::core::mem::size_of::<socket>(),
        128usize,
        concat!("Size of: ", stringify!(socket))
    );
    assert_eq!(
        ::core::mem::align_of::<socket>(),
        64usize,
        concat!("Alignment of ", stringify!(socket))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<socket>())).state as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(socket),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<socket>())).type_ as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(socket),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<socket>())).flags as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(socket),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<socket>())).file as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(socket),
            "::",
            stringify!(file)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<socket>())).sk as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(socket),
            "::",
            stringify!(sk)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<socket>())).ops as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(socket),
            "::",
            stringify!(ops)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<socket>())).wq as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(socket),
            "::",
            stringify!(wq)
        )
    );
}
impl Default for socket {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type sk_read_actor_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut read_descriptor_t,
        arg2: *mut sk_buff,
        arg3: c_types::c_uint,
        arg4: usize,
    ) -> c_types::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct proto_ops {
    pub family: c_types::c_int,
    pub owner: *mut module,
    pub release: ::core::option::Option<unsafe extern "C" fn(sock: *mut socket) -> c_types::c_int>,
    pub bind: ::core::option::Option<
        unsafe extern "C" fn(
            sock: *mut socket,
            myaddr: *mut sockaddr,
            sockaddr_len: c_types::c_int,
        ) -> c_types::c_int,
    >,
    pub connect: ::core::option::Option<
        unsafe extern "C" fn(
            sock: *mut socket,
            vaddr: *mut sockaddr,
            sockaddr_len: c_types::c_int,
            flags: c_types::c_int,
        ) -> c_types::c_int,
    >,
    pub socketpair: ::core::option::Option<
        unsafe extern "C" fn(sock1: *mut socket, sock2: *mut socket) -> c_types::c_int,
    >,
    pub accept: ::core::option::Option<
        unsafe extern "C" fn(
            sock: *mut socket,
            newsock: *mut socket,
            flags: c_types::c_int,
            kern: bool_,
        ) -> c_types::c_int,
    >,
    pub getname: ::core::option::Option<
        unsafe extern "C" fn(
            sock: *mut socket,
            addr: *mut sockaddr,
            peer: c_types::c_int,
        ) -> c_types::c_int,
    >,
    pub poll: ::core::option::Option<
        unsafe extern "C" fn(
            file: *mut file,
            sock: *mut socket,
            wait: *mut poll_table_struct,
        ) -> __poll_t,
    >,
    pub ioctl: ::core::option::Option<
        unsafe extern "C" fn(
            sock: *mut socket,
            cmd: c_types::c_uint,
            arg: c_types::c_ulong,
        ) -> c_types::c_int,
    >,
    pub compat_ioctl: ::core::option::Option<
        unsafe extern "C" fn(
            sock: *mut socket,
            cmd: c_types::c_uint,
            arg: c_types::c_ulong,
        ) -> c_types::c_int,
    >,
    pub gettstamp: ::core::option::Option<
        unsafe extern "C" fn(
            sock: *mut socket,
            userstamp: *mut c_types::c_void,
            timeval: bool_,
            time32: bool_,
        ) -> c_types::c_int,
    >,
    pub listen: ::core::option::Option<
        unsafe extern "C" fn(sock: *mut socket, len: c_types::c_int) -> c_types::c_int,
    >,
    pub shutdown: ::core::option::Option<
        unsafe extern "C" fn(sock: *mut socket, flags: c_types::c_int) -> c_types::c_int,
    >,
    pub setsockopt: ::core::option::Option<
        unsafe extern "C" fn(
            sock: *mut socket,
            level: c_types::c_int,
            optname: c_types::c_int,
            optval: *mut c_types::c_char,
            optlen: c_types::c_uint,
        ) -> c_types::c_int,
    >,
    pub getsockopt: ::core::option::Option<
        unsafe extern "C" fn(
            sock: *mut socket,
            level: c_types::c_int,
            optname: c_types::c_int,
            optval: *mut c_types::c_char,
            optlen: *mut c_types::c_int,
        ) -> c_types::c_int,
    >,
    pub compat_setsockopt: ::core::option::Option<
        unsafe extern "C" fn(
            sock: *mut socket,
            level: c_types::c_int,
            optname: c_types::c_int,
            optval: *mut c_types::c_char,
            optlen: c_types::c_uint,
        ) -> c_types::c_int,
    >,
    pub compat_getsockopt: ::core::option::Option<
        unsafe extern "C" fn(
            sock: *mut socket,
            level: c_types::c_int,
            optname: c_types::c_int,
            optval: *mut c_types::c_char,
            optlen: *mut c_types::c_int,
        ) -> c_types::c_int,
    >,
    pub sendmsg: ::core::option::Option<
        unsafe extern "C" fn(sock: *mut socket, m: *mut msghdr, total_len: usize) -> c_types::c_int,
    >,
    pub recvmsg: ::core::option::Option<
        unsafe extern "C" fn(
            sock: *mut socket,
            m: *mut msghdr,
            total_len: usize,
            flags: c_types::c_int,
        ) -> c_types::c_int,
    >,
    pub mmap: ::core::option::Option<
        unsafe extern "C" fn(
            file: *mut file,
            sock: *mut socket,
            vma: *mut vm_area_struct,
        ) -> c_types::c_int,
    >,
    pub sendpage: ::core::option::Option<
        unsafe extern "C" fn(
            sock: *mut socket,
            page: *mut page,
            offset: c_types::c_int,
            size: usize,
            flags: c_types::c_int,
        ) -> isize,
    >,
    pub splice_read: ::core::option::Option<
        unsafe extern "C" fn(
            sock: *mut socket,
            ppos: *mut loff_t,
            pipe: *mut pipe_inode_info,
            len: usize,
            flags: c_types::c_uint,
        ) -> isize,
    >,
    pub set_peek_off: ::core::option::Option<
        unsafe extern "C" fn(sk: *mut sock, val: c_types::c_int) -> c_types::c_int,
    >,
    pub peek_len: ::core::option::Option<unsafe extern "C" fn(sock: *mut socket) -> c_types::c_int>,
    pub read_sock: ::core::option::Option<
        unsafe extern "C" fn(
            sk: *mut sock,
            desc: *mut read_descriptor_t,
            recv_actor: sk_read_actor_t,
        ) -> c_types::c_int,
    >,
    pub sendpage_locked: ::core::option::Option<
        unsafe extern "C" fn(
            sk: *mut sock,
            page: *mut page,
            offset: c_types::c_int,
            size: usize,
            flags: c_types::c_int,
        ) -> c_types::c_int,
    >,
    pub sendmsg_locked: ::core::option::Option<
        unsafe extern "C" fn(sk: *mut sock, msg: *mut msghdr, size: usize) -> c_types::c_int,
    >,
    pub set_rcvlowat: ::core::option::Option<
        unsafe extern "C" fn(sk: *mut sock, val: c_types::c_int) -> c_types::c_int,
    >,
}
#[test]
fn bindgen_test_layout_proto_ops() {
    assert_eq!(
        ::core::mem::size_of::<proto_ops>(),
        232usize,
        concat!("Size of: ", stringify!(proto_ops))
    );
    assert_eq!(
        ::core::mem::align_of::<proto_ops>(),
        8usize,
        concat!("Alignment of ", stringify!(proto_ops))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<proto_ops>())).family as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(proto_ops),
            "::",
            stringify!(family)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<proto_ops>())).owner as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(proto_ops),
            "::",
            stringify!(owner)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<proto_ops>())).release as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(proto_ops),
            "::",
            stringify!(release)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<proto_ops>())).bind as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(proto_ops),
            "::",
            stringify!(bind)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<proto_ops>())).connect as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(proto_ops),
            "::",
            stringify!(connect)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<proto_ops>())).socketpair as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(proto_ops),
            "::",
            stringify!(socketpair)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<proto_ops>())).accept as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(proto_ops),
            "::",
            stringify!(accept)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<proto_ops>())).getname as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(proto_ops),
            "::",
            stringify!(getname)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<proto_ops>())).poll as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(proto_ops),
            "::",
            stringify!(poll)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<proto_ops>())).ioctl as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(proto_ops),
            "::",
            stringify!(ioctl)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<proto_ops>())).compat_ioctl as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(proto_ops),
            "::",
            stringify!(compat_ioctl)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<proto_ops>())).gettstamp as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(proto_ops),
            "::",
            stringify!(gettstamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<proto_ops>())).listen as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(proto_ops),
            "::",
            stringify!(listen)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<proto_ops>())).shutdown as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(proto_ops),
            "::",
            stringify!(shutdown)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<proto_ops>())).setsockopt as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(proto_ops),
            "::",
            stringify!(setsockopt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<proto_ops>())).getsockopt as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(proto_ops),
            "::",
            stringify!(getsockopt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<proto_ops>())).compat_setsockopt as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(proto_ops),
            "::",
            stringify!(compat_setsockopt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<proto_ops>())).compat_getsockopt as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(proto_ops),
            "::",
            stringify!(compat_getsockopt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<proto_ops>())).sendmsg as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(proto_ops),
            "::",
            stringify!(sendmsg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<proto_ops>())).recvmsg as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(proto_ops),
            "::",
            stringify!(recvmsg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<proto_ops>())).mmap as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(proto_ops),
            "::",
            stringify!(mmap)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<proto_ops>())).sendpage as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(proto_ops),
            "::",
            stringify!(sendpage)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<proto_ops>())).splice_read as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(proto_ops),
            "::",
            stringify!(splice_read)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<proto_ops>())).set_peek_off as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(proto_ops),
            "::",
            stringify!(set_peek_off)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<proto_ops>())).peek_len as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(proto_ops),
            "::",
            stringify!(peek_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<proto_ops>())).read_sock as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(proto_ops),
            "::",
            stringify!(read_sock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<proto_ops>())).sendpage_locked as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(proto_ops),
            "::",
            stringify!(sendpage_locked)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<proto_ops>())).sendmsg_locked as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(proto_ops),
            "::",
            stringify!(sendmsg_locked)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<proto_ops>())).set_rcvlowat as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(proto_ops),
            "::",
            stringify!(set_rcvlowat)
        )
    );
}
impl Default for proto_ops {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct idr {
    pub idr_rt: xarray,
    pub idr_base: c_types::c_uint,
    pub idr_next: c_types::c_uint,
}
#[test]
fn bindgen_test_layout_idr() {
    assert_eq!(
        ::core::mem::size_of::<idr>(),
        24usize,
        concat!("Size of: ", stringify!(idr))
    );
    assert_eq!(
        ::core::mem::align_of::<idr>(),
        8usize,
        concat!("Alignment of ", stringify!(idr))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<idr>())).idr_rt as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(idr),
            "::",
            stringify!(idr_rt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<idr>())).idr_base as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(idr),
            "::",
            stringify!(idr_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<idr>())).idr_next as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(idr),
            "::",
            stringify!(idr_next)
        )
    );
}
impl Default for idr {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kernfs_open_node {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kernfs_iattrs {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kernfs_elem_dir {
    pub subdirs: c_types::c_ulong,
    pub children: rb_root,
    pub root: *mut kernfs_root,
}
#[test]
fn bindgen_test_layout_kernfs_elem_dir() {
    assert_eq!(
        ::core::mem::size_of::<kernfs_elem_dir>(),
        24usize,
        concat!("Size of: ", stringify!(kernfs_elem_dir))
    );
    assert_eq!(
        ::core::mem::align_of::<kernfs_elem_dir>(),
        8usize,
        concat!("Alignment of ", stringify!(kernfs_elem_dir))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_elem_dir>())).subdirs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_elem_dir),
            "::",
            stringify!(subdirs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_elem_dir>())).children as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_elem_dir),
            "::",
            stringify!(children)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_elem_dir>())).root as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_elem_dir),
            "::",
            stringify!(root)
        )
    );
}
impl Default for kernfs_elem_dir {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kernfs_elem_symlink {
    pub target_kn: *mut kernfs_node,
}
#[test]
fn bindgen_test_layout_kernfs_elem_symlink() {
    assert_eq!(
        ::core::mem::size_of::<kernfs_elem_symlink>(),
        8usize,
        concat!("Size of: ", stringify!(kernfs_elem_symlink))
    );
    assert_eq!(
        ::core::mem::align_of::<kernfs_elem_symlink>(),
        8usize,
        concat!("Alignment of ", stringify!(kernfs_elem_symlink))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_elem_symlink>())).target_kn as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_elem_symlink),
            "::",
            stringify!(target_kn)
        )
    );
}
impl Default for kernfs_elem_symlink {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kernfs_elem_attr {
    pub ops: *const kernfs_ops,
    pub open: *mut kernfs_open_node,
    pub size: loff_t,
    pub notify_next: *mut kernfs_node,
}
#[test]
fn bindgen_test_layout_kernfs_elem_attr() {
    assert_eq!(
        ::core::mem::size_of::<kernfs_elem_attr>(),
        32usize,
        concat!("Size of: ", stringify!(kernfs_elem_attr))
    );
    assert_eq!(
        ::core::mem::align_of::<kernfs_elem_attr>(),
        8usize,
        concat!("Alignment of ", stringify!(kernfs_elem_attr))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_elem_attr>())).ops as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_elem_attr),
            "::",
            stringify!(ops)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_elem_attr>())).open as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_elem_attr),
            "::",
            stringify!(open)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_elem_attr>())).size as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_elem_attr),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_elem_attr>())).notify_next as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_elem_attr),
            "::",
            stringify!(notify_next)
        )
    );
}
impl Default for kernfs_elem_attr {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union kernfs_node_id {
    pub __bindgen_anon_1: kernfs_node_id__bindgen_ty_1,
    pub id: u64_,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kernfs_node_id__bindgen_ty_1 {
    pub ino: u32_,
    pub generation: u32_,
}
#[test]
fn bindgen_test_layout_kernfs_node_id__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<kernfs_node_id__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(kernfs_node_id__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<kernfs_node_id__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(kernfs_node_id__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<kernfs_node_id__bindgen_ty_1>())).ino as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_node_id__bindgen_ty_1),
            "::",
            stringify!(ino)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<kernfs_node_id__bindgen_ty_1>())).generation as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_node_id__bindgen_ty_1),
            "::",
            stringify!(generation)
        )
    );
}
#[test]
fn bindgen_test_layout_kernfs_node_id() {
    assert_eq!(
        ::core::mem::size_of::<kernfs_node_id>(),
        8usize,
        concat!("Size of: ", stringify!(kernfs_node_id))
    );
    assert_eq!(
        ::core::mem::align_of::<kernfs_node_id>(),
        8usize,
        concat!("Alignment of ", stringify!(kernfs_node_id))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_node_id>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_node_id),
            "::",
            stringify!(id)
        )
    );
}
impl Default for kernfs_node_id {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kernfs_node {
    pub count: atomic_t,
    pub active: atomic_t,
    pub parent: *mut kernfs_node,
    pub name: *const c_types::c_char,
    pub rb: rb_node,
    pub ns: *const c_types::c_void,
    pub hash: c_types::c_uint,
    pub __bindgen_anon_1: kernfs_node__bindgen_ty_1,
    pub priv_: *mut c_types::c_void,
    pub id: kernfs_node_id,
    pub flags: c_types::c_ushort,
    pub mode: umode_t,
    pub iattr: *mut kernfs_iattrs,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union kernfs_node__bindgen_ty_1 {
    pub dir: kernfs_elem_dir,
    pub symlink: kernfs_elem_symlink,
    pub attr: kernfs_elem_attr,
    _bindgen_union_align: [u64; 4usize],
}
#[test]
fn bindgen_test_layout_kernfs_node__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<kernfs_node__bindgen_ty_1>(),
        32usize,
        concat!("Size of: ", stringify!(kernfs_node__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<kernfs_node__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(kernfs_node__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_node__bindgen_ty_1>())).dir as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_node__bindgen_ty_1),
            "::",
            stringify!(dir)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<kernfs_node__bindgen_ty_1>())).symlink as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_node__bindgen_ty_1),
            "::",
            stringify!(symlink)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_node__bindgen_ty_1>())).attr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_node__bindgen_ty_1),
            "::",
            stringify!(attr)
        )
    );
}
impl Default for kernfs_node__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_kernfs_node() {
    assert_eq!(
        ::core::mem::size_of::<kernfs_node>(),
        128usize,
        concat!("Size of: ", stringify!(kernfs_node))
    );
    assert_eq!(
        ::core::mem::align_of::<kernfs_node>(),
        8usize,
        concat!("Alignment of ", stringify!(kernfs_node))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_node>())).count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_node),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_node>())).active as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_node),
            "::",
            stringify!(active)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_node>())).parent as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_node),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_node>())).name as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_node),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_node>())).rb as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_node),
            "::",
            stringify!(rb)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_node>())).ns as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_node),
            "::",
            stringify!(ns)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_node>())).hash as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_node),
            "::",
            stringify!(hash)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_node>())).priv_ as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_node),
            "::",
            stringify!(priv_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_node>())).id as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_node),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_node>())).flags as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_node),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_node>())).mode as *const _ as usize },
        114usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_node),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_node>())).iattr as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_node),
            "::",
            stringify!(iattr)
        )
    );
}
impl Default for kernfs_node {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kernfs_syscall_ops {
    pub show_options: ::core::option::Option<
        unsafe extern "C" fn(sf: *mut seq_file, root: *mut kernfs_root) -> c_types::c_int,
    >,
    pub mkdir: ::core::option::Option<
        unsafe extern "C" fn(
            parent: *mut kernfs_node,
            name: *const c_types::c_char,
            mode: umode_t,
        ) -> c_types::c_int,
    >,
    pub rmdir: ::core::option::Option<unsafe extern "C" fn(kn: *mut kernfs_node) -> c_types::c_int>,
    pub rename: ::core::option::Option<
        unsafe extern "C" fn(
            kn: *mut kernfs_node,
            new_parent: *mut kernfs_node,
            new_name: *const c_types::c_char,
        ) -> c_types::c_int,
    >,
    pub show_path: ::core::option::Option<
        unsafe extern "C" fn(
            sf: *mut seq_file,
            kn: *mut kernfs_node,
            root: *mut kernfs_root,
        ) -> c_types::c_int,
    >,
}
#[test]
fn bindgen_test_layout_kernfs_syscall_ops() {
    assert_eq!(
        ::core::mem::size_of::<kernfs_syscall_ops>(),
        40usize,
        concat!("Size of: ", stringify!(kernfs_syscall_ops))
    );
    assert_eq!(
        ::core::mem::align_of::<kernfs_syscall_ops>(),
        8usize,
        concat!("Alignment of ", stringify!(kernfs_syscall_ops))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<kernfs_syscall_ops>())).show_options as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_syscall_ops),
            "::",
            stringify!(show_options)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_syscall_ops>())).mkdir as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_syscall_ops),
            "::",
            stringify!(mkdir)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_syscall_ops>())).rmdir as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_syscall_ops),
            "::",
            stringify!(rmdir)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_syscall_ops>())).rename as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_syscall_ops),
            "::",
            stringify!(rename)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_syscall_ops>())).show_path as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_syscall_ops),
            "::",
            stringify!(show_path)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kernfs_root {
    pub kn: *mut kernfs_node,
    pub flags: c_types::c_uint,
    pub ino_idr: idr,
    pub last_ino: u32_,
    pub next_generation: u32_,
    pub syscall_ops: *mut kernfs_syscall_ops,
    pub supers: list_head,
    pub deactivate_waitq: wait_queue_head_t,
}
#[test]
fn bindgen_test_layout_kernfs_root() {
    assert_eq!(
        ::core::mem::size_of::<kernfs_root>(),
        96usize,
        concat!("Size of: ", stringify!(kernfs_root))
    );
    assert_eq!(
        ::core::mem::align_of::<kernfs_root>(),
        8usize,
        concat!("Alignment of ", stringify!(kernfs_root))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_root>())).kn as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_root),
            "::",
            stringify!(kn)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_root>())).flags as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_root),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_root>())).ino_idr as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_root),
            "::",
            stringify!(ino_idr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_root>())).last_ino as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_root),
            "::",
            stringify!(last_ino)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_root>())).next_generation as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_root),
            "::",
            stringify!(next_generation)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_root>())).syscall_ops as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_root),
            "::",
            stringify!(syscall_ops)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_root>())).supers as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_root),
            "::",
            stringify!(supers)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_root>())).deactivate_waitq as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_root),
            "::",
            stringify!(deactivate_waitq)
        )
    );
}
impl Default for kernfs_root {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kernfs_open_file {
    pub kn: *mut kernfs_node,
    pub file: *mut file,
    pub seq_file: *mut seq_file,
    pub priv_: *mut c_types::c_void,
    pub mutex: mutex,
    pub prealloc_mutex: mutex,
    pub event: c_types::c_int,
    pub list: list_head,
    pub prealloc_buf: *mut c_types::c_char,
    pub atomic_write_len: usize,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub vm_ops: *const vm_operations_struct,
}
#[test]
fn bindgen_test_layout_kernfs_open_file() {
    assert_eq!(
        ::core::mem::size_of::<kernfs_open_file>(),
        152usize,
        concat!("Size of: ", stringify!(kernfs_open_file))
    );
    assert_eq!(
        ::core::mem::align_of::<kernfs_open_file>(),
        8usize,
        concat!("Alignment of ", stringify!(kernfs_open_file))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_open_file>())).kn as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_open_file),
            "::",
            stringify!(kn)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_open_file>())).file as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_open_file),
            "::",
            stringify!(file)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_open_file>())).seq_file as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_open_file),
            "::",
            stringify!(seq_file)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_open_file>())).priv_ as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_open_file),
            "::",
            stringify!(priv_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_open_file>())).mutex as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_open_file),
            "::",
            stringify!(mutex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<kernfs_open_file>())).prealloc_mutex as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_open_file),
            "::",
            stringify!(prealloc_mutex)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_open_file>())).event as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_open_file),
            "::",
            stringify!(event)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_open_file>())).list as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_open_file),
            "::",
            stringify!(list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_open_file>())).prealloc_buf as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_open_file),
            "::",
            stringify!(prealloc_buf)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<kernfs_open_file>())).atomic_write_len as *const _ as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_open_file),
            "::",
            stringify!(atomic_write_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_open_file>())).vm_ops as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_open_file),
            "::",
            stringify!(vm_ops)
        )
    );
}
impl Default for kernfs_open_file {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl kernfs_open_file {
    #[inline]
    pub fn mmapped(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mmapped(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn released(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_released(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mmapped: bool_,
        released: bool_,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let mmapped: u8 = unsafe { ::core::mem::transmute(mmapped) };
            mmapped as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let released: u8 = unsafe { ::core::mem::transmute(released) };
            released as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kernfs_ops {
    pub open:
        ::core::option::Option<unsafe extern "C" fn(of: *mut kernfs_open_file) -> c_types::c_int>,
    pub release: ::core::option::Option<unsafe extern "C" fn(of: *mut kernfs_open_file)>,
    pub seq_show: ::core::option::Option<
        unsafe extern "C" fn(sf: *mut seq_file, v: *mut c_types::c_void) -> c_types::c_int,
    >,
    pub seq_start: ::core::option::Option<
        unsafe extern "C" fn(sf: *mut seq_file, ppos: *mut loff_t) -> *mut c_types::c_void,
    >,
    pub seq_next: ::core::option::Option<
        unsafe extern "C" fn(
            sf: *mut seq_file,
            v: *mut c_types::c_void,
            ppos: *mut loff_t,
        ) -> *mut c_types::c_void,
    >,
    pub seq_stop:
        ::core::option::Option<unsafe extern "C" fn(sf: *mut seq_file, v: *mut c_types::c_void)>,
    pub read: ::core::option::Option<
        unsafe extern "C" fn(
            of: *mut kernfs_open_file,
            buf: *mut c_types::c_char,
            bytes: usize,
            off: loff_t,
        ) -> isize,
    >,
    pub atomic_write_len: usize,
    pub prealloc: bool_,
    pub write: ::core::option::Option<
        unsafe extern "C" fn(
            of: *mut kernfs_open_file,
            buf: *mut c_types::c_char,
            bytes: usize,
            off: loff_t,
        ) -> isize,
    >,
    pub poll: ::core::option::Option<
        unsafe extern "C" fn(of: *mut kernfs_open_file, pt: *mut poll_table_struct) -> __poll_t,
    >,
    pub mmap: ::core::option::Option<
        unsafe extern "C" fn(of: *mut kernfs_open_file, vma: *mut vm_area_struct) -> c_types::c_int,
    >,
}
#[test]
fn bindgen_test_layout_kernfs_ops() {
    assert_eq!(
        ::core::mem::size_of::<kernfs_ops>(),
        96usize,
        concat!("Size of: ", stringify!(kernfs_ops))
    );
    assert_eq!(
        ::core::mem::align_of::<kernfs_ops>(),
        8usize,
        concat!("Alignment of ", stringify!(kernfs_ops))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_ops>())).open as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_ops),
            "::",
            stringify!(open)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_ops>())).release as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_ops),
            "::",
            stringify!(release)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_ops>())).seq_show as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_ops),
            "::",
            stringify!(seq_show)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_ops>())).seq_start as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_ops),
            "::",
            stringify!(seq_start)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_ops>())).seq_next as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_ops),
            "::",
            stringify!(seq_next)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_ops>())).seq_stop as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_ops),
            "::",
            stringify!(seq_stop)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_ops>())).read as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_ops),
            "::",
            stringify!(read)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_ops>())).atomic_write_len as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_ops),
            "::",
            stringify!(atomic_write_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_ops>())).prealloc as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_ops),
            "::",
            stringify!(prealloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_ops>())).write as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_ops),
            "::",
            stringify!(write)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_ops>())).poll as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_ops),
            "::",
            stringify!(poll)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_ops>())).mmap as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_ops),
            "::",
            stringify!(mmap)
        )
    );
}
pub const kobj_ns_type_KOBJ_NS_TYPE_NONE: kobj_ns_type = 0;
pub const kobj_ns_type_KOBJ_NS_TYPE_NET: kobj_ns_type = 1;
pub const kobj_ns_type_KOBJ_NS_TYPES: kobj_ns_type = 2;
pub type kobj_ns_type = c_types::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kobj_ns_type_operations {
    pub type_: kobj_ns_type,
    pub current_may_mount: ::core::option::Option<unsafe extern "C" fn() -> bool_>,
    pub grab_current_ns: ::core::option::Option<unsafe extern "C" fn() -> *mut c_types::c_void>,
    pub netlink_ns:
        ::core::option::Option<unsafe extern "C" fn(sk: *mut sock) -> *const c_types::c_void>,
    pub initial_ns: ::core::option::Option<unsafe extern "C" fn() -> *const c_types::c_void>,
    pub drop_ns: ::core::option::Option<unsafe extern "C" fn(arg1: *mut c_types::c_void)>,
}
#[test]
fn bindgen_test_layout_kobj_ns_type_operations() {
    assert_eq!(
        ::core::mem::size_of::<kobj_ns_type_operations>(),
        48usize,
        concat!("Size of: ", stringify!(kobj_ns_type_operations))
    );
    assert_eq!(
        ::core::mem::align_of::<kobj_ns_type_operations>(),
        8usize,
        concat!("Alignment of ", stringify!(kobj_ns_type_operations))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kobj_ns_type_operations>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kobj_ns_type_operations),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<kobj_ns_type_operations>())).current_may_mount as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(kobj_ns_type_operations),
            "::",
            stringify!(current_may_mount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<kobj_ns_type_operations>())).grab_current_ns as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(kobj_ns_type_operations),
            "::",
            stringify!(grab_current_ns)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<kobj_ns_type_operations>())).netlink_ns as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(kobj_ns_type_operations),
            "::",
            stringify!(netlink_ns)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<kobj_ns_type_operations>())).initial_ns as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(kobj_ns_type_operations),
            "::",
            stringify!(initial_ns)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<kobj_ns_type_operations>())).drop_ns as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(kobj_ns_type_operations),
            "::",
            stringify!(drop_ns)
        )
    );
}
impl Default for kobj_ns_type_operations {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct attribute {
    pub name: *const c_types::c_char,
    pub mode: umode_t,
}
#[test]
fn bindgen_test_layout_attribute() {
    assert_eq!(
        ::core::mem::size_of::<attribute>(),
        16usize,
        concat!("Size of: ", stringify!(attribute))
    );
    assert_eq!(
        ::core::mem::align_of::<attribute>(),
        8usize,
        concat!("Alignment of ", stringify!(attribute))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<attribute>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(attribute),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<attribute>())).mode as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(attribute),
            "::",
            stringify!(mode)
        )
    );
}
impl Default for attribute {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[doc = " struct attribute_group - data structure used to declare an attribute group."]
#[doc = " @name:\tOptional: Attribute group name"]
#[doc = "\t\tIf specified, the attribute group will be created in"]
#[doc = "\t\ta new subdirectory with this name."]
#[doc = " @is_visible:\tOptional: Function to return permissions associated with an"]
#[doc = "\t\tattribute of the group. Will be called repeatedly for each"]
#[doc = "\t\tnon-binary attribute in the group. Only read/write"]
#[doc = "\t\tpermissions as well as SYSFS_PREALLOC are accepted. Must"]
#[doc = "\t\treturn 0 if an attribute is not visible. The returned value"]
#[doc = "\t\twill replace static permissions defined in struct attribute."]
#[doc = " @is_bin_visible:"]
#[doc = "\t\tOptional: Function to return permissions associated with a"]
#[doc = "\t\tbinary attribute of the group. Will be called repeatedly"]
#[doc = "\t\tfor each binary attribute in the group. Only read/write"]
#[doc = "\t\tpermissions as well as SYSFS_PREALLOC are accepted. Must"]
#[doc = "\t\treturn 0 if a binary attribute is not visible. The returned"]
#[doc = "\t\tvalue will replace static permissions defined in"]
#[doc = "\t\tstruct bin_attribute."]
#[doc = " @attrs:\tPointer to NULL terminated list of attributes."]
#[doc = " @bin_attrs:\tPointer to NULL terminated list of binary attributes."]
#[doc = "\t\tEither attrs or bin_attrs or both must be provided."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct attribute_group {
    pub name: *const c_types::c_char,
    pub is_visible: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut kobject,
            arg2: *mut attribute,
            arg3: c_types::c_int,
        ) -> umode_t,
    >,
    pub is_bin_visible: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut kobject,
            arg2: *mut bin_attribute,
            arg3: c_types::c_int,
        ) -> umode_t,
    >,
    pub attrs: *mut *mut attribute,
    pub bin_attrs: *mut *mut bin_attribute,
}
#[test]
fn bindgen_test_layout_attribute_group() {
    assert_eq!(
        ::core::mem::size_of::<attribute_group>(),
        40usize,
        concat!("Size of: ", stringify!(attribute_group))
    );
    assert_eq!(
        ::core::mem::align_of::<attribute_group>(),
        8usize,
        concat!("Alignment of ", stringify!(attribute_group))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<attribute_group>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(attribute_group),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<attribute_group>())).is_visible as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(attribute_group),
            "::",
            stringify!(is_visible)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<attribute_group>())).is_bin_visible as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(attribute_group),
            "::",
            stringify!(is_bin_visible)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<attribute_group>())).attrs as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(attribute_group),
            "::",
            stringify!(attrs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<attribute_group>())).bin_attrs as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(attribute_group),
            "::",
            stringify!(bin_attrs)
        )
    );
}
impl Default for attribute_group {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bin_attribute {
    pub attr: attribute,
    pub size: usize,
    pub private: *mut c_types::c_void,
    pub read: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: *mut kobject,
            arg3: *mut bin_attribute,
            arg4: *mut c_types::c_char,
            arg5: loff_t,
            arg6: usize,
        ) -> isize,
    >,
    pub write: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: *mut kobject,
            arg3: *mut bin_attribute,
            arg4: *mut c_types::c_char,
            arg5: loff_t,
            arg6: usize,
        ) -> isize,
    >,
    pub mmap: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: *mut kobject,
            attr: *mut bin_attribute,
            vma: *mut vm_area_struct,
        ) -> c_types::c_int,
    >,
}
#[test]
fn bindgen_test_layout_bin_attribute() {
    assert_eq!(
        ::core::mem::size_of::<bin_attribute>(),
        56usize,
        concat!("Size of: ", stringify!(bin_attribute))
    );
    assert_eq!(
        ::core::mem::align_of::<bin_attribute>(),
        8usize,
        concat!("Alignment of ", stringify!(bin_attribute))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bin_attribute>())).attr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bin_attribute),
            "::",
            stringify!(attr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bin_attribute>())).size as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(bin_attribute),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bin_attribute>())).private as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(bin_attribute),
            "::",
            stringify!(private)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bin_attribute>())).read as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(bin_attribute),
            "::",
            stringify!(read)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bin_attribute>())).write as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(bin_attribute),
            "::",
            stringify!(write)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bin_attribute>())).mmap as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(bin_attribute),
            "::",
            stringify!(mmap)
        )
    );
}
impl Default for bin_attribute {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct sysfs_ops {
    pub show: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut kobject,
            arg2: *mut attribute,
            arg3: *mut c_types::c_char,
        ) -> isize,
    >,
    pub store: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut kobject,
            arg2: *mut attribute,
            arg3: *const c_types::c_char,
            arg4: usize,
        ) -> isize,
    >,
}
#[test]
fn bindgen_test_layout_sysfs_ops() {
    assert_eq!(
        ::core::mem::size_of::<sysfs_ops>(),
        16usize,
        concat!("Size of: ", stringify!(sysfs_ops))
    );
    assert_eq!(
        ::core::mem::align_of::<sysfs_ops>(),
        8usize,
        concat!("Alignment of ", stringify!(sysfs_ops))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sysfs_ops>())).show as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sysfs_ops),
            "::",
            stringify!(show)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sysfs_ops>())).store as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sysfs_ops),
            "::",
            stringify!(store)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kref {
    pub refcount: refcount_t,
}
#[test]
fn bindgen_test_layout_kref() {
    assert_eq!(
        ::core::mem::size_of::<kref>(),
        4usize,
        concat!("Size of: ", stringify!(kref))
    );
    assert_eq!(
        ::core::mem::align_of::<kref>(),
        4usize,
        concat!("Alignment of ", stringify!(kref))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kref>())).refcount as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kref),
            "::",
            stringify!(refcount)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kobject {
    pub name: *const c_types::c_char,
    pub entry: list_head,
    pub parent: *mut kobject,
    pub kset: *mut kset,
    pub ktype: *mut kobj_type,
    pub sd: *mut kernfs_node,
    pub kref: kref,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_kobject() {
    assert_eq!(
        ::core::mem::size_of::<kobject>(),
        64usize,
        concat!("Size of: ", stringify!(kobject))
    );
    assert_eq!(
        ::core::mem::align_of::<kobject>(),
        8usize,
        concat!("Alignment of ", stringify!(kobject))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kobject>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kobject),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kobject>())).entry as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(kobject),
            "::",
            stringify!(entry)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kobject>())).parent as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(kobject),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kobject>())).kset as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(kobject),
            "::",
            stringify!(kset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kobject>())).ktype as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(kobject),
            "::",
            stringify!(ktype)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kobject>())).sd as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(kobject),
            "::",
            stringify!(sd)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kobject>())).kref as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(kobject),
            "::",
            stringify!(kref)
        )
    );
}
impl Default for kobject {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl kobject {
    #[inline]
    pub fn state_initialized(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_state_initialized(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn state_in_sysfs(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_state_in_sysfs(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn state_add_uevent_sent(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_state_add_uevent_sent(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn state_remove_uevent_sent(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_state_remove_uevent_sent(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn uevent_suppress(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_uevent_suppress(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        state_initialized: c_types::c_uint,
        state_in_sysfs: c_types::c_uint,
        state_add_uevent_sent: c_types::c_uint,
        state_remove_uevent_sent: c_types::c_uint,
        uevent_suppress: c_types::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let state_initialized: u32 = unsafe { ::core::mem::transmute(state_initialized) };
            state_initialized as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let state_in_sysfs: u32 = unsafe { ::core::mem::transmute(state_in_sysfs) };
            state_in_sysfs as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let state_add_uevent_sent: u32 =
                unsafe { ::core::mem::transmute(state_add_uevent_sent) };
            state_add_uevent_sent as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let state_remove_uevent_sent: u32 =
                unsafe { ::core::mem::transmute(state_remove_uevent_sent) };
            state_remove_uevent_sent as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let uevent_suppress: u32 = unsafe { ::core::mem::transmute(uevent_suppress) };
            uevent_suppress as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kobj_type {
    pub release: ::core::option::Option<unsafe extern "C" fn(kobj: *mut kobject)>,
    pub sysfs_ops: *const sysfs_ops,
    pub default_attrs: *mut *mut attribute,
    pub default_groups: *mut *const attribute_group,
    pub child_ns_type: ::core::option::Option<
        unsafe extern "C" fn(kobj: *mut kobject) -> *const kobj_ns_type_operations,
    >,
    pub namespace:
        ::core::option::Option<unsafe extern "C" fn(kobj: *mut kobject) -> *const c_types::c_void>,
    pub get_ownership: ::core::option::Option<
        unsafe extern "C" fn(kobj: *mut kobject, uid: *mut kuid_t, gid: *mut kgid_t),
    >,
}
#[test]
fn bindgen_test_layout_kobj_type() {
    assert_eq!(
        ::core::mem::size_of::<kobj_type>(),
        56usize,
        concat!("Size of: ", stringify!(kobj_type))
    );
    assert_eq!(
        ::core::mem::align_of::<kobj_type>(),
        8usize,
        concat!("Alignment of ", stringify!(kobj_type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kobj_type>())).release as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kobj_type),
            "::",
            stringify!(release)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kobj_type>())).sysfs_ops as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(kobj_type),
            "::",
            stringify!(sysfs_ops)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kobj_type>())).default_attrs as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(kobj_type),
            "::",
            stringify!(default_attrs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kobj_type>())).default_groups as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(kobj_type),
            "::",
            stringify!(default_groups)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kobj_type>())).child_ns_type as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(kobj_type),
            "::",
            stringify!(child_ns_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kobj_type>())).namespace as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(kobj_type),
            "::",
            stringify!(namespace)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kobj_type>())).get_ownership as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(kobj_type),
            "::",
            stringify!(get_ownership)
        )
    );
}
impl Default for kobj_type {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kobj_uevent_env {
    pub argv: [*mut c_types::c_char; 3usize],
    pub envp: [*mut c_types::c_char; 32usize],
    pub envp_idx: c_types::c_int,
    pub buf: [c_types::c_char; 2048usize],
    pub buflen: c_types::c_int,
}
#[test]
fn bindgen_test_layout_kobj_uevent_env() {
    assert_eq!(
        ::core::mem::size_of::<kobj_uevent_env>(),
        2336usize,
        concat!("Size of: ", stringify!(kobj_uevent_env))
    );
    assert_eq!(
        ::core::mem::align_of::<kobj_uevent_env>(),
        8usize,
        concat!("Alignment of ", stringify!(kobj_uevent_env))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kobj_uevent_env>())).argv as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kobj_uevent_env),
            "::",
            stringify!(argv)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kobj_uevent_env>())).envp as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(kobj_uevent_env),
            "::",
            stringify!(envp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kobj_uevent_env>())).envp_idx as *const _ as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(kobj_uevent_env),
            "::",
            stringify!(envp_idx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kobj_uevent_env>())).buf as *const _ as usize },
        284usize,
        concat!(
            "Offset of field: ",
            stringify!(kobj_uevent_env),
            "::",
            stringify!(buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kobj_uevent_env>())).buflen as *const _ as usize },
        2332usize,
        concat!(
            "Offset of field: ",
            stringify!(kobj_uevent_env),
            "::",
            stringify!(buflen)
        )
    );
}
impl Default for kobj_uevent_env {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kset_uevent_ops {
    pub filter: ::core::option::Option<
        unsafe extern "C" fn(kset: *mut kset, kobj: *mut kobject) -> c_types::c_int,
    >,
    pub name: ::core::option::Option<
        unsafe extern "C" fn(kset: *mut kset, kobj: *mut kobject) -> *const c_types::c_char,
    >,
    pub uevent: ::core::option::Option<
        unsafe extern "C" fn(
            kset: *mut kset,
            kobj: *mut kobject,
            env: *mut kobj_uevent_env,
        ) -> c_types::c_int,
    >,
}
#[test]
fn bindgen_test_layout_kset_uevent_ops() {
    assert_eq!(
        ::core::mem::size_of::<kset_uevent_ops>(),
        24usize,
        concat!("Size of: ", stringify!(kset_uevent_ops))
    );
    assert_eq!(
        ::core::mem::align_of::<kset_uevent_ops>(),
        8usize,
        concat!("Alignment of ", stringify!(kset_uevent_ops))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kset_uevent_ops>())).filter as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kset_uevent_ops),
            "::",
            stringify!(filter)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kset_uevent_ops>())).name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(kset_uevent_ops),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kset_uevent_ops>())).uevent as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(kset_uevent_ops),
            "::",
            stringify!(uevent)
        )
    );
}
#[doc = " struct kset - a set of kobjects of a specific type, belonging to a specific subsystem."]
#[doc = ""]
#[doc = " A kset defines a group of kobjects.  They can be individually"]
#[doc = " different \"types\" but overall these kobjects all want to be grouped"]
#[doc = " together and operated on in the same manner.  ksets are used to"]
#[doc = " define the attribute callbacks and other common events that happen to"]
#[doc = " a kobject."]
#[doc = ""]
#[doc = " @list: the list of all kobjects for this kset"]
#[doc = " @list_lock: a lock for iterating over the kobjects"]
#[doc = " @kobj: the embedded kobject for this kset (recursion, isn't it fun...)"]
#[doc = " @uevent_ops: the set of uevent operations for this kset.  These are"]
#[doc = " called whenever a kobject has something happen to it so that the kset"]
#[doc = " can add new environment variables, or filter out the uevents if so"]
#[doc = " desired."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kset {
    pub list: list_head,
    pub list_lock: spinlock_t,
    pub kobj: kobject,
    pub uevent_ops: *const kset_uevent_ops,
}
#[test]
fn bindgen_test_layout_kset() {
    assert_eq!(
        ::core::mem::size_of::<kset>(),
        96usize,
        concat!("Size of: ", stringify!(kset))
    );
    assert_eq!(
        ::core::mem::align_of::<kset>(),
        8usize,
        concat!("Alignment of ", stringify!(kset))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kset>())).list as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kset),
            "::",
            stringify!(list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kset>())).list_lock as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(kset),
            "::",
            stringify!(list_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kset>())).kobj as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(kset),
            "::",
            stringify!(kobj)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kset>())).uevent_ops as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(kset),
            "::",
            stringify!(uevent_ops)
        )
    );
}
impl Default for kset {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct pm_message {
    pub event: c_types::c_int,
}
#[test]
fn bindgen_test_layout_pm_message() {
    assert_eq!(
        ::core::mem::size_of::<pm_message>(),
        4usize,
        concat!("Size of: ", stringify!(pm_message))
    );
    assert_eq!(
        ::core::mem::align_of::<pm_message>(),
        4usize,
        concat!("Alignment of ", stringify!(pm_message))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pm_message>())).event as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pm_message),
            "::",
            stringify!(event)
        )
    );
}
pub type pm_message_t = pm_message;
#[doc = " struct dev_pm_ops - device PM callbacks."]
#[doc = ""]
#[doc = " @prepare: The principal role of this callback is to prevent new children of"]
#[doc = "\tthe device from being registered after it has returned (the driver's"]
#[doc = "\tsubsystem and generally the rest of the kernel is supposed to prevent"]
#[doc = "\tnew calls to the probe method from being made too once @prepare() has"]
#[doc = "\tsucceeded).  If @prepare() detects a situation it cannot handle (e.g."]
#[doc = "\tregistration of a child already in progress), it may return -EAGAIN, so"]
#[doc = "\tthat the PM core can execute it once again (e.g. after a new child has"]
#[doc = "\tbeen registered) to recover from the race condition."]
#[doc = "\tThis method is executed for all kinds of suspend transitions and is"]
#[doc = "\tfollowed by one of the suspend callbacks: @suspend(), @freeze(), or"]
#[doc = "\t@poweroff().  If the transition is a suspend to memory or standby (that"]
#[doc = "\tis, not related to hibernation), the return value of @prepare() may be"]
#[doc = "\tused to indicate to the PM core to leave the device in runtime suspend"]
#[doc = "\tif applicable.  Namely, if @prepare() returns a positive number, the PM"]
#[doc = "\tcore will understand that as a declaration that the device appears to be"]
#[doc = "\truntime-suspended and it may be left in that state during the entire"]
#[doc = "\ttransition and during the subsequent resume if all of its descendants"]
#[doc = "\tare left in runtime suspend too.  If that happens, @complete() will be"]
#[doc = "\texecuted directly after @prepare() and it must ensure the proper"]
#[doc = "\tfunctioning of the device after the system resume."]
#[doc = "\tThe PM core executes subsystem-level @prepare() for all devices before"]
#[doc = "\tstarting to invoke suspend callbacks for any of them, so generally"]
#[doc = "\tdevices may be assumed to be functional or to respond to runtime resume"]
#[doc = "\trequests while @prepare() is being executed.  However, device drivers"]
#[doc = "\tmay NOT assume anything about the availability of user space at that"]
#[doc = "\ttime and it is NOT valid to request firmware from within @prepare()"]
#[doc = "\t(it's too late to do that).  It also is NOT valid to allocate"]
#[doc = "\tsubstantial amounts of memory from @prepare() in the GFP_KERNEL mode."]
#[doc = "\t[To work around these limitations, drivers may register suspend and"]
#[doc = "\thibernation notifiers to be executed before the freezing of tasks.]"]
#[doc = ""]
#[doc = " @complete: Undo the changes made by @prepare().  This method is executed for"]
#[doc = "\tall kinds of resume transitions, following one of the resume callbacks:"]
#[doc = "\t@resume(), @thaw(), @restore().  Also called if the state transition"]
#[doc = "\tfails before the driver's suspend callback: @suspend(), @freeze() or"]
#[doc = "\t@poweroff(), can be executed (e.g. if the suspend callback fails for one"]
#[doc = "\tof the other devices that the PM core has unsuccessfully attempted to"]
#[doc = "\tsuspend earlier)."]
#[doc = "\tThe PM core executes subsystem-level @complete() after it has executed"]
#[doc = "\tthe appropriate resume callbacks for all devices.  If the corresponding"]
#[doc = "\t@prepare() at the beginning of the suspend transition returned a"]
#[doc = "\tpositive number and the device was left in runtime suspend (without"]
#[doc = "\texecuting any suspend and resume callbacks for it), @complete() will be"]
#[doc = "\tthe only callback executed for the device during resume.  In that case,"]
#[doc = "\t@complete() must be prepared to do whatever is necessary to ensure the"]
#[doc = "\tproper functioning of the device after the system resume.  To this end,"]
#[doc = "\t@complete() can check the power.direct_complete flag of the device to"]
#[doc = "\tlearn whether (unset) or not (set) the previous suspend and resume"]
#[doc = "\tcallbacks have been executed for it."]
#[doc = ""]
#[doc = " @suspend: Executed before putting the system into a sleep state in which the"]
#[doc = "\tcontents of main memory are preserved.  The exact action to perform"]
#[doc = "\tdepends on the device's subsystem (PM domain, device type, class or bus"]
#[doc = "\ttype), but generally the device must be quiescent after subsystem-level"]
#[doc = "\t@suspend() has returned, so that it doesn't do any I/O or DMA."]
#[doc = "\tSubsystem-level @suspend() is executed for all devices after invoking"]
#[doc = "\tsubsystem-level @prepare() for all of them."]
#[doc = ""]
#[doc = " @suspend_late: Continue operations started by @suspend().  For a number of"]
#[doc = "\tdevices @suspend_late() may point to the same callback routine as the"]
#[doc = "\truntime suspend callback."]
#[doc = ""]
#[doc = " @resume: Executed after waking the system up from a sleep state in which the"]
#[doc = "\tcontents of main memory were preserved.  The exact action to perform"]
#[doc = "\tdepends on the device's subsystem, but generally the driver is expected"]
#[doc = "\tto start working again, responding to hardware events and software"]
#[doc = "\trequests (the device itself may be left in a low-power state, waiting"]
#[doc = "\tfor a runtime resume to occur).  The state of the device at the time its"]
#[doc = "\tdriver's @resume() callback is run depends on the platform and subsystem"]
#[doc = "\tthe device belongs to.  On most platforms, there are no restrictions on"]
#[doc = "\tavailability of resources like clocks during @resume()."]
#[doc = "\tSubsystem-level @resume() is executed for all devices after invoking"]
#[doc = "\tsubsystem-level @resume_noirq() for all of them."]
#[doc = ""]
#[doc = " @resume_early: Prepare to execute @resume().  For a number of devices"]
#[doc = "\t@resume_early() may point to the same callback routine as the runtime"]
#[doc = "\tresume callback."]
#[doc = ""]
#[doc = " @freeze: Hibernation-specific, executed before creating a hibernation image."]
#[doc = "\tAnalogous to @suspend(), but it should not enable the device to signal"]
#[doc = "\twakeup events or change its power state.  The majority of subsystems"]
#[doc = "\t(with the notable exception of the PCI bus type) expect the driver-level"]
#[doc = "\t@freeze() to save the device settings in memory to be used by @restore()"]
#[doc = "\tduring the subsequent resume from hibernation."]
#[doc = "\tSubsystem-level @freeze() is executed for all devices after invoking"]
#[doc = "\tsubsystem-level @prepare() for all of them."]
#[doc = ""]
#[doc = " @freeze_late: Continue operations started by @freeze().  Analogous to"]
#[doc = "\t@suspend_late(), but it should not enable the device to signal wakeup"]
#[doc = "\tevents or change its power state."]
#[doc = ""]
#[doc = " @thaw: Hibernation-specific, executed after creating a hibernation image OR"]
#[doc = "\tif the creation of an image has failed.  Also executed after a failing"]
#[doc = "\tattempt to restore the contents of main memory from such an image."]
#[doc = "\tUndo the changes made by the preceding @freeze(), so the device can be"]
#[doc = "\toperated in the same way as immediately before the call to @freeze()."]
#[doc = "\tSubsystem-level @thaw() is executed for all devices after invoking"]
#[doc = "\tsubsystem-level @thaw_noirq() for all of them.  It also may be executed"]
#[doc = "\tdirectly after @freeze() in case of a transition error."]
#[doc = ""]
#[doc = " @thaw_early: Prepare to execute @thaw().  Undo the changes made by the"]
#[doc = "\tpreceding @freeze_late()."]
#[doc = ""]
#[doc = " @poweroff: Hibernation-specific, executed after saving a hibernation image."]
#[doc = "\tAnalogous to @suspend(), but it need not save the device's settings in"]
#[doc = "\tmemory."]
#[doc = "\tSubsystem-level @poweroff() is executed for all devices after invoking"]
#[doc = "\tsubsystem-level @prepare() for all of them."]
#[doc = ""]
#[doc = " @poweroff_late: Continue operations started by @poweroff().  Analogous to"]
#[doc = "\t@suspend_late(), but it need not save the device's settings in memory."]
#[doc = ""]
#[doc = " @restore: Hibernation-specific, executed after restoring the contents of main"]
#[doc = "\tmemory from a hibernation image, analogous to @resume()."]
#[doc = ""]
#[doc = " @restore_early: Prepare to execute @restore(), analogous to @resume_early()."]
#[doc = ""]
#[doc = " @suspend_noirq: Complete the actions started by @suspend().  Carry out any"]
#[doc = "\tadditional operations required for suspending the device that might be"]
#[doc = "\tracing with its driver's interrupt handler, which is guaranteed not to"]
#[doc = "\trun while @suspend_noirq() is being executed."]
#[doc = "\tIt generally is expected that the device will be in a low-power state"]
#[doc = "\t(appropriate for the target system sleep state) after subsystem-level"]
#[doc = "\t@suspend_noirq() has returned successfully.  If the device can generate"]
#[doc = "\tsystem wakeup signals and is enabled to wake up the system, it should be"]
#[doc = "\tconfigured to do so at that time.  However, depending on the platform"]
#[doc = "\tand device's subsystem, @suspend() or @suspend_late() may be allowed to"]
#[doc = "\tput the device into the low-power state and configure it to generate"]
#[doc = "\twakeup signals, in which case it generally is not necessary to define"]
#[doc = "\t@suspend_noirq()."]
#[doc = ""]
#[doc = " @resume_noirq: Prepare for the execution of @resume() by carrying out any"]
#[doc = "\toperations required for resuming the device that might be racing with"]
#[doc = "\tits driver's interrupt handler, which is guaranteed not to run while"]
#[doc = "\t@resume_noirq() is being executed."]
#[doc = ""]
#[doc = " @freeze_noirq: Complete the actions started by @freeze().  Carry out any"]
#[doc = "\tadditional operations required for freezing the device that might be"]
#[doc = "\tracing with its driver's interrupt handler, which is guaranteed not to"]
#[doc = "\trun while @freeze_noirq() is being executed."]
#[doc = "\tThe power state of the device should not be changed by either @freeze(),"]
#[doc = "\tor @freeze_late(), or @freeze_noirq() and it should not be configured to"]
#[doc = "\tsignal system wakeup by any of these callbacks."]
#[doc = ""]
#[doc = " @thaw_noirq: Prepare for the execution of @thaw() by carrying out any"]
#[doc = "\toperations required for thawing the device that might be racing with its"]
#[doc = "\tdriver's interrupt handler, which is guaranteed not to run while"]
#[doc = "\t@thaw_noirq() is being executed."]
#[doc = ""]
#[doc = " @poweroff_noirq: Complete the actions started by @poweroff().  Analogous to"]
#[doc = "\t@suspend_noirq(), but it need not save the device's settings in memory."]
#[doc = ""]
#[doc = " @restore_noirq: Prepare for the execution of @restore() by carrying out any"]
#[doc = "\toperations required for thawing the device that might be racing with its"]
#[doc = "\tdriver's interrupt handler, which is guaranteed not to run while"]
#[doc = "\t@restore_noirq() is being executed.  Analogous to @resume_noirq()."]
#[doc = ""]
#[doc = " @runtime_suspend: Prepare the device for a condition in which it won't be"]
#[doc = "\table to communicate with the CPU(s) and RAM due to power management."]
#[doc = "\tThis need not mean that the device should be put into a low-power state."]
#[doc = "\tFor example, if the device is behind a link which is about to be turned"]
#[doc = "\toff, the device may remain at full power.  If the device does go to low"]
#[doc = "\tpower and is capable of generating runtime wakeup events, remote wakeup"]
#[doc = "\t(i.e., a hardware mechanism allowing the device to request a change of"]
#[doc = "\tits power state via an interrupt) should be enabled for it."]
#[doc = ""]
#[doc = " @runtime_resume: Put the device into the fully active state in response to a"]
#[doc = "\twakeup event generated by hardware or at the request of software.  If"]
#[doc = "\tnecessary, put the device into the full-power state and restore its"]
#[doc = "\tregisters, so that it is fully operational."]
#[doc = ""]
#[doc = " @runtime_idle: Device appears to be inactive and it might be put into a"]
#[doc = "\tlow-power state if all of the necessary conditions are satisfied."]
#[doc = "\tCheck these conditions, and return 0 if it's appropriate to let the PM"]
#[doc = "\tcore queue a suspend request for the device."]
#[doc = ""]
#[doc = " Several device power state transitions are externally visible, affecting"]
#[doc = " the state of pending I/O queues and (for drivers that touch hardware)"]
#[doc = " interrupts, wakeups, DMA, and other hardware state.  There may also be"]
#[doc = " internal transitions to various low-power modes which are transparent"]
#[doc = " to the rest of the driver stack (such as a driver that's ON gating off"]
#[doc = " clocks which are not in active use)."]
#[doc = ""]
#[doc = " The externally visible transitions are handled with the help of callbacks"]
#[doc = " included in this structure in such a way that, typically, two levels of"]
#[doc = " callbacks are involved.  First, the PM core executes callbacks provided by PM"]
#[doc = " domains, device types, classes and bus types.  They are the subsystem-level"]
#[doc = " callbacks expected to execute callbacks provided by device drivers, although"]
#[doc = " they may choose not to do that.  If the driver callbacks are executed, they"]
#[doc = " have to collaborate with the subsystem-level callbacks to achieve the goals"]
#[doc = " appropriate for the given system transition, given transition phase and the"]
#[doc = " subsystem the device belongs to."]
#[doc = ""]
#[doc = " All of the above callbacks, except for @complete(), return error codes."]
#[doc = " However, the error codes returned by @resume(), @thaw(), @restore(),"]
#[doc = " @resume_noirq(), @thaw_noirq(), and @restore_noirq(), do not cause the PM"]
#[doc = " core to abort the resume transition during which they are returned.  The"]
#[doc = " error codes returned in those cases are only printed to the system logs for"]
#[doc = " debugging purposes.  Still, it is recommended that drivers only return error"]
#[doc = " codes from their resume methods in case of an unrecoverable failure (i.e."]
#[doc = " when the device being handled refuses to resume and becomes unusable) to"]
#[doc = " allow the PM core to be modified in the future, so that it can avoid"]
#[doc = " attempting to handle devices that failed to resume and their children."]
#[doc = ""]
#[doc = " It is allowed to unregister devices while the above callbacks are being"]
#[doc = " executed.  However, a callback routine MUST NOT try to unregister the device"]
#[doc = " it was called for, although it may unregister children of that device (for"]
#[doc = " example, if it detects that a child was unplugged while the system was"]
#[doc = " asleep)."]
#[doc = ""]
#[doc = " There also are callbacks related to runtime power management of devices."]
#[doc = " Again, as a rule these callbacks are executed by the PM core for subsystems"]
#[doc = " (PM domains, device types, classes and bus types) and the subsystem-level"]
#[doc = " callbacks are expected to invoke the driver callbacks.  Moreover, the exact"]
#[doc = " actions to be performed by a device driver's callbacks generally depend on"]
#[doc = " the platform and subsystem the device belongs to."]
#[doc = ""]
#[doc = " Refer to Documentation/power/runtime_pm.rst for more information about the"]
#[doc = " role of the @runtime_suspend(), @runtime_resume() and @runtime_idle()"]
#[doc = " callbacks in device runtime power management."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct dev_pm_ops {
    pub prepare: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> c_types::c_int>,
    pub complete: ::core::option::Option<unsafe extern "C" fn(dev: *mut device)>,
    pub suspend: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> c_types::c_int>,
    pub resume: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> c_types::c_int>,
    pub freeze: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> c_types::c_int>,
    pub thaw: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> c_types::c_int>,
    pub poweroff: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> c_types::c_int>,
    pub restore: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> c_types::c_int>,
    pub suspend_late:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> c_types::c_int>,
    pub resume_early:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> c_types::c_int>,
    pub freeze_late:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> c_types::c_int>,
    pub thaw_early:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> c_types::c_int>,
    pub poweroff_late:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> c_types::c_int>,
    pub restore_early:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> c_types::c_int>,
    pub suspend_noirq:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> c_types::c_int>,
    pub resume_noirq:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> c_types::c_int>,
    pub freeze_noirq:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> c_types::c_int>,
    pub thaw_noirq:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> c_types::c_int>,
    pub poweroff_noirq:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> c_types::c_int>,
    pub restore_noirq:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> c_types::c_int>,
    pub runtime_suspend:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> c_types::c_int>,
    pub runtime_resume:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> c_types::c_int>,
    pub runtime_idle:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> c_types::c_int>,
}
#[test]
fn bindgen_test_layout_dev_pm_ops() {
    assert_eq!(
        ::core::mem::size_of::<dev_pm_ops>(),
        184usize,
        concat!("Size of: ", stringify!(dev_pm_ops))
    );
    assert_eq!(
        ::core::mem::align_of::<dev_pm_ops>(),
        8usize,
        concat!("Alignment of ", stringify!(dev_pm_ops))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dev_pm_ops>())).prepare as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_pm_ops),
            "::",
            stringify!(prepare)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dev_pm_ops>())).complete as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_pm_ops),
            "::",
            stringify!(complete)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dev_pm_ops>())).suspend as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_pm_ops),
            "::",
            stringify!(suspend)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dev_pm_ops>())).resume as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_pm_ops),
            "::",
            stringify!(resume)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dev_pm_ops>())).freeze as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_pm_ops),
            "::",
            stringify!(freeze)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dev_pm_ops>())).thaw as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_pm_ops),
            "::",
            stringify!(thaw)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dev_pm_ops>())).poweroff as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_pm_ops),
            "::",
            stringify!(poweroff)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dev_pm_ops>())).restore as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_pm_ops),
            "::",
            stringify!(restore)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dev_pm_ops>())).suspend_late as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_pm_ops),
            "::",
            stringify!(suspend_late)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dev_pm_ops>())).resume_early as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_pm_ops),
            "::",
            stringify!(resume_early)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dev_pm_ops>())).freeze_late as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_pm_ops),
            "::",
            stringify!(freeze_late)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dev_pm_ops>())).thaw_early as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_pm_ops),
            "::",
            stringify!(thaw_early)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dev_pm_ops>())).poweroff_late as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_pm_ops),
            "::",
            stringify!(poweroff_late)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dev_pm_ops>())).restore_early as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_pm_ops),
            "::",
            stringify!(restore_early)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dev_pm_ops>())).suspend_noirq as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_pm_ops),
            "::",
            stringify!(suspend_noirq)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dev_pm_ops>())).resume_noirq as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_pm_ops),
            "::",
            stringify!(resume_noirq)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dev_pm_ops>())).freeze_noirq as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_pm_ops),
            "::",
            stringify!(freeze_noirq)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dev_pm_ops>())).thaw_noirq as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_pm_ops),
            "::",
            stringify!(thaw_noirq)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dev_pm_ops>())).poweroff_noirq as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_pm_ops),
            "::",
            stringify!(poweroff_noirq)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dev_pm_ops>())).restore_noirq as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_pm_ops),
            "::",
            stringify!(restore_noirq)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dev_pm_ops>())).runtime_suspend as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_pm_ops),
            "::",
            stringify!(runtime_suspend)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dev_pm_ops>())).runtime_resume as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_pm_ops),
            "::",
            stringify!(runtime_resume)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dev_pm_ops>())).runtime_idle as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_pm_ops),
            "::",
            stringify!(runtime_idle)
        )
    );
}
pub const rpm_status_RPM_ACTIVE: rpm_status = 0;
pub const rpm_status_RPM_RESUMING: rpm_status = 1;
pub const rpm_status_RPM_SUSPENDED: rpm_status = 2;
pub const rpm_status_RPM_SUSPENDING: rpm_status = 3;
pub type rpm_status = c_types::c_uint;
pub const rpm_request_RPM_REQ_NONE: rpm_request = 0;
pub const rpm_request_RPM_REQ_IDLE: rpm_request = 1;
pub const rpm_request_RPM_REQ_SUSPEND: rpm_request = 2;
pub const rpm_request_RPM_REQ_AUTOSUSPEND: rpm_request = 3;
pub const rpm_request_RPM_REQ_RESUME: rpm_request = 4;
pub type rpm_request = c_types::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wake_irq {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_domain_data {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pm_subsys_data {
    pub lock: spinlock_t,
    pub refcount: c_types::c_uint,
    pub clock_list: list_head,
    pub domain_data: *mut pm_domain_data,
}
#[test]
fn bindgen_test_layout_pm_subsys_data() {
    assert_eq!(
        ::core::mem::size_of::<pm_subsys_data>(),
        32usize,
        concat!("Size of: ", stringify!(pm_subsys_data))
    );
    assert_eq!(
        ::core::mem::align_of::<pm_subsys_data>(),
        8usize,
        concat!("Alignment of ", stringify!(pm_subsys_data))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pm_subsys_data>())).lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pm_subsys_data),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pm_subsys_data>())).refcount as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(pm_subsys_data),
            "::",
            stringify!(refcount)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pm_subsys_data>())).clock_list as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pm_subsys_data),
            "::",
            stringify!(clock_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pm_subsys_data>())).domain_data as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(pm_subsys_data),
            "::",
            stringify!(domain_data)
        )
    );
}
impl Default for pm_subsys_data {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct dev_pm_info {
    pub power_state: pm_message_t,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
    pub driver_flags: u32_,
    pub lock: spinlock_t,
    pub entry: list_head,
    pub completion: completion,
    pub wakeup: *mut wakeup_source,
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub suspend_timer: hrtimer,
    pub timer_expires: c_types::c_ulong,
    pub work: work_struct,
    pub wait_queue: wait_queue_head_t,
    pub wakeirq: *mut wake_irq,
    pub usage_count: atomic_t,
    pub child_count: atomic_t,
    pub _bitfield_3: __BindgenBitfieldUnit<[u8; 2usize], u8>,
    pub links_count: c_types::c_uint,
    pub request: rpm_request,
    pub runtime_status: rpm_status,
    pub runtime_error: c_types::c_int,
    pub autosuspend_delay: c_types::c_int,
    pub last_busy: u64_,
    pub active_time: u64_,
    pub suspended_time: u64_,
    pub accounting_timestamp: u64_,
    pub subsys_data: *mut pm_subsys_data,
    pub set_latency_tolerance:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut device, arg2: s32)>,
    pub qos: *mut dev_pm_qos,
}
#[test]
fn bindgen_test_layout_dev_pm_info() {
    assert_eq!(
        ::core::mem::size_of::<dev_pm_info>(),
        304usize,
        concat!("Size of: ", stringify!(dev_pm_info))
    );
    assert_eq!(
        ::core::mem::align_of::<dev_pm_info>(),
        8usize,
        concat!("Alignment of ", stringify!(dev_pm_info))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dev_pm_info>())).power_state as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_pm_info),
            "::",
            stringify!(power_state)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dev_pm_info>())).driver_flags as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_pm_info),
            "::",
            stringify!(driver_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dev_pm_info>())).lock as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_pm_info),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dev_pm_info>())).entry as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_pm_info),
            "::",
            stringify!(entry)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dev_pm_info>())).completion as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_pm_info),
            "::",
            stringify!(completion)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dev_pm_info>())).wakeup as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_pm_info),
            "::",
            stringify!(wakeup)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dev_pm_info>())).suspend_timer as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_pm_info),
            "::",
            stringify!(suspend_timer)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dev_pm_info>())).timer_expires as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_pm_info),
            "::",
            stringify!(timer_expires)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dev_pm_info>())).work as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_pm_info),
            "::",
            stringify!(work)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dev_pm_info>())).wait_queue as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_pm_info),
            "::",
            stringify!(wait_queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dev_pm_info>())).wakeirq as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_pm_info),
            "::",
            stringify!(wakeirq)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dev_pm_info>())).usage_count as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_pm_info),
            "::",
            stringify!(usage_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dev_pm_info>())).child_count as *const _ as usize },
        220usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_pm_info),
            "::",
            stringify!(child_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dev_pm_info>())).links_count as *const _ as usize },
        228usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_pm_info),
            "::",
            stringify!(links_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dev_pm_info>())).request as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_pm_info),
            "::",
            stringify!(request)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dev_pm_info>())).runtime_status as *const _ as usize },
        236usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_pm_info),
            "::",
            stringify!(runtime_status)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dev_pm_info>())).runtime_error as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_pm_info),
            "::",
            stringify!(runtime_error)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dev_pm_info>())).autosuspend_delay as *const _ as usize },
        244usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_pm_info),
            "::",
            stringify!(autosuspend_delay)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dev_pm_info>())).last_busy as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_pm_info),
            "::",
            stringify!(last_busy)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dev_pm_info>())).active_time as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_pm_info),
            "::",
            stringify!(active_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dev_pm_info>())).suspended_time as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_pm_info),
            "::",
            stringify!(suspended_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<dev_pm_info>())).accounting_timestamp as *const _ as usize
        },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_pm_info),
            "::",
            stringify!(accounting_timestamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dev_pm_info>())).subsys_data as *const _ as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_pm_info),
            "::",
            stringify!(subsys_data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<dev_pm_info>())).set_latency_tolerance as *const _ as usize
        },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_pm_info),
            "::",
            stringify!(set_latency_tolerance)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dev_pm_info>())).qos as *const _ as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_pm_info),
            "::",
            stringify!(qos)
        )
    );
}
impl Default for dev_pm_info {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl dev_pm_info {
    #[inline]
    pub fn can_wakeup(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_can_wakeup(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn async_suspend(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_async_suspend(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_dpm_list(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_in_dpm_list(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_prepared(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_is_prepared(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_suspended(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_is_suspended(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_noirq_suspended(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_is_noirq_suspended(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_late_suspended(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_is_late_suspended(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn no_pm(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_no_pm(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn early_init(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_early_init(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn direct_complete(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_direct_complete(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        can_wakeup: c_types::c_uint,
        async_suspend: c_types::c_uint,
        in_dpm_list: bool_,
        is_prepared: bool_,
        is_suspended: bool_,
        is_noirq_suspended: bool_,
        is_late_suspended: bool_,
        no_pm: bool_,
        early_init: bool_,
        direct_complete: bool_,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let can_wakeup: u32 = unsafe { ::core::mem::transmute(can_wakeup) };
            can_wakeup as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let async_suspend: u32 = unsafe { ::core::mem::transmute(async_suspend) };
            async_suspend as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let in_dpm_list: u8 = unsafe { ::core::mem::transmute(in_dpm_list) };
            in_dpm_list as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let is_prepared: u8 = unsafe { ::core::mem::transmute(is_prepared) };
            is_prepared as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let is_suspended: u8 = unsafe { ::core::mem::transmute(is_suspended) };
            is_suspended as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let is_noirq_suspended: u8 = unsafe { ::core::mem::transmute(is_noirq_suspended) };
            is_noirq_suspended as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let is_late_suspended: u8 = unsafe { ::core::mem::transmute(is_late_suspended) };
            is_late_suspended as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let no_pm: u8 = unsafe { ::core::mem::transmute(no_pm) };
            no_pm as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let early_init: u8 = unsafe { ::core::mem::transmute(early_init) };
            early_init as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let direct_complete: u8 = unsafe { ::core::mem::transmute(direct_complete) };
            direct_complete as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn wakeup_path(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_wakeup_path(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn syscore(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_syscore(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn no_pm_callbacks(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_no_pm_callbacks(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn must_resume(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_must_resume(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn may_skip_resume(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_may_skip_resume(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_2(
        wakeup_path: bool_,
        syscore: bool_,
        no_pm_callbacks: bool_,
        must_resume: c_types::c_uint,
        may_skip_resume: c_types::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let wakeup_path: u8 = unsafe { ::core::mem::transmute(wakeup_path) };
            wakeup_path as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let syscore: u8 = unsafe { ::core::mem::transmute(syscore) };
            syscore as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let no_pm_callbacks: u8 = unsafe { ::core::mem::transmute(no_pm_callbacks) };
            no_pm_callbacks as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let must_resume: u32 = unsafe { ::core::mem::transmute(must_resume) };
            must_resume as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let may_skip_resume: u32 = unsafe { ::core::mem::transmute(may_skip_resume) };
            may_skip_resume as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn disable_depth(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(0usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_disable_depth(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_3.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn idle_notification(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_idle_notification(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_3.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn request_pending(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_request_pending(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_3.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn deferred_resume(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_deferred_resume(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_3.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn runtime_auto(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_runtime_auto(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_3.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ignore_children(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ignore_children(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_3.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn no_callbacks(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_no_callbacks(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_3.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn irq_safe(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_irq_safe(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_3.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn use_autosuspend(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_use_autosuspend(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_3.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn timer_autosuspends(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_timer_autosuspends(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_3.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn memalloc_noio(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_memalloc_noio(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_3.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_3(
        disable_depth: c_types::c_uint,
        idle_notification: c_types::c_uint,
        request_pending: c_types::c_uint,
        deferred_resume: c_types::c_uint,
        runtime_auto: c_types::c_uint,
        ignore_children: bool_,
        no_callbacks: c_types::c_uint,
        irq_safe: c_types::c_uint,
        use_autosuspend: c_types::c_uint,
        timer_autosuspends: c_types::c_uint,
        memalloc_noio: c_types::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let disable_depth: u32 = unsafe { ::core::mem::transmute(disable_depth) };
            disable_depth as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let idle_notification: u32 = unsafe { ::core::mem::transmute(idle_notification) };
            idle_notification as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let request_pending: u32 = unsafe { ::core::mem::transmute(request_pending) };
            request_pending as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let deferred_resume: u32 = unsafe { ::core::mem::transmute(deferred_resume) };
            deferred_resume as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let runtime_auto: u32 = unsafe { ::core::mem::transmute(runtime_auto) };
            runtime_auto as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let ignore_children: u8 = unsafe { ::core::mem::transmute(ignore_children) };
            ignore_children as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let no_callbacks: u32 = unsafe { ::core::mem::transmute(no_callbacks) };
            no_callbacks as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let irq_safe: u32 = unsafe { ::core::mem::transmute(irq_safe) };
            irq_safe as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let use_autosuspend: u32 = unsafe { ::core::mem::transmute(use_autosuspend) };
            use_autosuspend as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let timer_autosuspends: u32 = unsafe { ::core::mem::transmute(timer_autosuspends) };
            timer_autosuspends as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let memalloc_noio: u32 = unsafe { ::core::mem::transmute(memalloc_noio) };
            memalloc_noio as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " struct dev_pm_domain - power management domain representation."]
#[doc = ""]
#[doc = " @ops: Power management operations associated with this domain."]
#[doc = " @detach: Called when removing a device from the domain."]
#[doc = " @activate: Called before executing probe routines for bus types and drivers."]
#[doc = " @sync: Called after successful driver probe."]
#[doc = " @dismiss: Called after unsuccessful driver probe and after driver removal."]
#[doc = ""]
#[doc = " Power domains provide callbacks that are executed during system suspend,"]
#[doc = " hibernation, system resume and during runtime PM transitions instead of"]
#[doc = " subsystem-level and driver-level callbacks."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct dev_pm_domain {
    pub ops: dev_pm_ops,
    pub detach: ::core::option::Option<unsafe extern "C" fn(dev: *mut device, power_off: bool_)>,
    pub activate: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> c_types::c_int>,
    pub sync: ::core::option::Option<unsafe extern "C" fn(dev: *mut device)>,
    pub dismiss: ::core::option::Option<unsafe extern "C" fn(dev: *mut device)>,
}
#[test]
fn bindgen_test_layout_dev_pm_domain() {
    assert_eq!(
        ::core::mem::size_of::<dev_pm_domain>(),
        216usize,
        concat!("Size of: ", stringify!(dev_pm_domain))
    );
    assert_eq!(
        ::core::mem::align_of::<dev_pm_domain>(),
        8usize,
        concat!("Alignment of ", stringify!(dev_pm_domain))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dev_pm_domain>())).ops as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_pm_domain),
            "::",
            stringify!(ops)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dev_pm_domain>())).detach as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_pm_domain),
            "::",
            stringify!(detach)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dev_pm_domain>())).activate as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_pm_domain),
            "::",
            stringify!(activate)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dev_pm_domain>())).sync as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_pm_domain),
            "::",
            stringify!(sync)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dev_pm_domain>())).dismiss as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_pm_domain),
            "::",
            stringify!(dismiss)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ratelimit_state {
    pub lock: raw_spinlock_t,
    pub interval: c_types::c_int,
    pub burst: c_types::c_int,
    pub printed: c_types::c_int,
    pub missed: c_types::c_int,
    pub begin: c_types::c_ulong,
    pub flags: c_types::c_ulong,
}
#[test]
fn bindgen_test_layout_ratelimit_state() {
    assert_eq!(
        ::core::mem::size_of::<ratelimit_state>(),
        40usize,
        concat!("Size of: ", stringify!(ratelimit_state))
    );
    assert_eq!(
        ::core::mem::align_of::<ratelimit_state>(),
        8usize,
        concat!("Alignment of ", stringify!(ratelimit_state))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ratelimit_state>())).lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ratelimit_state),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ratelimit_state>())).interval as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ratelimit_state),
            "::",
            stringify!(interval)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ratelimit_state>())).burst as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ratelimit_state),
            "::",
            stringify!(burst)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ratelimit_state>())).printed as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ratelimit_state),
            "::",
            stringify!(printed)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ratelimit_state>())).missed as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ratelimit_state),
            "::",
            stringify!(missed)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ratelimit_state>())).begin as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ratelimit_state),
            "::",
            stringify!(begin)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ratelimit_state>())).flags as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ratelimit_state),
            "::",
            stringify!(flags)
        )
    );
}
impl Default for ratelimit_state {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dev_archdata {
    pub iommu: *mut c_types::c_void,
}
#[test]
fn bindgen_test_layout_dev_archdata() {
    assert_eq!(
        ::core::mem::size_of::<dev_archdata>(),
        8usize,
        concat!("Size of: ", stringify!(dev_archdata))
    );
    assert_eq!(
        ::core::mem::align_of::<dev_archdata>(),
        8usize,
        concat!("Alignment of ", stringify!(dev_archdata))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dev_archdata>())).iommu as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_archdata),
            "::",
            stringify!(iommu)
        )
    );
}
impl Default for dev_archdata {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct device_private {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct driver_private {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct subsys_private {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iommu_ops {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iommu_group {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iommu_fwspec {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dev_pin_info {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iommu_param {
    _unused: [u8; 0],
}
#[doc = " struct bus_type - The bus type of the device"]
#[doc = ""]
#[doc = " @name:\tThe name of the bus."]
#[doc = " @dev_name:\tUsed for subsystems to enumerate devices like (\"foo%u\", dev->id)."]
#[doc = " @dev_root:\tDefault device to use as the parent."]
#[doc = " @bus_groups:\tDefault attributes of the bus."]
#[doc = " @dev_groups:\tDefault attributes of the devices on the bus."]
#[doc = " @drv_groups: Default attributes of the device drivers on the bus."]
#[doc = " @match:\tCalled, perhaps multiple times, whenever a new device or driver"]
#[doc = "\t\tis added for this bus. It should return a positive value if the"]
#[doc = "\t\tgiven device can be handled by the given driver and zero"]
#[doc = "\t\totherwise. It may also return error code if determining that"]
#[doc = "\t\tthe driver supports the device is not possible. In case of"]
#[doc = "\t\t-EPROBE_DEFER it will queue the device for deferred probing."]
#[doc = " @uevent:\tCalled when a device is added, removed, or a few other things"]
#[doc = "\t\tthat generate uevents to add the environment variables."]
#[doc = " @probe:\tCalled when a new device or driver add to this bus, and callback"]
#[doc = "\t\tthe specific driver's probe to initial the matched device."]
#[doc = " @remove:\tCalled when a device removed from this bus."]
#[doc = " @shutdown:\tCalled at shut-down time to quiesce the device."]
#[doc = ""]
#[doc = " @online:\tCalled to put the device back online (after offlining it)."]
#[doc = " @offline:\tCalled to put the device offline for hot-removal. May fail."]
#[doc = ""]
#[doc = " @suspend:\tCalled when a device on this bus wants to go to sleep mode."]
#[doc = " @resume:\tCalled to bring a device on this bus out of sleep mode."]
#[doc = " @num_vf:\tCalled to find out how many virtual functions a device on this"]
#[doc = "\t\tbus supports."]
#[doc = " @dma_configure:\tCalled to setup DMA configuration on a device on"]
#[doc = "\t\t\tthis bus."]
#[doc = " @pm:\t\tPower management operations of this bus, callback the specific"]
#[doc = "\t\tdevice driver's pm-ops."]
#[doc = " @iommu_ops:  IOMMU specific operations for this bus, used to attach IOMMU"]
#[doc = "              driver implementations to a bus and allow the driver to do"]
#[doc = "              bus-specific setup"]
#[doc = " @p:\t\tThe private data of the driver core, only the driver core can"]
#[doc = "\t\ttouch this."]
#[doc = " @lock_key:\tLock class key for use by the lock validator"]
#[doc = " @need_parent_lock:\tWhen probing or removing a device on this bus, the"]
#[doc = "\t\t\tdevice core should lock the device's parent."]
#[doc = ""]
#[doc = " A bus is a channel between the processor and one or more devices. For the"]
#[doc = " purposes of the device model, all devices are connected via a bus, even if"]
#[doc = " it is an internal, virtual, \"platform\" bus. Buses can plug into each other."]
#[doc = " A USB controller is usually a PCI device, for example. The device model"]
#[doc = " represents the actual connections between buses and the devices they control."]
#[doc = " A bus is represented by the bus_type structure. It contains the name, the"]
#[doc = " default attributes, the bus' methods, PM operations, and the driver core's"]
#[doc = " private data."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bus_type {
    pub name: *const c_types::c_char,
    pub dev_name: *const c_types::c_char,
    pub dev_root: *mut device,
    pub bus_groups: *mut *const attribute_group,
    pub dev_groups: *mut *const attribute_group,
    pub drv_groups: *mut *const attribute_group,
    pub match_: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut device, drv: *mut device_driver) -> c_types::c_int,
    >,
    pub uevent: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut device, env: *mut kobj_uevent_env) -> c_types::c_int,
    >,
    pub probe: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> c_types::c_int>,
    pub remove: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> c_types::c_int>,
    pub shutdown: ::core::option::Option<unsafe extern "C" fn(dev: *mut device)>,
    pub online: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> c_types::c_int>,
    pub offline: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> c_types::c_int>,
    pub suspend: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut device, state: pm_message_t) -> c_types::c_int,
    >,
    pub resume: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> c_types::c_int>,
    pub num_vf: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> c_types::c_int>,
    pub dma_configure:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> c_types::c_int>,
    pub pm: *const dev_pm_ops,
    pub iommu_ops: *const iommu_ops,
    pub p: *mut subsys_private,
    pub lock_key: lock_class_key,
    pub need_parent_lock: bool_,
}
#[test]
fn bindgen_test_layout_bus_type() {
    assert_eq!(
        ::core::mem::size_of::<bus_type>(),
        168usize,
        concat!("Size of: ", stringify!(bus_type))
    );
    assert_eq!(
        ::core::mem::align_of::<bus_type>(),
        8usize,
        concat!("Alignment of ", stringify!(bus_type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bus_type>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bus_type),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bus_type>())).dev_name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bus_type),
            "::",
            stringify!(dev_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bus_type>())).dev_root as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(bus_type),
            "::",
            stringify!(dev_root)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bus_type>())).bus_groups as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(bus_type),
            "::",
            stringify!(bus_groups)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bus_type>())).dev_groups as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(bus_type),
            "::",
            stringify!(dev_groups)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bus_type>())).drv_groups as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(bus_type),
            "::",
            stringify!(drv_groups)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bus_type>())).match_ as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(bus_type),
            "::",
            stringify!(match_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bus_type>())).uevent as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(bus_type),
            "::",
            stringify!(uevent)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bus_type>())).probe as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(bus_type),
            "::",
            stringify!(probe)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bus_type>())).remove as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(bus_type),
            "::",
            stringify!(remove)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bus_type>())).shutdown as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(bus_type),
            "::",
            stringify!(shutdown)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bus_type>())).online as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(bus_type),
            "::",
            stringify!(online)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bus_type>())).offline as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(bus_type),
            "::",
            stringify!(offline)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bus_type>())).suspend as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(bus_type),
            "::",
            stringify!(suspend)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bus_type>())).resume as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(bus_type),
            "::",
            stringify!(resume)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bus_type>())).num_vf as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(bus_type),
            "::",
            stringify!(num_vf)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bus_type>())).dma_configure as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(bus_type),
            "::",
            stringify!(dma_configure)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bus_type>())).pm as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(bus_type),
            "::",
            stringify!(pm)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bus_type>())).iommu_ops as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(bus_type),
            "::",
            stringify!(iommu_ops)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bus_type>())).p as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(bus_type),
            "::",
            stringify!(p)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bus_type>())).lock_key as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(bus_type),
            "::",
            stringify!(lock_key)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bus_type>())).need_parent_lock as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(bus_type),
            "::",
            stringify!(need_parent_lock)
        )
    );
}
impl Default for bus_type {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub const probe_type_PROBE_DEFAULT_STRATEGY: probe_type = 0;
pub const probe_type_PROBE_PREFER_ASYNCHRONOUS: probe_type = 1;
pub const probe_type_PROBE_FORCE_SYNCHRONOUS: probe_type = 2;
#[doc = " enum probe_type - device driver probe type to try"]
#[doc = "\tDevice drivers may opt in for special handling of their"]
#[doc = "\trespective probe routines. This tells the core what to"]
#[doc = "\texpect and prefer."]
#[doc = ""]
#[doc = " @PROBE_DEFAULT_STRATEGY: Used by drivers that work equally well"]
#[doc = "\twhether probed synchronously or asynchronously."]
#[doc = " @PROBE_PREFER_ASYNCHRONOUS: Drivers for \"slow\" devices which"]
#[doc = "\tprobing order is not essential for booting the system may"]
#[doc = "\topt into executing their probes asynchronously."]
#[doc = " @PROBE_FORCE_SYNCHRONOUS: Use this to annotate drivers that need"]
#[doc = "\ttheir probe routines to run synchronously with driver and"]
#[doc = "\tdevice registration (with the exception of -EPROBE_DEFER"]
#[doc = "\thandling - re-probing always ends up being done asynchronously)."]
#[doc = ""]
#[doc = " Note that the end goal is to switch the kernel to use asynchronous"]
#[doc = " probing by default, so annotating drivers with"]
#[doc = " %PROBE_PREFER_ASYNCHRONOUS is a temporary measure that allows us"]
#[doc = " to speed up boot process while we are validating the rest of the"]
#[doc = " drivers."]
pub type probe_type = c_types::c_uint;
#[doc = " struct device_driver - The basic device driver structure"]
#[doc = " @name:\tName of the device driver."]
#[doc = " @bus:\tThe bus which the device of this driver belongs to."]
#[doc = " @owner:\tThe module owner."]
#[doc = " @mod_name:\tUsed for built-in modules."]
#[doc = " @suppress_bind_attrs: Disables bind/unbind via sysfs."]
#[doc = " @probe_type:\tType of the probe (synchronous or asynchronous) to use."]
#[doc = " @of_match_table: The open firmware table."]
#[doc = " @acpi_match_table: The ACPI match table."]
#[doc = " @probe:\tCalled to query the existence of a specific device,"]
#[doc = "\t\twhether this driver can work with it, and bind the driver"]
#[doc = "\t\tto a specific device."]
#[doc = " @remove:\tCalled when the device is removed from the system to"]
#[doc = "\t\tunbind a device from this driver."]
#[doc = " @shutdown:\tCalled at shut-down time to quiesce the device."]
#[doc = " @suspend:\tCalled to put the device to sleep mode. Usually to a"]
#[doc = "\t\tlow power state."]
#[doc = " @resume:\tCalled to bring a device from sleep mode."]
#[doc = " @groups:\tDefault attributes that get created by the driver core"]
#[doc = "\t\tautomatically."]
#[doc = " @dev_groups:\tAdditional attributes attached to device instance once the"]
#[doc = "\t\tit is bound to the driver."]
#[doc = " @pm:\t\tPower management operations of the device which matched"]
#[doc = "\t\tthis driver."]
#[doc = " @coredump:\tCalled when sysfs entry is written to. The device driver"]
#[doc = "\t\tis expected to call the dev_coredump API resulting in a"]
#[doc = "\t\tuevent."]
#[doc = " @p:\t\tDriver core's private data, no one other than the driver"]
#[doc = "\t\tcore can touch this."]
#[doc = ""]
#[doc = " The device driver-model tracks all of the drivers known to the system."]
#[doc = " The main reason for this tracking is to enable the driver core to match"]
#[doc = " up drivers with new devices. Once drivers are known objects within the"]
#[doc = " system, however, a number of other things become possible. Device drivers"]
#[doc = " can export information and configuration variables that are independent"]
#[doc = " of any specific device."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct device_driver {
    pub name: *const c_types::c_char,
    pub bus: *mut bus_type,
    pub owner: *mut module,
    pub mod_name: *const c_types::c_char,
    pub suppress_bind_attrs: bool_,
    pub probe_type: probe_type,
    pub of_match_table: *mut of_device_id,
    pub acpi_match_table: *mut acpi_device_id,
    pub probe: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> c_types::c_int>,
    pub remove: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> c_types::c_int>,
    pub shutdown: ::core::option::Option<unsafe extern "C" fn(dev: *mut device)>,
    pub suspend: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut device, state: pm_message_t) -> c_types::c_int,
    >,
    pub resume: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> c_types::c_int>,
    pub groups: *mut *const attribute_group,
    pub dev_groups: *mut *const attribute_group,
    pub pm: *const dev_pm_ops,
    pub coredump: ::core::option::Option<unsafe extern "C" fn(dev: *mut device)>,
    pub p: *mut driver_private,
}
#[test]
fn bindgen_test_layout_device_driver() {
    assert_eq!(
        ::core::mem::size_of::<device_driver>(),
        136usize,
        concat!("Size of: ", stringify!(device_driver))
    );
    assert_eq!(
        ::core::mem::align_of::<device_driver>(),
        8usize,
        concat!("Alignment of ", stringify!(device_driver))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<device_driver>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(device_driver),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<device_driver>())).bus as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(device_driver),
            "::",
            stringify!(bus)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<device_driver>())).owner as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(device_driver),
            "::",
            stringify!(owner)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<device_driver>())).mod_name as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(device_driver),
            "::",
            stringify!(mod_name)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<device_driver>())).suppress_bind_attrs as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(device_driver),
            "::",
            stringify!(suppress_bind_attrs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<device_driver>())).probe_type as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(device_driver),
            "::",
            stringify!(probe_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<device_driver>())).of_match_table as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(device_driver),
            "::",
            stringify!(of_match_table)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<device_driver>())).acpi_match_table as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(device_driver),
            "::",
            stringify!(acpi_match_table)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<device_driver>())).probe as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(device_driver),
            "::",
            stringify!(probe)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<device_driver>())).remove as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(device_driver),
            "::",
            stringify!(remove)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<device_driver>())).shutdown as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(device_driver),
            "::",
            stringify!(shutdown)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<device_driver>())).suspend as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(device_driver),
            "::",
            stringify!(suspend)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<device_driver>())).resume as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(device_driver),
            "::",
            stringify!(resume)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<device_driver>())).groups as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(device_driver),
            "::",
            stringify!(groups)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<device_driver>())).dev_groups as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(device_driver),
            "::",
            stringify!(dev_groups)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<device_driver>())).pm as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(device_driver),
            "::",
            stringify!(pm)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<device_driver>())).coredump as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(device_driver),
            "::",
            stringify!(coredump)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<device_driver>())).p as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(device_driver),
            "::",
            stringify!(p)
        )
    );
}
impl Default for device_driver {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[doc = " struct class - device classes"]
#[doc = " @name:\tName of the class."]
#[doc = " @owner:\tThe module owner."]
#[doc = " @class_groups: Default attributes of this class."]
#[doc = " @dev_groups:\tDefault attributes of the devices that belong to the class."]
#[doc = " @dev_kobj:\tThe kobject that represents this class and links it into the hierarchy."]
#[doc = " @dev_uevent:\tCalled when a device is added, removed from this class, or a"]
#[doc = "\t\tfew other things that generate uevents to add the environment"]
#[doc = "\t\tvariables."]
#[doc = " @devnode:\tCallback to provide the devtmpfs."]
#[doc = " @class_release: Called to release this class."]
#[doc = " @dev_release: Called to release the device."]
#[doc = " @shutdown_pre: Called at shut-down time before driver shutdown."]
#[doc = " @ns_type:\tCallbacks so sysfs can detemine namespaces."]
#[doc = " @namespace:\tNamespace of the device belongs to this class."]
#[doc = " @get_ownership: Allows class to specify uid/gid of the sysfs directories"]
#[doc = "\t\tfor the devices belonging to the class. Usually tied to"]
#[doc = "\t\tdevice's namespace."]
#[doc = " @pm:\t\tThe default device power management operations of this class."]
#[doc = " @p:\t\tThe private data of the driver core, no one other than the"]
#[doc = "\t\tdriver core can touch this."]
#[doc = ""]
#[doc = " A class is a higher-level view of a device that abstracts out low-level"]
#[doc = " implementation details. Drivers may see a SCSI disk or an ATA disk, but,"]
#[doc = " at the class level, they are all simply disks. Classes allow user space"]
#[doc = " to work with devices based on what they do, rather than how they are"]
#[doc = " connected or how they work."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct class {
    pub name: *const c_types::c_char,
    pub owner: *mut module,
    pub class_groups: *mut *const attribute_group,
    pub dev_groups: *mut *const attribute_group,
    pub dev_kobj: *mut kobject,
    pub dev_uevent: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut device, env: *mut kobj_uevent_env) -> c_types::c_int,
    >,
    pub devnode: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut device, mode: *mut umode_t) -> *mut c_types::c_char,
    >,
    pub class_release: ::core::option::Option<unsafe extern "C" fn(class: *mut class)>,
    pub dev_release: ::core::option::Option<unsafe extern "C" fn(dev: *mut device)>,
    pub shutdown_pre:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> c_types::c_int>,
    pub ns_type: *const kobj_ns_type_operations,
    pub namespace:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> *const c_types::c_void>,
    pub get_ownership: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut device, uid: *mut kuid_t, gid: *mut kgid_t),
    >,
    pub pm: *const dev_pm_ops,
    pub p: *mut subsys_private,
}
#[test]
fn bindgen_test_layout_class() {
    assert_eq!(
        ::core::mem::size_of::<class>(),
        120usize,
        concat!("Size of: ", stringify!(class))
    );
    assert_eq!(
        ::core::mem::align_of::<class>(),
        8usize,
        concat!("Alignment of ", stringify!(class))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<class>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(class),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<class>())).owner as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(class),
            "::",
            stringify!(owner)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<class>())).class_groups as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(class),
            "::",
            stringify!(class_groups)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<class>())).dev_groups as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(class),
            "::",
            stringify!(dev_groups)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<class>())).dev_kobj as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(class),
            "::",
            stringify!(dev_kobj)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<class>())).dev_uevent as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(class),
            "::",
            stringify!(dev_uevent)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<class>())).devnode as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(class),
            "::",
            stringify!(devnode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<class>())).class_release as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(class),
            "::",
            stringify!(class_release)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<class>())).dev_release as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(class),
            "::",
            stringify!(dev_release)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<class>())).shutdown_pre as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(class),
            "::",
            stringify!(shutdown_pre)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<class>())).ns_type as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(class),
            "::",
            stringify!(ns_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<class>())).namespace as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(class),
            "::",
            stringify!(namespace)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<class>())).get_ownership as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(class),
            "::",
            stringify!(get_ownership)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<class>())).pm as *const _ as usize },
        104usize,
        concat!("Offset of field: ", stringify!(class), "::", stringify!(pm))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<class>())).p as *const _ as usize },
        112usize,
        concat!("Offset of field: ", stringify!(class), "::", stringify!(p))
    );
}
impl Default for class {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct device_type {
    pub name: *const c_types::c_char,
    pub groups: *mut *const attribute_group,
    pub uevent: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut device, env: *mut kobj_uevent_env) -> c_types::c_int,
    >,
    pub devnode: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut device,
            mode: *mut umode_t,
            uid: *mut kuid_t,
            gid: *mut kgid_t,
        ) -> *mut c_types::c_char,
    >,
    pub release: ::core::option::Option<unsafe extern "C" fn(dev: *mut device)>,
    pub pm: *const dev_pm_ops,
}
#[test]
fn bindgen_test_layout_device_type() {
    assert_eq!(
        ::core::mem::size_of::<device_type>(),
        48usize,
        concat!("Size of: ", stringify!(device_type))
    );
    assert_eq!(
        ::core::mem::align_of::<device_type>(),
        8usize,
        concat!("Alignment of ", stringify!(device_type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<device_type>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(device_type),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<device_type>())).groups as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(device_type),
            "::",
            stringify!(groups)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<device_type>())).uevent as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(device_type),
            "::",
            stringify!(uevent)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<device_type>())).devnode as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(device_type),
            "::",
            stringify!(devnode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<device_type>())).release as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(device_type),
            "::",
            stringify!(release)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<device_type>())).pm as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(device_type),
            "::",
            stringify!(pm)
        )
    );
}
impl Default for device_type {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct device_dma_parameters {
    pub max_segment_size: c_types::c_uint,
    pub segment_boundary_mask: c_types::c_ulong,
}
#[test]
fn bindgen_test_layout_device_dma_parameters() {
    assert_eq!(
        ::core::mem::size_of::<device_dma_parameters>(),
        16usize,
        concat!("Size of: ", stringify!(device_dma_parameters))
    );
    assert_eq!(
        ::core::mem::align_of::<device_dma_parameters>(),
        8usize,
        concat!("Alignment of ", stringify!(device_dma_parameters))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<device_dma_parameters>())).max_segment_size as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(device_dma_parameters),
            "::",
            stringify!(max_segment_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<device_dma_parameters>())).segment_boundary_mask as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(device_dma_parameters),
            "::",
            stringify!(segment_boundary_mask)
        )
    );
}
pub const dl_dev_state_DL_DEV_NO_DRIVER: dl_dev_state = 0;
pub const dl_dev_state_DL_DEV_PROBING: dl_dev_state = 1;
pub const dl_dev_state_DL_DEV_DRIVER_BOUND: dl_dev_state = 2;
pub const dl_dev_state_DL_DEV_UNBINDING: dl_dev_state = 3;
#[doc = " enum dl_dev_state - Device driver presence tracking information."]
#[doc = " @DL_DEV_NO_DRIVER: There is no driver attached to the device."]
#[doc = " @DL_DEV_PROBING: A driver is probing."]
#[doc = " @DL_DEV_DRIVER_BOUND: The driver has been bound to the device."]
#[doc = " @DL_DEV_UNBINDING: The driver is unbinding from the device."]
pub type dl_dev_state = c_types::c_uint;
#[doc = " struct dev_links_info - Device data related to device links."]
#[doc = " @suppliers: List of links to supplier devices."]
#[doc = " @consumers: List of links to consumer devices."]
#[doc = " @status: Driver status information."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dev_links_info {
    pub suppliers: list_head,
    pub consumers: list_head,
    pub status: dl_dev_state,
}
#[test]
fn bindgen_test_layout_dev_links_info() {
    assert_eq!(
        ::core::mem::size_of::<dev_links_info>(),
        40usize,
        concat!("Size of: ", stringify!(dev_links_info))
    );
    assert_eq!(
        ::core::mem::align_of::<dev_links_info>(),
        8usize,
        concat!("Alignment of ", stringify!(dev_links_info))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dev_links_info>())).suppliers as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_links_info),
            "::",
            stringify!(suppliers)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dev_links_info>())).consumers as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_links_info),
            "::",
            stringify!(consumers)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dev_links_info>())).status as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_links_info),
            "::",
            stringify!(status)
        )
    );
}
impl Default for dev_links_info {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[doc = " struct device - The basic device structure"]
#[doc = " @parent:\tThe device's \"parent\" device, the device to which it is attached."]
#[doc = " \t\tIn most cases, a parent device is some sort of bus or host"]
#[doc = " \t\tcontroller. If parent is NULL, the device, is a top-level device,"]
#[doc = " \t\twhich is not usually what you want."]
#[doc = " @p:\t\tHolds the private data of the driver core portions of the device."]
#[doc = " \t\tSee the comment of the struct device_private for detail."]
#[doc = " @kobj:\tA top-level, abstract class from which other classes are derived."]
#[doc = " @init_name:\tInitial name of the device."]
#[doc = " @type:\tThe type of device."]
#[doc = " \t\tThis identifies the device type and carries type-specific"]
#[doc = " \t\tinformation."]
#[doc = " @mutex:\tMutex to synchronize calls to its driver."]
#[doc = " @lockdep_mutex: An optional debug lock that a subsystem can use as a"]
#[doc = " \t\tpeer lock to gain localized lockdep coverage of the device_lock."]
#[doc = " @bus:\tType of bus device is on."]
#[doc = " @driver:\tWhich driver has allocated this"]
#[doc = " @platform_data: Platform data specific to the device."]
#[doc = " \t\tExample: For devices on custom boards, as typical of embedded"]
#[doc = " \t\tand SOC based hardware, Linux often uses platform_data to point"]
#[doc = " \t\tto board-specific structures describing devices and how they"]
#[doc = " \t\tare wired.  That can include what ports are available, chip"]
#[doc = " \t\tvariants, which GPIO pins act in what additional roles, and so"]
#[doc = " \t\ton.  This shrinks the \"Board Support Packages\" (BSPs) and"]
#[doc = " \t\tminimizes board-specific #ifdefs in drivers."]
#[doc = " @driver_data: Private pointer for driver specific info."]
#[doc = " @links:\tLinks to suppliers and consumers of this device."]
#[doc = " @power:\tFor device power management."]
#[doc = "\t\tSee Documentation/driver-api/pm/devices.rst for details."]
#[doc = " @pm_domain:\tProvide callbacks that are executed during system suspend,"]
#[doc = " \t\thibernation, system resume and during runtime PM transitions"]
#[doc = " \t\talong with subsystem-level and driver-level callbacks."]
#[doc = " @pins:\tFor device pin management."]
#[doc = "\t\tSee Documentation/driver-api/pinctl.rst for details."]
#[doc = " @msi_list:\tHosts MSI descriptors"]
#[doc = " @msi_domain: The generic MSI domain this device is using."]
#[doc = " @numa_node:\tNUMA node this device is close to."]
#[doc = " @dma_ops:    DMA mapping operations for this device."]
#[doc = " @dma_mask:\tDma mask (if dma'ble device)."]
#[doc = " @coherent_dma_mask: Like dma_mask, but for alloc_coherent mapping as not all"]
#[doc = " \t\thardware supports 64-bit addresses for consistent allocations"]
#[doc = " \t\tsuch descriptors."]
#[doc = " @bus_dma_mask: Mask of an upstream bridge or bus which imposes a smaller DMA"]
#[doc = "\t\tlimit than the device itself supports."]
#[doc = " @dma_pfn_offset: offset of DMA memory range relatively of RAM"]
#[doc = " @dma_parms:\tA low level driver may set these to teach IOMMU code about"]
#[doc = " \t\tsegment limitations."]
#[doc = " @dma_pools:\tDma pools (if dma'ble device)."]
#[doc = " @dma_mem:\tInternal for coherent mem override."]
#[doc = " @cma_area:\tContiguous memory area for dma allocations"]
#[doc = " @archdata:\tFor arch-specific additions."]
#[doc = " @of_node:\tAssociated device tree node."]
#[doc = " @fwnode:\tAssociated device node supplied by platform firmware."]
#[doc = " @devt:\tFor creating the sysfs \"dev\"."]
#[doc = " @id:\t\tdevice instance"]
#[doc = " @devres_lock: Spinlock to protect the resource of the device."]
#[doc = " @devres_head: The resources list of the device."]
#[doc = " @knode_class: The node used to add the device to the class list."]
#[doc = " @class:\tThe class of the device."]
#[doc = " @groups:\tOptional attribute groups."]
#[doc = " @release:\tCallback to free the device after all references have"]
#[doc = " \t\tgone away. This should be set by the allocator of the"]
#[doc = " \t\tdevice (i.e. the bus driver that discovered the device)."]
#[doc = " @iommu_group: IOMMU group the device belongs to."]
#[doc = " @iommu_fwspec: IOMMU-specific properties supplied by firmware."]
#[doc = " @iommu_param: Per device generic IOMMU runtime data"]
#[doc = ""]
#[doc = " @offline_disabled: If set, the device is permanently online."]
#[doc = " @offline:\tSet after successful invocation of bus type's .offline()."]
#[doc = " @of_node_reused: Set if the device-tree node is shared with an ancestor"]
#[doc = "              device."]
#[doc = " @dma_coherent: this particular device is dma coherent, even if the"]
#[doc = "\t\tarchitecture supports non-coherent devices."]
#[doc = ""]
#[doc = " At the lowest level, every device in a Linux system is represented by an"]
#[doc = " instance of struct device. The device structure contains the information"]
#[doc = " that the device model core needs to model the system. Most subsystems,"]
#[doc = " however, track additional information about the devices they host. As a"]
#[doc = " result, it is rare for devices to be represented by bare device structures;"]
#[doc = " instead, that structure, like kobject structures, is usually embedded within"]
#[doc = " a higher-level representation of the device."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct device {
    pub kobj: kobject,
    pub parent: *mut device,
    pub p: *mut device_private,
    pub init_name: *const c_types::c_char,
    pub type_: *const device_type,
    pub bus: *mut bus_type,
    pub driver: *mut device_driver,
    pub platform_data: *mut c_types::c_void,
    pub driver_data: *mut c_types::c_void,
    pub mutex: mutex,
    pub links: dev_links_info,
    pub power: dev_pm_info,
    pub pm_domain: *mut dev_pm_domain,
    pub msi_domain: *mut irq_domain,
    pub pins: *mut dev_pin_info,
    pub msi_list: list_head,
    pub dma_ops: *const dma_map_ops,
    pub dma_mask: *mut u64_,
    pub coherent_dma_mask: u64_,
    pub bus_dma_mask: u64_,
    pub dma_pfn_offset: c_types::c_ulong,
    pub dma_parms: *mut device_dma_parameters,
    pub dma_pools: list_head,
    pub archdata: dev_archdata,
    pub of_node: *mut device_node,
    pub fwnode: *mut fwnode_handle,
    pub numa_node: c_types::c_int,
    pub devt: dev_t,
    pub id: u32_,
    pub devres_lock: spinlock_t,
    pub devres_head: list_head,
    pub class: *mut class,
    pub groups: *mut *const attribute_group,
    pub release: ::core::option::Option<unsafe extern "C" fn(dev: *mut device)>,
    pub iommu_group: *mut iommu_group,
    pub iommu_fwspec: *mut iommu_fwspec,
    pub iommu_param: *mut iommu_param,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u8; 7usize],
}
#[test]
fn bindgen_test_layout_device() {
    assert_eq!(
        ::core::mem::size_of::<device>(),
        720usize,
        concat!("Size of: ", stringify!(device))
    );
    assert_eq!(
        ::core::mem::align_of::<device>(),
        8usize,
        concat!("Alignment of ", stringify!(device))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<device>())).kobj as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(device),
            "::",
            stringify!(kobj)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<device>())).parent as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(device),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<device>())).p as *const _ as usize },
        72usize,
        concat!("Offset of field: ", stringify!(device), "::", stringify!(p))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<device>())).init_name as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(device),
            "::",
            stringify!(init_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<device>())).type_ as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(device),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<device>())).bus as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(device),
            "::",
            stringify!(bus)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<device>())).driver as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(device),
            "::",
            stringify!(driver)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<device>())).platform_data as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(device),
            "::",
            stringify!(platform_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<device>())).driver_data as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(device),
            "::",
            stringify!(driver_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<device>())).mutex as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(device),
            "::",
            stringify!(mutex)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<device>())).links as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(device),
            "::",
            stringify!(links)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<device>())).power as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(device),
            "::",
            stringify!(power)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<device>())).pm_domain as *const _ as usize },
        504usize,
        concat!(
            "Offset of field: ",
            stringify!(device),
            "::",
            stringify!(pm_domain)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<device>())).msi_domain as *const _ as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(device),
            "::",
            stringify!(msi_domain)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<device>())).pins as *const _ as usize },
        520usize,
        concat!(
            "Offset of field: ",
            stringify!(device),
            "::",
            stringify!(pins)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<device>())).msi_list as *const _ as usize },
        528usize,
        concat!(
            "Offset of field: ",
            stringify!(device),
            "::",
            stringify!(msi_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<device>())).dma_ops as *const _ as usize },
        544usize,
        concat!(
            "Offset of field: ",
            stringify!(device),
            "::",
            stringify!(dma_ops)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<device>())).dma_mask as *const _ as usize },
        552usize,
        concat!(
            "Offset of field: ",
            stringify!(device),
            "::",
            stringify!(dma_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<device>())).coherent_dma_mask as *const _ as usize },
        560usize,
        concat!(
            "Offset of field: ",
            stringify!(device),
            "::",
            stringify!(coherent_dma_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<device>())).bus_dma_mask as *const _ as usize },
        568usize,
        concat!(
            "Offset of field: ",
            stringify!(device),
            "::",
            stringify!(bus_dma_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<device>())).dma_pfn_offset as *const _ as usize },
        576usize,
        concat!(
            "Offset of field: ",
            stringify!(device),
            "::",
            stringify!(dma_pfn_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<device>())).dma_parms as *const _ as usize },
        584usize,
        concat!(
            "Offset of field: ",
            stringify!(device),
            "::",
            stringify!(dma_parms)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<device>())).dma_pools as *const _ as usize },
        592usize,
        concat!(
            "Offset of field: ",
            stringify!(device),
            "::",
            stringify!(dma_pools)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<device>())).archdata as *const _ as usize },
        608usize,
        concat!(
            "Offset of field: ",
            stringify!(device),
            "::",
            stringify!(archdata)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<device>())).of_node as *const _ as usize },
        616usize,
        concat!(
            "Offset of field: ",
            stringify!(device),
            "::",
            stringify!(of_node)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<device>())).fwnode as *const _ as usize },
        624usize,
        concat!(
            "Offset of field: ",
            stringify!(device),
            "::",
            stringify!(fwnode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<device>())).numa_node as *const _ as usize },
        632usize,
        concat!(
            "Offset of field: ",
            stringify!(device),
            "::",
            stringify!(numa_node)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<device>())).devt as *const _ as usize },
        636usize,
        concat!(
            "Offset of field: ",
            stringify!(device),
            "::",
            stringify!(devt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<device>())).id as *const _ as usize },
        640usize,
        concat!(
            "Offset of field: ",
            stringify!(device),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<device>())).devres_lock as *const _ as usize },
        644usize,
        concat!(
            "Offset of field: ",
            stringify!(device),
            "::",
            stringify!(devres_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<device>())).devres_head as *const _ as usize },
        648usize,
        concat!(
            "Offset of field: ",
            stringify!(device),
            "::",
            stringify!(devres_head)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<device>())).class as *const _ as usize },
        664usize,
        concat!(
            "Offset of field: ",
            stringify!(device),
            "::",
            stringify!(class)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<device>())).groups as *const _ as usize },
        672usize,
        concat!(
            "Offset of field: ",
            stringify!(device),
            "::",
            stringify!(groups)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<device>())).release as *const _ as usize },
        680usize,
        concat!(
            "Offset of field: ",
            stringify!(device),
            "::",
            stringify!(release)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<device>())).iommu_group as *const _ as usize },
        688usize,
        concat!(
            "Offset of field: ",
            stringify!(device),
            "::",
            stringify!(iommu_group)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<device>())).iommu_fwspec as *const _ as usize },
        696usize,
        concat!(
            "Offset of field: ",
            stringify!(device),
            "::",
            stringify!(iommu_fwspec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<device>())).iommu_param as *const _ as usize },
        704usize,
        concat!(
            "Offset of field: ",
            stringify!(device),
            "::",
            stringify!(iommu_param)
        )
    );
}
impl Default for device {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl device {
    #[inline]
    pub fn offline_disabled(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_offline_disabled(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn offline(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_offline(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn of_node_reused(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_of_node_reused(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        offline_disabled: bool_,
        offline: bool_,
        of_node_reused: bool_,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let offline_disabled: u8 = unsafe { ::core::mem::transmute(offline_disabled) };
            offline_disabled as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let offline: u8 = unsafe { ::core::mem::transmute(offline) };
            offline as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let of_node_reused: u8 = unsafe { ::core::mem::transmute(of_node_reused) };
            of_node_reused as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " struct wakeup_source - Representation of wakeup sources"]
#[doc = ""]
#[doc = " @name: Name of the wakeup source"]
#[doc = " @id: Wakeup source id"]
#[doc = " @entry: Wakeup source list entry"]
#[doc = " @lock: Wakeup source lock"]
#[doc = " @wakeirq: Optional device specific wakeirq"]
#[doc = " @timer: Wakeup timer list"]
#[doc = " @timer_expires: Wakeup timer expiration"]
#[doc = " @total_time: Total time this wakeup source has been active."]
#[doc = " @max_time: Maximum time this wakeup source has been continuously active."]
#[doc = " @last_time: Monotonic clock when the wakeup source's was touched last time."]
#[doc = " @prevent_sleep_time: Total time this source has been preventing autosleep."]
#[doc = " @event_count: Number of signaled wakeup events."]
#[doc = " @active_count: Number of times the wakeup source was activated."]
#[doc = " @relax_count: Number of times the wakeup source was deactivated."]
#[doc = " @expire_count: Number of times the wakeup source's timeout has expired."]
#[doc = " @wakeup_count: Number of times the wakeup source might abort suspend."]
#[doc = " @dev: Struct device for sysfs statistics about the wakeup source."]
#[doc = " @active: Status of the wakeup source."]
#[doc = " @autosleep_enabled: Autosleep is active, so update @prevent_sleep_time."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wakeup_source {
    pub name: *const c_types::c_char,
    pub id: c_types::c_int,
    pub entry: list_head,
    pub lock: spinlock_t,
    pub wakeirq: *mut wake_irq,
    pub timer: timer_list,
    pub timer_expires: c_types::c_ulong,
    pub total_time: ktime_t,
    pub max_time: ktime_t,
    pub last_time: ktime_t,
    pub start_prevent_time: ktime_t,
    pub prevent_sleep_time: ktime_t,
    pub event_count: c_types::c_ulong,
    pub active_count: c_types::c_ulong,
    pub relax_count: c_types::c_ulong,
    pub expire_count: c_types::c_ulong,
    pub wakeup_count: c_types::c_ulong,
    pub dev: *mut device,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u8; 7usize],
}
#[test]
fn bindgen_test_layout_wakeup_source() {
    assert_eq!(
        ::core::mem::size_of::<wakeup_source>(),
        192usize,
        concat!("Size of: ", stringify!(wakeup_source))
    );
    assert_eq!(
        ::core::mem::align_of::<wakeup_source>(),
        8usize,
        concat!("Alignment of ", stringify!(wakeup_source))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<wakeup_source>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wakeup_source),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<wakeup_source>())).id as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wakeup_source),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<wakeup_source>())).entry as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wakeup_source),
            "::",
            stringify!(entry)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<wakeup_source>())).lock as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(wakeup_source),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<wakeup_source>())).wakeirq as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(wakeup_source),
            "::",
            stringify!(wakeirq)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<wakeup_source>())).timer as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(wakeup_source),
            "::",
            stringify!(timer)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<wakeup_source>())).timer_expires as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(wakeup_source),
            "::",
            stringify!(timer_expires)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<wakeup_source>())).total_time as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(wakeup_source),
            "::",
            stringify!(total_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<wakeup_source>())).max_time as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(wakeup_source),
            "::",
            stringify!(max_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<wakeup_source>())).last_time as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(wakeup_source),
            "::",
            stringify!(last_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<wakeup_source>())).start_prevent_time as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(wakeup_source),
            "::",
            stringify!(start_prevent_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<wakeup_source>())).prevent_sleep_time as *const _ as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(wakeup_source),
            "::",
            stringify!(prevent_sleep_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<wakeup_source>())).event_count as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(wakeup_source),
            "::",
            stringify!(event_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<wakeup_source>())).active_count as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(wakeup_source),
            "::",
            stringify!(active_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<wakeup_source>())).relax_count as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(wakeup_source),
            "::",
            stringify!(relax_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<wakeup_source>())).expire_count as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(wakeup_source),
            "::",
            stringify!(expire_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<wakeup_source>())).wakeup_count as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(wakeup_source),
            "::",
            stringify!(wakeup_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<wakeup_source>())).dev as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(wakeup_source),
            "::",
            stringify!(dev)
        )
    );
}
impl Default for wakeup_source {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl wakeup_source {
    #[inline]
    pub fn active(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_active(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn autosleep_enabled(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_autosleep_enabled(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        active: bool_,
        autosleep_enabled: bool_,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let active: u8 = unsafe { ::core::mem::transmute(active) };
            active as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let autosleep_enabled: u8 = unsafe { ::core::mem::transmute(autosleep_enabled) };
            autosleep_enabled as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const dma_data_direction_DMA_BIDIRECTIONAL: dma_data_direction = 0;
pub const dma_data_direction_DMA_TO_DEVICE: dma_data_direction = 1;
pub const dma_data_direction_DMA_FROM_DEVICE: dma_data_direction = 2;
pub const dma_data_direction_DMA_NONE: dma_data_direction = 3;
pub type dma_data_direction = c_types::c_uint;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct scatterlist {
    pub page_link: c_types::c_ulong,
    pub offset: c_types::c_uint,
    pub length: c_types::c_uint,
    pub dma_address: dma_addr_t,
    pub dma_length: c_types::c_uint,
}
#[test]
fn bindgen_test_layout_scatterlist() {
    assert_eq!(
        ::core::mem::size_of::<scatterlist>(),
        32usize,
        concat!("Size of: ", stringify!(scatterlist))
    );
    assert_eq!(
        ::core::mem::align_of::<scatterlist>(),
        8usize,
        concat!("Alignment of ", stringify!(scatterlist))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<scatterlist>())).page_link as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(scatterlist),
            "::",
            stringify!(page_link)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<scatterlist>())).offset as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(scatterlist),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<scatterlist>())).length as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(scatterlist),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<scatterlist>())).dma_address as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(scatterlist),
            "::",
            stringify!(dma_address)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<scatterlist>())).dma_length as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(scatterlist),
            "::",
            stringify!(dma_length)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sg_table {
    pub sgl: *mut scatterlist,
    pub nents: c_types::c_uint,
    pub orig_nents: c_types::c_uint,
}
#[test]
fn bindgen_test_layout_sg_table() {
    assert_eq!(
        ::core::mem::size_of::<sg_table>(),
        16usize,
        concat!("Size of: ", stringify!(sg_table))
    );
    assert_eq!(
        ::core::mem::align_of::<sg_table>(),
        8usize,
        concat!("Alignment of ", stringify!(sg_table))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sg_table>())).sgl as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_table),
            "::",
            stringify!(sgl)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sg_table>())).nents as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_table),
            "::",
            stringify!(nents)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sg_table>())).orig_nents as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_table),
            "::",
            stringify!(orig_nents)
        )
    );
}
impl Default for sg_table {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct dma_map_ops {
    pub alloc: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut device,
            size: usize,
            dma_handle: *mut dma_addr_t,
            gfp: gfp_t,
            attrs: c_types::c_ulong,
        ) -> *mut c_types::c_void,
    >,
    pub free: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut device,
            size: usize,
            vaddr: *mut c_types::c_void,
            dma_handle: dma_addr_t,
            attrs: c_types::c_ulong,
        ),
    >,
    pub mmap: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut device,
            arg2: *mut vm_area_struct,
            arg3: *mut c_types::c_void,
            arg4: dma_addr_t,
            arg5: usize,
            attrs: c_types::c_ulong,
        ) -> c_types::c_int,
    >,
    pub get_sgtable: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut device,
            sgt: *mut sg_table,
            arg1: *mut c_types::c_void,
            arg2: dma_addr_t,
            arg3: usize,
            attrs: c_types::c_ulong,
        ) -> c_types::c_int,
    >,
    pub map_page: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut device,
            page: *mut page,
            offset: c_types::c_ulong,
            size: usize,
            dir: dma_data_direction,
            attrs: c_types::c_ulong,
        ) -> dma_addr_t,
    >,
    pub unmap_page: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut device,
            dma_handle: dma_addr_t,
            size: usize,
            dir: dma_data_direction,
            attrs: c_types::c_ulong,
        ),
    >,
    pub map_sg: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut device,
            sg: *mut scatterlist,
            nents: c_types::c_int,
            dir: dma_data_direction,
            attrs: c_types::c_ulong,
        ) -> c_types::c_int,
    >,
    pub unmap_sg: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut device,
            sg: *mut scatterlist,
            nents: c_types::c_int,
            dir: dma_data_direction,
            attrs: c_types::c_ulong,
        ),
    >,
    pub map_resource: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut device,
            phys_addr: phys_addr_t,
            size: usize,
            dir: dma_data_direction,
            attrs: c_types::c_ulong,
        ) -> dma_addr_t,
    >,
    pub unmap_resource: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut device,
            dma_handle: dma_addr_t,
            size: usize,
            dir: dma_data_direction,
            attrs: c_types::c_ulong,
        ),
    >,
    pub sync_single_for_cpu: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut device,
            dma_handle: dma_addr_t,
            size: usize,
            dir: dma_data_direction,
        ),
    >,
    pub sync_single_for_device: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut device,
            dma_handle: dma_addr_t,
            size: usize,
            dir: dma_data_direction,
        ),
    >,
    pub sync_sg_for_cpu: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut device,
            sg: *mut scatterlist,
            nents: c_types::c_int,
            dir: dma_data_direction,
        ),
    >,
    pub sync_sg_for_device: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut device,
            sg: *mut scatterlist,
            nents: c_types::c_int,
            dir: dma_data_direction,
        ),
    >,
    pub cache_sync: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut device,
            vaddr: *mut c_types::c_void,
            size: usize,
            direction: dma_data_direction,
        ),
    >,
    pub dma_supported: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut device, mask: u64_) -> c_types::c_int,
    >,
    pub get_required_mask: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> u64_>,
    pub max_mapping_size: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> usize>,
    pub get_merge_boundary:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> c_types::c_ulong>,
}
#[test]
fn bindgen_test_layout_dma_map_ops() {
    assert_eq!(
        ::core::mem::size_of::<dma_map_ops>(),
        152usize,
        concat!("Size of: ", stringify!(dma_map_ops))
    );
    assert_eq!(
        ::core::mem::align_of::<dma_map_ops>(),
        8usize,
        concat!("Alignment of ", stringify!(dma_map_ops))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dma_map_ops>())).alloc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dma_map_ops),
            "::",
            stringify!(alloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dma_map_ops>())).free as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(dma_map_ops),
            "::",
            stringify!(free)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dma_map_ops>())).mmap as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(dma_map_ops),
            "::",
            stringify!(mmap)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dma_map_ops>())).get_sgtable as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(dma_map_ops),
            "::",
            stringify!(get_sgtable)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dma_map_ops>())).map_page as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(dma_map_ops),
            "::",
            stringify!(map_page)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dma_map_ops>())).unmap_page as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(dma_map_ops),
            "::",
            stringify!(unmap_page)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dma_map_ops>())).map_sg as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(dma_map_ops),
            "::",
            stringify!(map_sg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dma_map_ops>())).unmap_sg as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(dma_map_ops),
            "::",
            stringify!(unmap_sg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dma_map_ops>())).map_resource as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(dma_map_ops),
            "::",
            stringify!(map_resource)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dma_map_ops>())).unmap_resource as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(dma_map_ops),
            "::",
            stringify!(unmap_resource)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<dma_map_ops>())).sync_single_for_cpu as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(dma_map_ops),
            "::",
            stringify!(sync_single_for_cpu)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<dma_map_ops>())).sync_single_for_device as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(dma_map_ops),
            "::",
            stringify!(sync_single_for_device)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dma_map_ops>())).sync_sg_for_cpu as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(dma_map_ops),
            "::",
            stringify!(sync_sg_for_cpu)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dma_map_ops>())).sync_sg_for_device as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(dma_map_ops),
            "::",
            stringify!(sync_sg_for_device)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dma_map_ops>())).cache_sync as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(dma_map_ops),
            "::",
            stringify!(cache_sync)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dma_map_ops>())).dma_supported as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(dma_map_ops),
            "::",
            stringify!(dma_supported)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dma_map_ops>())).get_required_mask as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(dma_map_ops),
            "::",
            stringify!(get_required_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dma_map_ops>())).max_mapping_size as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(dma_map_ops),
            "::",
            stringify!(max_mapping_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dma_map_ops>())).get_merge_boundary as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(dma_map_ops),
            "::",
            stringify!(get_merge_boundary)
        )
    );
}
pub type netdev_features_t = u64_;
#[doc = " csum_ipv6_magic - Compute checksum of an IPv6 pseudo header."]
#[doc = " @saddr: source address"]
#[doc = " @daddr: destination address"]
#[doc = " @len: length of packet"]
#[doc = " @proto: protocol of packet"]
#[doc = " @sum: initial sum (32bit unfolded) to be added in"]
#[doc = ""]
#[doc = " Computes an IPv6 pseudo header checksum. This sum is added the checksum"]
#[doc = " into UDP/TCP packets and contains some link layer information."]
#[doc = " Returns the unfolded 32bit checksum."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct in6_addr {
    pub in6_u: in6_addr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union in6_addr__bindgen_ty_1 {
    pub u6_addr8: [__u8; 16usize],
    pub u6_addr16: [__be16; 8usize],
    pub u6_addr32: [__be32; 4usize],
    _bindgen_union_align: [u32; 4usize],
}
#[test]
fn bindgen_test_layout_in6_addr__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<in6_addr__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(in6_addr__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<in6_addr__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(in6_addr__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<in6_addr__bindgen_ty_1>())).u6_addr8 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_addr__bindgen_ty_1),
            "::",
            stringify!(u6_addr8)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<in6_addr__bindgen_ty_1>())).u6_addr16 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_addr__bindgen_ty_1),
            "::",
            stringify!(u6_addr16)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<in6_addr__bindgen_ty_1>())).u6_addr32 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_addr__bindgen_ty_1),
            "::",
            stringify!(u6_addr32)
        )
    );
}
impl Default for in6_addr__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_in6_addr() {
    assert_eq!(
        ::core::mem::size_of::<in6_addr>(),
        16usize,
        concat!("Size of: ", stringify!(in6_addr))
    );
    assert_eq!(
        ::core::mem::align_of::<in6_addr>(),
        4usize,
        concat!("Alignment of ", stringify!(in6_addr))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<in6_addr>())).in6_u as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_addr),
            "::",
            stringify!(in6_u)
        )
    );
}
impl Default for in6_addr {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct siphash_key_t {
    pub key: [u64_; 2usize],
}
#[test]
fn bindgen_test_layout_siphash_key_t() {
    assert_eq!(
        ::core::mem::size_of::<siphash_key_t>(),
        16usize,
        concat!("Size of: ", stringify!(siphash_key_t))
    );
    assert_eq!(
        ::core::mem::align_of::<siphash_key_t>(),
        8usize,
        concat!("Alignment of ", stringify!(siphash_key_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<siphash_key_t>())).key as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siphash_key_t),
            "::",
            stringify!(key)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ethhdr {
    pub h_dest: [c_types::c_uchar; 6usize],
    pub h_source: [c_types::c_uchar; 6usize],
    pub h_proto: __be16,
}
#[test]
fn bindgen_test_layout_ethhdr() {
    assert_eq!(
        ::core::mem::size_of::<ethhdr>(),
        14usize,
        concat!("Size of: ", stringify!(ethhdr))
    );
    assert_eq!(
        ::core::mem::align_of::<ethhdr>(),
        1usize,
        concat!("Alignment of ", stringify!(ethhdr))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethhdr>())).h_dest as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ethhdr),
            "::",
            stringify!(h_dest)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethhdr>())).h_source as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(ethhdr),
            "::",
            stringify!(h_source)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethhdr>())).h_proto as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ethhdr),
            "::",
            stringify!(h_proto)
        )
    );
}
#[doc = "\tstruct pipe_buffer - a linux kernel pipe buffer"]
#[doc = "\t@page: the page containing the data for the pipe buffer"]
#[doc = "\t@offset: offset of data inside the @page"]
#[doc = "\t@len: length of data inside the @page"]
#[doc = "\t@ops: operations associated with this buffer. See @pipe_buf_operations."]
#[doc = "\t@flags: pipe buffer flags. See above."]
#[doc = "\t@private: private data owned by the ops."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pipe_buffer {
    pub page: *mut page,
    pub offset: c_types::c_uint,
    pub len: c_types::c_uint,
    pub ops: *const pipe_buf_operations,
    pub flags: c_types::c_uint,
    pub private: c_types::c_ulong,
}
#[test]
fn bindgen_test_layout_pipe_buffer() {
    assert_eq!(
        ::core::mem::size_of::<pipe_buffer>(),
        40usize,
        concat!("Size of: ", stringify!(pipe_buffer))
    );
    assert_eq!(
        ::core::mem::align_of::<pipe_buffer>(),
        8usize,
        concat!("Alignment of ", stringify!(pipe_buffer))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pipe_buffer>())).page as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pipe_buffer),
            "::",
            stringify!(page)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pipe_buffer>())).offset as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pipe_buffer),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pipe_buffer>())).len as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(pipe_buffer),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pipe_buffer>())).ops as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pipe_buffer),
            "::",
            stringify!(ops)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pipe_buffer>())).flags as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(pipe_buffer),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pipe_buffer>())).private as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(pipe_buffer),
            "::",
            stringify!(private)
        )
    );
}
impl Default for pipe_buffer {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[doc = "\tstruct pipe_inode_info - a linux kernel pipe"]
#[doc = "\t@mutex: mutex protecting the whole thing"]
#[doc = "\t@wait: reader/writer wait point in case of empty/full pipe"]
#[doc = "\t@nrbufs: the number of non-empty pipe buffers in this pipe"]
#[doc = "\t@buffers: total number of buffers (should be a power of 2)"]
#[doc = "\t@curbuf: the current pipe buffer entry"]
#[doc = "\t@tmp_page: cached released page"]
#[doc = "\t@readers: number of current readers of this pipe"]
#[doc = "\t@writers: number of current writers of this pipe"]
#[doc = "\t@files: number of struct file referring this pipe (protected by ->i_lock)"]
#[doc = "\t@waiting_writers: number of writers blocked waiting for room"]
#[doc = "\t@r_counter: reader counter"]
#[doc = "\t@w_counter: writer counter"]
#[doc = "\t@fasync_readers: reader side fasync"]
#[doc = "\t@fasync_writers: writer side fasync"]
#[doc = "\t@bufs: the circular array of pipe buffers"]
#[doc = "\t@user: the user who created this pipe"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pipe_inode_info {
    pub mutex: mutex,
    pub wait: wait_queue_head_t,
    pub nrbufs: c_types::c_uint,
    pub curbuf: c_types::c_uint,
    pub buffers: c_types::c_uint,
    pub readers: c_types::c_uint,
    pub writers: c_types::c_uint,
    pub files: c_types::c_uint,
    pub waiting_writers: c_types::c_uint,
    pub r_counter: c_types::c_uint,
    pub w_counter: c_types::c_uint,
    pub tmp_page: *mut page,
    pub fasync_readers: *mut fasync_struct,
    pub fasync_writers: *mut fasync_struct,
    pub bufs: *mut pipe_buffer,
    pub user: *mut user_struct,
}
#[test]
fn bindgen_test_layout_pipe_inode_info() {
    assert_eq!(
        ::core::mem::size_of::<pipe_inode_info>(),
        136usize,
        concat!("Size of: ", stringify!(pipe_inode_info))
    );
    assert_eq!(
        ::core::mem::align_of::<pipe_inode_info>(),
        8usize,
        concat!("Alignment of ", stringify!(pipe_inode_info))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pipe_inode_info>())).mutex as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pipe_inode_info),
            "::",
            stringify!(mutex)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pipe_inode_info>())).wait as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(pipe_inode_info),
            "::",
            stringify!(wait)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pipe_inode_info>())).nrbufs as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(pipe_inode_info),
            "::",
            stringify!(nrbufs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pipe_inode_info>())).curbuf as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(pipe_inode_info),
            "::",
            stringify!(curbuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pipe_inode_info>())).buffers as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(pipe_inode_info),
            "::",
            stringify!(buffers)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pipe_inode_info>())).readers as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(pipe_inode_info),
            "::",
            stringify!(readers)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pipe_inode_info>())).writers as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(pipe_inode_info),
            "::",
            stringify!(writers)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pipe_inode_info>())).files as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(pipe_inode_info),
            "::",
            stringify!(files)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<pipe_inode_info>())).waiting_writers as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(pipe_inode_info),
            "::",
            stringify!(waiting_writers)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pipe_inode_info>())).r_counter as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(pipe_inode_info),
            "::",
            stringify!(r_counter)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pipe_inode_info>())).w_counter as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(pipe_inode_info),
            "::",
            stringify!(w_counter)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pipe_inode_info>())).tmp_page as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(pipe_inode_info),
            "::",
            stringify!(tmp_page)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pipe_inode_info>())).fasync_readers as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(pipe_inode_info),
            "::",
            stringify!(fasync_readers)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pipe_inode_info>())).fasync_writers as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(pipe_inode_info),
            "::",
            stringify!(fasync_writers)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pipe_inode_info>())).bufs as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(pipe_inode_info),
            "::",
            stringify!(bufs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pipe_inode_info>())).user as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(pipe_inode_info),
            "::",
            stringify!(user)
        )
    );
}
impl Default for pipe_inode_info {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct pipe_buf_operations {
    pub confirm: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut pipe_inode_info, arg2: *mut pipe_buffer) -> c_types::c_int,
    >,
    pub release: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut pipe_inode_info, arg2: *mut pipe_buffer),
    >,
    pub steal: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut pipe_inode_info, arg2: *mut pipe_buffer) -> c_types::c_int,
    >,
    pub get: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut pipe_inode_info, arg2: *mut pipe_buffer) -> bool_,
    >,
}
#[test]
fn bindgen_test_layout_pipe_buf_operations() {
    assert_eq!(
        ::core::mem::size_of::<pipe_buf_operations>(),
        32usize,
        concat!("Size of: ", stringify!(pipe_buf_operations))
    );
    assert_eq!(
        ::core::mem::align_of::<pipe_buf_operations>(),
        8usize,
        concat!("Alignment of ", stringify!(pipe_buf_operations))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pipe_buf_operations>())).confirm as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pipe_buf_operations),
            "::",
            stringify!(confirm)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pipe_buf_operations>())).release as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pipe_buf_operations),
            "::",
            stringify!(release)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pipe_buf_operations>())).steal as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pipe_buf_operations),
            "::",
            stringify!(steal)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pipe_buf_operations>())).get as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(pipe_buf_operations),
            "::",
            stringify!(get)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct flowi_tunnel {
    pub tun_id: __be64,
}
#[test]
fn bindgen_test_layout_flowi_tunnel() {
    assert_eq!(
        ::core::mem::size_of::<flowi_tunnel>(),
        8usize,
        concat!("Size of: ", stringify!(flowi_tunnel))
    );
    assert_eq!(
        ::core::mem::align_of::<flowi_tunnel>(),
        8usize,
        concat!("Alignment of ", stringify!(flowi_tunnel))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<flowi_tunnel>())).tun_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(flowi_tunnel),
            "::",
            stringify!(tun_id)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct flowi_common {
    pub flowic_oif: c_types::c_int,
    pub flowic_iif: c_types::c_int,
    pub flowic_mark: __u32,
    pub flowic_tos: __u8,
    pub flowic_scope: __u8,
    pub flowic_proto: __u8,
    pub flowic_flags: __u8,
    pub flowic_secid: __u32,
    pub flowic_uid: kuid_t,
    pub flowic_tun_key: flowi_tunnel,
    pub flowic_multipath_hash: __u32,
}
#[test]
fn bindgen_test_layout_flowi_common() {
    assert_eq!(
        ::core::mem::size_of::<flowi_common>(),
        40usize,
        concat!("Size of: ", stringify!(flowi_common))
    );
    assert_eq!(
        ::core::mem::align_of::<flowi_common>(),
        8usize,
        concat!("Alignment of ", stringify!(flowi_common))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<flowi_common>())).flowic_oif as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(flowi_common),
            "::",
            stringify!(flowic_oif)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<flowi_common>())).flowic_iif as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(flowi_common),
            "::",
            stringify!(flowic_iif)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<flowi_common>())).flowic_mark as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(flowi_common),
            "::",
            stringify!(flowic_mark)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<flowi_common>())).flowic_tos as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(flowi_common),
            "::",
            stringify!(flowic_tos)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<flowi_common>())).flowic_scope as *const _ as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(flowi_common),
            "::",
            stringify!(flowic_scope)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<flowi_common>())).flowic_proto as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(flowi_common),
            "::",
            stringify!(flowic_proto)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<flowi_common>())).flowic_flags as *const _ as usize },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(flowi_common),
            "::",
            stringify!(flowic_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<flowi_common>())).flowic_secid as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(flowi_common),
            "::",
            stringify!(flowic_secid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<flowi_common>())).flowic_uid as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(flowi_common),
            "::",
            stringify!(flowic_uid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<flowi_common>())).flowic_tun_key as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(flowi_common),
            "::",
            stringify!(flowic_tun_key)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<flowi_common>())).flowic_multipath_hash as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(flowi_common),
            "::",
            stringify!(flowic_multipath_hash)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union flowi_uli {
    pub ports: flowi_uli__bindgen_ty_1,
    pub icmpt: flowi_uli__bindgen_ty_2,
    pub dnports: flowi_uli__bindgen_ty_3,
    pub spi: __be32,
    pub gre_key: __be32,
    pub mht: flowi_uli__bindgen_ty_4,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct flowi_uli__bindgen_ty_1 {
    pub dport: __be16,
    pub sport: __be16,
}
#[test]
fn bindgen_test_layout_flowi_uli__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<flowi_uli__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(flowi_uli__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<flowi_uli__bindgen_ty_1>(),
        2usize,
        concat!("Alignment of ", stringify!(flowi_uli__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<flowi_uli__bindgen_ty_1>())).dport as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(flowi_uli__bindgen_ty_1),
            "::",
            stringify!(dport)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<flowi_uli__bindgen_ty_1>())).sport as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(flowi_uli__bindgen_ty_1),
            "::",
            stringify!(sport)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct flowi_uli__bindgen_ty_2 {
    pub type_: __u8,
    pub code: __u8,
}
#[test]
fn bindgen_test_layout_flowi_uli__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<flowi_uli__bindgen_ty_2>(),
        2usize,
        concat!("Size of: ", stringify!(flowi_uli__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<flowi_uli__bindgen_ty_2>(),
        1usize,
        concat!("Alignment of ", stringify!(flowi_uli__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<flowi_uli__bindgen_ty_2>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(flowi_uli__bindgen_ty_2),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<flowi_uli__bindgen_ty_2>())).code as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(flowi_uli__bindgen_ty_2),
            "::",
            stringify!(code)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct flowi_uli__bindgen_ty_3 {
    pub dport: __le16,
    pub sport: __le16,
}
#[test]
fn bindgen_test_layout_flowi_uli__bindgen_ty_3() {
    assert_eq!(
        ::core::mem::size_of::<flowi_uli__bindgen_ty_3>(),
        4usize,
        concat!("Size of: ", stringify!(flowi_uli__bindgen_ty_3))
    );
    assert_eq!(
        ::core::mem::align_of::<flowi_uli__bindgen_ty_3>(),
        2usize,
        concat!("Alignment of ", stringify!(flowi_uli__bindgen_ty_3))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<flowi_uli__bindgen_ty_3>())).dport as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(flowi_uli__bindgen_ty_3),
            "::",
            stringify!(dport)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<flowi_uli__bindgen_ty_3>())).sport as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(flowi_uli__bindgen_ty_3),
            "::",
            stringify!(sport)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct flowi_uli__bindgen_ty_4 {
    pub type_: __u8,
}
#[test]
fn bindgen_test_layout_flowi_uli__bindgen_ty_4() {
    assert_eq!(
        ::core::mem::size_of::<flowi_uli__bindgen_ty_4>(),
        1usize,
        concat!("Size of: ", stringify!(flowi_uli__bindgen_ty_4))
    );
    assert_eq!(
        ::core::mem::align_of::<flowi_uli__bindgen_ty_4>(),
        1usize,
        concat!("Alignment of ", stringify!(flowi_uli__bindgen_ty_4))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<flowi_uli__bindgen_ty_4>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(flowi_uli__bindgen_ty_4),
            "::",
            stringify!(type_)
        )
    );
}
#[test]
fn bindgen_test_layout_flowi_uli() {
    assert_eq!(
        ::core::mem::size_of::<flowi_uli>(),
        4usize,
        concat!("Size of: ", stringify!(flowi_uli))
    );
    assert_eq!(
        ::core::mem::align_of::<flowi_uli>(),
        4usize,
        concat!("Alignment of ", stringify!(flowi_uli))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<flowi_uli>())).ports as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(flowi_uli),
            "::",
            stringify!(ports)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<flowi_uli>())).icmpt as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(flowi_uli),
            "::",
            stringify!(icmpt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<flowi_uli>())).dnports as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(flowi_uli),
            "::",
            stringify!(dnports)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<flowi_uli>())).spi as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(flowi_uli),
            "::",
            stringify!(spi)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<flowi_uli>())).gre_key as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(flowi_uli),
            "::",
            stringify!(gre_key)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<flowi_uli>())).mht as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(flowi_uli),
            "::",
            stringify!(mht)
        )
    );
}
impl Default for flowi_uli {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct flowi4 {
    pub __fl_common: flowi_common,
    pub saddr: __be32,
    pub daddr: __be32,
    pub uli: flowi_uli,
}
#[test]
fn bindgen_test_layout_flowi4() {
    assert_eq!(
        ::core::mem::size_of::<flowi4>(),
        56usize,
        concat!("Size of: ", stringify!(flowi4))
    );
    assert_eq!(
        ::core::mem::align_of::<flowi4>(),
        8usize,
        concat!("Alignment of ", stringify!(flowi4))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<flowi4>())).__fl_common as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(flowi4),
            "::",
            stringify!(__fl_common)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<flowi4>())).saddr as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(flowi4),
            "::",
            stringify!(saddr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<flowi4>())).daddr as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(flowi4),
            "::",
            stringify!(daddr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<flowi4>())).uli as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(flowi4),
            "::",
            stringify!(uli)
        )
    );
}
impl Default for flowi4 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct flowi6 {
    pub __fl_common: flowi_common,
    pub daddr: in6_addr,
    pub saddr: in6_addr,
    pub flowlabel: __be32,
    pub uli: flowi_uli,
    pub mp_hash: __u32,
}
#[test]
fn bindgen_test_layout_flowi6() {
    assert_eq!(
        ::core::mem::size_of::<flowi6>(),
        88usize,
        concat!("Size of: ", stringify!(flowi6))
    );
    assert_eq!(
        ::core::mem::align_of::<flowi6>(),
        8usize,
        concat!("Alignment of ", stringify!(flowi6))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<flowi6>())).__fl_common as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(flowi6),
            "::",
            stringify!(__fl_common)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<flowi6>())).daddr as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(flowi6),
            "::",
            stringify!(daddr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<flowi6>())).saddr as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(flowi6),
            "::",
            stringify!(saddr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<flowi6>())).flowlabel as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(flowi6),
            "::",
            stringify!(flowlabel)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<flowi6>())).uli as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(flowi6),
            "::",
            stringify!(uli)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<flowi6>())).mp_hash as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(flowi6),
            "::",
            stringify!(mp_hash)
        )
    );
}
impl Default for flowi6 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct flowidn {
    pub __fl_common: flowi_common,
    pub daddr: __le16,
    pub saddr: __le16,
    pub uli: flowi_uli,
}
#[test]
fn bindgen_test_layout_flowidn() {
    assert_eq!(
        ::core::mem::size_of::<flowidn>(),
        48usize,
        concat!("Size of: ", stringify!(flowidn))
    );
    assert_eq!(
        ::core::mem::align_of::<flowidn>(),
        8usize,
        concat!("Alignment of ", stringify!(flowidn))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<flowidn>())).__fl_common as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(flowidn),
            "::",
            stringify!(__fl_common)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<flowidn>())).daddr as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(flowidn),
            "::",
            stringify!(daddr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<flowidn>())).saddr as *const _ as usize },
        42usize,
        concat!(
            "Offset of field: ",
            stringify!(flowidn),
            "::",
            stringify!(saddr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<flowidn>())).uli as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(flowidn),
            "::",
            stringify!(uli)
        )
    );
}
impl Default for flowidn {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct flowi {
    pub u: flowi__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union flowi__bindgen_ty_1 {
    pub __fl_common: flowi_common,
    pub ip4: flowi4,
    pub ip6: flowi6,
    pub dn: flowidn,
    _bindgen_union_align: [u64; 11usize],
}
#[test]
fn bindgen_test_layout_flowi__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<flowi__bindgen_ty_1>(),
        88usize,
        concat!("Size of: ", stringify!(flowi__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<flowi__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(flowi__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<flowi__bindgen_ty_1>())).__fl_common as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(flowi__bindgen_ty_1),
            "::",
            stringify!(__fl_common)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<flowi__bindgen_ty_1>())).ip4 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(flowi__bindgen_ty_1),
            "::",
            stringify!(ip4)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<flowi__bindgen_ty_1>())).ip6 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(flowi__bindgen_ty_1),
            "::",
            stringify!(ip6)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<flowi__bindgen_ty_1>())).dn as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(flowi__bindgen_ty_1),
            "::",
            stringify!(dn)
        )
    );
}
impl Default for flowi__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_flowi() {
    assert_eq!(
        ::core::mem::size_of::<flowi>(),
        88usize,
        concat!("Size of: ", stringify!(flowi))
    );
    assert_eq!(
        ::core::mem::align_of::<flowi>(),
        8usize,
        concat!("Alignment of ", stringify!(flowi))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<flowi>())).u as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(flowi), "::", stringify!(u))
    );
}
impl Default for flowi {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ip_conntrack_stat {
    pub found: c_types::c_uint,
    pub invalid: c_types::c_uint,
    pub ignore: c_types::c_uint,
    pub insert: c_types::c_uint,
    pub insert_failed: c_types::c_uint,
    pub drop: c_types::c_uint,
    pub early_drop: c_types::c_uint,
    pub error: c_types::c_uint,
    pub expect_new: c_types::c_uint,
    pub expect_create: c_types::c_uint,
    pub expect_delete: c_types::c_uint,
    pub search_restart: c_types::c_uint,
}
#[test]
fn bindgen_test_layout_ip_conntrack_stat() {
    assert_eq!(
        ::core::mem::size_of::<ip_conntrack_stat>(),
        48usize,
        concat!("Size of: ", stringify!(ip_conntrack_stat))
    );
    assert_eq!(
        ::core::mem::align_of::<ip_conntrack_stat>(),
        4usize,
        concat!("Alignment of ", stringify!(ip_conntrack_stat))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ip_conntrack_stat>())).found as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_conntrack_stat),
            "::",
            stringify!(found)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ip_conntrack_stat>())).invalid as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_conntrack_stat),
            "::",
            stringify!(invalid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ip_conntrack_stat>())).ignore as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_conntrack_stat),
            "::",
            stringify!(ignore)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ip_conntrack_stat>())).insert as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_conntrack_stat),
            "::",
            stringify!(insert)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ip_conntrack_stat>())).insert_failed as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_conntrack_stat),
            "::",
            stringify!(insert_failed)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ip_conntrack_stat>())).drop as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_conntrack_stat),
            "::",
            stringify!(drop)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ip_conntrack_stat>())).early_drop as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_conntrack_stat),
            "::",
            stringify!(early_drop)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ip_conntrack_stat>())).error as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_conntrack_stat),
            "::",
            stringify!(error)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ip_conntrack_stat>())).expect_new as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_conntrack_stat),
            "::",
            stringify!(expect_new)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ip_conntrack_stat>())).expect_create as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_conntrack_stat),
            "::",
            stringify!(expect_create)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ip_conntrack_stat>())).expect_delete as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_conntrack_stat),
            "::",
            stringify!(expect_delete)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ip_conntrack_stat>())).search_restart as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_conntrack_stat),
            "::",
            stringify!(search_restart)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sk_buff_head {
    pub next: *mut sk_buff,
    pub prev: *mut sk_buff,
    pub qlen: __u32,
    pub lock: spinlock_t,
}
#[test]
fn bindgen_test_layout_sk_buff_head() {
    assert_eq!(
        ::core::mem::size_of::<sk_buff_head>(),
        24usize,
        concat!("Size of: ", stringify!(sk_buff_head))
    );
    assert_eq!(
        ::core::mem::align_of::<sk_buff_head>(),
        8usize,
        concat!("Alignment of ", stringify!(sk_buff_head))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sk_buff_head>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff_head),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sk_buff_head>())).prev as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff_head),
            "::",
            stringify!(prev)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sk_buff_head>())).qlen as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff_head),
            "::",
            stringify!(qlen)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sk_buff_head>())).lock as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff_head),
            "::",
            stringify!(lock)
        )
    );
}
impl Default for sk_buff_head {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type sk_buff_data_t = c_types::c_uint;
#[doc = "\tstruct sk_buff - socket buffer"]
#[doc = "\t@next: Next buffer in list"]
#[doc = "\t@prev: Previous buffer in list"]
#[doc = "\t@tstamp: Time we arrived/left"]
#[doc = "\t@rbnode: RB tree node, alternative to next/prev for netem/tcp"]
#[doc = "\t@sk: Socket we are owned by"]
#[doc = "\t@dev: Device we arrived on/are leaving by"]
#[doc = "\t@cb: Control buffer. Free for use by every layer. Put private vars here"]
#[doc = "\t@_skb_refdst: destination entry (with norefcount bit)"]
#[doc = "\t@sp: the security path, used for xfrm"]
#[doc = "\t@len: Length of actual data"]
#[doc = "\t@data_len: Data length"]
#[doc = "\t@mac_len: Length of link layer header"]
#[doc = "\t@hdr_len: writable header length of cloned skb"]
#[doc = "\t@csum: Checksum (must include start/offset pair)"]
#[doc = "\t@csum_start: Offset from skb->head where checksumming should start"]
#[doc = "\t@csum_offset: Offset from csum_start where checksum should be stored"]
#[doc = "\t@priority: Packet queueing priority"]
#[doc = "\t@ignore_df: allow local fragmentation"]
#[doc = "\t@cloned: Head may be cloned (check refcnt to be sure)"]
#[doc = "\t@ip_summed: Driver fed us an IP checksum"]
#[doc = "\t@nohdr: Payload reference only, must not modify header"]
#[doc = "\t@pkt_type: Packet class"]
#[doc = "\t@fclone: skbuff clone status"]
#[doc = "\t@ipvs_property: skbuff is owned by ipvs"]
#[doc = "\t@offload_fwd_mark: Packet was L2-forwarded in hardware"]
#[doc = "\t@offload_l3_fwd_mark: Packet was L3-forwarded in hardware"]
#[doc = "\t@tc_skip_classify: do not classify packet. set by IFB device"]
#[doc = "\t@tc_at_ingress: used within tc_classify to distinguish in/egress"]
#[doc = "\t@redirected: packet was redirected by packet classifier"]
#[doc = "\t@from_ingress: packet was redirected from the ingress path"]
#[doc = "\t@peeked: this packet has been seen already, so stats have been"]
#[doc = "\t\tdone for it, don't do them again"]
#[doc = "\t@nf_trace: netfilter packet trace flag"]
#[doc = "\t@protocol: Packet protocol from driver"]
#[doc = "\t@destructor: Destruct function"]
#[doc = "\t@tcp_tsorted_anchor: list structure for TCP (tp->tsorted_sent_queue)"]
#[doc = "\t@_nfct: Associated connection, if any (with nfctinfo bits)"]
#[doc = "\t@nf_bridge: Saved data about a bridged frame - see br_netfilter.c"]
#[doc = "\t@skb_iif: ifindex of device we arrived on"]
#[doc = "\t@tc_index: Traffic control index"]
#[doc = "\t@hash: the packet hash"]
#[doc = "\t@queue_mapping: Queue mapping for multiqueue devices"]
#[doc = "\t@pfmemalloc: skbuff was allocated from PFMEMALLOC reserves"]
#[doc = "\t@active_extensions: active extensions (skb_ext_id types)"]
#[doc = "\t@ndisc_nodetype: router type (from link layer)"]
#[doc = "\t@ooo_okay: allow the mapping of a socket to a queue to be changed"]
#[doc = "\t@l4_hash: indicate hash is a canonical 4-tuple hash over transport"]
#[doc = "\t\tports."]
#[doc = "\t@sw_hash: indicates hash was computed in software stack"]
#[doc = "\t@wifi_acked_valid: wifi_acked was set"]
#[doc = "\t@wifi_acked: whether frame was acked on wifi or not"]
#[doc = "\t@no_fcs:  Request NIC to treat last 4 bytes as Ethernet FCS"]
#[doc = "\t@csum_not_inet: use CRC32c to resolve CHECKSUM_PARTIAL"]
#[doc = "\t@dst_pending_confirm: need to confirm neighbour"]
#[doc = "\t@decrypted: Decrypted SKB"]
#[doc = "\t@napi_id: id of the NAPI struct this skb came from"]
#[doc = "\t@secmark: security marking"]
#[doc = "\t@mark: Generic packet mark"]
#[doc = "\t@vlan_proto: vlan encapsulation protocol"]
#[doc = "\t@vlan_tci: vlan tag control information"]
#[doc = "\t@inner_protocol: Protocol (encapsulation)"]
#[doc = "\t@inner_transport_header: Inner transport layer header (encapsulation)"]
#[doc = "\t@inner_network_header: Network layer header (encapsulation)"]
#[doc = "\t@inner_mac_header: Link layer header (encapsulation)"]
#[doc = "\t@transport_header: Transport layer header"]
#[doc = "\t@network_header: Network layer header"]
#[doc = "\t@mac_header: Link layer header"]
#[doc = "\t@tail: Tail pointer"]
#[doc = "\t@end: End pointer"]
#[doc = "\t@head: Head of buffer"]
#[doc = "\t@data: Data head pointer"]
#[doc = "\t@truesize: Buffer size"]
#[doc = "\t@users: User count - see {datagram,tcp}.c"]
#[doc = "\t@extensions: allocated extensions, valid if active_extensions is nonzero"]
#[repr(C)]
pub struct sk_buff {
    pub __bindgen_anon_1: sk_buff__bindgen_ty_1,
    pub __bindgen_anon_2: sk_buff__bindgen_ty_2,
    pub __bindgen_anon_3: sk_buff__bindgen_ty_3,
    pub cb: [c_types::c_char; 48usize],
    pub __bindgen_anon_4: sk_buff__bindgen_ty_4,
    pub _nfct: c_types::c_ulong,
    pub len: c_types::c_uint,
    pub data_len: c_types::c_uint,
    pub mac_len: __u16,
    pub hdr_len: __u16,
    pub queue_mapping: __u16,
    pub __cloned_offset: __IncompleteArrayField<__u8>,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub active_extensions: __u8,
    pub headers_start: __IncompleteArrayField<__u32>,
    pub __pkt_type_offset: __IncompleteArrayField<__u8>,
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 2usize], u8>,
    pub __pkt_vlan_present_offset: __IncompleteArrayField<__u8>,
    pub _bitfield_3: __BindgenBitfieldUnit<[u8; 3usize], u8>,
    pub tc_index: __u16,
    pub __bindgen_anon_5: sk_buff__bindgen_ty_5,
    pub priority: __u32,
    pub skb_iif: c_types::c_int,
    pub hash: __u32,
    pub vlan_proto: __be16,
    pub vlan_tci: __u16,
    pub __bindgen_anon_6: sk_buff__bindgen_ty_6,
    pub secmark: __u32,
    pub __bindgen_anon_7: sk_buff__bindgen_ty_7,
    pub __bindgen_anon_8: sk_buff__bindgen_ty_8,
    pub inner_transport_header: __u16,
    pub inner_network_header: __u16,
    pub inner_mac_header: __u16,
    pub protocol: __be16,
    pub transport_header: __u16,
    pub network_header: __u16,
    pub mac_header: __u16,
    pub headers_end: __IncompleteArrayField<__u32>,
    pub tail: sk_buff_data_t,
    pub end: sk_buff_data_t,
    pub head: *mut c_types::c_uchar,
    pub data: *mut c_types::c_uchar,
    pub truesize: c_types::c_uint,
    pub users: refcount_t,
    pub extensions: *mut skb_ext,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sk_buff__bindgen_ty_1 {
    pub __bindgen_anon_1: sk_buff__bindgen_ty_1__bindgen_ty_1,
    pub rbnode: rb_node,
    pub list: list_head,
    _bindgen_union_align: [u64; 3usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sk_buff__bindgen_ty_1__bindgen_ty_1 {
    pub next: *mut sk_buff,
    pub prev: *mut sk_buff,
    pub __bindgen_anon_1: sk_buff__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sk_buff__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub dev: *mut net_device,
    pub dev_scratch: c_types::c_ulong,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_sk_buff__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<sk_buff__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(sk_buff__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_buff__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(sk_buff__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sk_buff__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>())).dev
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(dev)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sk_buff__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>()))
                .dev_scratch as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(dev_scratch)
        )
    );
}
impl Default for sk_buff__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_sk_buff__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<sk_buff__bindgen_ty_1__bindgen_ty_1>(),
        24usize,
        concat!("Size of: ", stringify!(sk_buff__bindgen_ty_1__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<sk_buff__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(sk_buff__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sk_buff__bindgen_ty_1__bindgen_ty_1>())).next as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sk_buff__bindgen_ty_1__bindgen_ty_1>())).prev as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(prev)
        )
    );
}
impl Default for sk_buff__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_sk_buff__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<sk_buff__bindgen_ty_1>(),
        24usize,
        concat!("Size of: ", stringify!(sk_buff__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<sk_buff__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(sk_buff__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sk_buff__bindgen_ty_1>())).rbnode as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff__bindgen_ty_1),
            "::",
            stringify!(rbnode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sk_buff__bindgen_ty_1>())).list as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff__bindgen_ty_1),
            "::",
            stringify!(list)
        )
    );
}
impl Default for sk_buff__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sk_buff__bindgen_ty_2 {
    pub sk: *mut sock,
    pub ip_defrag_offset: c_types::c_int,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_sk_buff__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<sk_buff__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(sk_buff__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<sk_buff__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(sk_buff__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sk_buff__bindgen_ty_2>())).sk as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff__bindgen_ty_2),
            "::",
            stringify!(sk)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sk_buff__bindgen_ty_2>())).ip_defrag_offset as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff__bindgen_ty_2),
            "::",
            stringify!(ip_defrag_offset)
        )
    );
}
impl Default for sk_buff__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sk_buff__bindgen_ty_3 {
    pub tstamp: ktime_t,
    pub skb_mstamp_ns: u64_,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_sk_buff__bindgen_ty_3() {
    assert_eq!(
        ::core::mem::size_of::<sk_buff__bindgen_ty_3>(),
        8usize,
        concat!("Size of: ", stringify!(sk_buff__bindgen_ty_3))
    );
    assert_eq!(
        ::core::mem::align_of::<sk_buff__bindgen_ty_3>(),
        8usize,
        concat!("Alignment of ", stringify!(sk_buff__bindgen_ty_3))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sk_buff__bindgen_ty_3>())).tstamp as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff__bindgen_ty_3),
            "::",
            stringify!(tstamp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sk_buff__bindgen_ty_3>())).skb_mstamp_ns as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff__bindgen_ty_3),
            "::",
            stringify!(skb_mstamp_ns)
        )
    );
}
impl Default for sk_buff__bindgen_ty_3 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sk_buff__bindgen_ty_4 {
    pub __bindgen_anon_1: sk_buff__bindgen_ty_4__bindgen_ty_1,
    pub tcp_tsorted_anchor: list_head,
    _bindgen_union_align: [u64; 2usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct sk_buff__bindgen_ty_4__bindgen_ty_1 {
    pub _skb_refdst: c_types::c_ulong,
    pub destructor: ::core::option::Option<unsafe extern "C" fn(skb: *mut sk_buff)>,
}
#[test]
fn bindgen_test_layout_sk_buff__bindgen_ty_4__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<sk_buff__bindgen_ty_4__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(sk_buff__bindgen_ty_4__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<sk_buff__bindgen_ty_4__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(sk_buff__bindgen_ty_4__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sk_buff__bindgen_ty_4__bindgen_ty_1>()))._skb_refdst as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff__bindgen_ty_4__bindgen_ty_1),
            "::",
            stringify!(_skb_refdst)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sk_buff__bindgen_ty_4__bindgen_ty_1>())).destructor as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff__bindgen_ty_4__bindgen_ty_1),
            "::",
            stringify!(destructor)
        )
    );
}
#[test]
fn bindgen_test_layout_sk_buff__bindgen_ty_4() {
    assert_eq!(
        ::core::mem::size_of::<sk_buff__bindgen_ty_4>(),
        16usize,
        concat!("Size of: ", stringify!(sk_buff__bindgen_ty_4))
    );
    assert_eq!(
        ::core::mem::align_of::<sk_buff__bindgen_ty_4>(),
        8usize,
        concat!("Alignment of ", stringify!(sk_buff__bindgen_ty_4))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sk_buff__bindgen_ty_4>())).tcp_tsorted_anchor as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff__bindgen_ty_4),
            "::",
            stringify!(tcp_tsorted_anchor)
        )
    );
}
impl Default for sk_buff__bindgen_ty_4 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sk_buff__bindgen_ty_5 {
    pub csum: __wsum,
    pub __bindgen_anon_1: sk_buff__bindgen_ty_5__bindgen_ty_1,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct sk_buff__bindgen_ty_5__bindgen_ty_1 {
    pub csum_start: __u16,
    pub csum_offset: __u16,
}
#[test]
fn bindgen_test_layout_sk_buff__bindgen_ty_5__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<sk_buff__bindgen_ty_5__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(sk_buff__bindgen_ty_5__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<sk_buff__bindgen_ty_5__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(sk_buff__bindgen_ty_5__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sk_buff__bindgen_ty_5__bindgen_ty_1>())).csum_start as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff__bindgen_ty_5__bindgen_ty_1),
            "::",
            stringify!(csum_start)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sk_buff__bindgen_ty_5__bindgen_ty_1>())).csum_offset as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff__bindgen_ty_5__bindgen_ty_1),
            "::",
            stringify!(csum_offset)
        )
    );
}
#[test]
fn bindgen_test_layout_sk_buff__bindgen_ty_5() {
    assert_eq!(
        ::core::mem::size_of::<sk_buff__bindgen_ty_5>(),
        4usize,
        concat!("Size of: ", stringify!(sk_buff__bindgen_ty_5))
    );
    assert_eq!(
        ::core::mem::align_of::<sk_buff__bindgen_ty_5>(),
        4usize,
        concat!("Alignment of ", stringify!(sk_buff__bindgen_ty_5))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sk_buff__bindgen_ty_5>())).csum as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff__bindgen_ty_5),
            "::",
            stringify!(csum)
        )
    );
}
impl Default for sk_buff__bindgen_ty_5 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sk_buff__bindgen_ty_6 {
    pub napi_id: c_types::c_uint,
    pub sender_cpu: c_types::c_uint,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_sk_buff__bindgen_ty_6() {
    assert_eq!(
        ::core::mem::size_of::<sk_buff__bindgen_ty_6>(),
        4usize,
        concat!("Size of: ", stringify!(sk_buff__bindgen_ty_6))
    );
    assert_eq!(
        ::core::mem::align_of::<sk_buff__bindgen_ty_6>(),
        4usize,
        concat!("Alignment of ", stringify!(sk_buff__bindgen_ty_6))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sk_buff__bindgen_ty_6>())).napi_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff__bindgen_ty_6),
            "::",
            stringify!(napi_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sk_buff__bindgen_ty_6>())).sender_cpu as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff__bindgen_ty_6),
            "::",
            stringify!(sender_cpu)
        )
    );
}
impl Default for sk_buff__bindgen_ty_6 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sk_buff__bindgen_ty_7 {
    pub mark: __u32,
    pub reserved_tailroom: __u32,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_sk_buff__bindgen_ty_7() {
    assert_eq!(
        ::core::mem::size_of::<sk_buff__bindgen_ty_7>(),
        4usize,
        concat!("Size of: ", stringify!(sk_buff__bindgen_ty_7))
    );
    assert_eq!(
        ::core::mem::align_of::<sk_buff__bindgen_ty_7>(),
        4usize,
        concat!("Alignment of ", stringify!(sk_buff__bindgen_ty_7))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sk_buff__bindgen_ty_7>())).mark as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff__bindgen_ty_7),
            "::",
            stringify!(mark)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sk_buff__bindgen_ty_7>())).reserved_tailroom as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff__bindgen_ty_7),
            "::",
            stringify!(reserved_tailroom)
        )
    );
}
impl Default for sk_buff__bindgen_ty_7 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sk_buff__bindgen_ty_8 {
    pub inner_protocol: __be16,
    pub inner_ipproto: __u8,
    _bindgen_union_align: u16,
}
#[test]
fn bindgen_test_layout_sk_buff__bindgen_ty_8() {
    assert_eq!(
        ::core::mem::size_of::<sk_buff__bindgen_ty_8>(),
        2usize,
        concat!("Size of: ", stringify!(sk_buff__bindgen_ty_8))
    );
    assert_eq!(
        ::core::mem::align_of::<sk_buff__bindgen_ty_8>(),
        2usize,
        concat!("Alignment of ", stringify!(sk_buff__bindgen_ty_8))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sk_buff__bindgen_ty_8>())).inner_protocol as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff__bindgen_ty_8),
            "::",
            stringify!(inner_protocol)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sk_buff__bindgen_ty_8>())).inner_ipproto as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff__bindgen_ty_8),
            "::",
            stringify!(inner_ipproto)
        )
    );
}
impl Default for sk_buff__bindgen_ty_8 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_sk_buff() {
    assert_eq!(
        ::core::mem::size_of::<sk_buff>(),
        224usize,
        concat!("Size of: ", stringify!(sk_buff))
    );
    assert_eq!(
        ::core::mem::align_of::<sk_buff>(),
        8usize,
        concat!("Alignment of ", stringify!(sk_buff))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sk_buff>())).cb as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff),
            "::",
            stringify!(cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sk_buff>()))._nfct as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff),
            "::",
            stringify!(_nfct)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sk_buff>())).len as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sk_buff>())).data_len as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff),
            "::",
            stringify!(data_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sk_buff>())).mac_len as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff),
            "::",
            stringify!(mac_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sk_buff>())).hdr_len as *const _ as usize },
        122usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff),
            "::",
            stringify!(hdr_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sk_buff>())).queue_mapping as *const _ as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff),
            "::",
            stringify!(queue_mapping)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sk_buff>())).__cloned_offset as *const _ as usize },
        126usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff),
            "::",
            stringify!(__cloned_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sk_buff>())).active_extensions as *const _ as usize },
        127usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff),
            "::",
            stringify!(active_extensions)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sk_buff>())).headers_start as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff),
            "::",
            stringify!(headers_start)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sk_buff>())).__pkt_type_offset as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff),
            "::",
            stringify!(__pkt_type_offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sk_buff>())).__pkt_vlan_present_offset as *const _ as usize
        },
        130usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff),
            "::",
            stringify!(__pkt_vlan_present_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sk_buff>())).tc_index as *const _ as usize },
        134usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff),
            "::",
            stringify!(tc_index)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sk_buff>())).priority as *const _ as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff),
            "::",
            stringify!(priority)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sk_buff>())).skb_iif as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff),
            "::",
            stringify!(skb_iif)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sk_buff>())).hash as *const _ as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff),
            "::",
            stringify!(hash)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sk_buff>())).vlan_proto as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff),
            "::",
            stringify!(vlan_proto)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sk_buff>())).vlan_tci as *const _ as usize },
        154usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff),
            "::",
            stringify!(vlan_tci)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sk_buff>())).secmark as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff),
            "::",
            stringify!(secmark)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sk_buff>())).inner_transport_header as *const _ as usize },
        170usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff),
            "::",
            stringify!(inner_transport_header)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sk_buff>())).inner_network_header as *const _ as usize },
        172usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff),
            "::",
            stringify!(inner_network_header)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sk_buff>())).inner_mac_header as *const _ as usize },
        174usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff),
            "::",
            stringify!(inner_mac_header)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sk_buff>())).protocol as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff),
            "::",
            stringify!(protocol)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sk_buff>())).transport_header as *const _ as usize },
        178usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff),
            "::",
            stringify!(transport_header)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sk_buff>())).network_header as *const _ as usize },
        180usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff),
            "::",
            stringify!(network_header)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sk_buff>())).mac_header as *const _ as usize },
        182usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff),
            "::",
            stringify!(mac_header)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sk_buff>())).headers_end as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff),
            "::",
            stringify!(headers_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sk_buff>())).tail as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff),
            "::",
            stringify!(tail)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sk_buff>())).end as *const _ as usize },
        188usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff),
            "::",
            stringify!(end)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sk_buff>())).head as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff),
            "::",
            stringify!(head)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sk_buff>())).data as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sk_buff>())).truesize as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff),
            "::",
            stringify!(truesize)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sk_buff>())).users as *const _ as usize },
        212usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff),
            "::",
            stringify!(users)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sk_buff>())).extensions as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff),
            "::",
            stringify!(extensions)
        )
    );
}
impl Default for sk_buff {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl sk_buff {
    #[inline]
    pub fn cloned(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_cloned(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn nohdr(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_nohdr(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fclone(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_fclone(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn peeked(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_peeked(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn head_frag(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_head_frag(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pfmemalloc(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_pfmemalloc(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        cloned: __u8,
        nohdr: __u8,
        fclone: __u8,
        peeked: __u8,
        head_frag: __u8,
        pfmemalloc: __u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let cloned: u8 = unsafe { ::core::mem::transmute(cloned) };
            cloned as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let nohdr: u8 = unsafe { ::core::mem::transmute(nohdr) };
            nohdr as u64
        });
        __bindgen_bitfield_unit.set(2usize, 2u8, {
            let fclone: u8 = unsafe { ::core::mem::transmute(fclone) };
            fclone as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let peeked: u8 = unsafe { ::core::mem::transmute(peeked) };
            peeked as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let head_frag: u8 = unsafe { ::core::mem::transmute(head_frag) };
            head_frag as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let pfmemalloc: u8 = unsafe { ::core::mem::transmute(pfmemalloc) };
            pfmemalloc as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn pkt_type(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(0usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_pkt_type(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn ignore_df(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ignore_df(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn nf_trace(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_nf_trace(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ip_summed(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(5usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_ip_summed(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(5usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn ooo_okay(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ooo_okay(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn l4_hash(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(8usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_l4_hash(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sw_hash(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(9usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_sw_hash(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wifi_acked_valid(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(10usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_wifi_acked_valid(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wifi_acked(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(11usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_wifi_acked(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn no_fcs(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(12usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_no_fcs(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn encapsulation(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(13usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_encapsulation(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn encap_hdr_csum(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(14usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_encap_hdr_csum(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn csum_valid(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(15usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_csum_valid(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_2(
        pkt_type: __u8,
        ignore_df: __u8,
        nf_trace: __u8,
        ip_summed: __u8,
        ooo_okay: __u8,
        l4_hash: __u8,
        sw_hash: __u8,
        wifi_acked_valid: __u8,
        wifi_acked: __u8,
        no_fcs: __u8,
        encapsulation: __u8,
        encap_hdr_csum: __u8,
        csum_valid: __u8,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let pkt_type: u8 = unsafe { ::core::mem::transmute(pkt_type) };
            pkt_type as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let ignore_df: u8 = unsafe { ::core::mem::transmute(ignore_df) };
            ignore_df as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let nf_trace: u8 = unsafe { ::core::mem::transmute(nf_trace) };
            nf_trace as u64
        });
        __bindgen_bitfield_unit.set(5usize, 2u8, {
            let ip_summed: u8 = unsafe { ::core::mem::transmute(ip_summed) };
            ip_summed as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let ooo_okay: u8 = unsafe { ::core::mem::transmute(ooo_okay) };
            ooo_okay as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let l4_hash: u8 = unsafe { ::core::mem::transmute(l4_hash) };
            l4_hash as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let sw_hash: u8 = unsafe { ::core::mem::transmute(sw_hash) };
            sw_hash as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let wifi_acked_valid: u8 = unsafe { ::core::mem::transmute(wifi_acked_valid) };
            wifi_acked_valid as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let wifi_acked: u8 = unsafe { ::core::mem::transmute(wifi_acked) };
            wifi_acked as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let no_fcs: u8 = unsafe { ::core::mem::transmute(no_fcs) };
            no_fcs as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let encapsulation: u8 = unsafe { ::core::mem::transmute(encapsulation) };
            encapsulation as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let encap_hdr_csum: u8 = unsafe { ::core::mem::transmute(encap_hdr_csum) };
            encap_hdr_csum as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let csum_valid: u8 = unsafe { ::core::mem::transmute(csum_valid) };
            csum_valid as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn vlan_present(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_vlan_present(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_3.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn csum_complete_sw(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_csum_complete_sw(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_3.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn csum_level(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(2usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_csum_level(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_3.set(2usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn csum_not_inet(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_csum_not_inet(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_3.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dst_pending_confirm(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_dst_pending_confirm(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_3.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ndisc_nodetype(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(6usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_ndisc_nodetype(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_3.set(6usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn ipvs_property(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(8usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ipvs_property(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_3.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn inner_protocol_type(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(9usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_inner_protocol_type(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_3.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn remcsum_offload(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(10usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_remcsum_offload(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_3.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn offload_fwd_mark(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(11usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_offload_fwd_mark(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_3.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn offload_l3_fwd_mark(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(12usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_offload_l3_fwd_mark(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_3.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tc_skip_classify(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(13usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_tc_skip_classify(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_3.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tc_at_ingress(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(14usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_tc_at_ingress(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_3.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn redirected(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(15usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_redirected(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_3.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn from_ingress(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(16usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_from_ingress(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_3.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn decrypted(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(17usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_decrypted(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_3.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_3(
        vlan_present: __u8,
        csum_complete_sw: __u8,
        csum_level: __u8,
        csum_not_inet: __u8,
        dst_pending_confirm: __u8,
        ndisc_nodetype: __u8,
        ipvs_property: __u8,
        inner_protocol_type: __u8,
        remcsum_offload: __u8,
        offload_fwd_mark: __u8,
        offload_l3_fwd_mark: __u8,
        tc_skip_classify: __u8,
        tc_at_ingress: __u8,
        redirected: __u8,
        from_ingress: __u8,
        decrypted: __u8,
    ) -> __BindgenBitfieldUnit<[u8; 3usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let vlan_present: u8 = unsafe { ::core::mem::transmute(vlan_present) };
            vlan_present as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let csum_complete_sw: u8 = unsafe { ::core::mem::transmute(csum_complete_sw) };
            csum_complete_sw as u64
        });
        __bindgen_bitfield_unit.set(2usize, 2u8, {
            let csum_level: u8 = unsafe { ::core::mem::transmute(csum_level) };
            csum_level as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let csum_not_inet: u8 = unsafe { ::core::mem::transmute(csum_not_inet) };
            csum_not_inet as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let dst_pending_confirm: u8 = unsafe { ::core::mem::transmute(dst_pending_confirm) };
            dst_pending_confirm as u64
        });
        __bindgen_bitfield_unit.set(6usize, 2u8, {
            let ndisc_nodetype: u8 = unsafe { ::core::mem::transmute(ndisc_nodetype) };
            ndisc_nodetype as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let ipvs_property: u8 = unsafe { ::core::mem::transmute(ipvs_property) };
            ipvs_property as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let inner_protocol_type: u8 = unsafe { ::core::mem::transmute(inner_protocol_type) };
            inner_protocol_type as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let remcsum_offload: u8 = unsafe { ::core::mem::transmute(remcsum_offload) };
            remcsum_offload as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let offload_fwd_mark: u8 = unsafe { ::core::mem::transmute(offload_fwd_mark) };
            offload_fwd_mark as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let offload_l3_fwd_mark: u8 = unsafe { ::core::mem::transmute(offload_l3_fwd_mark) };
            offload_l3_fwd_mark as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let tc_skip_classify: u8 = unsafe { ::core::mem::transmute(tc_skip_classify) };
            tc_skip_classify as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let tc_at_ingress: u8 = unsafe { ::core::mem::transmute(tc_at_ingress) };
            tc_at_ingress as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let redirected: u8 = unsafe { ::core::mem::transmute(redirected) };
            redirected as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let from_ingress: u8 = unsafe { ::core::mem::transmute(from_ingress) };
            from_ingress as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let decrypted: u8 = unsafe { ::core::mem::transmute(decrypted) };
            decrypted as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub fn skb_dequeue(list: *mut sk_buff_head) -> *mut sk_buff;
}
extern "C" {
    pub fn skb_copy_bits(
        skb: *const sk_buff,
        offset: c_types::c_int,
        to: *mut c_types::c_void,
        len: c_types::c_int,
    ) -> c_types::c_int;
}
#[doc = "\tstruct skb_ext - sk_buff extensions"]
#[doc = "\t@refcnt: 1 on allocation, deallocated on 0"]
#[doc = "\t@offset: offset to add to @data to obtain extension address"]
#[doc = "\t@chunks: size currently allocated, stored in SKB_EXT_ALIGN_SHIFT units"]
#[doc = "\t@data: start of extension data, variable sized"]
#[doc = ""]
#[doc = "\tNote: offsets/lengths are stored in chunks of 8 bytes, this allows"]
#[doc = "\tto use 'u8' types while allowing up to 2kb worth of extension data."]
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Default)]
pub struct skb_ext {
    pub refcnt: refcount_t,
    pub offset: [u8_; 3usize],
    pub chunks: u8_,
    pub data: __IncompleteArrayField<c_types::c_char>,
}
#[test]
fn bindgen_test_layout_skb_ext() {
    assert_eq!(
        ::core::mem::size_of::<skb_ext>(),
        8usize,
        concat!("Size of: ", stringify!(skb_ext))
    );
    assert_eq!(
        ::core::mem::align_of::<skb_ext>(),
        8usize,
        concat!("Alignment of ", stringify!(skb_ext))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<skb_ext>())).refcnt as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(skb_ext),
            "::",
            stringify!(refcnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<skb_ext>())).offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(skb_ext),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<skb_ext>())).chunks as *const _ as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(skb_ext),
            "::",
            stringify!(chunks)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<skb_ext>())).data as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(skb_ext),
            "::",
            stringify!(data)
        )
    );
}
pub type proc_handler = ::core::option::Option<
    unsafe extern "C" fn(
        ctl: *mut ctl_table,
        write: c_types::c_int,
        buffer: *mut c_types::c_void,
        lenp: *mut usize,
        ppos: *mut loff_t,
    ) -> c_types::c_int,
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ctl_table_poll {
    pub event: atomic_t,
    pub wait: wait_queue_head_t,
}
#[test]
fn bindgen_test_layout_ctl_table_poll() {
    assert_eq!(
        ::core::mem::size_of::<ctl_table_poll>(),
        32usize,
        concat!("Size of: ", stringify!(ctl_table_poll))
    );
    assert_eq!(
        ::core::mem::align_of::<ctl_table_poll>(),
        8usize,
        concat!("Alignment of ", stringify!(ctl_table_poll))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ctl_table_poll>())).event as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ctl_table_poll),
            "::",
            stringify!(event)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ctl_table_poll>())).wait as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ctl_table_poll),
            "::",
            stringify!(wait)
        )
    );
}
impl Default for ctl_table_poll {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ctl_table {
    pub procname: *const c_types::c_char,
    pub data: *mut c_types::c_void,
    pub maxlen: c_types::c_int,
    pub mode: umode_t,
    pub child: *mut ctl_table,
    pub proc_handler: proc_handler,
    pub poll: *mut ctl_table_poll,
    pub extra1: *mut c_types::c_void,
    pub extra2: *mut c_types::c_void,
}
#[test]
fn bindgen_test_layout_ctl_table() {
    assert_eq!(
        ::core::mem::size_of::<ctl_table>(),
        64usize,
        concat!("Size of: ", stringify!(ctl_table))
    );
    assert_eq!(
        ::core::mem::align_of::<ctl_table>(),
        8usize,
        concat!("Alignment of ", stringify!(ctl_table))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ctl_table>())).procname as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ctl_table),
            "::",
            stringify!(procname)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ctl_table>())).data as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ctl_table),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ctl_table>())).maxlen as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ctl_table),
            "::",
            stringify!(maxlen)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ctl_table>())).mode as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ctl_table),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ctl_table>())).child as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ctl_table),
            "::",
            stringify!(child)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ctl_table>())).proc_handler as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ctl_table),
            "::",
            stringify!(proc_handler)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ctl_table>())).poll as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ctl_table),
            "::",
            stringify!(poll)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ctl_table>())).extra1 as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ctl_table),
            "::",
            stringify!(extra1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ctl_table>())).extra2 as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ctl_table),
            "::",
            stringify!(extra2)
        )
    );
}
impl Default for ctl_table {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ctl_node {
    pub node: rb_node,
    pub header: *mut ctl_table_header,
}
#[test]
fn bindgen_test_layout_ctl_node() {
    assert_eq!(
        ::core::mem::size_of::<ctl_node>(),
        32usize,
        concat!("Size of: ", stringify!(ctl_node))
    );
    assert_eq!(
        ::core::mem::align_of::<ctl_node>(),
        8usize,
        concat!("Alignment of ", stringify!(ctl_node))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ctl_node>())).node as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ctl_node),
            "::",
            stringify!(node)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ctl_node>())).header as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ctl_node),
            "::",
            stringify!(header)
        )
    );
}
impl Default for ctl_node {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ctl_table_header {
    pub __bindgen_anon_1: ctl_table_header__bindgen_ty_1,
    pub unregistering: *mut completion,
    pub ctl_table_arg: *mut ctl_table,
    pub root: *mut ctl_table_root,
    pub set: *mut ctl_table_set,
    pub parent: *mut ctl_dir,
    pub node: *mut ctl_node,
    pub inodes: hlist_head,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ctl_table_header__bindgen_ty_1 {
    pub __bindgen_anon_1: ctl_table_header__bindgen_ty_1__bindgen_ty_1,
    pub rcu: callback_head,
    _bindgen_union_align: [u64; 3usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ctl_table_header__bindgen_ty_1__bindgen_ty_1 {
    pub ctl_table: *mut ctl_table,
    pub used: c_types::c_int,
    pub count: c_types::c_int,
    pub nreg: c_types::c_int,
}
#[test]
fn bindgen_test_layout_ctl_table_header__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<ctl_table_header__bindgen_ty_1__bindgen_ty_1>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(ctl_table_header__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<ctl_table_header__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(ctl_table_header__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ctl_table_header__bindgen_ty_1__bindgen_ty_1>())).ctl_table
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ctl_table_header__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(ctl_table)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ctl_table_header__bindgen_ty_1__bindgen_ty_1>())).used
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ctl_table_header__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(used)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ctl_table_header__bindgen_ty_1__bindgen_ty_1>())).count
                as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ctl_table_header__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ctl_table_header__bindgen_ty_1__bindgen_ty_1>())).nreg
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ctl_table_header__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(nreg)
        )
    );
}
impl Default for ctl_table_header__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_ctl_table_header__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<ctl_table_header__bindgen_ty_1>(),
        24usize,
        concat!("Size of: ", stringify!(ctl_table_header__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<ctl_table_header__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(ctl_table_header__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ctl_table_header__bindgen_ty_1>())).rcu as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ctl_table_header__bindgen_ty_1),
            "::",
            stringify!(rcu)
        )
    );
}
impl Default for ctl_table_header__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_ctl_table_header() {
    assert_eq!(
        ::core::mem::size_of::<ctl_table_header>(),
        80usize,
        concat!("Size of: ", stringify!(ctl_table_header))
    );
    assert_eq!(
        ::core::mem::align_of::<ctl_table_header>(),
        8usize,
        concat!("Alignment of ", stringify!(ctl_table_header))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ctl_table_header>())).unregistering as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ctl_table_header),
            "::",
            stringify!(unregistering)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ctl_table_header>())).ctl_table_arg as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ctl_table_header),
            "::",
            stringify!(ctl_table_arg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ctl_table_header>())).root as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ctl_table_header),
            "::",
            stringify!(root)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ctl_table_header>())).set as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ctl_table_header),
            "::",
            stringify!(set)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ctl_table_header>())).parent as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ctl_table_header),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ctl_table_header>())).node as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(ctl_table_header),
            "::",
            stringify!(node)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ctl_table_header>())).inodes as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(ctl_table_header),
            "::",
            stringify!(inodes)
        )
    );
}
impl Default for ctl_table_header {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ctl_dir {
    pub header: ctl_table_header,
    pub root: rb_root,
}
#[test]
fn bindgen_test_layout_ctl_dir() {
    assert_eq!(
        ::core::mem::size_of::<ctl_dir>(),
        88usize,
        concat!("Size of: ", stringify!(ctl_dir))
    );
    assert_eq!(
        ::core::mem::align_of::<ctl_dir>(),
        8usize,
        concat!("Alignment of ", stringify!(ctl_dir))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ctl_dir>())).header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ctl_dir),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ctl_dir>())).root as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(ctl_dir),
            "::",
            stringify!(root)
        )
    );
}
impl Default for ctl_dir {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ctl_table_set {
    pub is_seen:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut ctl_table_set) -> c_types::c_int>,
    pub dir: ctl_dir,
}
#[test]
fn bindgen_test_layout_ctl_table_set() {
    assert_eq!(
        ::core::mem::size_of::<ctl_table_set>(),
        96usize,
        concat!("Size of: ", stringify!(ctl_table_set))
    );
    assert_eq!(
        ::core::mem::align_of::<ctl_table_set>(),
        8usize,
        concat!("Alignment of ", stringify!(ctl_table_set))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ctl_table_set>())).is_seen as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ctl_table_set),
            "::",
            stringify!(is_seen)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ctl_table_set>())).dir as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ctl_table_set),
            "::",
            stringify!(dir)
        )
    );
}
impl Default for ctl_table_set {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ctl_table_root {
    pub default_set: ctl_table_set,
    pub lookup: ::core::option::Option<
        unsafe extern "C" fn(root: *mut ctl_table_root) -> *mut ctl_table_set,
    >,
    pub set_ownership: ::core::option::Option<
        unsafe extern "C" fn(
            head: *mut ctl_table_header,
            table: *mut ctl_table,
            uid: *mut kuid_t,
            gid: *mut kgid_t,
        ),
    >,
    pub permissions: ::core::option::Option<
        unsafe extern "C" fn(head: *mut ctl_table_header, table: *mut ctl_table) -> c_types::c_int,
    >,
}
#[test]
fn bindgen_test_layout_ctl_table_root() {
    assert_eq!(
        ::core::mem::size_of::<ctl_table_root>(),
        120usize,
        concat!("Size of: ", stringify!(ctl_table_root))
    );
    assert_eq!(
        ::core::mem::align_of::<ctl_table_root>(),
        8usize,
        concat!("Alignment of ", stringify!(ctl_table_root))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ctl_table_root>())).default_set as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ctl_table_root),
            "::",
            stringify!(default_set)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ctl_table_root>())).lookup as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(ctl_table_root),
            "::",
            stringify!(lookup)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ctl_table_root>())).set_ownership as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(ctl_table_root),
            "::",
            stringify!(set_ownership)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ctl_table_root>())).permissions as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(ctl_table_root),
            "::",
            stringify!(permissions)
        )
    );
}
impl Default for ctl_table_root {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct assoc_array {
    pub root: *mut assoc_array_ptr,
    pub nr_leaves_on_tree: c_types::c_ulong,
}
#[test]
fn bindgen_test_layout_assoc_array() {
    assert_eq!(
        ::core::mem::size_of::<assoc_array>(),
        16usize,
        concat!("Size of: ", stringify!(assoc_array))
    );
    assert_eq!(
        ::core::mem::align_of::<assoc_array>(),
        8usize,
        concat!("Alignment of ", stringify!(assoc_array))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<assoc_array>())).root as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(assoc_array),
            "::",
            stringify!(root)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<assoc_array>())).nr_leaves_on_tree as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(assoc_array),
            "::",
            stringify!(nr_leaves_on_tree)
        )
    );
}
impl Default for assoc_array {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type key_serial_t = i32;
pub type key_perm_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct key_type {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct key_tag {
    pub rcu: callback_head,
    pub usage: refcount_t,
    pub removed: bool_,
}
#[test]
fn bindgen_test_layout_key_tag() {
    assert_eq!(
        ::core::mem::size_of::<key_tag>(),
        24usize,
        concat!("Size of: ", stringify!(key_tag))
    );
    assert_eq!(
        ::core::mem::align_of::<key_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(key_tag))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<key_tag>())).rcu as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(key_tag),
            "::",
            stringify!(rcu)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<key_tag>())).usage as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(key_tag),
            "::",
            stringify!(usage)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<key_tag>())).removed as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(key_tag),
            "::",
            stringify!(removed)
        )
    );
}
impl Default for key_tag {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct keyring_index_key {
    pub hash: c_types::c_ulong,
    pub __bindgen_anon_1: keyring_index_key__bindgen_ty_1,
    pub type_: *mut key_type,
    pub domain_tag: *mut key_tag,
    pub description: *const c_types::c_char,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union keyring_index_key__bindgen_ty_1 {
    pub __bindgen_anon_1: keyring_index_key__bindgen_ty_1__bindgen_ty_1,
    pub x: c_types::c_ulong,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct keyring_index_key__bindgen_ty_1__bindgen_ty_1 {
    pub desc_len: u16_,
    pub desc: [c_types::c_char; 6usize],
}
#[test]
fn bindgen_test_layout_keyring_index_key__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<keyring_index_key__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(keyring_index_key__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<keyring_index_key__bindgen_ty_1__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(keyring_index_key__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<keyring_index_key__bindgen_ty_1__bindgen_ty_1>())).desc_len
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(keyring_index_key__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(desc_len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<keyring_index_key__bindgen_ty_1__bindgen_ty_1>())).desc
                as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(keyring_index_key__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(desc)
        )
    );
}
#[test]
fn bindgen_test_layout_keyring_index_key__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<keyring_index_key__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(keyring_index_key__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<keyring_index_key__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(keyring_index_key__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<keyring_index_key__bindgen_ty_1>())).x as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(keyring_index_key__bindgen_ty_1),
            "::",
            stringify!(x)
        )
    );
}
impl Default for keyring_index_key__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_keyring_index_key() {
    assert_eq!(
        ::core::mem::size_of::<keyring_index_key>(),
        40usize,
        concat!("Size of: ", stringify!(keyring_index_key))
    );
    assert_eq!(
        ::core::mem::align_of::<keyring_index_key>(),
        8usize,
        concat!("Alignment of ", stringify!(keyring_index_key))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<keyring_index_key>())).hash as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(keyring_index_key),
            "::",
            stringify!(hash)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<keyring_index_key>())).type_ as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(keyring_index_key),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<keyring_index_key>())).domain_tag as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(keyring_index_key),
            "::",
            stringify!(domain_tag)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<keyring_index_key>())).description as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(keyring_index_key),
            "::",
            stringify!(description)
        )
    );
}
impl Default for keyring_index_key {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union key_payload {
    pub rcu_data0: *mut c_types::c_void,
    pub data: [*mut c_types::c_void; 4usize],
    _bindgen_union_align: [u64; 4usize],
}
#[test]
fn bindgen_test_layout_key_payload() {
    assert_eq!(
        ::core::mem::size_of::<key_payload>(),
        32usize,
        concat!("Size of: ", stringify!(key_payload))
    );
    assert_eq!(
        ::core::mem::align_of::<key_payload>(),
        8usize,
        concat!("Alignment of ", stringify!(key_payload))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<key_payload>())).rcu_data0 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(key_payload),
            "::",
            stringify!(rcu_data0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<key_payload>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(key_payload),
            "::",
            stringify!(data)
        )
    );
}
impl Default for key_payload {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type key_restrict_link_func_t = ::core::option::Option<
    unsafe extern "C" fn(
        dest_keyring: *mut key,
        type_: *const key_type,
        payload: *const key_payload,
        restriction_key: *mut key,
    ) -> c_types::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct key_restriction {
    pub check: key_restrict_link_func_t,
    pub key: *mut key,
    pub keytype: *mut key_type,
}
#[test]
fn bindgen_test_layout_key_restriction() {
    assert_eq!(
        ::core::mem::size_of::<key_restriction>(),
        24usize,
        concat!("Size of: ", stringify!(key_restriction))
    );
    assert_eq!(
        ::core::mem::align_of::<key_restriction>(),
        8usize,
        concat!("Alignment of ", stringify!(key_restriction))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<key_restriction>())).check as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(key_restriction),
            "::",
            stringify!(check)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<key_restriction>())).key as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(key_restriction),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<key_restriction>())).keytype as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(key_restriction),
            "::",
            stringify!(keytype)
        )
    );
}
impl Default for key_restriction {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct key {
    pub usage: refcount_t,
    pub serial: key_serial_t,
    pub __bindgen_anon_1: key__bindgen_ty_1,
    pub sem: rw_semaphore,
    pub user: *mut key_user,
    pub security: *mut c_types::c_void,
    pub __bindgen_anon_2: key__bindgen_ty_2,
    pub last_used_at: time64_t,
    pub uid: kuid_t,
    pub gid: kgid_t,
    pub perm: key_perm_t,
    pub quotalen: c_types::c_ushort,
    pub datalen: c_types::c_ushort,
    pub state: c_types::c_short,
    pub flags: c_types::c_ulong,
    pub __bindgen_anon_3: key__bindgen_ty_3,
    pub __bindgen_anon_4: key__bindgen_ty_4,
    pub restrict_link: *mut key_restriction,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union key__bindgen_ty_1 {
    pub graveyard_link: list_head,
    pub serial_node: rb_node,
    _bindgen_union_align: [u64; 3usize],
}
#[test]
fn bindgen_test_layout_key__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<key__bindgen_ty_1>(),
        24usize,
        concat!("Size of: ", stringify!(key__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<key__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(key__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<key__bindgen_ty_1>())).graveyard_link as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(key__bindgen_ty_1),
            "::",
            stringify!(graveyard_link)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<key__bindgen_ty_1>())).serial_node as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(key__bindgen_ty_1),
            "::",
            stringify!(serial_node)
        )
    );
}
impl Default for key__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union key__bindgen_ty_2 {
    pub expiry: time64_t,
    pub revoked_at: time64_t,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_key__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<key__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(key__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<key__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(key__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<key__bindgen_ty_2>())).expiry as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(key__bindgen_ty_2),
            "::",
            stringify!(expiry)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<key__bindgen_ty_2>())).revoked_at as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(key__bindgen_ty_2),
            "::",
            stringify!(revoked_at)
        )
    );
}
impl Default for key__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union key__bindgen_ty_3 {
    pub index_key: keyring_index_key,
    pub __bindgen_anon_1: key__bindgen_ty_3__bindgen_ty_1,
    _bindgen_union_align: [u64; 5usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct key__bindgen_ty_3__bindgen_ty_1 {
    pub hash: c_types::c_ulong,
    pub len_desc: c_types::c_ulong,
    pub type_: *mut key_type,
    pub domain_tag: *mut key_tag,
    pub description: *mut c_types::c_char,
}
#[test]
fn bindgen_test_layout_key__bindgen_ty_3__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<key__bindgen_ty_3__bindgen_ty_1>(),
        40usize,
        concat!("Size of: ", stringify!(key__bindgen_ty_3__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<key__bindgen_ty_3__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(key__bindgen_ty_3__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<key__bindgen_ty_3__bindgen_ty_1>())).hash as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(key__bindgen_ty_3__bindgen_ty_1),
            "::",
            stringify!(hash)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<key__bindgen_ty_3__bindgen_ty_1>())).len_desc as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(key__bindgen_ty_3__bindgen_ty_1),
            "::",
            stringify!(len_desc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<key__bindgen_ty_3__bindgen_ty_1>())).type_ as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(key__bindgen_ty_3__bindgen_ty_1),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<key__bindgen_ty_3__bindgen_ty_1>())).domain_tag as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(key__bindgen_ty_3__bindgen_ty_1),
            "::",
            stringify!(domain_tag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<key__bindgen_ty_3__bindgen_ty_1>())).description as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(key__bindgen_ty_3__bindgen_ty_1),
            "::",
            stringify!(description)
        )
    );
}
impl Default for key__bindgen_ty_3__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_key__bindgen_ty_3() {
    assert_eq!(
        ::core::mem::size_of::<key__bindgen_ty_3>(),
        40usize,
        concat!("Size of: ", stringify!(key__bindgen_ty_3))
    );
    assert_eq!(
        ::core::mem::align_of::<key__bindgen_ty_3>(),
        8usize,
        concat!("Alignment of ", stringify!(key__bindgen_ty_3))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<key__bindgen_ty_3>())).index_key as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(key__bindgen_ty_3),
            "::",
            stringify!(index_key)
        )
    );
}
impl Default for key__bindgen_ty_3 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union key__bindgen_ty_4 {
    pub payload: key_payload,
    pub __bindgen_anon_1: key__bindgen_ty_4__bindgen_ty_1,
    _bindgen_union_align: [u64; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct key__bindgen_ty_4__bindgen_ty_1 {
    pub name_link: list_head,
    pub keys: assoc_array,
}
#[test]
fn bindgen_test_layout_key__bindgen_ty_4__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<key__bindgen_ty_4__bindgen_ty_1>(),
        32usize,
        concat!("Size of: ", stringify!(key__bindgen_ty_4__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<key__bindgen_ty_4__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(key__bindgen_ty_4__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<key__bindgen_ty_4__bindgen_ty_1>())).name_link as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(key__bindgen_ty_4__bindgen_ty_1),
            "::",
            stringify!(name_link)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<key__bindgen_ty_4__bindgen_ty_1>())).keys as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(key__bindgen_ty_4__bindgen_ty_1),
            "::",
            stringify!(keys)
        )
    );
}
impl Default for key__bindgen_ty_4__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_key__bindgen_ty_4() {
    assert_eq!(
        ::core::mem::size_of::<key__bindgen_ty_4>(),
        32usize,
        concat!("Size of: ", stringify!(key__bindgen_ty_4))
    );
    assert_eq!(
        ::core::mem::align_of::<key__bindgen_ty_4>(),
        8usize,
        concat!("Alignment of ", stringify!(key__bindgen_ty_4))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<key__bindgen_ty_4>())).payload as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(key__bindgen_ty_4),
            "::",
            stringify!(payload)
        )
    );
}
impl Default for key__bindgen_ty_4 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_key() {
    assert_eq!(
        ::core::mem::size_of::<key>(),
        216usize,
        concat!("Size of: ", stringify!(key))
    );
    assert_eq!(
        ::core::mem::align_of::<key>(),
        8usize,
        concat!("Alignment of ", stringify!(key))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<key>())).usage as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(key),
            "::",
            stringify!(usage)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<key>())).serial as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(key),
            "::",
            stringify!(serial)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<key>())).sem as *const _ as usize },
        32usize,
        concat!("Offset of field: ", stringify!(key), "::", stringify!(sem))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<key>())).user as *const _ as usize },
        72usize,
        concat!("Offset of field: ", stringify!(key), "::", stringify!(user))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<key>())).security as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(key),
            "::",
            stringify!(security)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<key>())).last_used_at as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(key),
            "::",
            stringify!(last_used_at)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<key>())).uid as *const _ as usize },
        104usize,
        concat!("Offset of field: ", stringify!(key), "::", stringify!(uid))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<key>())).gid as *const _ as usize },
        108usize,
        concat!("Offset of field: ", stringify!(key), "::", stringify!(gid))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<key>())).perm as *const _ as usize },
        112usize,
        concat!("Offset of field: ", stringify!(key), "::", stringify!(perm))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<key>())).quotalen as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(key),
            "::",
            stringify!(quotalen)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<key>())).datalen as *const _ as usize },
        118usize,
        concat!(
            "Offset of field: ",
            stringify!(key),
            "::",
            stringify!(datalen)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<key>())).state as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(key),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<key>())).flags as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(key),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<key>())).restrict_link as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(key),
            "::",
            stringify!(restrict_link)
        )
    );
}
impl Default for key {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct user_struct {
    pub __count: refcount_t,
    pub processes: atomic_t,
    pub sigpending: atomic_t,
    pub fanotify_listeners: atomic_t,
    pub epoll_watches: atomic_long_t,
    pub mq_bytes: c_types::c_ulong,
    pub locked_shm: c_types::c_ulong,
    pub unix_inflight: c_types::c_ulong,
    pub pipe_bufs: atomic_long_t,
    pub uidhash_node: hlist_node,
    pub uid: kuid_t,
    pub locked_vm: atomic_long_t,
    pub ratelimit: ratelimit_state,
}
#[test]
fn bindgen_test_layout_user_struct() {
    assert_eq!(
        ::core::mem::size_of::<user_struct>(),
        128usize,
        concat!("Size of: ", stringify!(user_struct))
    );
    assert_eq!(
        ::core::mem::align_of::<user_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(user_struct))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<user_struct>())).__count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(user_struct),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<user_struct>())).processes as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(user_struct),
            "::",
            stringify!(processes)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<user_struct>())).sigpending as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(user_struct),
            "::",
            stringify!(sigpending)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<user_struct>())).fanotify_listeners as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(user_struct),
            "::",
            stringify!(fanotify_listeners)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<user_struct>())).epoll_watches as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(user_struct),
            "::",
            stringify!(epoll_watches)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<user_struct>())).mq_bytes as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(user_struct),
            "::",
            stringify!(mq_bytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<user_struct>())).locked_shm as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(user_struct),
            "::",
            stringify!(locked_shm)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<user_struct>())).unix_inflight as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(user_struct),
            "::",
            stringify!(unix_inflight)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<user_struct>())).pipe_bufs as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(user_struct),
            "::",
            stringify!(pipe_bufs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<user_struct>())).uidhash_node as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(user_struct),
            "::",
            stringify!(uidhash_node)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<user_struct>())).uid as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(user_struct),
            "::",
            stringify!(uid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<user_struct>())).locked_vm as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(user_struct),
            "::",
            stringify!(locked_vm)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<user_struct>())).ratelimit as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(user_struct),
            "::",
            stringify!(ratelimit)
        )
    );
}
impl Default for user_struct {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct group_info {
    pub usage: atomic_t,
    pub ngroups: c_types::c_int,
    pub gid: __IncompleteArrayField<kgid_t>,
}
#[test]
fn bindgen_test_layout_group_info() {
    assert_eq!(
        ::core::mem::size_of::<group_info>(),
        8usize,
        concat!("Size of: ", stringify!(group_info))
    );
    assert_eq!(
        ::core::mem::align_of::<group_info>(),
        4usize,
        concat!("Alignment of ", stringify!(group_info))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<group_info>())).usage as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(group_info),
            "::",
            stringify!(usage)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<group_info>())).ngroups as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(group_info),
            "::",
            stringify!(ngroups)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<group_info>())).gid as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(group_info),
            "::",
            stringify!(gid)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cred {
    pub usage: atomic_t,
    pub uid: kuid_t,
    pub gid: kgid_t,
    pub suid: kuid_t,
    pub sgid: kgid_t,
    pub euid: kuid_t,
    pub egid: kgid_t,
    pub fsuid: kuid_t,
    pub fsgid: kgid_t,
    pub securebits: c_types::c_uint,
    pub cap_inheritable: kernel_cap_t,
    pub cap_permitted: kernel_cap_t,
    pub cap_effective: kernel_cap_t,
    pub cap_bset: kernel_cap_t,
    pub cap_ambient: kernel_cap_t,
    pub jit_keyring: c_types::c_uchar,
    pub session_keyring: *mut key,
    pub process_keyring: *mut key,
    pub thread_keyring: *mut key,
    pub request_key_auth: *mut key,
    pub security: *mut c_types::c_void,
    pub user: *mut user_struct,
    pub user_ns: *mut user_namespace,
    pub group_info: *mut group_info,
    pub __bindgen_anon_1: cred__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union cred__bindgen_ty_1 {
    pub non_rcu: c_types::c_int,
    pub rcu: callback_head,
    _bindgen_union_align: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_cred__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<cred__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(cred__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<cred__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(cred__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cred__bindgen_ty_1>())).non_rcu as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cred__bindgen_ty_1),
            "::",
            stringify!(non_rcu)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cred__bindgen_ty_1>())).rcu as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cred__bindgen_ty_1),
            "::",
            stringify!(rcu)
        )
    );
}
impl Default for cred__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_cred() {
    assert_eq!(
        ::core::mem::size_of::<cred>(),
        168usize,
        concat!("Size of: ", stringify!(cred))
    );
    assert_eq!(
        ::core::mem::align_of::<cred>(),
        8usize,
        concat!("Alignment of ", stringify!(cred))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cred>())).usage as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cred),
            "::",
            stringify!(usage)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cred>())).uid as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(cred), "::", stringify!(uid))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cred>())).gid as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(cred), "::", stringify!(gid))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cred>())).suid as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cred),
            "::",
            stringify!(suid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cred>())).sgid as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cred),
            "::",
            stringify!(sgid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cred>())).euid as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(cred),
            "::",
            stringify!(euid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cred>())).egid as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cred),
            "::",
            stringify!(egid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cred>())).fsuid as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(cred),
            "::",
            stringify!(fsuid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cred>())).fsgid as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cred),
            "::",
            stringify!(fsgid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cred>())).securebits as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(cred),
            "::",
            stringify!(securebits)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cred>())).cap_inheritable as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cred),
            "::",
            stringify!(cap_inheritable)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cred>())).cap_permitted as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(cred),
            "::",
            stringify!(cap_permitted)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cred>())).cap_effective as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(cred),
            "::",
            stringify!(cap_effective)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cred>())).cap_bset as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(cred),
            "::",
            stringify!(cap_bset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cred>())).cap_ambient as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(cred),
            "::",
            stringify!(cap_ambient)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cred>())).jit_keyring as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(cred),
            "::",
            stringify!(jit_keyring)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cred>())).session_keyring as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(cred),
            "::",
            stringify!(session_keyring)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cred>())).process_keyring as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(cred),
            "::",
            stringify!(process_keyring)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cred>())).thread_keyring as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(cred),
            "::",
            stringify!(thread_keyring)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cred>())).request_key_auth as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(cred),
            "::",
            stringify!(request_key_auth)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cred>())).security as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(cred),
            "::",
            stringify!(security)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cred>())).user as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(cred),
            "::",
            stringify!(user)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cred>())).user_ns as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(cred),
            "::",
            stringify!(user_ns)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cred>())).group_info as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(cred),
            "::",
            stringify!(group_info)
        )
    );
}
impl Default for cred {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xfrm_policy {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xfrm_state {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mnt_namespace {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uts_namespace {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ipc_namespace {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nsproxy {
    pub count: atomic_t,
    pub uts_ns: *mut uts_namespace,
    pub ipc_ns: *mut ipc_namespace,
    pub mnt_ns: *mut mnt_namespace,
    pub pid_ns_for_children: *mut pid_namespace,
    pub net_ns: *mut net,
    pub cgroup_ns: *mut cgroup_namespace,
}
#[test]
fn bindgen_test_layout_nsproxy() {
    assert_eq!(
        ::core::mem::size_of::<nsproxy>(),
        56usize,
        concat!("Size of: ", stringify!(nsproxy))
    );
    assert_eq!(
        ::core::mem::align_of::<nsproxy>(),
        8usize,
        concat!("Alignment of ", stringify!(nsproxy))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nsproxy>())).count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nsproxy),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nsproxy>())).uts_ns as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nsproxy),
            "::",
            stringify!(uts_ns)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nsproxy>())).ipc_ns as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nsproxy),
            "::",
            stringify!(ipc_ns)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nsproxy>())).mnt_ns as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(nsproxy),
            "::",
            stringify!(mnt_ns)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nsproxy>())).pid_ns_for_children as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(nsproxy),
            "::",
            stringify!(pid_ns_for_children)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nsproxy>())).net_ns as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(nsproxy),
            "::",
            stringify!(net_ns)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nsproxy>())).cgroup_ns as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(nsproxy),
            "::",
            stringify!(cgroup_ns)
        )
    );
}
impl Default for nsproxy {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sighand_struct {
    pub siglock: spinlock_t,
    pub count: refcount_t,
    pub signalfd_wqh: wait_queue_head_t,
    pub action: [k_sigaction; 64usize],
}
#[test]
fn bindgen_test_layout_sighand_struct() {
    assert_eq!(
        ::core::mem::size_of::<sighand_struct>(),
        2080usize,
        concat!("Size of: ", stringify!(sighand_struct))
    );
    assert_eq!(
        ::core::mem::align_of::<sighand_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(sighand_struct))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sighand_struct>())).siglock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sighand_struct),
            "::",
            stringify!(siglock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sighand_struct>())).count as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sighand_struct),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sighand_struct>())).signalfd_wqh as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sighand_struct),
            "::",
            stringify!(signalfd_wqh)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sighand_struct>())).action as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sighand_struct),
            "::",
            stringify!(action)
        )
    );
}
impl Default for sighand_struct {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct pacct_struct {
    pub ac_flag: c_types::c_int,
    pub ac_exitcode: c_types::c_long,
    pub ac_mem: c_types::c_ulong,
    pub ac_utime: u64_,
    pub ac_stime: u64_,
    pub ac_minflt: c_types::c_ulong,
    pub ac_majflt: c_types::c_ulong,
}
#[test]
fn bindgen_test_layout_pacct_struct() {
    assert_eq!(
        ::core::mem::size_of::<pacct_struct>(),
        56usize,
        concat!("Size of: ", stringify!(pacct_struct))
    );
    assert_eq!(
        ::core::mem::align_of::<pacct_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(pacct_struct))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pacct_struct>())).ac_flag as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pacct_struct),
            "::",
            stringify!(ac_flag)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pacct_struct>())).ac_exitcode as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pacct_struct),
            "::",
            stringify!(ac_exitcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pacct_struct>())).ac_mem as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pacct_struct),
            "::",
            stringify!(ac_mem)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pacct_struct>())).ac_utime as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(pacct_struct),
            "::",
            stringify!(ac_utime)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pacct_struct>())).ac_stime as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(pacct_struct),
            "::",
            stringify!(ac_stime)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pacct_struct>())).ac_minflt as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(pacct_struct),
            "::",
            stringify!(ac_minflt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pacct_struct>())).ac_majflt as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(pacct_struct),
            "::",
            stringify!(ac_majflt)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct cpu_itimer {
    pub expires: u64_,
    pub incr: u64_,
}
#[test]
fn bindgen_test_layout_cpu_itimer() {
    assert_eq!(
        ::core::mem::size_of::<cpu_itimer>(),
        16usize,
        concat!("Size of: ", stringify!(cpu_itimer))
    );
    assert_eq!(
        ::core::mem::align_of::<cpu_itimer>(),
        8usize,
        concat!("Alignment of ", stringify!(cpu_itimer))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cpu_itimer>())).expires as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_itimer),
            "::",
            stringify!(expires)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cpu_itimer>())).incr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_itimer),
            "::",
            stringify!(incr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct task_cputime_atomic {
    pub utime: atomic64_t,
    pub stime: atomic64_t,
    pub sum_exec_runtime: atomic64_t,
}
#[test]
fn bindgen_test_layout_task_cputime_atomic() {
    assert_eq!(
        ::core::mem::size_of::<task_cputime_atomic>(),
        24usize,
        concat!("Size of: ", stringify!(task_cputime_atomic))
    );
    assert_eq!(
        ::core::mem::align_of::<task_cputime_atomic>(),
        8usize,
        concat!("Alignment of ", stringify!(task_cputime_atomic))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_cputime_atomic>())).utime as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(task_cputime_atomic),
            "::",
            stringify!(utime)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_cputime_atomic>())).stime as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(task_cputime_atomic),
            "::",
            stringify!(stime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<task_cputime_atomic>())).sum_exec_runtime as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(task_cputime_atomic),
            "::",
            stringify!(sum_exec_runtime)
        )
    );
}
#[doc = " struct thread_group_cputimer - thread group interval timer counts"]
#[doc = " @cputime_atomic:\tatomic thread group interval timers."]
#[doc = ""]
#[doc = " This structure contains the version of task_cputime, above, that is"]
#[doc = " used for thread group CPU timer calculations."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct thread_group_cputimer {
    pub cputime_atomic: task_cputime_atomic,
}
#[test]
fn bindgen_test_layout_thread_group_cputimer() {
    assert_eq!(
        ::core::mem::size_of::<thread_group_cputimer>(),
        24usize,
        concat!("Size of: ", stringify!(thread_group_cputimer))
    );
    assert_eq!(
        ::core::mem::align_of::<thread_group_cputimer>(),
        8usize,
        concat!("Alignment of ", stringify!(thread_group_cputimer))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<thread_group_cputimer>())).cputime_atomic as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_group_cputimer),
            "::",
            stringify!(cputime_atomic)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct signal_struct {
    pub sigcnt: refcount_t,
    pub live: atomic_t,
    pub nr_threads: c_types::c_int,
    pub thread_head: list_head,
    pub wait_chldexit: wait_queue_head_t,
    pub curr_target: *mut task_struct,
    pub shared_pending: sigpending,
    pub multiprocess: hlist_head,
    pub group_exit_code: c_types::c_int,
    pub notify_count: c_types::c_int,
    pub group_exit_task: *mut task_struct,
    pub group_stop_count: c_types::c_int,
    pub flags: c_types::c_uint,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub posix_timer_id: c_types::c_int,
    pub posix_timers: list_head,
    pub real_timer: hrtimer,
    pub it_real_incr: ktime_t,
    pub it: [cpu_itimer; 2usize],
    pub cputimer: thread_group_cputimer,
    pub posix_cputimers: posix_cputimers,
    pub pids: [*mut pid; 4usize],
    pub tty_old_pgrp: *mut pid,
    pub leader: c_types::c_int,
    pub tty: *mut tty_struct,
    pub autogroup: *mut autogroup,
    pub stats_lock: seqlock_t,
    pub utime: u64_,
    pub stime: u64_,
    pub cutime: u64_,
    pub cstime: u64_,
    pub gtime: u64_,
    pub cgtime: u64_,
    pub prev_cputime: prev_cputime,
    pub nvcsw: c_types::c_ulong,
    pub nivcsw: c_types::c_ulong,
    pub cnvcsw: c_types::c_ulong,
    pub cnivcsw: c_types::c_ulong,
    pub min_flt: c_types::c_ulong,
    pub maj_flt: c_types::c_ulong,
    pub cmin_flt: c_types::c_ulong,
    pub cmaj_flt: c_types::c_ulong,
    pub inblock: c_types::c_ulong,
    pub oublock: c_types::c_ulong,
    pub cinblock: c_types::c_ulong,
    pub coublock: c_types::c_ulong,
    pub maxrss: c_types::c_ulong,
    pub cmaxrss: c_types::c_ulong,
    pub ioac: task_io_accounting,
    pub sum_sched_runtime: c_types::c_ulonglong,
    pub rlim: [rlimit; 16usize],
    pub pacct: pacct_struct,
    pub stats: *mut taskstats,
    pub audit_tty: c_types::c_uint,
    pub tty_audit_buf: *mut tty_audit_buf,
    pub oom_flag_origin: bool_,
    pub oom_score_adj: c_types::c_short,
    pub oom_score_adj_min: c_types::c_short,
    pub oom_mm: *mut mm_struct,
    pub cred_guard_mutex: mutex,
}
#[test]
fn bindgen_test_layout_signal_struct() {
    assert_eq!(
        ::core::mem::size_of::<signal_struct>(),
        1056usize,
        concat!("Size of: ", stringify!(signal_struct))
    );
    assert_eq!(
        ::core::mem::align_of::<signal_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(signal_struct))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<signal_struct>())).sigcnt as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_struct),
            "::",
            stringify!(sigcnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<signal_struct>())).live as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_struct),
            "::",
            stringify!(live)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<signal_struct>())).nr_threads as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_struct),
            "::",
            stringify!(nr_threads)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<signal_struct>())).thread_head as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_struct),
            "::",
            stringify!(thread_head)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<signal_struct>())).wait_chldexit as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_struct),
            "::",
            stringify!(wait_chldexit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<signal_struct>())).curr_target as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_struct),
            "::",
            stringify!(curr_target)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<signal_struct>())).shared_pending as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_struct),
            "::",
            stringify!(shared_pending)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<signal_struct>())).multiprocess as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_struct),
            "::",
            stringify!(multiprocess)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<signal_struct>())).group_exit_code as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_struct),
            "::",
            stringify!(group_exit_code)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<signal_struct>())).notify_count as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_struct),
            "::",
            stringify!(notify_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<signal_struct>())).group_exit_task as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_struct),
            "::",
            stringify!(group_exit_task)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<signal_struct>())).group_stop_count as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_struct),
            "::",
            stringify!(group_stop_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<signal_struct>())).flags as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_struct),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<signal_struct>())).posix_timer_id as *const _ as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_struct),
            "::",
            stringify!(posix_timer_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<signal_struct>())).posix_timers as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_struct),
            "::",
            stringify!(posix_timers)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<signal_struct>())).real_timer as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_struct),
            "::",
            stringify!(real_timer)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<signal_struct>())).it_real_incr as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_struct),
            "::",
            stringify!(it_real_incr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<signal_struct>())).it as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_struct),
            "::",
            stringify!(it)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<signal_struct>())).cputimer as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_struct),
            "::",
            stringify!(cputimer)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<signal_struct>())).posix_cputimers as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_struct),
            "::",
            stringify!(posix_cputimers)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<signal_struct>())).pids as *const _ as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_struct),
            "::",
            stringify!(pids)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<signal_struct>())).tty_old_pgrp as *const _ as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_struct),
            "::",
            stringify!(tty_old_pgrp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<signal_struct>())).leader as *const _ as usize },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_struct),
            "::",
            stringify!(leader)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<signal_struct>())).tty as *const _ as usize },
        400usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_struct),
            "::",
            stringify!(tty)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<signal_struct>())).autogroup as *const _ as usize },
        408usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_struct),
            "::",
            stringify!(autogroup)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<signal_struct>())).stats_lock as *const _ as usize },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_struct),
            "::",
            stringify!(stats_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<signal_struct>())).utime as *const _ as usize },
        424usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_struct),
            "::",
            stringify!(utime)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<signal_struct>())).stime as *const _ as usize },
        432usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_struct),
            "::",
            stringify!(stime)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<signal_struct>())).cutime as *const _ as usize },
        440usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_struct),
            "::",
            stringify!(cutime)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<signal_struct>())).cstime as *const _ as usize },
        448usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_struct),
            "::",
            stringify!(cstime)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<signal_struct>())).gtime as *const _ as usize },
        456usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_struct),
            "::",
            stringify!(gtime)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<signal_struct>())).cgtime as *const _ as usize },
        464usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_struct),
            "::",
            stringify!(cgtime)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<signal_struct>())).prev_cputime as *const _ as usize },
        472usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_struct),
            "::",
            stringify!(prev_cputime)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<signal_struct>())).nvcsw as *const _ as usize },
        496usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_struct),
            "::",
            stringify!(nvcsw)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<signal_struct>())).nivcsw as *const _ as usize },
        504usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_struct),
            "::",
            stringify!(nivcsw)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<signal_struct>())).cnvcsw as *const _ as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_struct),
            "::",
            stringify!(cnvcsw)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<signal_struct>())).cnivcsw as *const _ as usize },
        520usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_struct),
            "::",
            stringify!(cnivcsw)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<signal_struct>())).min_flt as *const _ as usize },
        528usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_struct),
            "::",
            stringify!(min_flt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<signal_struct>())).maj_flt as *const _ as usize },
        536usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_struct),
            "::",
            stringify!(maj_flt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<signal_struct>())).cmin_flt as *const _ as usize },
        544usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_struct),
            "::",
            stringify!(cmin_flt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<signal_struct>())).cmaj_flt as *const _ as usize },
        552usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_struct),
            "::",
            stringify!(cmaj_flt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<signal_struct>())).inblock as *const _ as usize },
        560usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_struct),
            "::",
            stringify!(inblock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<signal_struct>())).oublock as *const _ as usize },
        568usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_struct),
            "::",
            stringify!(oublock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<signal_struct>())).cinblock as *const _ as usize },
        576usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_struct),
            "::",
            stringify!(cinblock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<signal_struct>())).coublock as *const _ as usize },
        584usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_struct),
            "::",
            stringify!(coublock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<signal_struct>())).maxrss as *const _ as usize },
        592usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_struct),
            "::",
            stringify!(maxrss)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<signal_struct>())).cmaxrss as *const _ as usize },
        600usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_struct),
            "::",
            stringify!(cmaxrss)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<signal_struct>())).ioac as *const _ as usize },
        608usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_struct),
            "::",
            stringify!(ioac)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<signal_struct>())).sum_sched_runtime as *const _ as usize
        },
        664usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_struct),
            "::",
            stringify!(sum_sched_runtime)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<signal_struct>())).rlim as *const _ as usize },
        672usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_struct),
            "::",
            stringify!(rlim)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<signal_struct>())).pacct as *const _ as usize },
        928usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_struct),
            "::",
            stringify!(pacct)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<signal_struct>())).stats as *const _ as usize },
        984usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_struct),
            "::",
            stringify!(stats)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<signal_struct>())).audit_tty as *const _ as usize },
        992usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_struct),
            "::",
            stringify!(audit_tty)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<signal_struct>())).tty_audit_buf as *const _ as usize },
        1000usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_struct),
            "::",
            stringify!(tty_audit_buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<signal_struct>())).oom_flag_origin as *const _ as usize },
        1008usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_struct),
            "::",
            stringify!(oom_flag_origin)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<signal_struct>())).oom_score_adj as *const _ as usize },
        1010usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_struct),
            "::",
            stringify!(oom_score_adj)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<signal_struct>())).oom_score_adj_min as *const _ as usize
        },
        1012usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_struct),
            "::",
            stringify!(oom_score_adj_min)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<signal_struct>())).oom_mm as *const _ as usize },
        1016usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_struct),
            "::",
            stringify!(oom_mm)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<signal_struct>())).cred_guard_mutex as *const _ as usize },
        1024usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_struct),
            "::",
            stringify!(cred_guard_mutex)
        )
    );
}
impl Default for signal_struct {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl signal_struct {
    #[inline]
    pub fn is_child_subreaper(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_child_subreaper(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn has_child_subreaper(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_child_subreaper(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        is_child_subreaper: c_types::c_uint,
        has_child_subreaper: c_types::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let is_child_subreaper: u32 = unsafe { ::core::mem::transmute(is_child_subreaper) };
            is_child_subreaper as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let has_child_subreaper: u32 = unsafe { ::core::mem::transmute(has_child_subreaper) };
            has_child_subreaper as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct scm_creds {
    pub pid: u32_,
    pub uid: kuid_t,
    pub gid: kgid_t,
}
#[test]
fn bindgen_test_layout_scm_creds() {
    assert_eq!(
        ::core::mem::size_of::<scm_creds>(),
        12usize,
        concat!("Size of: ", stringify!(scm_creds))
    );
    assert_eq!(
        ::core::mem::align_of::<scm_creds>(),
        4usize,
        concat!("Alignment of ", stringify!(scm_creds))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<scm_creds>())).pid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_creds),
            "::",
            stringify!(pid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<scm_creds>())).uid as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_creds),
            "::",
            stringify!(uid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<scm_creds>())).gid as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_creds),
            "::",
            stringify!(gid)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct nlmsghdr {
    pub nlmsg_len: __u32,
    pub nlmsg_type: __u16,
    pub nlmsg_flags: __u16,
    pub nlmsg_seq: __u32,
    pub nlmsg_pid: __u32,
}
#[test]
fn bindgen_test_layout_nlmsghdr() {
    assert_eq!(
        ::core::mem::size_of::<nlmsghdr>(),
        16usize,
        concat!("Size of: ", stringify!(nlmsghdr))
    );
    assert_eq!(
        ::core::mem::align_of::<nlmsghdr>(),
        4usize,
        concat!("Alignment of ", stringify!(nlmsghdr))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nlmsghdr>())).nlmsg_len as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nlmsghdr),
            "::",
            stringify!(nlmsg_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nlmsghdr>())).nlmsg_type as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nlmsghdr),
            "::",
            stringify!(nlmsg_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nlmsghdr>())).nlmsg_flags as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(nlmsghdr),
            "::",
            stringify!(nlmsg_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nlmsghdr>())).nlmsg_seq as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nlmsghdr),
            "::",
            stringify!(nlmsg_seq)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nlmsghdr>())).nlmsg_pid as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(nlmsghdr),
            "::",
            stringify!(nlmsg_pid)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct nlattr {
    pub nla_len: __u16,
    pub nla_type: __u16,
}
#[test]
fn bindgen_test_layout_nlattr() {
    assert_eq!(
        ::core::mem::size_of::<nlattr>(),
        4usize,
        concat!("Size of: ", stringify!(nlattr))
    );
    assert_eq!(
        ::core::mem::align_of::<nlattr>(),
        2usize,
        concat!("Alignment of ", stringify!(nlattr))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nlattr>())).nla_len as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nlattr),
            "::",
            stringify!(nla_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nlattr>())).nla_type as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(nlattr),
            "::",
            stringify!(nla_type)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct netlink_skb_parms {
    pub creds: scm_creds,
    pub portid: __u32,
    pub dst_group: __u32,
    pub flags: __u32,
    pub sk: *mut sock,
    pub nsid_is_set: bool_,
    pub nsid: c_types::c_int,
}
#[test]
fn bindgen_test_layout_netlink_skb_parms() {
    assert_eq!(
        ::core::mem::size_of::<netlink_skb_parms>(),
        40usize,
        concat!("Size of: ", stringify!(netlink_skb_parms))
    );
    assert_eq!(
        ::core::mem::align_of::<netlink_skb_parms>(),
        8usize,
        concat!("Alignment of ", stringify!(netlink_skb_parms))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netlink_skb_parms>())).creds as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(netlink_skb_parms),
            "::",
            stringify!(creds)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netlink_skb_parms>())).portid as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(netlink_skb_parms),
            "::",
            stringify!(portid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netlink_skb_parms>())).dst_group as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(netlink_skb_parms),
            "::",
            stringify!(dst_group)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netlink_skb_parms>())).flags as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(netlink_skb_parms),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netlink_skb_parms>())).sk as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(netlink_skb_parms),
            "::",
            stringify!(sk)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netlink_skb_parms>())).nsid_is_set as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(netlink_skb_parms),
            "::",
            stringify!(nsid_is_set)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netlink_skb_parms>())).nsid as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(netlink_skb_parms),
            "::",
            stringify!(nsid)
        )
    );
}
impl Default for netlink_skb_parms {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct netlink_kernel_cfg {
    pub groups: c_types::c_uint,
    pub flags: c_types::c_uint,
    pub input: ::core::option::Option<unsafe extern "C" fn(skb: *mut sk_buff)>,
    pub cb_mutex: *mut mutex,
    pub bind: ::core::option::Option<
        unsafe extern "C" fn(net: *mut net, group: c_types::c_int) -> c_types::c_int,
    >,
    pub unbind: ::core::option::Option<unsafe extern "C" fn(net: *mut net, group: c_types::c_int)>,
    pub compare:
        ::core::option::Option<unsafe extern "C" fn(net: *mut net, sk: *mut sock) -> bool_>,
}
#[test]
fn bindgen_test_layout_netlink_kernel_cfg() {
    assert_eq!(
        ::core::mem::size_of::<netlink_kernel_cfg>(),
        48usize,
        concat!("Size of: ", stringify!(netlink_kernel_cfg))
    );
    assert_eq!(
        ::core::mem::align_of::<netlink_kernel_cfg>(),
        8usize,
        concat!("Alignment of ", stringify!(netlink_kernel_cfg))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netlink_kernel_cfg>())).groups as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(netlink_kernel_cfg),
            "::",
            stringify!(groups)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netlink_kernel_cfg>())).flags as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(netlink_kernel_cfg),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netlink_kernel_cfg>())).input as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(netlink_kernel_cfg),
            "::",
            stringify!(input)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netlink_kernel_cfg>())).cb_mutex as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(netlink_kernel_cfg),
            "::",
            stringify!(cb_mutex)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netlink_kernel_cfg>())).bind as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(netlink_kernel_cfg),
            "::",
            stringify!(bind)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netlink_kernel_cfg>())).unbind as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(netlink_kernel_cfg),
            "::",
            stringify!(unbind)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netlink_kernel_cfg>())).compare as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(netlink_kernel_cfg),
            "::",
            stringify!(compare)
        )
    );
}
impl Default for netlink_kernel_cfg {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn __netlink_kernel_create(
        net: *mut net,
        unit: c_types::c_int,
        module: *mut module,
        cfg: *mut netlink_kernel_cfg,
    ) -> *mut sock;
}
#[doc = " struct netlink_ext_ack - netlink extended ACK report struct"]
#[doc = " @_msg: message string to report - don't access directly, use"]
#[doc = "\t%NL_SET_ERR_MSG"]
#[doc = " @bad_attr: attribute with error"]
#[doc = " @cookie: cookie data to return to userspace (for success)"]
#[doc = " @cookie_len: actual cookie data length"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct netlink_ext_ack {
    pub _msg: *const c_types::c_char,
    pub bad_attr: *const nlattr,
    pub cookie: [u8_; 20usize],
    pub cookie_len: u8_,
}
#[test]
fn bindgen_test_layout_netlink_ext_ack() {
    assert_eq!(
        ::core::mem::size_of::<netlink_ext_ack>(),
        40usize,
        concat!("Size of: ", stringify!(netlink_ext_ack))
    );
    assert_eq!(
        ::core::mem::align_of::<netlink_ext_ack>(),
        8usize,
        concat!("Alignment of ", stringify!(netlink_ext_ack))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netlink_ext_ack>()))._msg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(netlink_ext_ack),
            "::",
            stringify!(_msg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netlink_ext_ack>())).bad_attr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(netlink_ext_ack),
            "::",
            stringify!(bad_attr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netlink_ext_ack>())).cookie as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(netlink_ext_ack),
            "::",
            stringify!(cookie)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netlink_ext_ack>())).cookie_len as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(netlink_ext_ack),
            "::",
            stringify!(cookie_len)
        )
    );
}
impl Default for netlink_ext_ack {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn netlink_kernel_release(sk: *mut sock);
}
extern "C" {
    pub fn netlink_unicast(
        ssk: *mut sock,
        skb: *mut sk_buff,
        portid: __u32,
        nonblock: c_types::c_int,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn netlink_broadcast(
        ssk: *mut sock,
        skb: *mut sk_buff,
        portid: __u32,
        group: __u32,
        allocation: gfp_t,
    ) -> c_types::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct netlink_callback {
    pub skb: *mut sk_buff,
    pub nlh: *const nlmsghdr,
    pub dump: ::core::option::Option<
        unsafe extern "C" fn(skb: *mut sk_buff, cb: *mut netlink_callback) -> c_types::c_int,
    >,
    pub done:
        ::core::option::Option<unsafe extern "C" fn(cb: *mut netlink_callback) -> c_types::c_int>,
    pub data: *mut c_types::c_void,
    pub module: *mut module,
    pub extack: *mut netlink_ext_ack,
    pub family: u16_,
    pub min_dump_alloc: u16_,
    pub strict_check: bool_,
    pub answer_flags: u16_,
    pub prev_seq: c_types::c_uint,
    pub seq: c_types::c_uint,
    pub __bindgen_anon_1: netlink_callback__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union netlink_callback__bindgen_ty_1 {
    pub ctx: [u8_; 48usize],
    pub args: [c_types::c_long; 6usize],
    _bindgen_union_align: [u64; 6usize],
}
#[test]
fn bindgen_test_layout_netlink_callback__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<netlink_callback__bindgen_ty_1>(),
        48usize,
        concat!("Size of: ", stringify!(netlink_callback__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<netlink_callback__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(netlink_callback__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<netlink_callback__bindgen_ty_1>())).ctx as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(netlink_callback__bindgen_ty_1),
            "::",
            stringify!(ctx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<netlink_callback__bindgen_ty_1>())).args as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(netlink_callback__bindgen_ty_1),
            "::",
            stringify!(args)
        )
    );
}
impl Default for netlink_callback__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_netlink_callback() {
    assert_eq!(
        ::core::mem::size_of::<netlink_callback>(),
        120usize,
        concat!("Size of: ", stringify!(netlink_callback))
    );
    assert_eq!(
        ::core::mem::align_of::<netlink_callback>(),
        8usize,
        concat!("Alignment of ", stringify!(netlink_callback))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netlink_callback>())).skb as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(netlink_callback),
            "::",
            stringify!(skb)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netlink_callback>())).nlh as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(netlink_callback),
            "::",
            stringify!(nlh)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netlink_callback>())).dump as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(netlink_callback),
            "::",
            stringify!(dump)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netlink_callback>())).done as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(netlink_callback),
            "::",
            stringify!(done)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netlink_callback>())).data as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(netlink_callback),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netlink_callback>())).module as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(netlink_callback),
            "::",
            stringify!(module)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netlink_callback>())).extack as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(netlink_callback),
            "::",
            stringify!(extack)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netlink_callback>())).family as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(netlink_callback),
            "::",
            stringify!(family)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<netlink_callback>())).min_dump_alloc as *const _ as usize
        },
        58usize,
        concat!(
            "Offset of field: ",
            stringify!(netlink_callback),
            "::",
            stringify!(min_dump_alloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netlink_callback>())).strict_check as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(netlink_callback),
            "::",
            stringify!(strict_check)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netlink_callback>())).answer_flags as *const _ as usize },
        62usize,
        concat!(
            "Offset of field: ",
            stringify!(netlink_callback),
            "::",
            stringify!(answer_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netlink_callback>())).prev_seq as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(netlink_callback),
            "::",
            stringify!(prev_seq)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netlink_callback>())).seq as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(netlink_callback),
            "::",
            stringify!(seq)
        )
    );
}
impl Default for netlink_callback {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct sync_serial_settings {
    pub clock_rate: c_types::c_uint,
    pub clock_type: c_types::c_uint,
    pub loopback: c_types::c_ushort,
}
#[test]
fn bindgen_test_layout_sync_serial_settings() {
    assert_eq!(
        ::core::mem::size_of::<sync_serial_settings>(),
        12usize,
        concat!("Size of: ", stringify!(sync_serial_settings))
    );
    assert_eq!(
        ::core::mem::align_of::<sync_serial_settings>(),
        4usize,
        concat!("Alignment of ", stringify!(sync_serial_settings))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sync_serial_settings>())).clock_rate as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sync_serial_settings),
            "::",
            stringify!(clock_rate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sync_serial_settings>())).clock_type as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sync_serial_settings),
            "::",
            stringify!(clock_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sync_serial_settings>())).loopback as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sync_serial_settings),
            "::",
            stringify!(loopback)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct te1_settings {
    pub clock_rate: c_types::c_uint,
    pub clock_type: c_types::c_uint,
    pub loopback: c_types::c_ushort,
    pub slot_map: c_types::c_uint,
}
#[test]
fn bindgen_test_layout_te1_settings() {
    assert_eq!(
        ::core::mem::size_of::<te1_settings>(),
        16usize,
        concat!("Size of: ", stringify!(te1_settings))
    );
    assert_eq!(
        ::core::mem::align_of::<te1_settings>(),
        4usize,
        concat!("Alignment of ", stringify!(te1_settings))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<te1_settings>())).clock_rate as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(te1_settings),
            "::",
            stringify!(clock_rate)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<te1_settings>())).clock_type as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(te1_settings),
            "::",
            stringify!(clock_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<te1_settings>())).loopback as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(te1_settings),
            "::",
            stringify!(loopback)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<te1_settings>())).slot_map as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(te1_settings),
            "::",
            stringify!(slot_map)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct raw_hdlc_proto {
    pub encoding: c_types::c_ushort,
    pub parity: c_types::c_ushort,
}
#[test]
fn bindgen_test_layout_raw_hdlc_proto() {
    assert_eq!(
        ::core::mem::size_of::<raw_hdlc_proto>(),
        4usize,
        concat!("Size of: ", stringify!(raw_hdlc_proto))
    );
    assert_eq!(
        ::core::mem::align_of::<raw_hdlc_proto>(),
        2usize,
        concat!("Alignment of ", stringify!(raw_hdlc_proto))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<raw_hdlc_proto>())).encoding as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(raw_hdlc_proto),
            "::",
            stringify!(encoding)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<raw_hdlc_proto>())).parity as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(raw_hdlc_proto),
            "::",
            stringify!(parity)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct fr_proto {
    pub t391: c_types::c_uint,
    pub t392: c_types::c_uint,
    pub n391: c_types::c_uint,
    pub n392: c_types::c_uint,
    pub n393: c_types::c_uint,
    pub lmi: c_types::c_ushort,
    pub dce: c_types::c_ushort,
}
#[test]
fn bindgen_test_layout_fr_proto() {
    assert_eq!(
        ::core::mem::size_of::<fr_proto>(),
        24usize,
        concat!("Size of: ", stringify!(fr_proto))
    );
    assert_eq!(
        ::core::mem::align_of::<fr_proto>(),
        4usize,
        concat!("Alignment of ", stringify!(fr_proto))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fr_proto>())).t391 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fr_proto),
            "::",
            stringify!(t391)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fr_proto>())).t392 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(fr_proto),
            "::",
            stringify!(t392)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fr_proto>())).n391 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(fr_proto),
            "::",
            stringify!(n391)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fr_proto>())).n392 as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(fr_proto),
            "::",
            stringify!(n392)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fr_proto>())).n393 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(fr_proto),
            "::",
            stringify!(n393)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fr_proto>())).lmi as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(fr_proto),
            "::",
            stringify!(lmi)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fr_proto>())).dce as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(fr_proto),
            "::",
            stringify!(dce)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct fr_proto_pvc {
    pub dlci: c_types::c_uint,
}
#[test]
fn bindgen_test_layout_fr_proto_pvc() {
    assert_eq!(
        ::core::mem::size_of::<fr_proto_pvc>(),
        4usize,
        concat!("Size of: ", stringify!(fr_proto_pvc))
    );
    assert_eq!(
        ::core::mem::align_of::<fr_proto_pvc>(),
        4usize,
        concat!("Alignment of ", stringify!(fr_proto_pvc))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fr_proto_pvc>())).dlci as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fr_proto_pvc),
            "::",
            stringify!(dlci)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct fr_proto_pvc_info {
    pub dlci: c_types::c_uint,
    pub master: [c_types::c_char; 16usize],
}
#[test]
fn bindgen_test_layout_fr_proto_pvc_info() {
    assert_eq!(
        ::core::mem::size_of::<fr_proto_pvc_info>(),
        20usize,
        concat!("Size of: ", stringify!(fr_proto_pvc_info))
    );
    assert_eq!(
        ::core::mem::align_of::<fr_proto_pvc_info>(),
        4usize,
        concat!("Alignment of ", stringify!(fr_proto_pvc_info))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fr_proto_pvc_info>())).dlci as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fr_proto_pvc_info),
            "::",
            stringify!(dlci)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fr_proto_pvc_info>())).master as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(fr_proto_pvc_info),
            "::",
            stringify!(master)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct cisco_proto {
    pub interval: c_types::c_uint,
    pub timeout: c_types::c_uint,
}
#[test]
fn bindgen_test_layout_cisco_proto() {
    assert_eq!(
        ::core::mem::size_of::<cisco_proto>(),
        8usize,
        concat!("Size of: ", stringify!(cisco_proto))
    );
    assert_eq!(
        ::core::mem::align_of::<cisco_proto>(),
        4usize,
        concat!("Alignment of ", stringify!(cisco_proto))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cisco_proto>())).interval as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cisco_proto),
            "::",
            stringify!(interval)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cisco_proto>())).timeout as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cisco_proto),
            "::",
            stringify!(timeout)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ifmap {
    pub mem_start: c_types::c_ulong,
    pub mem_end: c_types::c_ulong,
    pub base_addr: c_types::c_ushort,
    pub irq: c_types::c_uchar,
    pub dma: c_types::c_uchar,
    pub port: c_types::c_uchar,
}
#[test]
fn bindgen_test_layout_ifmap() {
    assert_eq!(
        ::core::mem::size_of::<ifmap>(),
        24usize,
        concat!("Size of: ", stringify!(ifmap))
    );
    assert_eq!(
        ::core::mem::align_of::<ifmap>(),
        8usize,
        concat!("Alignment of ", stringify!(ifmap))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ifmap>())).mem_start as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ifmap),
            "::",
            stringify!(mem_start)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ifmap>())).mem_end as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ifmap),
            "::",
            stringify!(mem_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ifmap>())).base_addr as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ifmap),
            "::",
            stringify!(base_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ifmap>())).irq as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(ifmap),
            "::",
            stringify!(irq)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ifmap>())).dma as *const _ as usize },
        19usize,
        concat!(
            "Offset of field: ",
            stringify!(ifmap),
            "::",
            stringify!(dma)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ifmap>())).port as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ifmap),
            "::",
            stringify!(port)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct if_settings {
    pub type_: c_types::c_uint,
    pub size: c_types::c_uint,
    pub ifs_ifsu: if_settings__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union if_settings__bindgen_ty_1 {
    pub raw_hdlc: *mut raw_hdlc_proto,
    pub cisco: *mut cisco_proto,
    pub fr: *mut fr_proto,
    pub fr_pvc: *mut fr_proto_pvc,
    pub fr_pvc_info: *mut fr_proto_pvc_info,
    pub sync: *mut sync_serial_settings,
    pub te1: *mut te1_settings,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_if_settings__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<if_settings__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(if_settings__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<if_settings__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(if_settings__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<if_settings__bindgen_ty_1>())).raw_hdlc as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(if_settings__bindgen_ty_1),
            "::",
            stringify!(raw_hdlc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<if_settings__bindgen_ty_1>())).cisco as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(if_settings__bindgen_ty_1),
            "::",
            stringify!(cisco)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<if_settings__bindgen_ty_1>())).fr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(if_settings__bindgen_ty_1),
            "::",
            stringify!(fr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<if_settings__bindgen_ty_1>())).fr_pvc as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(if_settings__bindgen_ty_1),
            "::",
            stringify!(fr_pvc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<if_settings__bindgen_ty_1>())).fr_pvc_info as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(if_settings__bindgen_ty_1),
            "::",
            stringify!(fr_pvc_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<if_settings__bindgen_ty_1>())).sync as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(if_settings__bindgen_ty_1),
            "::",
            stringify!(sync)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<if_settings__bindgen_ty_1>())).te1 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(if_settings__bindgen_ty_1),
            "::",
            stringify!(te1)
        )
    );
}
impl Default for if_settings__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_if_settings() {
    assert_eq!(
        ::core::mem::size_of::<if_settings>(),
        16usize,
        concat!("Size of: ", stringify!(if_settings))
    );
    assert_eq!(
        ::core::mem::align_of::<if_settings>(),
        8usize,
        concat!("Alignment of ", stringify!(if_settings))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<if_settings>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(if_settings),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<if_settings>())).size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(if_settings),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<if_settings>())).ifs_ifsu as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(if_settings),
            "::",
            stringify!(ifs_ifsu)
        )
    );
}
impl Default for if_settings {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ifreq {
    pub ifr_ifrn: ifreq__bindgen_ty_1,
    pub ifr_ifru: ifreq__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ifreq__bindgen_ty_1 {
    pub ifrn_name: [c_types::c_char; 16usize],
    _bindgen_union_align: [u8; 16usize],
}
#[test]
fn bindgen_test_layout_ifreq__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<ifreq__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(ifreq__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<ifreq__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(ifreq__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ifreq__bindgen_ty_1>())).ifrn_name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ifreq__bindgen_ty_1),
            "::",
            stringify!(ifrn_name)
        )
    );
}
impl Default for ifreq__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ifreq__bindgen_ty_2 {
    pub ifru_addr: sockaddr,
    pub ifru_dstaddr: sockaddr,
    pub ifru_broadaddr: sockaddr,
    pub ifru_netmask: sockaddr,
    pub ifru_hwaddr: sockaddr,
    pub ifru_flags: c_types::c_short,
    pub ifru_ivalue: c_types::c_int,
    pub ifru_mtu: c_types::c_int,
    pub ifru_map: ifmap,
    pub ifru_slave: [c_types::c_char; 16usize],
    pub ifru_newname: [c_types::c_char; 16usize],
    pub ifru_data: *mut c_types::c_void,
    pub ifru_settings: if_settings,
    _bindgen_union_align: [u64; 3usize],
}
#[test]
fn bindgen_test_layout_ifreq__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<ifreq__bindgen_ty_2>(),
        24usize,
        concat!("Size of: ", stringify!(ifreq__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<ifreq__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(ifreq__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ifreq__bindgen_ty_2>())).ifru_addr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ifreq__bindgen_ty_2),
            "::",
            stringify!(ifru_addr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ifreq__bindgen_ty_2>())).ifru_dstaddr as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ifreq__bindgen_ty_2),
            "::",
            stringify!(ifru_dstaddr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ifreq__bindgen_ty_2>())).ifru_broadaddr as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ifreq__bindgen_ty_2),
            "::",
            stringify!(ifru_broadaddr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ifreq__bindgen_ty_2>())).ifru_netmask as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ifreq__bindgen_ty_2),
            "::",
            stringify!(ifru_netmask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ifreq__bindgen_ty_2>())).ifru_hwaddr as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ifreq__bindgen_ty_2),
            "::",
            stringify!(ifru_hwaddr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ifreq__bindgen_ty_2>())).ifru_flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ifreq__bindgen_ty_2),
            "::",
            stringify!(ifru_flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ifreq__bindgen_ty_2>())).ifru_ivalue as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ifreq__bindgen_ty_2),
            "::",
            stringify!(ifru_ivalue)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ifreq__bindgen_ty_2>())).ifru_mtu as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ifreq__bindgen_ty_2),
            "::",
            stringify!(ifru_mtu)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ifreq__bindgen_ty_2>())).ifru_map as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ifreq__bindgen_ty_2),
            "::",
            stringify!(ifru_map)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ifreq__bindgen_ty_2>())).ifru_slave as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ifreq__bindgen_ty_2),
            "::",
            stringify!(ifru_slave)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ifreq__bindgen_ty_2>())).ifru_newname as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ifreq__bindgen_ty_2),
            "::",
            stringify!(ifru_newname)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ifreq__bindgen_ty_2>())).ifru_data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ifreq__bindgen_ty_2),
            "::",
            stringify!(ifru_data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ifreq__bindgen_ty_2>())).ifru_settings as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ifreq__bindgen_ty_2),
            "::",
            stringify!(ifru_settings)
        )
    );
}
impl Default for ifreq__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_ifreq() {
    assert_eq!(
        ::core::mem::size_of::<ifreq>(),
        40usize,
        concat!("Size of: ", stringify!(ifreq))
    );
    assert_eq!(
        ::core::mem::align_of::<ifreq>(),
        8usize,
        concat!("Alignment of ", stringify!(ifreq))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ifreq>())).ifr_ifrn as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ifreq),
            "::",
            stringify!(ifr_ifrn)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ifreq>())).ifr_ifru as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ifreq),
            "::",
            stringify!(ifr_ifru)
        )
    );
}
impl Default for ifreq {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub const nf_inet_hooks_NF_INET_PRE_ROUTING: nf_inet_hooks = 0;
pub const nf_inet_hooks_NF_INET_LOCAL_IN: nf_inet_hooks = 1;
pub const nf_inet_hooks_NF_INET_FORWARD: nf_inet_hooks = 2;
pub const nf_inet_hooks_NF_INET_LOCAL_OUT: nf_inet_hooks = 3;
pub const nf_inet_hooks_NF_INET_POST_ROUTING: nf_inet_hooks = 4;
pub const nf_inet_hooks_NF_INET_NUMHOOKS: nf_inet_hooks = 5;
pub type nf_inet_hooks = c_types::c_uint;
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct dql {
    pub num_queued: c_types::c_uint,
    pub adj_limit: c_types::c_uint,
    pub last_obj_cnt: c_types::c_uint,
    pub __bindgen_padding_0: [u32; 13usize],
    pub limit: c_types::c_uint,
    pub num_completed: c_types::c_uint,
    pub prev_ovlimit: c_types::c_uint,
    pub prev_num_queued: c_types::c_uint,
    pub prev_last_obj_cnt: c_types::c_uint,
    pub lowest_slack: c_types::c_uint,
    pub slack_start_time: c_types::c_ulong,
    pub max_limit: c_types::c_uint,
    pub min_limit: c_types::c_uint,
    pub slack_hold_time: c_types::c_uint,
}
#[test]
fn bindgen_test_layout_dql() {
    assert_eq!(
        ::core::mem::size_of::<dql>(),
        128usize,
        concat!("Size of: ", stringify!(dql))
    );
    assert_eq!(
        ::core::mem::align_of::<dql>(),
        64usize,
        concat!("Alignment of ", stringify!(dql))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dql>())).num_queued as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dql),
            "::",
            stringify!(num_queued)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dql>())).adj_limit as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(dql),
            "::",
            stringify!(adj_limit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dql>())).last_obj_cnt as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(dql),
            "::",
            stringify!(last_obj_cnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dql>())).limit as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(dql),
            "::",
            stringify!(limit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dql>())).num_completed as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(dql),
            "::",
            stringify!(num_completed)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dql>())).prev_ovlimit as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(dql),
            "::",
            stringify!(prev_ovlimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dql>())).prev_num_queued as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(dql),
            "::",
            stringify!(prev_num_queued)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dql>())).prev_last_obj_cnt as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(dql),
            "::",
            stringify!(prev_last_obj_cnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dql>())).lowest_slack as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(dql),
            "::",
            stringify!(lowest_slack)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dql>())).slack_start_time as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(dql),
            "::",
            stringify!(slack_start_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dql>())).max_limit as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(dql),
            "::",
            stringify!(max_limit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dql>())).min_limit as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(dql),
            "::",
            stringify!(min_limit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dql>())).slack_hold_time as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(dql),
            "::",
            stringify!(slack_hold_time)
        )
    );
}
impl Default for dql {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type compat_long_t = s32;
pub type compat_uptr_t = u32_;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct compat_robust_list {
    pub next: compat_uptr_t,
}
#[test]
fn bindgen_test_layout_compat_robust_list() {
    assert_eq!(
        ::core::mem::size_of::<compat_robust_list>(),
        4usize,
        concat!("Size of: ", stringify!(compat_robust_list))
    );
    assert_eq!(
        ::core::mem::align_of::<compat_robust_list>(),
        4usize,
        concat!("Alignment of ", stringify!(compat_robust_list))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<compat_robust_list>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(compat_robust_list),
            "::",
            stringify!(next)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct compat_robust_list_head {
    pub list: compat_robust_list,
    pub futex_offset: compat_long_t,
    pub list_op_pending: compat_uptr_t,
}
#[test]
fn bindgen_test_layout_compat_robust_list_head() {
    assert_eq!(
        ::core::mem::size_of::<compat_robust_list_head>(),
        12usize,
        concat!("Size of: ", stringify!(compat_robust_list_head))
    );
    assert_eq!(
        ::core::mem::align_of::<compat_robust_list_head>(),
        4usize,
        concat!("Alignment of ", stringify!(compat_robust_list_head))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<compat_robust_list_head>())).list as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(compat_robust_list_head),
            "::",
            stringify!(list)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<compat_robust_list_head>())).futex_offset as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(compat_robust_list_head),
            "::",
            stringify!(futex_offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<compat_robust_list_head>())).list_op_pending as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(compat_robust_list_head),
            "::",
            stringify!(list_op_pending)
        )
    );
}
#[doc = " struct ethtool_drvinfo - general driver and device information"]
#[doc = " @cmd: Command number = %ETHTOOL_GDRVINFO"]
#[doc = " @driver: Driver short name.  This should normally match the name"]
#[doc = "\tin its bus driver structure (e.g. pci_driver::name).  Must"]
#[doc = "\tnot be an empty string."]
#[doc = " @version: Driver version string; may be an empty string"]
#[doc = " @fw_version: Firmware version string; may be an empty string"]
#[doc = " @erom_version: Expansion ROM version string; may be an empty string"]
#[doc = " @bus_info: Device bus address.  This should match the dev_name()"]
#[doc = "\tstring for the underlying bus device, if there is one.  May be"]
#[doc = "\tan empty string."]
#[doc = " @n_priv_flags: Number of flags valid for %ETHTOOL_GPFLAGS and"]
#[doc = "\t%ETHTOOL_SPFLAGS commands; also the number of strings in the"]
#[doc = "\t%ETH_SS_PRIV_FLAGS set"]
#[doc = " @n_stats: Number of u64 statistics returned by the %ETHTOOL_GSTATS"]
#[doc = "\tcommand; also the number of strings in the %ETH_SS_STATS set"]
#[doc = " @testinfo_len: Number of results returned by the %ETHTOOL_TEST"]
#[doc = "\tcommand; also the number of strings in the %ETH_SS_TEST set"]
#[doc = " @eedump_len: Size of EEPROM accessible through the %ETHTOOL_GEEPROM"]
#[doc = "\tand %ETHTOOL_SEEPROM commands, in bytes"]
#[doc = " @regdump_len: Size of register dump returned by the %ETHTOOL_GREGS"]
#[doc = "\tcommand, in bytes"]
#[doc = ""]
#[doc = " Users can use the %ETHTOOL_GSSET_INFO command to get the number of"]
#[doc = " strings in any string set (from Linux 2.6.34)."]
#[doc = ""]
#[doc = " Drivers should set at most @driver, @version, @fw_version and"]
#[doc = " @bus_info in their get_drvinfo() implementation.  The ethtool"]
#[doc = " core fills in the other fields using other driver operations."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ethtool_drvinfo {
    pub cmd: __u32,
    pub driver: [c_types::c_char; 32usize],
    pub version: [c_types::c_char; 32usize],
    pub fw_version: [c_types::c_char; 32usize],
    pub bus_info: [c_types::c_char; 32usize],
    pub erom_version: [c_types::c_char; 32usize],
    pub reserved2: [c_types::c_char; 12usize],
    pub n_priv_flags: __u32,
    pub n_stats: __u32,
    pub testinfo_len: __u32,
    pub eedump_len: __u32,
    pub regdump_len: __u32,
}
#[test]
fn bindgen_test_layout_ethtool_drvinfo() {
    assert_eq!(
        ::core::mem::size_of::<ethtool_drvinfo>(),
        196usize,
        concat!("Size of: ", stringify!(ethtool_drvinfo))
    );
    assert_eq!(
        ::core::mem::align_of::<ethtool_drvinfo>(),
        4usize,
        concat!("Alignment of ", stringify!(ethtool_drvinfo))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_drvinfo>())).cmd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_drvinfo),
            "::",
            stringify!(cmd)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_drvinfo>())).driver as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_drvinfo),
            "::",
            stringify!(driver)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_drvinfo>())).version as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_drvinfo),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_drvinfo>())).fw_version as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_drvinfo),
            "::",
            stringify!(fw_version)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_drvinfo>())).bus_info as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_drvinfo),
            "::",
            stringify!(bus_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_drvinfo>())).erom_version as *const _ as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_drvinfo),
            "::",
            stringify!(erom_version)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_drvinfo>())).reserved2 as *const _ as usize },
        164usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_drvinfo),
            "::",
            stringify!(reserved2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_drvinfo>())).n_priv_flags as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_drvinfo),
            "::",
            stringify!(n_priv_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_drvinfo>())).n_stats as *const _ as usize },
        180usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_drvinfo),
            "::",
            stringify!(n_stats)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_drvinfo>())).testinfo_len as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_drvinfo),
            "::",
            stringify!(testinfo_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_drvinfo>())).eedump_len as *const _ as usize },
        188usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_drvinfo),
            "::",
            stringify!(eedump_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_drvinfo>())).regdump_len as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_drvinfo),
            "::",
            stringify!(regdump_len)
        )
    );
}
#[doc = " struct ethtool_wolinfo - Wake-On-Lan configuration"]
#[doc = " @cmd: Command number = %ETHTOOL_GWOL or %ETHTOOL_SWOL"]
#[doc = " @supported: Bitmask of %WAKE_* flags for supported Wake-On-Lan modes."]
#[doc = "\tRead-only."]
#[doc = " @wolopts: Bitmask of %WAKE_* flags for enabled Wake-On-Lan modes."]
#[doc = " @sopass: SecureOn(tm) password; meaningful only if %WAKE_MAGICSECURE"]
#[doc = "\tis set in @wolopts."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ethtool_wolinfo {
    pub cmd: __u32,
    pub supported: __u32,
    pub wolopts: __u32,
    pub sopass: [__u8; 6usize],
}
#[test]
fn bindgen_test_layout_ethtool_wolinfo() {
    assert_eq!(
        ::core::mem::size_of::<ethtool_wolinfo>(),
        20usize,
        concat!("Size of: ", stringify!(ethtool_wolinfo))
    );
    assert_eq!(
        ::core::mem::align_of::<ethtool_wolinfo>(),
        4usize,
        concat!("Alignment of ", stringify!(ethtool_wolinfo))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_wolinfo>())).cmd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_wolinfo),
            "::",
            stringify!(cmd)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_wolinfo>())).supported as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_wolinfo),
            "::",
            stringify!(supported)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_wolinfo>())).wolopts as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_wolinfo),
            "::",
            stringify!(wolopts)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_wolinfo>())).sopass as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_wolinfo),
            "::",
            stringify!(sopass)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct ethtool_tunable {
    pub cmd: __u32,
    pub id: __u32,
    pub type_id: __u32,
    pub len: __u32,
    pub data: __IncompleteArrayField<*mut c_types::c_void>,
}
#[test]
fn bindgen_test_layout_ethtool_tunable() {
    assert_eq!(
        ::core::mem::size_of::<ethtool_tunable>(),
        16usize,
        concat!("Size of: ", stringify!(ethtool_tunable))
    );
    assert_eq!(
        ::core::mem::align_of::<ethtool_tunable>(),
        8usize,
        concat!("Alignment of ", stringify!(ethtool_tunable))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_tunable>())).cmd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_tunable),
            "::",
            stringify!(cmd)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_tunable>())).id as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_tunable),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_tunable>())).type_id as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_tunable),
            "::",
            stringify!(type_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_tunable>())).len as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_tunable),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_tunable>())).data as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_tunable),
            "::",
            stringify!(data)
        )
    );
}
impl Default for ethtool_tunable {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[doc = " struct ethtool_regs - hardware register dump"]
#[doc = " @cmd: Command number = %ETHTOOL_GREGS"]
#[doc = " @version: Dump format version.  This is driver-specific and may"]
#[doc = "\tdistinguish different chips/revisions.  Drivers must use new"]
#[doc = "\tversion numbers whenever the dump format changes in an"]
#[doc = "\tincompatible way."]
#[doc = " @len: On entry, the real length of @data.  On return, the number of"]
#[doc = "\tbytes used."]
#[doc = " @data: Buffer for the register dump"]
#[doc = ""]
#[doc = " Users should use %ETHTOOL_GDRVINFO to find the maximum length of"]
#[doc = " a register dump for the interface.  They must allocate the buffer"]
#[doc = " immediately following this structure."]
#[repr(C)]
#[derive(Debug, Default)]
pub struct ethtool_regs {
    pub cmd: __u32,
    pub version: __u32,
    pub len: __u32,
    pub data: __IncompleteArrayField<__u8>,
}
#[test]
fn bindgen_test_layout_ethtool_regs() {
    assert_eq!(
        ::core::mem::size_of::<ethtool_regs>(),
        12usize,
        concat!("Size of: ", stringify!(ethtool_regs))
    );
    assert_eq!(
        ::core::mem::align_of::<ethtool_regs>(),
        4usize,
        concat!("Alignment of ", stringify!(ethtool_regs))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_regs>())).cmd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_regs),
            "::",
            stringify!(cmd)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_regs>())).version as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_regs),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_regs>())).len as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_regs),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_regs>())).data as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_regs),
            "::",
            stringify!(data)
        )
    );
}
#[doc = " struct ethtool_eeprom - EEPROM dump"]
#[doc = " @cmd: Command number = %ETHTOOL_GEEPROM, %ETHTOOL_GMODULEEEPROM or"]
#[doc = "\t%ETHTOOL_SEEPROM"]
#[doc = " @magic: A 'magic cookie' value to guard against accidental changes."]
#[doc = "\tThe value passed in to %ETHTOOL_SEEPROM must match the value"]
#[doc = "\treturned by %ETHTOOL_GEEPROM for the same device.  This is"]
#[doc = "\tunused when @cmd is %ETHTOOL_GMODULEEEPROM."]
#[doc = " @offset: Offset within the EEPROM to begin reading/writing, in bytes"]
#[doc = " @len: On entry, number of bytes to read/write.  On successful"]
#[doc = "\treturn, number of bytes actually read/written.  In case of"]
#[doc = "\terror, this may indicate at what point the error occurred."]
#[doc = " @data: Buffer to read/write from"]
#[doc = ""]
#[doc = " Users may use %ETHTOOL_GDRVINFO or %ETHTOOL_GMODULEINFO to find"]
#[doc = " the length of an on-board or module EEPROM, respectively.  They"]
#[doc = " must allocate the buffer immediately following this structure."]
#[repr(C)]
#[derive(Debug, Default)]
pub struct ethtool_eeprom {
    pub cmd: __u32,
    pub magic: __u32,
    pub offset: __u32,
    pub len: __u32,
    pub data: __IncompleteArrayField<__u8>,
}
#[test]
fn bindgen_test_layout_ethtool_eeprom() {
    assert_eq!(
        ::core::mem::size_of::<ethtool_eeprom>(),
        16usize,
        concat!("Size of: ", stringify!(ethtool_eeprom))
    );
    assert_eq!(
        ::core::mem::align_of::<ethtool_eeprom>(),
        4usize,
        concat!("Alignment of ", stringify!(ethtool_eeprom))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_eeprom>())).cmd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_eeprom),
            "::",
            stringify!(cmd)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_eeprom>())).magic as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_eeprom),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_eeprom>())).offset as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_eeprom),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_eeprom>())).len as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_eeprom),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_eeprom>())).data as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_eeprom),
            "::",
            stringify!(data)
        )
    );
}
#[doc = " struct ethtool_eee - Energy Efficient Ethernet information"]
#[doc = " @cmd: ETHTOOL_{G,S}EEE"]
#[doc = " @supported: Mask of %SUPPORTED_* flags for the speed/duplex combinations"]
#[doc = "\tfor which there is EEE support."]
#[doc = " @advertised: Mask of %ADVERTISED_* flags for the speed/duplex combinations"]
#[doc = "\tadvertised as eee capable."]
#[doc = " @lp_advertised: Mask of %ADVERTISED_* flags for the speed/duplex"]
#[doc = "\tcombinations advertised by the link partner as eee capable."]
#[doc = " @eee_active: Result of the eee auto negotiation."]
#[doc = " @eee_enabled: EEE configured mode (enabled/disabled)."]
#[doc = " @tx_lpi_enabled: Whether the interface should assert its tx lpi, given"]
#[doc = "\tthat eee was negotiated."]
#[doc = " @tx_lpi_timer: Time in microseconds the interface delays prior to asserting"]
#[doc = "\tits tx lpi (after reaching 'idle' state). Effective only when eee"]
#[doc = "\twas negotiated and tx_lpi_enabled was set."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ethtool_eee {
    pub cmd: __u32,
    pub supported: __u32,
    pub advertised: __u32,
    pub lp_advertised: __u32,
    pub eee_active: __u32,
    pub eee_enabled: __u32,
    pub tx_lpi_enabled: __u32,
    pub tx_lpi_timer: __u32,
    pub reserved: [__u32; 2usize],
}
#[test]
fn bindgen_test_layout_ethtool_eee() {
    assert_eq!(
        ::core::mem::size_of::<ethtool_eee>(),
        40usize,
        concat!("Size of: ", stringify!(ethtool_eee))
    );
    assert_eq!(
        ::core::mem::align_of::<ethtool_eee>(),
        4usize,
        concat!("Alignment of ", stringify!(ethtool_eee))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_eee>())).cmd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_eee),
            "::",
            stringify!(cmd)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_eee>())).supported as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_eee),
            "::",
            stringify!(supported)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_eee>())).advertised as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_eee),
            "::",
            stringify!(advertised)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_eee>())).lp_advertised as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_eee),
            "::",
            stringify!(lp_advertised)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_eee>())).eee_active as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_eee),
            "::",
            stringify!(eee_active)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_eee>())).eee_enabled as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_eee),
            "::",
            stringify!(eee_enabled)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_eee>())).tx_lpi_enabled as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_eee),
            "::",
            stringify!(tx_lpi_enabled)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_eee>())).tx_lpi_timer as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_eee),
            "::",
            stringify!(tx_lpi_timer)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_eee>())).reserved as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_eee),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " struct ethtool_modinfo - plugin module eeprom information"]
#[doc = " @cmd: %ETHTOOL_GMODULEINFO"]
#[doc = " @type: Standard the module information conforms to %ETH_MODULE_SFF_xxxx"]
#[doc = " @eeprom_len: Length of the eeprom"]
#[doc = ""]
#[doc = " This structure is used to return the information to"]
#[doc = " properly size memory for a subsequent call to %ETHTOOL_GMODULEEEPROM."]
#[doc = " The type code indicates the eeprom data format"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ethtool_modinfo {
    pub cmd: __u32,
    pub type_: __u32,
    pub eeprom_len: __u32,
    pub reserved: [__u32; 8usize],
}
#[test]
fn bindgen_test_layout_ethtool_modinfo() {
    assert_eq!(
        ::core::mem::size_of::<ethtool_modinfo>(),
        44usize,
        concat!("Size of: ", stringify!(ethtool_modinfo))
    );
    assert_eq!(
        ::core::mem::align_of::<ethtool_modinfo>(),
        4usize,
        concat!("Alignment of ", stringify!(ethtool_modinfo))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_modinfo>())).cmd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_modinfo),
            "::",
            stringify!(cmd)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_modinfo>())).type_ as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_modinfo),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_modinfo>())).eeprom_len as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_modinfo),
            "::",
            stringify!(eeprom_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_modinfo>())).reserved as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_modinfo),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " struct ethtool_coalesce - coalescing parameters for IRQs and stats updates"]
#[doc = " @cmd: ETHTOOL_{G,S}COALESCE"]
#[doc = " @rx_coalesce_usecs: How many usecs to delay an RX interrupt after"]
#[doc = "\ta packet arrives."]
#[doc = " @rx_max_coalesced_frames: Maximum number of packets to receive"]
#[doc = "\tbefore an RX interrupt."]
#[doc = " @rx_coalesce_usecs_irq: Same as @rx_coalesce_usecs, except that"]
#[doc = "\tthis value applies while an IRQ is being serviced by the host."]
#[doc = " @rx_max_coalesced_frames_irq: Same as @rx_max_coalesced_frames,"]
#[doc = "\texcept that this value applies while an IRQ is being serviced"]
#[doc = "\tby the host."]
#[doc = " @tx_coalesce_usecs: How many usecs to delay a TX interrupt after"]
#[doc = "\ta packet is sent."]
#[doc = " @tx_max_coalesced_frames: Maximum number of packets to be sent"]
#[doc = "\tbefore a TX interrupt."]
#[doc = " @tx_coalesce_usecs_irq: Same as @tx_coalesce_usecs, except that"]
#[doc = "\tthis value applies while an IRQ is being serviced by the host."]
#[doc = " @tx_max_coalesced_frames_irq: Same as @tx_max_coalesced_frames,"]
#[doc = "\texcept that this value applies while an IRQ is being serviced"]
#[doc = "\tby the host."]
#[doc = " @stats_block_coalesce_usecs: How many usecs to delay in-memory"]
#[doc = "\tstatistics block updates.  Some drivers do not have an"]
#[doc = "\tin-memory statistic block, and in such cases this value is"]
#[doc = "\tignored.  This value must not be zero."]
#[doc = " @use_adaptive_rx_coalesce: Enable adaptive RX coalescing."]
#[doc = " @use_adaptive_tx_coalesce: Enable adaptive TX coalescing."]
#[doc = " @pkt_rate_low: Threshold for low packet rate (packets per second)."]
#[doc = " @rx_coalesce_usecs_low: How many usecs to delay an RX interrupt after"]
#[doc = "\ta packet arrives, when the packet rate is below @pkt_rate_low."]
#[doc = " @rx_max_coalesced_frames_low: Maximum number of packets to be received"]
#[doc = "\tbefore an RX interrupt, when the packet rate is below @pkt_rate_low."]
#[doc = " @tx_coalesce_usecs_low: How many usecs to delay a TX interrupt after"]
#[doc = "\ta packet is sent, when the packet rate is below @pkt_rate_low."]
#[doc = " @tx_max_coalesced_frames_low: Maximum nuumber of packets to be sent before"]
#[doc = "\ta TX interrupt, when the packet rate is below @pkt_rate_low."]
#[doc = " @pkt_rate_high: Threshold for high packet rate (packets per second)."]
#[doc = " @rx_coalesce_usecs_high: How many usecs to delay an RX interrupt after"]
#[doc = "\ta packet arrives, when the packet rate is above @pkt_rate_high."]
#[doc = " @rx_max_coalesced_frames_high: Maximum number of packets to be received"]
#[doc = "\tbefore an RX interrupt, when the packet rate is above @pkt_rate_high."]
#[doc = " @tx_coalesce_usecs_high: How many usecs to delay a TX interrupt after"]
#[doc = "\ta packet is sent, when the packet rate is above @pkt_rate_high."]
#[doc = " @tx_max_coalesced_frames_high: Maximum number of packets to be sent before"]
#[doc = "\ta TX interrupt, when the packet rate is above @pkt_rate_high."]
#[doc = " @rate_sample_interval: How often to do adaptive coalescing packet rate"]
#[doc = "\tsampling, measured in seconds.  Must not be zero."]
#[doc = ""]
#[doc = " Each pair of (usecs, max_frames) fields specifies that interrupts"]
#[doc = " should be coalesced until"]
#[doc = "\t(usecs > 0 && time_since_first_completion >= usecs) ||"]
#[doc = "\t(max_frames > 0 && completed_frames >= max_frames)"]
#[doc = ""]
#[doc = " It is illegal to set both usecs and max_frames to zero as this"]
#[doc = " would cause interrupts to never be generated.  To disable"]
#[doc = " coalescing, set usecs = 0 and max_frames = 1."]
#[doc = ""]
#[doc = " Some implementations ignore the value of max_frames and use the"]
#[doc = " condition time_since_first_completion >= usecs"]
#[doc = ""]
#[doc = " This is deprecated.  Drivers for hardware that does not support"]
#[doc = " counting completions should validate that max_frames == !rx_usecs."]
#[doc = ""]
#[doc = " Adaptive RX/TX coalescing is an algorithm implemented by some"]
#[doc = " drivers to improve latency under low packet rates and improve"]
#[doc = " throughput under high packet rates.  Some drivers only implement"]
#[doc = " one of RX or TX adaptive coalescing.  Anything not implemented by"]
#[doc = " the driver causes these values to be silently ignored."]
#[doc = ""]
#[doc = " When the packet rate is below @pkt_rate_high but above"]
#[doc = " @pkt_rate_low (both measured in packets per second) the"]
#[doc = " normal {rx,tx}_* coalescing parameters are used."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ethtool_coalesce {
    pub cmd: __u32,
    pub rx_coalesce_usecs: __u32,
    pub rx_max_coalesced_frames: __u32,
    pub rx_coalesce_usecs_irq: __u32,
    pub rx_max_coalesced_frames_irq: __u32,
    pub tx_coalesce_usecs: __u32,
    pub tx_max_coalesced_frames: __u32,
    pub tx_coalesce_usecs_irq: __u32,
    pub tx_max_coalesced_frames_irq: __u32,
    pub stats_block_coalesce_usecs: __u32,
    pub use_adaptive_rx_coalesce: __u32,
    pub use_adaptive_tx_coalesce: __u32,
    pub pkt_rate_low: __u32,
    pub rx_coalesce_usecs_low: __u32,
    pub rx_max_coalesced_frames_low: __u32,
    pub tx_coalesce_usecs_low: __u32,
    pub tx_max_coalesced_frames_low: __u32,
    pub pkt_rate_high: __u32,
    pub rx_coalesce_usecs_high: __u32,
    pub rx_max_coalesced_frames_high: __u32,
    pub tx_coalesce_usecs_high: __u32,
    pub tx_max_coalesced_frames_high: __u32,
    pub rate_sample_interval: __u32,
}
#[test]
fn bindgen_test_layout_ethtool_coalesce() {
    assert_eq!(
        ::core::mem::size_of::<ethtool_coalesce>(),
        92usize,
        concat!("Size of: ", stringify!(ethtool_coalesce))
    );
    assert_eq!(
        ::core::mem::align_of::<ethtool_coalesce>(),
        4usize,
        concat!("Alignment of ", stringify!(ethtool_coalesce))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_coalesce>())).cmd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_coalesce),
            "::",
            stringify!(cmd)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ethtool_coalesce>())).rx_coalesce_usecs as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_coalesce),
            "::",
            stringify!(rx_coalesce_usecs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ethtool_coalesce>())).rx_max_coalesced_frames as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_coalesce),
            "::",
            stringify!(rx_max_coalesced_frames)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ethtool_coalesce>())).rx_coalesce_usecs_irq as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_coalesce),
            "::",
            stringify!(rx_coalesce_usecs_irq)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ethtool_coalesce>())).rx_max_coalesced_frames_irq as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_coalesce),
            "::",
            stringify!(rx_max_coalesced_frames_irq)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ethtool_coalesce>())).tx_coalesce_usecs as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_coalesce),
            "::",
            stringify!(tx_coalesce_usecs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ethtool_coalesce>())).tx_max_coalesced_frames as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_coalesce),
            "::",
            stringify!(tx_max_coalesced_frames)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ethtool_coalesce>())).tx_coalesce_usecs_irq as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_coalesce),
            "::",
            stringify!(tx_coalesce_usecs_irq)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ethtool_coalesce>())).tx_max_coalesced_frames_irq as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_coalesce),
            "::",
            stringify!(tx_max_coalesced_frames_irq)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ethtool_coalesce>())).stats_block_coalesce_usecs as *const _
                as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_coalesce),
            "::",
            stringify!(stats_block_coalesce_usecs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ethtool_coalesce>())).use_adaptive_rx_coalesce as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_coalesce),
            "::",
            stringify!(use_adaptive_rx_coalesce)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ethtool_coalesce>())).use_adaptive_tx_coalesce as *const _
                as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_coalesce),
            "::",
            stringify!(use_adaptive_tx_coalesce)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_coalesce>())).pkt_rate_low as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_coalesce),
            "::",
            stringify!(pkt_rate_low)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ethtool_coalesce>())).rx_coalesce_usecs_low as *const _ as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_coalesce),
            "::",
            stringify!(rx_coalesce_usecs_low)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ethtool_coalesce>())).rx_max_coalesced_frames_low as *const _
                as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_coalesce),
            "::",
            stringify!(rx_max_coalesced_frames_low)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ethtool_coalesce>())).tx_coalesce_usecs_low as *const _ as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_coalesce),
            "::",
            stringify!(tx_coalesce_usecs_low)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ethtool_coalesce>())).tx_max_coalesced_frames_low as *const _
                as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_coalesce),
            "::",
            stringify!(tx_max_coalesced_frames_low)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_coalesce>())).pkt_rate_high as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_coalesce),
            "::",
            stringify!(pkt_rate_high)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ethtool_coalesce>())).rx_coalesce_usecs_high as *const _
                as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_coalesce),
            "::",
            stringify!(rx_coalesce_usecs_high)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ethtool_coalesce>())).rx_max_coalesced_frames_high as *const _
                as usize
        },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_coalesce),
            "::",
            stringify!(rx_max_coalesced_frames_high)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ethtool_coalesce>())).tx_coalesce_usecs_high as *const _
                as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_coalesce),
            "::",
            stringify!(tx_coalesce_usecs_high)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ethtool_coalesce>())).tx_max_coalesced_frames_high as *const _
                as usize
        },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_coalesce),
            "::",
            stringify!(tx_max_coalesced_frames_high)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ethtool_coalesce>())).rate_sample_interval as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_coalesce),
            "::",
            stringify!(rate_sample_interval)
        )
    );
}
#[doc = " struct ethtool_ringparam - RX/TX ring parameters"]
#[doc = " @cmd: Command number = %ETHTOOL_GRINGPARAM or %ETHTOOL_SRINGPARAM"]
#[doc = " @rx_max_pending: Maximum supported number of pending entries per"]
#[doc = "\tRX ring.  Read-only."]
#[doc = " @rx_mini_max_pending: Maximum supported number of pending entries"]
#[doc = "\tper RX mini ring.  Read-only."]
#[doc = " @rx_jumbo_max_pending: Maximum supported number of pending entries"]
#[doc = "\tper RX jumbo ring.  Read-only."]
#[doc = " @tx_max_pending: Maximum supported number of pending entries per"]
#[doc = "\tTX ring.  Read-only."]
#[doc = " @rx_pending: Current maximum number of pending entries per RX ring"]
#[doc = " @rx_mini_pending: Current maximum number of pending entries per RX"]
#[doc = "\tmini ring"]
#[doc = " @rx_jumbo_pending: Current maximum number of pending entries per RX"]
#[doc = "\tjumbo ring"]
#[doc = " @tx_pending: Current maximum supported number of pending entries"]
#[doc = "\tper TX ring"]
#[doc = ""]
#[doc = " If the interface does not have separate RX mini and/or jumbo rings,"]
#[doc = " @rx_mini_max_pending and/or @rx_jumbo_max_pending will be 0."]
#[doc = ""]
#[doc = " There may also be driver-dependent minimum values for the number"]
#[doc = " of entries per ring."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ethtool_ringparam {
    pub cmd: __u32,
    pub rx_max_pending: __u32,
    pub rx_mini_max_pending: __u32,
    pub rx_jumbo_max_pending: __u32,
    pub tx_max_pending: __u32,
    pub rx_pending: __u32,
    pub rx_mini_pending: __u32,
    pub rx_jumbo_pending: __u32,
    pub tx_pending: __u32,
}
#[test]
fn bindgen_test_layout_ethtool_ringparam() {
    assert_eq!(
        ::core::mem::size_of::<ethtool_ringparam>(),
        36usize,
        concat!("Size of: ", stringify!(ethtool_ringparam))
    );
    assert_eq!(
        ::core::mem::align_of::<ethtool_ringparam>(),
        4usize,
        concat!("Alignment of ", stringify!(ethtool_ringparam))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_ringparam>())).cmd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_ringparam),
            "::",
            stringify!(cmd)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ethtool_ringparam>())).rx_max_pending as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_ringparam),
            "::",
            stringify!(rx_max_pending)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ethtool_ringparam>())).rx_mini_max_pending as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_ringparam),
            "::",
            stringify!(rx_mini_max_pending)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ethtool_ringparam>())).rx_jumbo_max_pending as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_ringparam),
            "::",
            stringify!(rx_jumbo_max_pending)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ethtool_ringparam>())).tx_max_pending as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_ringparam),
            "::",
            stringify!(tx_max_pending)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_ringparam>())).rx_pending as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_ringparam),
            "::",
            stringify!(rx_pending)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ethtool_ringparam>())).rx_mini_pending as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_ringparam),
            "::",
            stringify!(rx_mini_pending)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ethtool_ringparam>())).rx_jumbo_pending as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_ringparam),
            "::",
            stringify!(rx_jumbo_pending)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_ringparam>())).tx_pending as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_ringparam),
            "::",
            stringify!(tx_pending)
        )
    );
}
#[doc = " struct ethtool_channels - configuring number of network channel"]
#[doc = " @cmd: ETHTOOL_{G,S}CHANNELS"]
#[doc = " @max_rx: Read only. Maximum number of receive channel the driver support."]
#[doc = " @max_tx: Read only. Maximum number of transmit channel the driver support."]
#[doc = " @max_other: Read only. Maximum number of other channel the driver support."]
#[doc = " @max_combined: Read only. Maximum number of combined channel the driver"]
#[doc = "\tsupport. Set of queues RX, TX or other."]
#[doc = " @rx_count: Valid values are in the range 1 to the max_rx."]
#[doc = " @tx_count: Valid values are in the range 1 to the max_tx."]
#[doc = " @other_count: Valid values are in the range 1 to the max_other."]
#[doc = " @combined_count: Valid values are in the range 1 to the max_combined."]
#[doc = ""]
#[doc = " This can be used to configure RX, TX and other channels."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ethtool_channels {
    pub cmd: __u32,
    pub max_rx: __u32,
    pub max_tx: __u32,
    pub max_other: __u32,
    pub max_combined: __u32,
    pub rx_count: __u32,
    pub tx_count: __u32,
    pub other_count: __u32,
    pub combined_count: __u32,
}
#[test]
fn bindgen_test_layout_ethtool_channels() {
    assert_eq!(
        ::core::mem::size_of::<ethtool_channels>(),
        36usize,
        concat!("Size of: ", stringify!(ethtool_channels))
    );
    assert_eq!(
        ::core::mem::align_of::<ethtool_channels>(),
        4usize,
        concat!("Alignment of ", stringify!(ethtool_channels))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_channels>())).cmd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_channels),
            "::",
            stringify!(cmd)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_channels>())).max_rx as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_channels),
            "::",
            stringify!(max_rx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_channels>())).max_tx as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_channels),
            "::",
            stringify!(max_tx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_channels>())).max_other as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_channels),
            "::",
            stringify!(max_other)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_channels>())).max_combined as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_channels),
            "::",
            stringify!(max_combined)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_channels>())).rx_count as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_channels),
            "::",
            stringify!(rx_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_channels>())).tx_count as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_channels),
            "::",
            stringify!(tx_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_channels>())).other_count as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_channels),
            "::",
            stringify!(other_count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ethtool_channels>())).combined_count as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_channels),
            "::",
            stringify!(combined_count)
        )
    );
}
#[doc = " struct ethtool_pauseparam - Ethernet pause (flow control) parameters"]
#[doc = " @cmd: Command number = %ETHTOOL_GPAUSEPARAM or %ETHTOOL_SPAUSEPARAM"]
#[doc = " @autoneg: Flag to enable autonegotiation of pause frame use"]
#[doc = " @rx_pause: Flag to enable reception of pause frames"]
#[doc = " @tx_pause: Flag to enable transmission of pause frames"]
#[doc = ""]
#[doc = " Drivers should reject a non-zero setting of @autoneg when"]
#[doc = " autoneogotiation is disabled (or not supported) for the link."]
#[doc = ""]
#[doc = " If the link is autonegotiated, drivers should use"]
#[doc = " mii_advertise_flowctrl() or similar code to set the advertised"]
#[doc = " pause frame capabilities based on the @rx_pause and @tx_pause flags,"]
#[doc = " even if @autoneg is zero.  They should also allow the advertised"]
#[doc = " pause frame capabilities to be controlled directly through the"]
#[doc = " advertising field of &struct ethtool_cmd."]
#[doc = ""]
#[doc = " If @autoneg is non-zero, the MAC is configured to send and/or"]
#[doc = " receive pause frames according to the result of autonegotiation."]
#[doc = " Otherwise, it is configured directly based on the @rx_pause and"]
#[doc = " @tx_pause flags."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ethtool_pauseparam {
    pub cmd: __u32,
    pub autoneg: __u32,
    pub rx_pause: __u32,
    pub tx_pause: __u32,
}
#[test]
fn bindgen_test_layout_ethtool_pauseparam() {
    assert_eq!(
        ::core::mem::size_of::<ethtool_pauseparam>(),
        16usize,
        concat!("Size of: ", stringify!(ethtool_pauseparam))
    );
    assert_eq!(
        ::core::mem::align_of::<ethtool_pauseparam>(),
        4usize,
        concat!("Alignment of ", stringify!(ethtool_pauseparam))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_pauseparam>())).cmd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_pauseparam),
            "::",
            stringify!(cmd)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_pauseparam>())).autoneg as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_pauseparam),
            "::",
            stringify!(autoneg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_pauseparam>())).rx_pause as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_pauseparam),
            "::",
            stringify!(rx_pause)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_pauseparam>())).tx_pause as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_pauseparam),
            "::",
            stringify!(tx_pause)
        )
    );
}
#[doc = " struct ethtool_test - device self-test invocation"]
#[doc = " @cmd: Command number = %ETHTOOL_TEST"]
#[doc = " @flags: A bitmask of flags from &enum ethtool_test_flags.  Some"]
#[doc = "\tflags may be set by the user on entry; others may be set by"]
#[doc = "\tthe driver on return."]
#[doc = " @len: On return, the number of test results"]
#[doc = " @data: Array of test results"]
#[doc = ""]
#[doc = " Users must use %ETHTOOL_GSSET_INFO or %ETHTOOL_GDRVINFO to find the"]
#[doc = " number of test results that will be returned.  They must allocate a"]
#[doc = " buffer of the appropriate size (8 * number of results) immediately"]
#[doc = " following this structure."]
#[repr(C)]
#[derive(Debug, Default)]
pub struct ethtool_test {
    pub cmd: __u32,
    pub flags: __u32,
    pub reserved: __u32,
    pub len: __u32,
    pub data: __IncompleteArrayField<__u64>,
}
#[test]
fn bindgen_test_layout_ethtool_test() {
    assert_eq!(
        ::core::mem::size_of::<ethtool_test>(),
        16usize,
        concat!("Size of: ", stringify!(ethtool_test))
    );
    assert_eq!(
        ::core::mem::align_of::<ethtool_test>(),
        8usize,
        concat!("Alignment of ", stringify!(ethtool_test))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_test>())).cmd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_test),
            "::",
            stringify!(cmd)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_test>())).flags as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_test),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_test>())).reserved as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_test),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_test>())).len as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_test),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_test>())).data as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_test),
            "::",
            stringify!(data)
        )
    );
}
#[doc = " struct ethtool_stats - device-specific statistics"]
#[doc = " @cmd: Command number = %ETHTOOL_GSTATS"]
#[doc = " @n_stats: On return, the number of statistics"]
#[doc = " @data: Array of statistics"]
#[doc = ""]
#[doc = " Users must use %ETHTOOL_GSSET_INFO or %ETHTOOL_GDRVINFO to find the"]
#[doc = " number of statistics that will be returned.  They must allocate a"]
#[doc = " buffer of the appropriate size (8 * number of statistics)"]
#[doc = " immediately following this structure."]
#[repr(C)]
#[derive(Debug, Default)]
pub struct ethtool_stats {
    pub cmd: __u32,
    pub n_stats: __u32,
    pub data: __IncompleteArrayField<__u64>,
}
#[test]
fn bindgen_test_layout_ethtool_stats() {
    assert_eq!(
        ::core::mem::size_of::<ethtool_stats>(),
        8usize,
        concat!("Size of: ", stringify!(ethtool_stats))
    );
    assert_eq!(
        ::core::mem::align_of::<ethtool_stats>(),
        8usize,
        concat!("Alignment of ", stringify!(ethtool_stats))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_stats>())).cmd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_stats),
            "::",
            stringify!(cmd)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_stats>())).n_stats as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_stats),
            "::",
            stringify!(n_stats)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_stats>())).data as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_stats),
            "::",
            stringify!(data)
        )
    );
}
#[doc = " struct ethtool_tcpip4_spec - flow specification for TCP/IPv4 etc."]
#[doc = " @ip4src: Source host"]
#[doc = " @ip4dst: Destination host"]
#[doc = " @psrc: Source port"]
#[doc = " @pdst: Destination port"]
#[doc = " @tos: Type-of-service"]
#[doc = ""]
#[doc = " This can be used to specify a TCP/IPv4, UDP/IPv4 or SCTP/IPv4 flow."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ethtool_tcpip4_spec {
    pub ip4src: __be32,
    pub ip4dst: __be32,
    pub psrc: __be16,
    pub pdst: __be16,
    pub tos: __u8,
}
#[test]
fn bindgen_test_layout_ethtool_tcpip4_spec() {
    assert_eq!(
        ::core::mem::size_of::<ethtool_tcpip4_spec>(),
        16usize,
        concat!("Size of: ", stringify!(ethtool_tcpip4_spec))
    );
    assert_eq!(
        ::core::mem::align_of::<ethtool_tcpip4_spec>(),
        4usize,
        concat!("Alignment of ", stringify!(ethtool_tcpip4_spec))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_tcpip4_spec>())).ip4src as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_tcpip4_spec),
            "::",
            stringify!(ip4src)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_tcpip4_spec>())).ip4dst as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_tcpip4_spec),
            "::",
            stringify!(ip4dst)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_tcpip4_spec>())).psrc as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_tcpip4_spec),
            "::",
            stringify!(psrc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_tcpip4_spec>())).pdst as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_tcpip4_spec),
            "::",
            stringify!(pdst)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_tcpip4_spec>())).tos as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_tcpip4_spec),
            "::",
            stringify!(tos)
        )
    );
}
#[doc = " struct ethtool_ah_espip4_spec - flow specification for IPsec/IPv4"]
#[doc = " @ip4src: Source host"]
#[doc = " @ip4dst: Destination host"]
#[doc = " @spi: Security parameters index"]
#[doc = " @tos: Type-of-service"]
#[doc = ""]
#[doc = " This can be used to specify an IPsec transport or tunnel over IPv4."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ethtool_ah_espip4_spec {
    pub ip4src: __be32,
    pub ip4dst: __be32,
    pub spi: __be32,
    pub tos: __u8,
}
#[test]
fn bindgen_test_layout_ethtool_ah_espip4_spec() {
    assert_eq!(
        ::core::mem::size_of::<ethtool_ah_espip4_spec>(),
        16usize,
        concat!("Size of: ", stringify!(ethtool_ah_espip4_spec))
    );
    assert_eq!(
        ::core::mem::align_of::<ethtool_ah_espip4_spec>(),
        4usize,
        concat!("Alignment of ", stringify!(ethtool_ah_espip4_spec))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_ah_espip4_spec>())).ip4src as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_ah_espip4_spec),
            "::",
            stringify!(ip4src)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_ah_espip4_spec>())).ip4dst as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_ah_espip4_spec),
            "::",
            stringify!(ip4dst)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_ah_espip4_spec>())).spi as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_ah_espip4_spec),
            "::",
            stringify!(spi)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_ah_espip4_spec>())).tos as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_ah_espip4_spec),
            "::",
            stringify!(tos)
        )
    );
}
#[doc = " struct ethtool_usrip4_spec - general flow specification for IPv4"]
#[doc = " @ip4src: Source host"]
#[doc = " @ip4dst: Destination host"]
#[doc = " @l4_4_bytes: First 4 bytes of transport (layer 4) header"]
#[doc = " @tos: Type-of-service"]
#[doc = " @ip_ver: Value must be %ETH_RX_NFC_IP4; mask must be 0"]
#[doc = " @proto: Transport protocol number; mask must be 0"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ethtool_usrip4_spec {
    pub ip4src: __be32,
    pub ip4dst: __be32,
    pub l4_4_bytes: __be32,
    pub tos: __u8,
    pub ip_ver: __u8,
    pub proto: __u8,
}
#[test]
fn bindgen_test_layout_ethtool_usrip4_spec() {
    assert_eq!(
        ::core::mem::size_of::<ethtool_usrip4_spec>(),
        16usize,
        concat!("Size of: ", stringify!(ethtool_usrip4_spec))
    );
    assert_eq!(
        ::core::mem::align_of::<ethtool_usrip4_spec>(),
        4usize,
        concat!("Alignment of ", stringify!(ethtool_usrip4_spec))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_usrip4_spec>())).ip4src as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_usrip4_spec),
            "::",
            stringify!(ip4src)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_usrip4_spec>())).ip4dst as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_usrip4_spec),
            "::",
            stringify!(ip4dst)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_usrip4_spec>())).l4_4_bytes as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_usrip4_spec),
            "::",
            stringify!(l4_4_bytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_usrip4_spec>())).tos as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_usrip4_spec),
            "::",
            stringify!(tos)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_usrip4_spec>())).ip_ver as *const _ as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_usrip4_spec),
            "::",
            stringify!(ip_ver)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_usrip4_spec>())).proto as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_usrip4_spec),
            "::",
            stringify!(proto)
        )
    );
}
#[doc = " struct ethtool_tcpip6_spec - flow specification for TCP/IPv6 etc."]
#[doc = " @ip6src: Source host"]
#[doc = " @ip6dst: Destination host"]
#[doc = " @psrc: Source port"]
#[doc = " @pdst: Destination port"]
#[doc = " @tclass: Traffic Class"]
#[doc = ""]
#[doc = " This can be used to specify a TCP/IPv6, UDP/IPv6 or SCTP/IPv6 flow."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ethtool_tcpip6_spec {
    pub ip6src: [__be32; 4usize],
    pub ip6dst: [__be32; 4usize],
    pub psrc: __be16,
    pub pdst: __be16,
    pub tclass: __u8,
}
#[test]
fn bindgen_test_layout_ethtool_tcpip6_spec() {
    assert_eq!(
        ::core::mem::size_of::<ethtool_tcpip6_spec>(),
        40usize,
        concat!("Size of: ", stringify!(ethtool_tcpip6_spec))
    );
    assert_eq!(
        ::core::mem::align_of::<ethtool_tcpip6_spec>(),
        4usize,
        concat!("Alignment of ", stringify!(ethtool_tcpip6_spec))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_tcpip6_spec>())).ip6src as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_tcpip6_spec),
            "::",
            stringify!(ip6src)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_tcpip6_spec>())).ip6dst as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_tcpip6_spec),
            "::",
            stringify!(ip6dst)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_tcpip6_spec>())).psrc as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_tcpip6_spec),
            "::",
            stringify!(psrc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_tcpip6_spec>())).pdst as *const _ as usize },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_tcpip6_spec),
            "::",
            stringify!(pdst)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_tcpip6_spec>())).tclass as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_tcpip6_spec),
            "::",
            stringify!(tclass)
        )
    );
}
#[doc = " struct ethtool_ah_espip6_spec - flow specification for IPsec/IPv6"]
#[doc = " @ip6src: Source host"]
#[doc = " @ip6dst: Destination host"]
#[doc = " @spi: Security parameters index"]
#[doc = " @tclass: Traffic Class"]
#[doc = ""]
#[doc = " This can be used to specify an IPsec transport or tunnel over IPv6."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ethtool_ah_espip6_spec {
    pub ip6src: [__be32; 4usize],
    pub ip6dst: [__be32; 4usize],
    pub spi: __be32,
    pub tclass: __u8,
}
#[test]
fn bindgen_test_layout_ethtool_ah_espip6_spec() {
    assert_eq!(
        ::core::mem::size_of::<ethtool_ah_espip6_spec>(),
        40usize,
        concat!("Size of: ", stringify!(ethtool_ah_espip6_spec))
    );
    assert_eq!(
        ::core::mem::align_of::<ethtool_ah_espip6_spec>(),
        4usize,
        concat!("Alignment of ", stringify!(ethtool_ah_espip6_spec))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_ah_espip6_spec>())).ip6src as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_ah_espip6_spec),
            "::",
            stringify!(ip6src)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_ah_espip6_spec>())).ip6dst as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_ah_espip6_spec),
            "::",
            stringify!(ip6dst)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_ah_espip6_spec>())).spi as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_ah_espip6_spec),
            "::",
            stringify!(spi)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_ah_espip6_spec>())).tclass as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_ah_espip6_spec),
            "::",
            stringify!(tclass)
        )
    );
}
#[doc = " struct ethtool_usrip6_spec - general flow specification for IPv6"]
#[doc = " @ip6src: Source host"]
#[doc = " @ip6dst: Destination host"]
#[doc = " @l4_4_bytes: First 4 bytes of transport (layer 4) header"]
#[doc = " @tclass: Traffic Class"]
#[doc = " @l4_proto: Transport protocol number (nexthdr after any Extension Headers)"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ethtool_usrip6_spec {
    pub ip6src: [__be32; 4usize],
    pub ip6dst: [__be32; 4usize],
    pub l4_4_bytes: __be32,
    pub tclass: __u8,
    pub l4_proto: __u8,
}
#[test]
fn bindgen_test_layout_ethtool_usrip6_spec() {
    assert_eq!(
        ::core::mem::size_of::<ethtool_usrip6_spec>(),
        40usize,
        concat!("Size of: ", stringify!(ethtool_usrip6_spec))
    );
    assert_eq!(
        ::core::mem::align_of::<ethtool_usrip6_spec>(),
        4usize,
        concat!("Alignment of ", stringify!(ethtool_usrip6_spec))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_usrip6_spec>())).ip6src as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_usrip6_spec),
            "::",
            stringify!(ip6src)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_usrip6_spec>())).ip6dst as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_usrip6_spec),
            "::",
            stringify!(ip6dst)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_usrip6_spec>())).l4_4_bytes as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_usrip6_spec),
            "::",
            stringify!(l4_4_bytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_usrip6_spec>())).tclass as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_usrip6_spec),
            "::",
            stringify!(tclass)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_usrip6_spec>())).l4_proto as *const _ as usize },
        37usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_usrip6_spec),
            "::",
            stringify!(l4_proto)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ethtool_flow_union {
    pub tcp_ip4_spec: ethtool_tcpip4_spec,
    pub udp_ip4_spec: ethtool_tcpip4_spec,
    pub sctp_ip4_spec: ethtool_tcpip4_spec,
    pub ah_ip4_spec: ethtool_ah_espip4_spec,
    pub esp_ip4_spec: ethtool_ah_espip4_spec,
    pub usr_ip4_spec: ethtool_usrip4_spec,
    pub tcp_ip6_spec: ethtool_tcpip6_spec,
    pub udp_ip6_spec: ethtool_tcpip6_spec,
    pub sctp_ip6_spec: ethtool_tcpip6_spec,
    pub ah_ip6_spec: ethtool_ah_espip6_spec,
    pub esp_ip6_spec: ethtool_ah_espip6_spec,
    pub usr_ip6_spec: ethtool_usrip6_spec,
    pub ether_spec: ethhdr,
    pub hdata: [__u8; 52usize],
    _bindgen_union_align: [u32; 13usize],
}
#[test]
fn bindgen_test_layout_ethtool_flow_union() {
    assert_eq!(
        ::core::mem::size_of::<ethtool_flow_union>(),
        52usize,
        concat!("Size of: ", stringify!(ethtool_flow_union))
    );
    assert_eq!(
        ::core::mem::align_of::<ethtool_flow_union>(),
        4usize,
        concat!("Alignment of ", stringify!(ethtool_flow_union))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ethtool_flow_union>())).tcp_ip4_spec as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_flow_union),
            "::",
            stringify!(tcp_ip4_spec)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ethtool_flow_union>())).udp_ip4_spec as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_flow_union),
            "::",
            stringify!(udp_ip4_spec)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ethtool_flow_union>())).sctp_ip4_spec as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_flow_union),
            "::",
            stringify!(sctp_ip4_spec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_flow_union>())).ah_ip4_spec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_flow_union),
            "::",
            stringify!(ah_ip4_spec)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ethtool_flow_union>())).esp_ip4_spec as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_flow_union),
            "::",
            stringify!(esp_ip4_spec)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ethtool_flow_union>())).usr_ip4_spec as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_flow_union),
            "::",
            stringify!(usr_ip4_spec)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ethtool_flow_union>())).tcp_ip6_spec as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_flow_union),
            "::",
            stringify!(tcp_ip6_spec)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ethtool_flow_union>())).udp_ip6_spec as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_flow_union),
            "::",
            stringify!(udp_ip6_spec)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ethtool_flow_union>())).sctp_ip6_spec as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_flow_union),
            "::",
            stringify!(sctp_ip6_spec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_flow_union>())).ah_ip6_spec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_flow_union),
            "::",
            stringify!(ah_ip6_spec)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ethtool_flow_union>())).esp_ip6_spec as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_flow_union),
            "::",
            stringify!(esp_ip6_spec)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ethtool_flow_union>())).usr_ip6_spec as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_flow_union),
            "::",
            stringify!(usr_ip6_spec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_flow_union>())).ether_spec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_flow_union),
            "::",
            stringify!(ether_spec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_flow_union>())).hdata as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_flow_union),
            "::",
            stringify!(hdata)
        )
    );
}
impl Default for ethtool_flow_union {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[doc = " struct ethtool_flow_ext - additional RX flow fields"]
#[doc = " @h_dest: destination MAC address"]
#[doc = " @vlan_etype: VLAN EtherType"]
#[doc = " @vlan_tci: VLAN tag control information"]
#[doc = " @data: user defined data"]
#[doc = ""]
#[doc = " Note, @vlan_etype, @vlan_tci, and @data are only valid if %FLOW_EXT"]
#[doc = " is set in &struct ethtool_rx_flow_spec @flow_type."]
#[doc = " @h_dest is valid if %FLOW_MAC_EXT is set."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ethtool_flow_ext {
    pub padding: [__u8; 2usize],
    pub h_dest: [c_types::c_uchar; 6usize],
    pub vlan_etype: __be16,
    pub vlan_tci: __be16,
    pub data: [__be32; 2usize],
}
#[test]
fn bindgen_test_layout_ethtool_flow_ext() {
    assert_eq!(
        ::core::mem::size_of::<ethtool_flow_ext>(),
        20usize,
        concat!("Size of: ", stringify!(ethtool_flow_ext))
    );
    assert_eq!(
        ::core::mem::align_of::<ethtool_flow_ext>(),
        4usize,
        concat!("Alignment of ", stringify!(ethtool_flow_ext))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_flow_ext>())).padding as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_flow_ext),
            "::",
            stringify!(padding)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_flow_ext>())).h_dest as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_flow_ext),
            "::",
            stringify!(h_dest)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_flow_ext>())).vlan_etype as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_flow_ext),
            "::",
            stringify!(vlan_etype)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_flow_ext>())).vlan_tci as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_flow_ext),
            "::",
            stringify!(vlan_tci)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_flow_ext>())).data as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_flow_ext),
            "::",
            stringify!(data)
        )
    );
}
#[doc = " struct ethtool_rx_flow_spec - classification rule for RX flows"]
#[doc = " @flow_type: Type of match to perform, e.g. %TCP_V4_FLOW"]
#[doc = " @h_u: Flow fields to match (dependent on @flow_type)"]
#[doc = " @h_ext: Additional fields to match"]
#[doc = " @m_u: Masks for flow field bits to be matched"]
#[doc = " @m_ext: Masks for additional field bits to be matched"]
#[doc = "\tNote, all additional fields must be ignored unless @flow_type"]
#[doc = "\tincludes the %FLOW_EXT or %FLOW_MAC_EXT flag"]
#[doc = "\t(see &struct ethtool_flow_ext description)."]
#[doc = " @ring_cookie: RX ring/queue index to deliver to, or %RX_CLS_FLOW_DISC"]
#[doc = "\tif packets should be discarded, or %RX_CLS_FLOW_WAKE if the"]
#[doc = "\tpackets should be used for Wake-on-LAN with %WAKE_FILTER"]
#[doc = " @location: Location of rule in the table.  Locations must be"]
#[doc = "\tnumbered such that a flow matching multiple rules will be"]
#[doc = "\tclassified according to the first (lowest numbered) rule."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ethtool_rx_flow_spec {
    pub flow_type: __u32,
    pub h_u: ethtool_flow_union,
    pub h_ext: ethtool_flow_ext,
    pub m_u: ethtool_flow_union,
    pub m_ext: ethtool_flow_ext,
    pub ring_cookie: __u64,
    pub location: __u32,
}
#[test]
fn bindgen_test_layout_ethtool_rx_flow_spec() {
    assert_eq!(
        ::core::mem::size_of::<ethtool_rx_flow_spec>(),
        168usize,
        concat!("Size of: ", stringify!(ethtool_rx_flow_spec))
    );
    assert_eq!(
        ::core::mem::align_of::<ethtool_rx_flow_spec>(),
        8usize,
        concat!("Alignment of ", stringify!(ethtool_rx_flow_spec))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_rx_flow_spec>())).flow_type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_rx_flow_spec),
            "::",
            stringify!(flow_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_rx_flow_spec>())).h_u as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_rx_flow_spec),
            "::",
            stringify!(h_u)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_rx_flow_spec>())).h_ext as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_rx_flow_spec),
            "::",
            stringify!(h_ext)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_rx_flow_spec>())).m_u as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_rx_flow_spec),
            "::",
            stringify!(m_u)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_rx_flow_spec>())).m_ext as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_rx_flow_spec),
            "::",
            stringify!(m_ext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ethtool_rx_flow_spec>())).ring_cookie as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_rx_flow_spec),
            "::",
            stringify!(ring_cookie)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_rx_flow_spec>())).location as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_rx_flow_spec),
            "::",
            stringify!(location)
        )
    );
}
impl Default for ethtool_rx_flow_spec {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[doc = " struct ethtool_rxnfc - command to get or set RX flow classification rules"]
#[doc = " @cmd: Specific command number - %ETHTOOL_GRXFH, %ETHTOOL_SRXFH,"]
#[doc = "\t%ETHTOOL_GRXRINGS, %ETHTOOL_GRXCLSRLCNT, %ETHTOOL_GRXCLSRULE,"]
#[doc = "\t%ETHTOOL_GRXCLSRLALL, %ETHTOOL_SRXCLSRLDEL or %ETHTOOL_SRXCLSRLINS"]
#[doc = " @flow_type: Type of flow to be affected, e.g. %TCP_V4_FLOW"]
#[doc = " @data: Command-dependent value"]
#[doc = " @fs: Flow classification rule"]
#[doc = " @rss_context: RSS context to be affected"]
#[doc = " @rule_cnt: Number of rules to be affected"]
#[doc = " @rule_locs: Array of used rule locations"]
#[doc = ""]
#[doc = " For %ETHTOOL_GRXFH and %ETHTOOL_SRXFH, @data is a bitmask indicating"]
#[doc = " the fields included in the flow hash, e.g. %RXH_IP_SRC.  The following"]
#[doc = " structure fields must not be used, except that if @flow_type includes"]
#[doc = " the %FLOW_RSS flag, then @rss_context determines which RSS context to"]
#[doc = " act on."]
#[doc = ""]
#[doc = " For %ETHTOOL_GRXRINGS, @data is set to the number of RX rings/queues"]
#[doc = " on return."]
#[doc = ""]
#[doc = " For %ETHTOOL_GRXCLSRLCNT, @rule_cnt is set to the number of defined"]
#[doc = " rules on return.  If @data is non-zero on return then it is the"]
#[doc = " size of the rule table, plus the flag %RX_CLS_LOC_SPECIAL if the"]
#[doc = " driver supports any special location values.  If that flag is not"]
#[doc = " set in @data then special location values should not be used."]
#[doc = ""]
#[doc = " For %ETHTOOL_GRXCLSRULE, @fs.@location specifies the location of an"]
#[doc = " existing rule on entry and @fs contains the rule on return; if"]
#[doc = " @fs.@flow_type includes the %FLOW_RSS flag, then @rss_context is"]
#[doc = " filled with the RSS context ID associated with the rule."]
#[doc = ""]
#[doc = " For %ETHTOOL_GRXCLSRLALL, @rule_cnt specifies the array size of the"]
#[doc = " user buffer for @rule_locs on entry.  On return, @data is the size"]
#[doc = " of the rule table, @rule_cnt is the number of defined rules, and"]
#[doc = " @rule_locs contains the locations of the defined rules.  Drivers"]
#[doc = " must use the second parameter to get_rxnfc() instead of @rule_locs."]
#[doc = ""]
#[doc = " For %ETHTOOL_SRXCLSRLINS, @fs specifies the rule to add or update."]
#[doc = " @fs.@location either specifies the location to use or is a special"]
#[doc = " location value with %RX_CLS_LOC_SPECIAL flag set.  On return,"]
#[doc = " @fs.@location is the actual rule location.  If @fs.@flow_type"]
#[doc = " includes the %FLOW_RSS flag, @rss_context is the RSS context ID to"]
#[doc = " use for flow spreading traffic which matches this rule.  The value"]
#[doc = " from the rxfh indirection table will be added to @fs.@ring_cookie"]
#[doc = " to choose which ring to deliver to."]
#[doc = ""]
#[doc = " For %ETHTOOL_SRXCLSRLDEL, @fs.@location specifies the location of an"]
#[doc = " existing rule on entry."]
#[doc = ""]
#[doc = " A driver supporting the special location values for"]
#[doc = " %ETHTOOL_SRXCLSRLINS may add the rule at any suitable unused"]
#[doc = " location, and may remove a rule at a later location (lower"]
#[doc = " priority) that matches exactly the same set of flows.  The special"]
#[doc = " values are %RX_CLS_LOC_ANY, selecting any location;"]
#[doc = " %RX_CLS_LOC_FIRST, selecting the first suitable location (maximum"]
#[doc = " priority); and %RX_CLS_LOC_LAST, selecting the last suitable"]
#[doc = " location (minimum priority).  Additional special values may be"]
#[doc = " defined in future and drivers must return -%EINVAL for any"]
#[doc = " unrecognised value."]
#[repr(C)]
pub struct ethtool_rxnfc {
    pub cmd: __u32,
    pub flow_type: __u32,
    pub data: __u64,
    pub fs: ethtool_rx_flow_spec,
    pub __bindgen_anon_1: ethtool_rxnfc__bindgen_ty_1,
    pub rule_locs: __IncompleteArrayField<__u32>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ethtool_rxnfc__bindgen_ty_1 {
    pub rule_cnt: __u32,
    pub rss_context: __u32,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_ethtool_rxnfc__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<ethtool_rxnfc__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(ethtool_rxnfc__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<ethtool_rxnfc__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(ethtool_rxnfc__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ethtool_rxnfc__bindgen_ty_1>())).rule_cnt as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_rxnfc__bindgen_ty_1),
            "::",
            stringify!(rule_cnt)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ethtool_rxnfc__bindgen_ty_1>())).rss_context as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_rxnfc__bindgen_ty_1),
            "::",
            stringify!(rss_context)
        )
    );
}
impl Default for ethtool_rxnfc__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_ethtool_rxnfc() {
    assert_eq!(
        ::core::mem::size_of::<ethtool_rxnfc>(),
        192usize,
        concat!("Size of: ", stringify!(ethtool_rxnfc))
    );
    assert_eq!(
        ::core::mem::align_of::<ethtool_rxnfc>(),
        8usize,
        concat!("Alignment of ", stringify!(ethtool_rxnfc))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_rxnfc>())).cmd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_rxnfc),
            "::",
            stringify!(cmd)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_rxnfc>())).flow_type as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_rxnfc),
            "::",
            stringify!(flow_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_rxnfc>())).data as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_rxnfc),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_rxnfc>())).fs as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_rxnfc),
            "::",
            stringify!(fs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_rxnfc>())).rule_locs as *const _ as usize },
        188usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_rxnfc),
            "::",
            stringify!(rule_locs)
        )
    );
}
impl Default for ethtool_rxnfc {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ethtool_flash {
    pub cmd: __u32,
    pub region: __u32,
    pub data: [c_types::c_char; 128usize],
}
#[test]
fn bindgen_test_layout_ethtool_flash() {
    assert_eq!(
        ::core::mem::size_of::<ethtool_flash>(),
        136usize,
        concat!("Size of: ", stringify!(ethtool_flash))
    );
    assert_eq!(
        ::core::mem::align_of::<ethtool_flash>(),
        4usize,
        concat!("Alignment of ", stringify!(ethtool_flash))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_flash>())).cmd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_flash),
            "::",
            stringify!(cmd)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_flash>())).region as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_flash),
            "::",
            stringify!(region)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_flash>())).data as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_flash),
            "::",
            stringify!(data)
        )
    );
}
impl Default for ethtool_flash {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[doc = " struct ethtool_dump - used for retrieving, setting device dump"]
#[doc = " @cmd: Command number - %ETHTOOL_GET_DUMP_FLAG, %ETHTOOL_GET_DUMP_DATA, or"]
#[doc = " \t%ETHTOOL_SET_DUMP"]
#[doc = " @version: FW version of the dump, filled in by driver"]
#[doc = " @flag: driver dependent flag for dump setting, filled in by driver during"]
#[doc = "        get and filled in by ethtool for set operation."]
#[doc = "        flag must be initialized by macro ETH_FW_DUMP_DISABLE value when"]
#[doc = "        firmware dump is disabled."]
#[doc = " @len: length of dump data, used as the length of the user buffer on entry to"]
#[doc = " \t %ETHTOOL_GET_DUMP_DATA and this is returned as dump length by driver"]
#[doc = " \t for %ETHTOOL_GET_DUMP_FLAG command"]
#[doc = " @data: data collected for get dump data operation"]
#[repr(C)]
#[derive(Debug, Default)]
pub struct ethtool_dump {
    pub cmd: __u32,
    pub version: __u32,
    pub flag: __u32,
    pub len: __u32,
    pub data: __IncompleteArrayField<__u8>,
}
#[test]
fn bindgen_test_layout_ethtool_dump() {
    assert_eq!(
        ::core::mem::size_of::<ethtool_dump>(),
        16usize,
        concat!("Size of: ", stringify!(ethtool_dump))
    );
    assert_eq!(
        ::core::mem::align_of::<ethtool_dump>(),
        4usize,
        concat!("Alignment of ", stringify!(ethtool_dump))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_dump>())).cmd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_dump),
            "::",
            stringify!(cmd)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_dump>())).version as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_dump),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_dump>())).flag as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_dump),
            "::",
            stringify!(flag)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_dump>())).len as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_dump),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_dump>())).data as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_dump),
            "::",
            stringify!(data)
        )
    );
}
#[doc = " struct ethtool_ts_info - holds a device's timestamping and PHC association"]
#[doc = " @cmd: command number = %ETHTOOL_GET_TS_INFO"]
#[doc = " @so_timestamping: bit mask of the sum of the supported SO_TIMESTAMPING flags"]
#[doc = " @phc_index: device index of the associated PHC, or -1 if there is none"]
#[doc = " @tx_types: bit mask of the supported hwtstamp_tx_types enumeration values"]
#[doc = " @rx_filters: bit mask of the supported hwtstamp_rx_filters enumeration values"]
#[doc = ""]
#[doc = " The bits in the 'tx_types' and 'rx_filters' fields correspond to"]
#[doc = " the 'hwtstamp_tx_types' and 'hwtstamp_rx_filters' enumeration values,"]
#[doc = " respectively.  For example, if the device supports HWTSTAMP_TX_ON,"]
#[doc = " then (1 << HWTSTAMP_TX_ON) in 'tx_types' will be set."]
#[doc = ""]
#[doc = " Drivers should only report the filters they actually support without"]
#[doc = " upscaling in the SIOCSHWTSTAMP ioctl. If the SIOCSHWSTAMP request for"]
#[doc = " HWTSTAMP_FILTER_V1_SYNC is supported by HWTSTAMP_FILTER_V1_EVENT, then the"]
#[doc = " driver should only report HWTSTAMP_FILTER_V1_EVENT in this op."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ethtool_ts_info {
    pub cmd: __u32,
    pub so_timestamping: __u32,
    pub phc_index: __s32,
    pub tx_types: __u32,
    pub tx_reserved: [__u32; 3usize],
    pub rx_filters: __u32,
    pub rx_reserved: [__u32; 3usize],
}
#[test]
fn bindgen_test_layout_ethtool_ts_info() {
    assert_eq!(
        ::core::mem::size_of::<ethtool_ts_info>(),
        44usize,
        concat!("Size of: ", stringify!(ethtool_ts_info))
    );
    assert_eq!(
        ::core::mem::align_of::<ethtool_ts_info>(),
        4usize,
        concat!("Alignment of ", stringify!(ethtool_ts_info))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_ts_info>())).cmd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_ts_info),
            "::",
            stringify!(cmd)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ethtool_ts_info>())).so_timestamping as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_ts_info),
            "::",
            stringify!(so_timestamping)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_ts_info>())).phc_index as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_ts_info),
            "::",
            stringify!(phc_index)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_ts_info>())).tx_types as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_ts_info),
            "::",
            stringify!(tx_types)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_ts_info>())).tx_reserved as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_ts_info),
            "::",
            stringify!(tx_reserved)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_ts_info>())).rx_filters as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_ts_info),
            "::",
            stringify!(rx_filters)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_ts_info>())).rx_reserved as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_ts_info),
            "::",
            stringify!(rx_reserved)
        )
    );
}
#[doc = " struct ethtool_fecparam - Ethernet forward error correction(fec) parameters"]
#[doc = " @cmd: Command number = %ETHTOOL_GFECPARAM or %ETHTOOL_SFECPARAM"]
#[doc = " @active_fec: FEC mode which is active on porte"]
#[doc = " @fec: Bitmask of supported/configured FEC modes"]
#[doc = " @rsvd: Reserved for future extensions. i.e FEC bypass feature."]
#[doc = ""]
#[doc = " Drivers should reject a non-zero setting of @autoneg when"]
#[doc = " autoneogotiation is disabled (or not supported) for the link."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ethtool_fecparam {
    pub cmd: __u32,
    pub active_fec: __u32,
    pub fec: __u32,
    pub reserved: __u32,
}
#[test]
fn bindgen_test_layout_ethtool_fecparam() {
    assert_eq!(
        ::core::mem::size_of::<ethtool_fecparam>(),
        16usize,
        concat!("Size of: ", stringify!(ethtool_fecparam))
    );
    assert_eq!(
        ::core::mem::align_of::<ethtool_fecparam>(),
        4usize,
        concat!("Alignment of ", stringify!(ethtool_fecparam))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_fecparam>())).cmd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_fecparam),
            "::",
            stringify!(cmd)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_fecparam>())).active_fec as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_fecparam),
            "::",
            stringify!(active_fec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_fecparam>())).fec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_fecparam),
            "::",
            stringify!(fec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_fecparam>())).reserved as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_fecparam),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " struct ethtool_link_settings - link control and status"]
#[doc = ""]
#[doc = " IMPORTANT, Backward compatibility notice: When implementing new"]
#[doc = "\tuser-space tools, please first try %ETHTOOL_GLINKSETTINGS, and"]
#[doc = "\tif it succeeds use %ETHTOOL_SLINKSETTINGS to change link"]
#[doc = "\tsettings; do not use %ETHTOOL_SSET if %ETHTOOL_GLINKSETTINGS"]
#[doc = "\tsucceeded: stick to %ETHTOOL_GLINKSETTINGS/%SLINKSETTINGS in"]
#[doc = "\tthat case.  Conversely, if %ETHTOOL_GLINKSETTINGS fails, use"]
#[doc = "\t%ETHTOOL_GSET to query and %ETHTOOL_SSET to change link"]
#[doc = "\tsettings; do not use %ETHTOOL_SLINKSETTINGS if"]
#[doc = "\t%ETHTOOL_GLINKSETTINGS failed: stick to"]
#[doc = "\t%ETHTOOL_GSET/%ETHTOOL_SSET in that case."]
#[doc = ""]
#[doc = " @cmd: Command number = %ETHTOOL_GLINKSETTINGS or %ETHTOOL_SLINKSETTINGS"]
#[doc = " @speed: Link speed (Mbps)"]
#[doc = " @duplex: Duplex mode; one of %DUPLEX_*"]
#[doc = " @port: Physical connector type; one of %PORT_*"]
#[doc = " @phy_address: MDIO address of PHY (transceiver); 0 or 255 if not"]
#[doc = "\tapplicable.  For clause 45 PHYs this is the PRTAD."]
#[doc = " @autoneg: Enable/disable autonegotiation and auto-detection;"]
#[doc = "\teither %AUTONEG_DISABLE or %AUTONEG_ENABLE"]
#[doc = " @mdio_support: Bitmask of %ETH_MDIO_SUPPORTS_* flags for the MDIO"]
#[doc = "\tprotocols supported by the interface; 0 if unknown."]
#[doc = "\tRead-only."]
#[doc = " @eth_tp_mdix: Ethernet twisted-pair MDI(-X) status; one of"]
#[doc = "\t%ETH_TP_MDI_*.  If the status is unknown or not applicable, the"]
#[doc = "\tvalue will be %ETH_TP_MDI_INVALID.  Read-only."]
#[doc = " @eth_tp_mdix_ctrl: Ethernet twisted pair MDI(-X) control; one of"]
#[doc = "\t%ETH_TP_MDI_*.  If MDI(-X) control is not implemented, reads"]
#[doc = "\tyield %ETH_TP_MDI_INVALID and writes may be ignored or rejected."]
#[doc = "\tWhen written successfully, the link should be renegotiated if"]
#[doc = "\tnecessary."]
#[doc = " @link_mode_masks_nwords: Number of 32-bit words for each of the"]
#[doc = "\tsupported, advertising, lp_advertising link mode bitmaps. For"]
#[doc = "\t%ETHTOOL_GLINKSETTINGS: on entry, number of words passed by user"]
#[doc = "\t(>= 0); on return, if handshake in progress, negative if"]
#[doc = "\trequest size unsupported by kernel: absolute value indicates"]
#[doc = "\tkernel expected size and all the other fields but cmd"]
#[doc = "\tare 0; otherwise (handshake completed), strictly positive"]
#[doc = "\tto indicate size used by kernel and cmd field stays"]
#[doc = "\t%ETHTOOL_GLINKSETTINGS, all other fields populated by driver. For"]
#[doc = "\t%ETHTOOL_SLINKSETTINGS: must be valid on entry, ie. a positive"]
#[doc = "\tvalue returned previously by %ETHTOOL_GLINKSETTINGS, otherwise"]
#[doc = "\trefused. For drivers: ignore this field (use kernel's"]
#[doc = "\t__ETHTOOL_LINK_MODE_MASK_NBITS instead), any change to it will"]
#[doc = "\tbe overwritten by kernel."]
#[doc = " @supported: Bitmap with each bit meaning given by"]
#[doc = "\t%ethtool_link_mode_bit_indices for the link modes, physical"]
#[doc = "\tconnectors and other link features for which the interface"]
#[doc = "\tsupports autonegotiation or auto-detection.  Read-only."]
#[doc = " @advertising: Bitmap with each bit meaning given by"]
#[doc = "\t%ethtool_link_mode_bit_indices for the link modes, physical"]
#[doc = "\tconnectors and other link features that are advertised through"]
#[doc = "\tautonegotiation or enabled for auto-detection."]
#[doc = " @lp_advertising: Bitmap with each bit meaning given by"]
#[doc = "\t%ethtool_link_mode_bit_indices for the link modes, and other"]
#[doc = "\tlink features that the link partner advertised through"]
#[doc = "\tautonegotiation; 0 if unknown or not applicable.  Read-only."]
#[doc = " @transceiver: Used to distinguish different possible PHY types,"]
#[doc = "\treported consistently by PHYLIB.  Read-only."]
#[doc = ""]
#[doc = " If autonegotiation is disabled, the speed and @duplex represent the"]
#[doc = " fixed link mode and are writable if the driver supports multiple"]
#[doc = " link modes.  If it is enabled then they are read-only; if the link"]
#[doc = " is up they represent the negotiated link mode; if the link is down,"]
#[doc = " the speed is 0, %SPEED_UNKNOWN or the highest enabled speed and"]
#[doc = " @duplex is %DUPLEX_UNKNOWN or the best enabled duplex mode."]
#[doc = ""]
#[doc = " Some hardware interfaces may have multiple PHYs and/or physical"]
#[doc = " connectors fitted or do not allow the driver to detect which are"]
#[doc = " fitted.  For these interfaces @port and/or @phy_address may be"]
#[doc = " writable, possibly dependent on @autoneg being %AUTONEG_DISABLE."]
#[doc = " Otherwise, attempts to write different values may be ignored or"]
#[doc = " rejected."]
#[doc = ""]
#[doc = " Deprecated %ethtool_cmd fields transceiver, maxtxpkt and maxrxpkt"]
#[doc = " are not available in %ethtool_link_settings. These fields will be"]
#[doc = " always set to zero in %ETHTOOL_GSET reply and %ETHTOOL_SSET will"]
#[doc = " fail if any of them is set to non-zero value."]
#[doc = ""]
#[doc = " Users should assume that all fields not marked read-only are"]
#[doc = " writable and subject to validation by the driver.  They should use"]
#[doc = " %ETHTOOL_GLINKSETTINGS to get the current values before making specific"]
#[doc = " changes and then applying them with %ETHTOOL_SLINKSETTINGS."]
#[doc = ""]
#[doc = " Drivers that implement %get_link_ksettings and/or"]
#[doc = " %set_link_ksettings should ignore the @cmd"]
#[doc = " and @link_mode_masks_nwords fields (any change to them overwritten"]
#[doc = " by kernel), and rely only on kernel's internal"]
#[doc = " %__ETHTOOL_LINK_MODE_MASK_NBITS and"]
#[doc = " %ethtool_link_mode_mask_t. Drivers that implement"]
#[doc = " %set_link_ksettings() should validate all fields other than @cmd"]
#[doc = " and @link_mode_masks_nwords that are not described as read-only or"]
#[doc = " deprecated, and must ignore all fields described as read-only."]
#[repr(C)]
#[derive(Debug, Default)]
pub struct ethtool_link_settings {
    pub cmd: __u32,
    pub speed: __u32,
    pub duplex: __u8,
    pub port: __u8,
    pub phy_address: __u8,
    pub autoneg: __u8,
    pub mdio_support: __u8,
    pub eth_tp_mdix: __u8,
    pub eth_tp_mdix_ctrl: __u8,
    pub link_mode_masks_nwords: __s8,
    pub transceiver: __u8,
    pub reserved1: [__u8; 3usize],
    pub reserved: [__u32; 7usize],
    pub link_mode_masks: __IncompleteArrayField<__u32>,
}
#[test]
fn bindgen_test_layout_ethtool_link_settings() {
    assert_eq!(
        ::core::mem::size_of::<ethtool_link_settings>(),
        48usize,
        concat!("Size of: ", stringify!(ethtool_link_settings))
    );
    assert_eq!(
        ::core::mem::align_of::<ethtool_link_settings>(),
        4usize,
        concat!("Alignment of ", stringify!(ethtool_link_settings))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_link_settings>())).cmd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_link_settings),
            "::",
            stringify!(cmd)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_link_settings>())).speed as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_link_settings),
            "::",
            stringify!(speed)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_link_settings>())).duplex as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_link_settings),
            "::",
            stringify!(duplex)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_link_settings>())).port as *const _ as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_link_settings),
            "::",
            stringify!(port)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ethtool_link_settings>())).phy_address as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_link_settings),
            "::",
            stringify!(phy_address)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_link_settings>())).autoneg as *const _ as usize },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_link_settings),
            "::",
            stringify!(autoneg)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ethtool_link_settings>())).mdio_support as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_link_settings),
            "::",
            stringify!(mdio_support)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ethtool_link_settings>())).eth_tp_mdix as *const _ as usize
        },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_link_settings),
            "::",
            stringify!(eth_tp_mdix)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ethtool_link_settings>())).eth_tp_mdix_ctrl as *const _ as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_link_settings),
            "::",
            stringify!(eth_tp_mdix_ctrl)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ethtool_link_settings>())).link_mode_masks_nwords as *const _
                as usize
        },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_link_settings),
            "::",
            stringify!(link_mode_masks_nwords)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ethtool_link_settings>())).transceiver as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_link_settings),
            "::",
            stringify!(transceiver)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ethtool_link_settings>())).reserved1 as *const _ as usize
        },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_link_settings),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_link_settings>())).reserved as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_link_settings),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ethtool_link_settings>())).link_mode_masks as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_link_settings),
            "::",
            stringify!(link_mode_masks)
        )
    );
}
pub const ethtool_phys_id_state_ETHTOOL_ID_INACTIVE: ethtool_phys_id_state = 0;
pub const ethtool_phys_id_state_ETHTOOL_ID_ACTIVE: ethtool_phys_id_state = 1;
pub const ethtool_phys_id_state_ETHTOOL_ID_ON: ethtool_phys_id_state = 2;
pub const ethtool_phys_id_state_ETHTOOL_ID_OFF: ethtool_phys_id_state = 3;
#[doc = " enum ethtool_phys_id_state - indicator state for physical identification"]
#[doc = " @ETHTOOL_ID_INACTIVE: Physical ID indicator should be deactivated"]
#[doc = " @ETHTOOL_ID_ACTIVE: Physical ID indicator should be activated"]
#[doc = " @ETHTOOL_ID_ON: LED should be turned on (used iff %ETHTOOL_ID_ACTIVE"]
#[doc = "\tis not supported)"]
#[doc = " @ETHTOOL_ID_OFF: LED should be turned off (used iff %ETHTOOL_ID_ACTIVE"]
#[doc = "\tis not supported)"]
pub type ethtool_phys_id_state = c_types::c_uint;
#[repr(C)]
#[derive(Debug, Default)]
pub struct ethtool_link_ksettings {
    pub base: ethtool_link_settings,
    pub link_modes: ethtool_link_ksettings__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ethtool_link_ksettings__bindgen_ty_1 {
    pub supported: [c_types::c_ulong; 2usize],
    pub advertising: [c_types::c_ulong; 2usize],
    pub lp_advertising: [c_types::c_ulong; 2usize],
}
#[test]
fn bindgen_test_layout_ethtool_link_ksettings__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<ethtool_link_ksettings__bindgen_ty_1>(),
        48usize,
        concat!(
            "Size of: ",
            stringify!(ethtool_link_ksettings__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<ethtool_link_ksettings__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(ethtool_link_ksettings__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ethtool_link_ksettings__bindgen_ty_1>())).supported as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_link_ksettings__bindgen_ty_1),
            "::",
            stringify!(supported)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ethtool_link_ksettings__bindgen_ty_1>())).advertising
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_link_ksettings__bindgen_ty_1),
            "::",
            stringify!(advertising)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ethtool_link_ksettings__bindgen_ty_1>())).lp_advertising
                as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_link_ksettings__bindgen_ty_1),
            "::",
            stringify!(lp_advertising)
        )
    );
}
#[test]
fn bindgen_test_layout_ethtool_link_ksettings() {
    assert_eq!(
        ::core::mem::size_of::<ethtool_link_ksettings>(),
        96usize,
        concat!("Size of: ", stringify!(ethtool_link_ksettings))
    );
    assert_eq!(
        ::core::mem::align_of::<ethtool_link_ksettings>(),
        8usize,
        concat!("Alignment of ", stringify!(ethtool_link_ksettings))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_link_ksettings>())).base as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_link_ksettings),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ethtool_link_ksettings>())).link_modes as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_link_ksettings),
            "::",
            stringify!(link_modes)
        )
    );
}
#[doc = " struct ethtool_ops - optional netdev operations"]
#[doc = " @get_drvinfo: Report driver/device information.  Should only set the"]
#[doc = "\t@driver, @version, @fw_version and @bus_info fields.  If not"]
#[doc = "\timplemented, the @driver and @bus_info fields will be filled in"]
#[doc = "\taccording to the netdev's parent device."]
#[doc = " @get_regs_len: Get buffer length required for @get_regs"]
#[doc = " @get_regs: Get device registers"]
#[doc = " @get_wol: Report whether Wake-on-Lan is enabled"]
#[doc = " @set_wol: Turn Wake-on-Lan on or off.  Returns a negative error code"]
#[doc = "\tor zero."]
#[doc = " @get_msglevel: Report driver message level.  This should be the value"]
#[doc = "\tof the @msg_enable field used by netif logging functions."]
#[doc = " @set_msglevel: Set driver message level"]
#[doc = " @nway_reset: Restart autonegotiation.  Returns a negative error code"]
#[doc = "\tor zero."]
#[doc = " @get_link: Report whether physical link is up.  Will only be called if"]
#[doc = "\tthe netdev is up.  Should usually be set to ethtool_op_get_link(),"]
#[doc = "\twhich uses netif_carrier_ok()."]
#[doc = " @get_eeprom: Read data from the device EEPROM."]
#[doc = "\tShould fill in the magic field.  Don't need to check len for zero"]
#[doc = "\tor wraparound.  Fill in the data argument with the eeprom values"]
#[doc = "\tfrom offset to offset + len.  Update len to the amount read."]
#[doc = "\tReturns an error or zero."]
#[doc = " @set_eeprom: Write data to the device EEPROM."]
#[doc = "\tShould validate the magic field.  Don't need to check len for zero"]
#[doc = "\tor wraparound.  Update len to the amount written.  Returns an error"]
#[doc = "\tor zero."]
#[doc = " @get_coalesce: Get interrupt coalescing parameters.  Returns a negative"]
#[doc = "\terror code or zero."]
#[doc = " @set_coalesce: Set interrupt coalescing parameters.  Returns a negative"]
#[doc = "\terror code or zero."]
#[doc = " @get_ringparam: Report ring sizes"]
#[doc = " @set_ringparam: Set ring sizes.  Returns a negative error code or zero."]
#[doc = " @get_pauseparam: Report pause parameters"]
#[doc = " @set_pauseparam: Set pause parameters.  Returns a negative error code"]
#[doc = "\tor zero."]
#[doc = " @self_test: Run specified self-tests"]
#[doc = " @get_strings: Return a set of strings that describe the requested objects"]
#[doc = " @set_phys_id: Identify the physical devices, e.g. by flashing an LED"]
#[doc = "\tattached to it.  The implementation may update the indicator"]
#[doc = "\tasynchronously or synchronously, but in either case it must return"]
#[doc = "\tquickly.  It is initially called with the argument %ETHTOOL_ID_ACTIVE,"]
#[doc = "\tand must either activate asynchronous updates and return zero, return"]
#[doc = "\ta negative error or return a positive frequency for synchronous"]
#[doc = "\tindication (e.g. 1 for one on/off cycle per second).  If it returns"]
#[doc = "\ta frequency then it will be called again at intervals with the"]
#[doc = "\targument %ETHTOOL_ID_ON or %ETHTOOL_ID_OFF and should set the state of"]
#[doc = "\tthe indicator accordingly.  Finally, it is called with the argument"]
#[doc = "\t%ETHTOOL_ID_INACTIVE and must deactivate the indicator.  Returns a"]
#[doc = "\tnegative error code or zero."]
#[doc = " @get_ethtool_stats: Return extended statistics about the device."]
#[doc = "\tThis is only useful if the device maintains statistics not"]
#[doc = "\tincluded in &struct rtnl_link_stats64."]
#[doc = " @begin: Function to be called before any other operation.  Returns a"]
#[doc = "\tnegative error code or zero."]
#[doc = " @complete: Function to be called after any other operation except"]
#[doc = "\t@begin.  Will be called even if the other operation failed."]
#[doc = " @get_priv_flags: Report driver-specific feature flags."]
#[doc = " @set_priv_flags: Set driver-specific feature flags.  Returns a negative"]
#[doc = "\terror code or zero."]
#[doc = " @get_sset_count: Get number of strings that @get_strings will write."]
#[doc = " @get_rxnfc: Get RX flow classification rules.  Returns a negative"]
#[doc = "\terror code or zero."]
#[doc = " @set_rxnfc: Set RX flow classification rules.  Returns a negative"]
#[doc = "\terror code or zero."]
#[doc = " @flash_device: Write a firmware image to device's flash memory."]
#[doc = "\tReturns a negative error code or zero."]
#[doc = " @reset: Reset (part of) the device, as specified by a bitmask of"]
#[doc = "\tflags from &enum ethtool_reset_flags.  Returns a negative"]
#[doc = "\terror code or zero."]
#[doc = " @get_rxfh_key_size: Get the size of the RX flow hash key."]
#[doc = "\tReturns zero if not supported for this specific device."]
#[doc = " @get_rxfh_indir_size: Get the size of the RX flow hash indirection table."]
#[doc = "\tReturns zero if not supported for this specific device."]
#[doc = " @get_rxfh: Get the contents of the RX flow hash indirection table, hash key"]
#[doc = "\tand/or hash function."]
#[doc = "\tReturns a negative error code or zero."]
#[doc = " @set_rxfh: Set the contents of the RX flow hash indirection table, hash"]
#[doc = "\tkey, and/or hash function.  Arguments which are set to %NULL or zero"]
#[doc = "\twill remain unchanged."]
#[doc = "\tReturns a negative error code or zero. An error code must be returned"]
#[doc = "\tif at least one unsupported change was requested."]
#[doc = " @get_rxfh_context: Get the contents of the RX flow hash indirection table,"]
#[doc = "\thash key, and/or hash function assiciated to the given rss context."]
#[doc = "\tReturns a negative error code or zero."]
#[doc = " @set_rxfh_context: Create, remove and configure RSS contexts. Allows setting"]
#[doc = "\tthe contents of the RX flow hash indirection table, hash key, and/or"]
#[doc = "\thash function associated to the given context. Arguments which are set"]
#[doc = "\tto %NULL or zero will remain unchanged."]
#[doc = "\tReturns a negative error code or zero. An error code must be returned"]
#[doc = "\tif at least one unsupported change was requested."]
#[doc = " @get_channels: Get number of channels."]
#[doc = " @set_channels: Set number of channels.  Returns a negative error code or"]
#[doc = "\tzero."]
#[doc = " @get_dump_flag: Get dump flag indicating current dump length, version,"]
#[doc = " \t\t   and flag of the device."]
#[doc = " @get_dump_data: Get dump data."]
#[doc = " @set_dump: Set dump specific flags to the device."]
#[doc = " @get_ts_info: Get the time stamping and PTP hardware clock capabilities."]
#[doc = "\tDrivers supporting transmit time stamps in software should set this to"]
#[doc = "\tethtool_op_get_ts_info()."]
#[doc = " @get_module_info: Get the size and type of the eeprom contained within"]
#[doc = "\ta plug-in module."]
#[doc = " @get_module_eeprom: Get the eeprom information from the plug-in module"]
#[doc = " @get_eee: Get Energy-Efficient (EEE) supported and status."]
#[doc = " @set_eee: Set EEE status (enable/disable) as well as LPI timers."]
#[doc = " @get_per_queue_coalesce: Get interrupt coalescing parameters per queue."]
#[doc = "\tIt must check that the given queue number is valid. If neither a RX nor"]
#[doc = "\ta TX queue has this number, return -EINVAL. If only a RX queue or a TX"]
#[doc = "\tqueue has this number, set the inapplicable fields to ~0 and return 0."]
#[doc = "\tReturns a negative error code or zero."]
#[doc = " @set_per_queue_coalesce: Set interrupt coalescing parameters per queue."]
#[doc = "\tIt must check that the given queue number is valid. If neither a RX nor"]
#[doc = "\ta TX queue has this number, return -EINVAL. If only a RX queue or a TX"]
#[doc = "\tqueue has this number, ignore the inapplicable fields."]
#[doc = "\tReturns a negative error code or zero."]
#[doc = " @get_link_ksettings: Get various device settings including Ethernet link"]
#[doc = "\tsettings. The %cmd and %link_mode_masks_nwords fields should be"]
#[doc = "\tignored (use %__ETHTOOL_LINK_MODE_MASK_NBITS instead of the latter),"]
#[doc = "\tany change to them will be overwritten by kernel. Returns a negative"]
#[doc = "\terror code or zero."]
#[doc = " @set_link_ksettings: Set various device settings including Ethernet link"]
#[doc = "\tsettings. The %cmd and %link_mode_masks_nwords fields should be"]
#[doc = "\tignored (use %__ETHTOOL_LINK_MODE_MASK_NBITS instead of the latter),"]
#[doc = "\tany change to them will be overwritten by kernel. Returns a negative"]
#[doc = "\terror code or zero."]
#[doc = " @get_fecparam: Get the network device Forward Error Correction parameters."]
#[doc = " @set_fecparam: Set the network device Forward Error Correction parameters."]
#[doc = " @get_ethtool_phy_stats: Return extended statistics about the PHY device."]
#[doc = "\tThis is only useful if the device maintains PHY statistics and"]
#[doc = "\tcannot use the standard PHY library helpers."]
#[doc = ""]
#[doc = " All operations are optional (i.e. the function pointer may be set"]
#[doc = " to %NULL) and callers must take this into account.  Callers must"]
#[doc = " hold the RTNL lock."]
#[doc = ""]
#[doc = " See the structures used by these operations for further documentation."]
#[doc = " Note that for all operations using a structure ending with a zero-"]
#[doc = " length array, the array is allocated separately in the kernel and"]
#[doc = " is passed to the driver as an additional parameter."]
#[doc = ""]
#[doc = " See &struct net_device and &struct net_device_ops for documentation"]
#[doc = " of the generic netdev features interface."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ethtool_ops {
    pub get_drvinfo: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut ethtool_drvinfo),
    >,
    pub get_regs_len:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut net_device) -> c_types::c_int>,
    pub get_regs: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut ethtool_regs,
            arg3: *mut c_types::c_void,
        ),
    >,
    pub get_wol: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut ethtool_wolinfo),
    >,
    pub set_wol: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut ethtool_wolinfo) -> c_types::c_int,
    >,
    pub get_msglevel: ::core::option::Option<unsafe extern "C" fn(arg1: *mut net_device) -> u32_>,
    pub set_msglevel:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut net_device, arg2: u32_)>,
    pub nway_reset:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut net_device) -> c_types::c_int>,
    pub get_link: ::core::option::Option<unsafe extern "C" fn(arg1: *mut net_device) -> u32_>,
    pub get_eeprom_len:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut net_device) -> c_types::c_int>,
    pub get_eeprom: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut ethtool_eeprom,
            arg3: *mut u8_,
        ) -> c_types::c_int,
    >,
    pub set_eeprom: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut ethtool_eeprom,
            arg3: *mut u8_,
        ) -> c_types::c_int,
    >,
    pub get_coalesce: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut ethtool_coalesce) -> c_types::c_int,
    >,
    pub set_coalesce: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut ethtool_coalesce) -> c_types::c_int,
    >,
    pub get_ringparam: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut ethtool_ringparam),
    >,
    pub set_ringparam: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut ethtool_ringparam) -> c_types::c_int,
    >,
    pub get_pauseparam: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut ethtool_pauseparam),
    >,
    pub set_pauseparam: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut ethtool_pauseparam,
        ) -> c_types::c_int,
    >,
    pub self_test: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut ethtool_test, arg3: *mut u64_),
    >,
    pub get_strings: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, stringset: u32_, arg2: *mut u8_),
    >,
    pub set_phys_id: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: ethtool_phys_id_state) -> c_types::c_int,
    >,
    pub get_ethtool_stats: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut ethtool_stats, arg3: *mut u64_),
    >,
    pub begin:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut net_device) -> c_types::c_int>,
    pub complete: ::core::option::Option<unsafe extern "C" fn(arg1: *mut net_device)>,
    pub get_priv_flags: ::core::option::Option<unsafe extern "C" fn(arg1: *mut net_device) -> u32_>,
    pub set_priv_flags: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: u32_) -> c_types::c_int,
    >,
    pub get_sset_count: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: c_types::c_int) -> c_types::c_int,
    >,
    pub get_rxnfc: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut ethtool_rxnfc,
            rule_locs: *mut u32_,
        ) -> c_types::c_int,
    >,
    pub set_rxnfc: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut ethtool_rxnfc) -> c_types::c_int,
    >,
    pub flash_device: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut ethtool_flash) -> c_types::c_int,
    >,
    pub reset: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut u32_) -> c_types::c_int,
    >,
    pub get_rxfh_key_size:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut net_device) -> u32_>,
    pub get_rxfh_indir_size:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut net_device) -> u32_>,
    pub get_rxfh: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            indir: *mut u32_,
            key: *mut u8_,
            hfunc: *mut u8_,
        ) -> c_types::c_int,
    >,
    pub set_rxfh: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            indir: *const u32_,
            key: *const u8_,
            hfunc: u8_,
        ) -> c_types::c_int,
    >,
    pub get_rxfh_context: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            indir: *mut u32_,
            key: *mut u8_,
            hfunc: *mut u8_,
            rss_context: u32_,
        ) -> c_types::c_int,
    >,
    pub set_rxfh_context: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            indir: *const u32_,
            key: *const u8_,
            hfunc: u8_,
            rss_context: *mut u32_,
            delete: bool_,
        ) -> c_types::c_int,
    >,
    pub get_channels: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut ethtool_channels),
    >,
    pub set_channels: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut ethtool_channels) -> c_types::c_int,
    >,
    pub get_dump_flag: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut ethtool_dump) -> c_types::c_int,
    >,
    pub get_dump_data: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut ethtool_dump,
            arg3: *mut c_types::c_void,
        ) -> c_types::c_int,
    >,
    pub set_dump: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut ethtool_dump) -> c_types::c_int,
    >,
    pub get_ts_info: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut ethtool_ts_info) -> c_types::c_int,
    >,
    pub get_module_info: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut ethtool_modinfo) -> c_types::c_int,
    >,
    pub get_module_eeprom: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut ethtool_eeprom,
            arg3: *mut u8_,
        ) -> c_types::c_int,
    >,
    pub get_eee: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut ethtool_eee) -> c_types::c_int,
    >,
    pub set_eee: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut ethtool_eee) -> c_types::c_int,
    >,
    pub get_tunable: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *const ethtool_tunable,
            arg3: *mut c_types::c_void,
        ) -> c_types::c_int,
    >,
    pub set_tunable: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *const ethtool_tunable,
            arg3: *const c_types::c_void,
        ) -> c_types::c_int,
    >,
    pub get_per_queue_coalesce: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: u32_,
            arg3: *mut ethtool_coalesce,
        ) -> c_types::c_int,
    >,
    pub set_per_queue_coalesce: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: u32_,
            arg3: *mut ethtool_coalesce,
        ) -> c_types::c_int,
    >,
    pub get_link_ksettings: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut ethtool_link_ksettings,
        ) -> c_types::c_int,
    >,
    pub set_link_ksettings: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *const ethtool_link_ksettings,
        ) -> c_types::c_int,
    >,
    pub get_fecparam: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut ethtool_fecparam) -> c_types::c_int,
    >,
    pub set_fecparam: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut ethtool_fecparam) -> c_types::c_int,
    >,
    pub get_ethtool_phy_stats: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut ethtool_stats, arg3: *mut u64_),
    >,
}
#[test]
fn bindgen_test_layout_ethtool_ops() {
    assert_eq!(
        ::core::mem::size_of::<ethtool_ops>(),
        448usize,
        concat!("Size of: ", stringify!(ethtool_ops))
    );
    assert_eq!(
        ::core::mem::align_of::<ethtool_ops>(),
        8usize,
        concat!("Alignment of ", stringify!(ethtool_ops))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_ops>())).get_drvinfo as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_ops),
            "::",
            stringify!(get_drvinfo)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_ops>())).get_regs_len as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_ops),
            "::",
            stringify!(get_regs_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_ops>())).get_regs as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_ops),
            "::",
            stringify!(get_regs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_ops>())).get_wol as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_ops),
            "::",
            stringify!(get_wol)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_ops>())).set_wol as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_ops),
            "::",
            stringify!(set_wol)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_ops>())).get_msglevel as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_ops),
            "::",
            stringify!(get_msglevel)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_ops>())).set_msglevel as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_ops),
            "::",
            stringify!(set_msglevel)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_ops>())).nway_reset as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_ops),
            "::",
            stringify!(nway_reset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_ops>())).get_link as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_ops),
            "::",
            stringify!(get_link)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_ops>())).get_eeprom_len as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_ops),
            "::",
            stringify!(get_eeprom_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_ops>())).get_eeprom as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_ops),
            "::",
            stringify!(get_eeprom)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_ops>())).set_eeprom as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_ops),
            "::",
            stringify!(set_eeprom)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_ops>())).get_coalesce as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_ops),
            "::",
            stringify!(get_coalesce)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_ops>())).set_coalesce as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_ops),
            "::",
            stringify!(set_coalesce)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_ops>())).get_ringparam as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_ops),
            "::",
            stringify!(get_ringparam)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_ops>())).set_ringparam as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_ops),
            "::",
            stringify!(set_ringparam)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_ops>())).get_pauseparam as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_ops),
            "::",
            stringify!(get_pauseparam)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_ops>())).set_pauseparam as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_ops),
            "::",
            stringify!(set_pauseparam)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_ops>())).self_test as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_ops),
            "::",
            stringify!(self_test)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_ops>())).get_strings as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_ops),
            "::",
            stringify!(get_strings)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_ops>())).set_phys_id as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_ops),
            "::",
            stringify!(set_phys_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_ops>())).get_ethtool_stats as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_ops),
            "::",
            stringify!(get_ethtool_stats)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_ops>())).begin as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_ops),
            "::",
            stringify!(begin)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_ops>())).complete as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_ops),
            "::",
            stringify!(complete)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_ops>())).get_priv_flags as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_ops),
            "::",
            stringify!(get_priv_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_ops>())).set_priv_flags as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_ops),
            "::",
            stringify!(set_priv_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_ops>())).get_sset_count as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_ops),
            "::",
            stringify!(get_sset_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_ops>())).get_rxnfc as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_ops),
            "::",
            stringify!(get_rxnfc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_ops>())).set_rxnfc as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_ops),
            "::",
            stringify!(set_rxnfc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_ops>())).flash_device as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_ops),
            "::",
            stringify!(flash_device)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_ops>())).reset as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_ops),
            "::",
            stringify!(reset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_ops>())).get_rxfh_key_size as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_ops),
            "::",
            stringify!(get_rxfh_key_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ethtool_ops>())).get_rxfh_indir_size as *const _ as usize
        },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_ops),
            "::",
            stringify!(get_rxfh_indir_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_ops>())).get_rxfh as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_ops),
            "::",
            stringify!(get_rxfh)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_ops>())).set_rxfh as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_ops),
            "::",
            stringify!(set_rxfh)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_ops>())).get_rxfh_context as *const _ as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_ops),
            "::",
            stringify!(get_rxfh_context)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_ops>())).set_rxfh_context as *const _ as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_ops),
            "::",
            stringify!(set_rxfh_context)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_ops>())).get_channels as *const _ as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_ops),
            "::",
            stringify!(get_channels)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_ops>())).set_channels as *const _ as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_ops),
            "::",
            stringify!(set_channels)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_ops>())).get_dump_flag as *const _ as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_ops),
            "::",
            stringify!(get_dump_flag)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_ops>())).get_dump_data as *const _ as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_ops),
            "::",
            stringify!(get_dump_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_ops>())).set_dump as *const _ as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_ops),
            "::",
            stringify!(set_dump)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_ops>())).get_ts_info as *const _ as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_ops),
            "::",
            stringify!(get_ts_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_ops>())).get_module_info as *const _ as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_ops),
            "::",
            stringify!(get_module_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_ops>())).get_module_eeprom as *const _ as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_ops),
            "::",
            stringify!(get_module_eeprom)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_ops>())).get_eee as *const _ as usize },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_ops),
            "::",
            stringify!(get_eee)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_ops>())).set_eee as *const _ as usize },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_ops),
            "::",
            stringify!(set_eee)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_ops>())).get_tunable as *const _ as usize },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_ops),
            "::",
            stringify!(get_tunable)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_ops>())).set_tunable as *const _ as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_ops),
            "::",
            stringify!(set_tunable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ethtool_ops>())).get_per_queue_coalesce as *const _ as usize
        },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_ops),
            "::",
            stringify!(get_per_queue_coalesce)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ethtool_ops>())).set_per_queue_coalesce as *const _ as usize
        },
        400usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_ops),
            "::",
            stringify!(set_per_queue_coalesce)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_ops>())).get_link_ksettings as *const _ as usize },
        408usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_ops),
            "::",
            stringify!(get_link_ksettings)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_ops>())).set_link_ksettings as *const _ as usize },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_ops),
            "::",
            stringify!(set_link_ksettings)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_ops>())).get_fecparam as *const _ as usize },
        424usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_ops),
            "::",
            stringify!(get_fecparam)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ethtool_ops>())).set_fecparam as *const _ as usize },
        432usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_ops),
            "::",
            stringify!(set_fecparam)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ethtool_ops>())).get_ethtool_phy_stats as *const _ as usize
        },
        440usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_ops),
            "::",
            stringify!(get_ethtool_phy_stats)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct prot_inuse {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct netns_core {
    pub sysctl_hdr: *mut ctl_table_header,
    pub sysctl_somaxconn: c_types::c_int,
    pub sock_inuse: *mut c_types::c_int,
    pub prot_inuse: *mut prot_inuse,
}
#[test]
fn bindgen_test_layout_netns_core() {
    assert_eq!(
        ::core::mem::size_of::<netns_core>(),
        32usize,
        concat!("Size of: ", stringify!(netns_core))
    );
    assert_eq!(
        ::core::mem::align_of::<netns_core>(),
        8usize,
        concat!("Alignment of ", stringify!(netns_core))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_core>())).sysctl_hdr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_core),
            "::",
            stringify!(sysctl_hdr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_core>())).sysctl_somaxconn as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_core),
            "::",
            stringify!(sysctl_somaxconn)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_core>())).sock_inuse as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_core),
            "::",
            stringify!(sock_inuse)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_core>())).prot_inuse as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_core),
            "::",
            stringify!(prot_inuse)
        )
    );
}
impl Default for netns_core {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct u64_stats_sync {}
#[test]
fn bindgen_test_layout_u64_stats_sync() {
    assert_eq!(
        ::core::mem::size_of::<u64_stats_sync>(),
        0usize,
        concat!("Size of: ", stringify!(u64_stats_sync))
    );
    assert_eq!(
        ::core::mem::align_of::<u64_stats_sync>(),
        1usize,
        concat!("Alignment of ", stringify!(u64_stats_sync))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ipstats_mib {
    pub mibs: [u64_; 37usize],
    pub syncp: u64_stats_sync,
}
#[test]
fn bindgen_test_layout_ipstats_mib() {
    assert_eq!(
        ::core::mem::size_of::<ipstats_mib>(),
        296usize,
        concat!("Size of: ", stringify!(ipstats_mib))
    );
    assert_eq!(
        ::core::mem::align_of::<ipstats_mib>(),
        8usize,
        concat!("Alignment of ", stringify!(ipstats_mib))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ipstats_mib>())).mibs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ipstats_mib),
            "::",
            stringify!(mibs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ipstats_mib>())).syncp as *const _ as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(ipstats_mib),
            "::",
            stringify!(syncp)
        )
    );
}
impl Default for ipstats_mib {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct icmp_mib {
    pub mibs: [c_types::c_ulong; 28usize],
}
#[test]
fn bindgen_test_layout_icmp_mib() {
    assert_eq!(
        ::core::mem::size_of::<icmp_mib>(),
        224usize,
        concat!("Size of: ", stringify!(icmp_mib))
    );
    assert_eq!(
        ::core::mem::align_of::<icmp_mib>(),
        8usize,
        concat!("Alignment of ", stringify!(icmp_mib))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<icmp_mib>())).mibs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(icmp_mib),
            "::",
            stringify!(mibs)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct icmpmsg_mib {
    pub mibs: [atomic_long_t; 512usize],
}
#[test]
fn bindgen_test_layout_icmpmsg_mib() {
    assert_eq!(
        ::core::mem::size_of::<icmpmsg_mib>(),
        4096usize,
        concat!("Size of: ", stringify!(icmpmsg_mib))
    );
    assert_eq!(
        ::core::mem::align_of::<icmpmsg_mib>(),
        8usize,
        concat!("Alignment of ", stringify!(icmpmsg_mib))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<icmpmsg_mib>())).mibs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(icmpmsg_mib),
            "::",
            stringify!(mibs)
        )
    );
}
impl Default for icmpmsg_mib {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct icmpv6_mib {
    pub mibs: [c_types::c_ulong; 6usize],
}
#[test]
fn bindgen_test_layout_icmpv6_mib() {
    assert_eq!(
        ::core::mem::size_of::<icmpv6_mib>(),
        48usize,
        concat!("Size of: ", stringify!(icmpv6_mib))
    );
    assert_eq!(
        ::core::mem::align_of::<icmpv6_mib>(),
        8usize,
        concat!("Alignment of ", stringify!(icmpv6_mib))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<icmpv6_mib>())).mibs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(icmpv6_mib),
            "::",
            stringify!(mibs)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct icmpv6msg_mib {
    pub mibs: [atomic_long_t; 512usize],
}
#[test]
fn bindgen_test_layout_icmpv6msg_mib() {
    assert_eq!(
        ::core::mem::size_of::<icmpv6msg_mib>(),
        4096usize,
        concat!("Size of: ", stringify!(icmpv6msg_mib))
    );
    assert_eq!(
        ::core::mem::align_of::<icmpv6msg_mib>(),
        8usize,
        concat!("Alignment of ", stringify!(icmpv6msg_mib))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<icmpv6msg_mib>())).mibs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(icmpv6msg_mib),
            "::",
            stringify!(mibs)
        )
    );
}
impl Default for icmpv6msg_mib {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct tcp_mib {
    pub mibs: [c_types::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout_tcp_mib() {
    assert_eq!(
        ::core::mem::size_of::<tcp_mib>(),
        128usize,
        concat!("Size of: ", stringify!(tcp_mib))
    );
    assert_eq!(
        ::core::mem::align_of::<tcp_mib>(),
        8usize,
        concat!("Alignment of ", stringify!(tcp_mib))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tcp_mib>())).mibs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_mib),
            "::",
            stringify!(mibs)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct udp_mib {
    pub mibs: [c_types::c_ulong; 9usize],
}
#[test]
fn bindgen_test_layout_udp_mib() {
    assert_eq!(
        ::core::mem::size_of::<udp_mib>(),
        72usize,
        concat!("Size of: ", stringify!(udp_mib))
    );
    assert_eq!(
        ::core::mem::align_of::<udp_mib>(),
        8usize,
        concat!("Alignment of ", stringify!(udp_mib))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<udp_mib>())).mibs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(udp_mib),
            "::",
            stringify!(mibs)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct linux_mib {
    pub mibs: [c_types::c_ulong; 120usize],
}
#[test]
fn bindgen_test_layout_linux_mib() {
    assert_eq!(
        ::core::mem::size_of::<linux_mib>(),
        960usize,
        concat!("Size of: ", stringify!(linux_mib))
    );
    assert_eq!(
        ::core::mem::align_of::<linux_mib>(),
        8usize,
        concat!("Alignment of ", stringify!(linux_mib))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<linux_mib>())).mibs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(linux_mib),
            "::",
            stringify!(mibs)
        )
    );
}
impl Default for linux_mib {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct linux_xfrm_mib {
    pub mibs: [c_types::c_ulong; 29usize],
}
#[test]
fn bindgen_test_layout_linux_xfrm_mib() {
    assert_eq!(
        ::core::mem::size_of::<linux_xfrm_mib>(),
        232usize,
        concat!("Size of: ", stringify!(linux_xfrm_mib))
    );
    assert_eq!(
        ::core::mem::align_of::<linux_xfrm_mib>(),
        8usize,
        concat!("Alignment of ", stringify!(linux_xfrm_mib))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<linux_xfrm_mib>())).mibs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(linux_xfrm_mib),
            "::",
            stringify!(mibs)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct netns_mib {
    pub tcp_statistics: *mut tcp_mib,
    pub ip_statistics: *mut ipstats_mib,
    pub net_statistics: *mut linux_mib,
    pub udp_statistics: *mut udp_mib,
    pub udplite_statistics: *mut udp_mib,
    pub icmp_statistics: *mut icmp_mib,
    pub icmpmsg_statistics: *mut icmpmsg_mib,
    pub proc_net_devsnmp6: *mut proc_dir_entry,
    pub udp_stats_in6: *mut udp_mib,
    pub udplite_stats_in6: *mut udp_mib,
    pub ipv6_statistics: *mut ipstats_mib,
    pub icmpv6_statistics: *mut icmpv6_mib,
    pub icmpv6msg_statistics: *mut icmpv6msg_mib,
    pub xfrm_statistics: *mut linux_xfrm_mib,
}
#[test]
fn bindgen_test_layout_netns_mib() {
    assert_eq!(
        ::core::mem::size_of::<netns_mib>(),
        112usize,
        concat!("Size of: ", stringify!(netns_mib))
    );
    assert_eq!(
        ::core::mem::align_of::<netns_mib>(),
        8usize,
        concat!("Alignment of ", stringify!(netns_mib))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_mib>())).tcp_statistics as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_mib),
            "::",
            stringify!(tcp_statistics)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_mib>())).ip_statistics as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_mib),
            "::",
            stringify!(ip_statistics)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_mib>())).net_statistics as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_mib),
            "::",
            stringify!(net_statistics)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_mib>())).udp_statistics as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_mib),
            "::",
            stringify!(udp_statistics)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_mib>())).udplite_statistics as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_mib),
            "::",
            stringify!(udplite_statistics)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_mib>())).icmp_statistics as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_mib),
            "::",
            stringify!(icmp_statistics)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_mib>())).icmpmsg_statistics as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_mib),
            "::",
            stringify!(icmpmsg_statistics)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_mib>())).proc_net_devsnmp6 as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_mib),
            "::",
            stringify!(proc_net_devsnmp6)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_mib>())).udp_stats_in6 as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_mib),
            "::",
            stringify!(udp_stats_in6)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_mib>())).udplite_stats_in6 as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_mib),
            "::",
            stringify!(udplite_stats_in6)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_mib>())).ipv6_statistics as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_mib),
            "::",
            stringify!(ipv6_statistics)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_mib>())).icmpv6_statistics as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_mib),
            "::",
            stringify!(icmpv6_statistics)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_mib>())).icmpv6msg_statistics as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_mib),
            "::",
            stringify!(icmpv6msg_statistics)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_mib>())).xfrm_statistics as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_mib),
            "::",
            stringify!(xfrm_statistics)
        )
    );
}
impl Default for netns_mib {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct netns_unix {
    pub sysctl_max_dgram_qlen: c_types::c_int,
    pub ctl: *mut ctl_table_header,
}
#[test]
fn bindgen_test_layout_netns_unix() {
    assert_eq!(
        ::core::mem::size_of::<netns_unix>(),
        16usize,
        concat!("Size of: ", stringify!(netns_unix))
    );
    assert_eq!(
        ::core::mem::align_of::<netns_unix>(),
        8usize,
        concat!("Alignment of ", stringify!(netns_unix))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<netns_unix>())).sysctl_max_dgram_qlen as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_unix),
            "::",
            stringify!(sysctl_max_dgram_qlen)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_unix>())).ctl as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_unix),
            "::",
            stringify!(ctl)
        )
    );
}
impl Default for netns_unix {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct netns_packet {
    pub sklist_lock: mutex,
    pub sklist: hlist_head,
}
#[test]
fn bindgen_test_layout_netns_packet() {
    assert_eq!(
        ::core::mem::size_of::<netns_packet>(),
        40usize,
        concat!("Size of: ", stringify!(netns_packet))
    );
    assert_eq!(
        ::core::mem::align_of::<netns_packet>(),
        8usize,
        concat!("Alignment of ", stringify!(netns_packet))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_packet>())).sklist_lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_packet),
            "::",
            stringify!(sklist_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_packet>())).sklist as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_packet),
            "::",
            stringify!(sklist)
        )
    );
}
impl Default for netns_packet {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct fqdir {
    pub high_thresh: c_types::c_long,
    pub low_thresh: c_types::c_long,
    pub timeout: c_types::c_int,
    pub max_dist: c_types::c_int,
    pub f: *mut inet_frags,
    pub net: *mut net,
    pub dead: bool_,
    pub __bindgen_padding_0: [u64; 2usize],
    pub rhashtable: rhashtable,
    pub __bindgen_padding_1: [u64; 7usize],
    pub mem: atomic_long_t,
    pub destroy_work: work_struct,
}
#[test]
fn bindgen_test_layout_fqdir() {
    assert_eq!(
        ::core::mem::size_of::<fqdir>(),
        320usize,
        concat!("Size of: ", stringify!(fqdir))
    );
    assert_eq!(
        ::core::mem::align_of::<fqdir>(),
        64usize,
        concat!("Alignment of ", stringify!(fqdir))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fqdir>())).high_thresh as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fqdir),
            "::",
            stringify!(high_thresh)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fqdir>())).low_thresh as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(fqdir),
            "::",
            stringify!(low_thresh)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fqdir>())).timeout as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(fqdir),
            "::",
            stringify!(timeout)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fqdir>())).max_dist as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(fqdir),
            "::",
            stringify!(max_dist)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fqdir>())).f as *const _ as usize },
        24usize,
        concat!("Offset of field: ", stringify!(fqdir), "::", stringify!(f))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fqdir>())).net as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(fqdir),
            "::",
            stringify!(net)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fqdir>())).dead as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(fqdir),
            "::",
            stringify!(dead)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fqdir>())).rhashtable as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(fqdir),
            "::",
            stringify!(rhashtable)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fqdir>())).mem as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(fqdir),
            "::",
            stringify!(mem)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fqdir>())).destroy_work as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(fqdir),
            "::",
            stringify!(destroy_work)
        )
    );
}
impl Default for fqdir {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct frag_v4_compare_key {
    pub saddr: __be32,
    pub daddr: __be32,
    pub user: u32_,
    pub vif: u32_,
    pub id: __be16,
    pub protocol: u16_,
}
#[test]
fn bindgen_test_layout_frag_v4_compare_key() {
    assert_eq!(
        ::core::mem::size_of::<frag_v4_compare_key>(),
        20usize,
        concat!("Size of: ", stringify!(frag_v4_compare_key))
    );
    assert_eq!(
        ::core::mem::align_of::<frag_v4_compare_key>(),
        4usize,
        concat!("Alignment of ", stringify!(frag_v4_compare_key))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<frag_v4_compare_key>())).saddr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(frag_v4_compare_key),
            "::",
            stringify!(saddr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<frag_v4_compare_key>())).daddr as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(frag_v4_compare_key),
            "::",
            stringify!(daddr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<frag_v4_compare_key>())).user as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(frag_v4_compare_key),
            "::",
            stringify!(user)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<frag_v4_compare_key>())).vif as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(frag_v4_compare_key),
            "::",
            stringify!(vif)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<frag_v4_compare_key>())).id as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(frag_v4_compare_key),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<frag_v4_compare_key>())).protocol as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(frag_v4_compare_key),
            "::",
            stringify!(protocol)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct frag_v6_compare_key {
    pub saddr: in6_addr,
    pub daddr: in6_addr,
    pub user: u32_,
    pub id: __be32,
    pub iif: u32_,
}
#[test]
fn bindgen_test_layout_frag_v6_compare_key() {
    assert_eq!(
        ::core::mem::size_of::<frag_v6_compare_key>(),
        44usize,
        concat!("Size of: ", stringify!(frag_v6_compare_key))
    );
    assert_eq!(
        ::core::mem::align_of::<frag_v6_compare_key>(),
        4usize,
        concat!("Alignment of ", stringify!(frag_v6_compare_key))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<frag_v6_compare_key>())).saddr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(frag_v6_compare_key),
            "::",
            stringify!(saddr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<frag_v6_compare_key>())).daddr as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(frag_v6_compare_key),
            "::",
            stringify!(daddr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<frag_v6_compare_key>())).user as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(frag_v6_compare_key),
            "::",
            stringify!(user)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<frag_v6_compare_key>())).id as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(frag_v6_compare_key),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<frag_v6_compare_key>())).iif as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(frag_v6_compare_key),
            "::",
            stringify!(iif)
        )
    );
}
impl Default for frag_v6_compare_key {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[doc = " struct inet_frag_queue - fragment queue"]
#[doc = ""]
#[doc = " @node: rhash node"]
#[doc = " @key: keys identifying this frag."]
#[doc = " @timer: queue expiration timer"]
#[doc = " @lock: spinlock protecting this frag"]
#[doc = " @refcnt: reference count of the queue"]
#[doc = " @rb_fragments: received fragments rb-tree root"]
#[doc = " @fragments_tail: received fragments tail"]
#[doc = " @last_run_head: the head of the last \"run\". see ip_fragment.c"]
#[doc = " @stamp: timestamp of the last received fragment"]
#[doc = " @len: total length of the original datagram"]
#[doc = " @meat: length of received fragments so far"]
#[doc = " @flags: fragment queue flags"]
#[doc = " @max_size: maximum received fragment size"]
#[doc = " @fqdir: pointer to struct fqdir"]
#[doc = " @rcu: rcu head for freeing deferall"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct inet_frag_queue {
    pub node: rhash_head,
    pub key: inet_frag_queue__bindgen_ty_1,
    pub timer: timer_list,
    pub lock: spinlock_t,
    pub refcnt: refcount_t,
    pub rb_fragments: rb_root,
    pub fragments_tail: *mut sk_buff,
    pub last_run_head: *mut sk_buff,
    pub stamp: ktime_t,
    pub len: c_types::c_int,
    pub meat: c_types::c_int,
    pub flags: __u8,
    pub max_size: u16_,
    pub fqdir: *mut fqdir,
    pub rcu: callback_head,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union inet_frag_queue__bindgen_ty_1 {
    pub v4: frag_v4_compare_key,
    pub v6: frag_v6_compare_key,
    _bindgen_union_align: [u32; 11usize],
}
#[test]
fn bindgen_test_layout_inet_frag_queue__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<inet_frag_queue__bindgen_ty_1>(),
        44usize,
        concat!("Size of: ", stringify!(inet_frag_queue__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<inet_frag_queue__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(inet_frag_queue__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<inet_frag_queue__bindgen_ty_1>())).v4 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(inet_frag_queue__bindgen_ty_1),
            "::",
            stringify!(v4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<inet_frag_queue__bindgen_ty_1>())).v6 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(inet_frag_queue__bindgen_ty_1),
            "::",
            stringify!(v6)
        )
    );
}
impl Default for inet_frag_queue__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_inet_frag_queue() {
    assert_eq!(
        ::core::mem::size_of::<inet_frag_queue>(),
        176usize,
        concat!("Size of: ", stringify!(inet_frag_queue))
    );
    assert_eq!(
        ::core::mem::align_of::<inet_frag_queue>(),
        8usize,
        concat!("Alignment of ", stringify!(inet_frag_queue))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inet_frag_queue>())).node as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(inet_frag_queue),
            "::",
            stringify!(node)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inet_frag_queue>())).key as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(inet_frag_queue),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inet_frag_queue>())).timer as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(inet_frag_queue),
            "::",
            stringify!(timer)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inet_frag_queue>())).lock as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(inet_frag_queue),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inet_frag_queue>())).refcnt as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(inet_frag_queue),
            "::",
            stringify!(refcnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inet_frag_queue>())).rb_fragments as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(inet_frag_queue),
            "::",
            stringify!(rb_fragments)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inet_frag_queue>())).fragments_tail as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(inet_frag_queue),
            "::",
            stringify!(fragments_tail)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inet_frag_queue>())).last_run_head as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(inet_frag_queue),
            "::",
            stringify!(last_run_head)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inet_frag_queue>())).stamp as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(inet_frag_queue),
            "::",
            stringify!(stamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inet_frag_queue>())).len as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(inet_frag_queue),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inet_frag_queue>())).meat as *const _ as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(inet_frag_queue),
            "::",
            stringify!(meat)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inet_frag_queue>())).flags as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(inet_frag_queue),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inet_frag_queue>())).max_size as *const _ as usize },
        146usize,
        concat!(
            "Offset of field: ",
            stringify!(inet_frag_queue),
            "::",
            stringify!(max_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inet_frag_queue>())).fqdir as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(inet_frag_queue),
            "::",
            stringify!(fqdir)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inet_frag_queue>())).rcu as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(inet_frag_queue),
            "::",
            stringify!(rcu)
        )
    );
}
impl Default for inet_frag_queue {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct inet_frags {
    pub qsize: c_types::c_uint,
    pub constructor: ::core::option::Option<
        unsafe extern "C" fn(q: *mut inet_frag_queue, arg: *const c_types::c_void),
    >,
    pub destructor: ::core::option::Option<unsafe extern "C" fn(arg1: *mut inet_frag_queue)>,
    pub frag_expire: ::core::option::Option<unsafe extern "C" fn(t: *mut timer_list)>,
    pub frags_cachep: *mut kmem_cache,
    pub frags_cache_name: *const c_types::c_char,
    pub rhash_params: rhashtable_params,
    pub refcnt: refcount_t,
    pub completion: completion,
}
#[test]
fn bindgen_test_layout_inet_frags() {
    assert_eq!(
        ::core::mem::size_of::<inet_frags>(),
        128usize,
        concat!("Size of: ", stringify!(inet_frags))
    );
    assert_eq!(
        ::core::mem::align_of::<inet_frags>(),
        8usize,
        concat!("Alignment of ", stringify!(inet_frags))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inet_frags>())).qsize as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(inet_frags),
            "::",
            stringify!(qsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inet_frags>())).constructor as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(inet_frags),
            "::",
            stringify!(constructor)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inet_frags>())).destructor as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(inet_frags),
            "::",
            stringify!(destructor)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inet_frags>())).frag_expire as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(inet_frags),
            "::",
            stringify!(frag_expire)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inet_frags>())).frags_cachep as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(inet_frags),
            "::",
            stringify!(frags_cachep)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inet_frags>())).frags_cache_name as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(inet_frags),
            "::",
            stringify!(frags_cache_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inet_frags>())).rhash_params as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(inet_frags),
            "::",
            stringify!(rhash_params)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inet_frags>())).refcnt as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(inet_frags),
            "::",
            stringify!(refcnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inet_frags>())).completion as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(inet_frags),
            "::",
            stringify!(completion)
        )
    );
}
impl Default for inet_frags {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ipv4_devconf {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fib_table {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct local_ports {
    pub lock: seqlock_t,
    pub range: [c_types::c_int; 2usize],
    pub warned: bool_,
}
#[test]
fn bindgen_test_layout_local_ports() {
    assert_eq!(
        ::core::mem::size_of::<local_ports>(),
        20usize,
        concat!("Size of: ", stringify!(local_ports))
    );
    assert_eq!(
        ::core::mem::align_of::<local_ports>(),
        4usize,
        concat!("Alignment of ", stringify!(local_ports))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<local_ports>())).lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(local_ports),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<local_ports>())).range as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(local_ports),
            "::",
            stringify!(range)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<local_ports>())).warned as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(local_ports),
            "::",
            stringify!(warned)
        )
    );
}
impl Default for local_ports {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ping_group_range {
    pub lock: seqlock_t,
    pub range: [kgid_t; 2usize],
}
#[test]
fn bindgen_test_layout_ping_group_range() {
    assert_eq!(
        ::core::mem::size_of::<ping_group_range>(),
        16usize,
        concat!("Size of: ", stringify!(ping_group_range))
    );
    assert_eq!(
        ::core::mem::align_of::<ping_group_range>(),
        4usize,
        concat!("Alignment of ", stringify!(ping_group_range))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ping_group_range>())).lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ping_group_range),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ping_group_range>())).range as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ping_group_range),
            "::",
            stringify!(range)
        )
    );
}
impl Default for ping_group_range {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct inet_hashinfo {
    _unused: [u8; 0],
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct inet_timewait_death_row {
    pub tw_count: atomic_t,
    pub __bindgen_padding_0: [u64; 7usize],
    pub hashinfo: *mut inet_hashinfo,
    pub sysctl_max_tw_buckets: c_types::c_int,
}
#[test]
fn bindgen_test_layout_inet_timewait_death_row() {
    assert_eq!(
        ::core::mem::size_of::<inet_timewait_death_row>(),
        128usize,
        concat!("Size of: ", stringify!(inet_timewait_death_row))
    );
    assert_eq!(
        ::core::mem::align_of::<inet_timewait_death_row>(),
        64usize,
        concat!("Alignment of ", stringify!(inet_timewait_death_row))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<inet_timewait_death_row>())).tw_count as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(inet_timewait_death_row),
            "::",
            stringify!(tw_count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<inet_timewait_death_row>())).hashinfo as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(inet_timewait_death_row),
            "::",
            stringify!(hashinfo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<inet_timewait_death_row>())).sysctl_max_tw_buckets as *const _
                as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(inet_timewait_death_row),
            "::",
            stringify!(sysctl_max_tw_buckets)
        )
    );
}
impl Default for inet_timewait_death_row {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tcp_fastopen_context {
    _unused: [u8; 0],
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct netns_ipv4 {
    pub forw_hdr: *mut ctl_table_header,
    pub frags_hdr: *mut ctl_table_header,
    pub ipv4_hdr: *mut ctl_table_header,
    pub route_hdr: *mut ctl_table_header,
    pub xfrm4_hdr: *mut ctl_table_header,
    pub devconf_all: *mut ipv4_devconf,
    pub devconf_dflt: *mut ipv4_devconf,
    pub ra_chain: *mut ip_ra_chain,
    pub ra_mutex: mutex,
    pub rules_ops: *mut fib_rules_ops,
    pub fib_has_custom_rules: bool_,
    pub fib_rules_require_fldissect: c_types::c_uint,
    pub fib_main: *mut fib_table,
    pub fib_default: *mut fib_table,
    pub fib_has_custom_local_routes: bool_,
    pub fib_num_tclassid_users: c_types::c_int,
    pub fib_table_hash: *mut hlist_head,
    pub fib_offload_disabled: bool_,
    pub fibnl: *mut sock,
    pub icmp_sk: *mut *mut sock,
    pub mc_autojoin_sk: *mut sock,
    pub peers: *mut inet_peer_base,
    pub tcp_sk: *mut *mut sock,
    pub fqdir: *mut fqdir,
    pub iptable_filter: *mut xt_table,
    pub iptable_mangle: *mut xt_table,
    pub iptable_raw: *mut xt_table,
    pub arptable_filter: *mut xt_table,
    pub iptable_security: *mut xt_table,
    pub nat_table: *mut xt_table,
    pub sysctl_icmp_echo_ignore_all: c_types::c_int,
    pub sysctl_icmp_echo_ignore_broadcasts: c_types::c_int,
    pub sysctl_icmp_ignore_bogus_error_responses: c_types::c_int,
    pub sysctl_icmp_ratelimit: c_types::c_int,
    pub sysctl_icmp_ratemask: c_types::c_int,
    pub sysctl_icmp_errors_use_inbound_ifaddr: c_types::c_int,
    pub ip_local_ports: local_ports,
    pub sysctl_tcp_ecn: c_types::c_int,
    pub sysctl_tcp_ecn_fallback: c_types::c_int,
    pub sysctl_ip_default_ttl: c_types::c_int,
    pub sysctl_ip_no_pmtu_disc: c_types::c_int,
    pub sysctl_ip_fwd_use_pmtu: c_types::c_int,
    pub sysctl_ip_fwd_update_priority: c_types::c_int,
    pub sysctl_ip_nonlocal_bind: c_types::c_int,
    pub sysctl_ip_dynaddr: c_types::c_int,
    pub sysctl_ip_early_demux: c_types::c_int,
    pub sysctl_raw_l3mdev_accept: c_types::c_int,
    pub sysctl_tcp_early_demux: c_types::c_int,
    pub sysctl_udp_early_demux: c_types::c_int,
    pub sysctl_fwmark_reflect: c_types::c_int,
    pub sysctl_tcp_fwmark_accept: c_types::c_int,
    pub sysctl_tcp_l3mdev_accept: c_types::c_int,
    pub sysctl_tcp_mtu_probing: c_types::c_int,
    pub sysctl_tcp_mtu_probe_floor: c_types::c_int,
    pub sysctl_tcp_base_mss: c_types::c_int,
    pub sysctl_tcp_min_snd_mss: c_types::c_int,
    pub sysctl_tcp_probe_threshold: c_types::c_int,
    pub sysctl_tcp_probe_interval: u32_,
    pub sysctl_tcp_keepalive_time: c_types::c_int,
    pub sysctl_tcp_keepalive_probes: c_types::c_int,
    pub sysctl_tcp_keepalive_intvl: c_types::c_int,
    pub sysctl_tcp_syn_retries: c_types::c_int,
    pub sysctl_tcp_synack_retries: c_types::c_int,
    pub sysctl_tcp_syncookies: c_types::c_int,
    pub sysctl_tcp_reordering: c_types::c_int,
    pub sysctl_tcp_retries1: c_types::c_int,
    pub sysctl_tcp_retries2: c_types::c_int,
    pub sysctl_tcp_orphan_retries: c_types::c_int,
    pub sysctl_tcp_fin_timeout: c_types::c_int,
    pub sysctl_tcp_notsent_lowat: c_types::c_uint,
    pub sysctl_tcp_tw_reuse: c_types::c_int,
    pub sysctl_tcp_sack: c_types::c_int,
    pub sysctl_tcp_window_scaling: c_types::c_int,
    pub sysctl_tcp_timestamps: c_types::c_int,
    pub sysctl_tcp_early_retrans: c_types::c_int,
    pub sysctl_tcp_recovery: c_types::c_int,
    pub sysctl_tcp_thin_linear_timeouts: c_types::c_int,
    pub sysctl_tcp_slow_start_after_idle: c_types::c_int,
    pub sysctl_tcp_retrans_collapse: c_types::c_int,
    pub sysctl_tcp_stdurg: c_types::c_int,
    pub sysctl_tcp_rfc1337: c_types::c_int,
    pub sysctl_tcp_abort_on_overflow: c_types::c_int,
    pub sysctl_tcp_fack: c_types::c_int,
    pub sysctl_tcp_max_reordering: c_types::c_int,
    pub sysctl_tcp_dsack: c_types::c_int,
    pub sysctl_tcp_app_win: c_types::c_int,
    pub sysctl_tcp_adv_win_scale: c_types::c_int,
    pub sysctl_tcp_frto: c_types::c_int,
    pub sysctl_tcp_nometrics_save: c_types::c_int,
    pub sysctl_tcp_moderate_rcvbuf: c_types::c_int,
    pub sysctl_tcp_tso_win_divisor: c_types::c_int,
    pub sysctl_tcp_workaround_signed_windows: c_types::c_int,
    pub sysctl_tcp_limit_output_bytes: c_types::c_int,
    pub sysctl_tcp_challenge_ack_limit: c_types::c_int,
    pub sysctl_tcp_min_tso_segs: c_types::c_int,
    pub sysctl_tcp_min_rtt_wlen: c_types::c_int,
    pub sysctl_tcp_autocorking: c_types::c_int,
    pub sysctl_tcp_invalid_ratelimit: c_types::c_int,
    pub sysctl_tcp_pacing_ss_ratio: c_types::c_int,
    pub sysctl_tcp_pacing_ca_ratio: c_types::c_int,
    pub sysctl_tcp_wmem: [c_types::c_int; 3usize],
    pub sysctl_tcp_rmem: [c_types::c_int; 3usize],
    pub sysctl_tcp_comp_sack_nr: c_types::c_int,
    pub sysctl_tcp_comp_sack_delay_ns: c_types::c_ulong,
    pub __bindgen_padding_0: [u64; 7usize],
    pub tcp_death_row: inet_timewait_death_row,
    pub sysctl_max_syn_backlog: c_types::c_int,
    pub sysctl_tcp_fastopen: c_types::c_int,
    pub tcp_congestion_control: *const tcp_congestion_ops,
    pub tcp_fastopen_ctx: *mut tcp_fastopen_context,
    pub tcp_fastopen_ctx_lock: spinlock_t,
    pub sysctl_tcp_fastopen_blackhole_timeout: c_types::c_uint,
    pub tfo_active_disable_times: atomic_t,
    pub tfo_active_disable_stamp: c_types::c_ulong,
    pub sysctl_udp_wmem_min: c_types::c_int,
    pub sysctl_udp_rmem_min: c_types::c_int,
    pub sysctl_udp_l3mdev_accept: c_types::c_int,
    pub sysctl_igmp_max_memberships: c_types::c_int,
    pub sysctl_igmp_max_msf: c_types::c_int,
    pub sysctl_igmp_llm_reports: c_types::c_int,
    pub sysctl_igmp_qrv: c_types::c_int,
    pub ping_group_range: ping_group_range,
    pub dev_addr_genid: atomic_t,
    pub sysctl_local_reserved_ports: *mut c_types::c_ulong,
    pub sysctl_ip_prot_sock: c_types::c_int,
    pub mr_tables: list_head,
    pub mr_rules_ops: *mut fib_rules_ops,
    pub sysctl_fib_multipath_use_neigh: c_types::c_int,
    pub sysctl_fib_multipath_hash_policy: c_types::c_int,
    pub notifier_ops: *mut fib_notifier_ops,
    pub fib_seq: c_types::c_uint,
    pub ipmr_notifier_ops: *mut fib_notifier_ops,
    pub ipmr_seq: c_types::c_uint,
    pub rt_genid: atomic_t,
    pub ip_id_key: siphash_key_t,
}
#[test]
fn bindgen_test_layout_netns_ipv4() {
    assert_eq!(
        ::core::mem::size_of::<netns_ipv4>(),
        960usize,
        concat!("Size of: ", stringify!(netns_ipv4))
    );
    assert_eq!(
        ::core::mem::align_of::<netns_ipv4>(),
        64usize,
        concat!("Alignment of ", stringify!(netns_ipv4))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_ipv4>())).forw_hdr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv4),
            "::",
            stringify!(forw_hdr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_ipv4>())).frags_hdr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv4),
            "::",
            stringify!(frags_hdr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_ipv4>())).ipv4_hdr as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv4),
            "::",
            stringify!(ipv4_hdr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_ipv4>())).route_hdr as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv4),
            "::",
            stringify!(route_hdr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_ipv4>())).xfrm4_hdr as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv4),
            "::",
            stringify!(xfrm4_hdr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_ipv4>())).devconf_all as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv4),
            "::",
            stringify!(devconf_all)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_ipv4>())).devconf_dflt as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv4),
            "::",
            stringify!(devconf_dflt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_ipv4>())).ra_chain as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv4),
            "::",
            stringify!(ra_chain)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_ipv4>())).ra_mutex as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv4),
            "::",
            stringify!(ra_mutex)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_ipv4>())).rules_ops as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv4),
            "::",
            stringify!(rules_ops)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<netns_ipv4>())).fib_has_custom_rules as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv4),
            "::",
            stringify!(fib_has_custom_rules)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<netns_ipv4>())).fib_rules_require_fldissect as *const _ as usize
        },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv4),
            "::",
            stringify!(fib_rules_require_fldissect)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_ipv4>())).fib_main as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv4),
            "::",
            stringify!(fib_main)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_ipv4>())).fib_default as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv4),
            "::",
            stringify!(fib_default)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<netns_ipv4>())).fib_has_custom_local_routes as *const _ as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv4),
            "::",
            stringify!(fib_has_custom_local_routes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<netns_ipv4>())).fib_num_tclassid_users as *const _ as usize
        },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv4),
            "::",
            stringify!(fib_num_tclassid_users)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_ipv4>())).fib_table_hash as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv4),
            "::",
            stringify!(fib_table_hash)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<netns_ipv4>())).fib_offload_disabled as *const _ as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv4),
            "::",
            stringify!(fib_offload_disabled)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_ipv4>())).fibnl as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv4),
            "::",
            stringify!(fibnl)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_ipv4>())).icmp_sk as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv4),
            "::",
            stringify!(icmp_sk)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_ipv4>())).mc_autojoin_sk as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv4),
            "::",
            stringify!(mc_autojoin_sk)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_ipv4>())).peers as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv4),
            "::",
            stringify!(peers)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_ipv4>())).tcp_sk as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv4),
            "::",
            stringify!(tcp_sk)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_ipv4>())).fqdir as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv4),
            "::",
            stringify!(fqdir)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_ipv4>())).iptable_filter as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv4),
            "::",
            stringify!(iptable_filter)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_ipv4>())).iptable_mangle as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv4),
            "::",
            stringify!(iptable_mangle)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_ipv4>())).iptable_raw as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv4),
            "::",
            stringify!(iptable_raw)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_ipv4>())).arptable_filter as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv4),
            "::",
            stringify!(arptable_filter)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_ipv4>())).iptable_security as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv4),
            "::",
            stringify!(iptable_security)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_ipv4>())).nat_table as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv4),
            "::",
            stringify!(nat_table)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<netns_ipv4>())).sysctl_icmp_echo_ignore_all as *const _ as usize
        },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv4),
            "::",
            stringify!(sysctl_icmp_echo_ignore_all)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<netns_ipv4>())).sysctl_icmp_echo_ignore_broadcasts as *const _
                as usize
        },
        252usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv4),
            "::",
            stringify!(sysctl_icmp_echo_ignore_broadcasts)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<netns_ipv4>())).sysctl_icmp_ignore_bogus_error_responses
                as *const _ as usize
        },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv4),
            "::",
            stringify!(sysctl_icmp_ignore_bogus_error_responses)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<netns_ipv4>())).sysctl_icmp_ratelimit as *const _ as usize
        },
        260usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv4),
            "::",
            stringify!(sysctl_icmp_ratelimit)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<netns_ipv4>())).sysctl_icmp_ratemask as *const _ as usize
        },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv4),
            "::",
            stringify!(sysctl_icmp_ratemask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<netns_ipv4>())).sysctl_icmp_errors_use_inbound_ifaddr
                as *const _ as usize
        },
        268usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv4),
            "::",
            stringify!(sysctl_icmp_errors_use_inbound_ifaddr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_ipv4>())).ip_local_ports as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv4),
            "::",
            stringify!(ip_local_ports)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_ipv4>())).sysctl_tcp_ecn as *const _ as usize },
        292usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv4),
            "::",
            stringify!(sysctl_tcp_ecn)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<netns_ipv4>())).sysctl_tcp_ecn_fallback as *const _ as usize
        },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv4),
            "::",
            stringify!(sysctl_tcp_ecn_fallback)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<netns_ipv4>())).sysctl_ip_default_ttl as *const _ as usize
        },
        300usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv4),
            "::",
            stringify!(sysctl_ip_default_ttl)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<netns_ipv4>())).sysctl_ip_no_pmtu_disc as *const _ as usize
        },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv4),
            "::",
            stringify!(sysctl_ip_no_pmtu_disc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<netns_ipv4>())).sysctl_ip_fwd_use_pmtu as *const _ as usize
        },
        308usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv4),
            "::",
            stringify!(sysctl_ip_fwd_use_pmtu)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<netns_ipv4>())).sysctl_ip_fwd_update_priority as *const _
                as usize
        },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv4),
            "::",
            stringify!(sysctl_ip_fwd_update_priority)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<netns_ipv4>())).sysctl_ip_nonlocal_bind as *const _ as usize
        },
        316usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv4),
            "::",
            stringify!(sysctl_ip_nonlocal_bind)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_ipv4>())).sysctl_ip_dynaddr as *const _ as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv4),
            "::",
            stringify!(sysctl_ip_dynaddr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<netns_ipv4>())).sysctl_ip_early_demux as *const _ as usize
        },
        324usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv4),
            "::",
            stringify!(sysctl_ip_early_demux)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<netns_ipv4>())).sysctl_raw_l3mdev_accept as *const _ as usize
        },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv4),
            "::",
            stringify!(sysctl_raw_l3mdev_accept)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<netns_ipv4>())).sysctl_tcp_early_demux as *const _ as usize
        },
        332usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv4),
            "::",
            stringify!(sysctl_tcp_early_demux)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<netns_ipv4>())).sysctl_udp_early_demux as *const _ as usize
        },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv4),
            "::",
            stringify!(sysctl_udp_early_demux)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<netns_ipv4>())).sysctl_fwmark_reflect as *const _ as usize
        },
        340usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv4),
            "::",
            stringify!(sysctl_fwmark_reflect)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<netns_ipv4>())).sysctl_tcp_fwmark_accept as *const _ as usize
        },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv4),
            "::",
            stringify!(sysctl_tcp_fwmark_accept)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<netns_ipv4>())).sysctl_tcp_l3mdev_accept as *const _ as usize
        },
        348usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv4),
            "::",
            stringify!(sysctl_tcp_l3mdev_accept)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<netns_ipv4>())).sysctl_tcp_mtu_probing as *const _ as usize
        },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv4),
            "::",
            stringify!(sysctl_tcp_mtu_probing)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<netns_ipv4>())).sysctl_tcp_mtu_probe_floor as *const _ as usize
        },
        356usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv4),
            "::",
            stringify!(sysctl_tcp_mtu_probe_floor)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_ipv4>())).sysctl_tcp_base_mss as *const _ as usize },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv4),
            "::",
            stringify!(sysctl_tcp_base_mss)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<netns_ipv4>())).sysctl_tcp_min_snd_mss as *const _ as usize
        },
        364usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv4),
            "::",
            stringify!(sysctl_tcp_min_snd_mss)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<netns_ipv4>())).sysctl_tcp_probe_threshold as *const _ as usize
        },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv4),
            "::",
            stringify!(sysctl_tcp_probe_threshold)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<netns_ipv4>())).sysctl_tcp_probe_interval as *const _ as usize
        },
        372usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv4),
            "::",
            stringify!(sysctl_tcp_probe_interval)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<netns_ipv4>())).sysctl_tcp_keepalive_time as *const _ as usize
        },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv4),
            "::",
            stringify!(sysctl_tcp_keepalive_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<netns_ipv4>())).sysctl_tcp_keepalive_probes as *const _ as usize
        },
        380usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv4),
            "::",
            stringify!(sysctl_tcp_keepalive_probes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<netns_ipv4>())).sysctl_tcp_keepalive_intvl as *const _ as usize
        },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv4),
            "::",
            stringify!(sysctl_tcp_keepalive_intvl)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<netns_ipv4>())).sysctl_tcp_syn_retries as *const _ as usize
        },
        388usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv4),
            "::",
            stringify!(sysctl_tcp_syn_retries)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<netns_ipv4>())).sysctl_tcp_synack_retries as *const _ as usize
        },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv4),
            "::",
            stringify!(sysctl_tcp_synack_retries)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<netns_ipv4>())).sysctl_tcp_syncookies as *const _ as usize
        },
        396usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv4),
            "::",
            stringify!(sysctl_tcp_syncookies)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<netns_ipv4>())).sysctl_tcp_reordering as *const _ as usize
        },
        400usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv4),
            "::",
            stringify!(sysctl_tcp_reordering)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_ipv4>())).sysctl_tcp_retries1 as *const _ as usize },
        404usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv4),
            "::",
            stringify!(sysctl_tcp_retries1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_ipv4>())).sysctl_tcp_retries2 as *const _ as usize },
        408usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv4),
            "::",
            stringify!(sysctl_tcp_retries2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<netns_ipv4>())).sysctl_tcp_orphan_retries as *const _ as usize
        },
        412usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv4),
            "::",
            stringify!(sysctl_tcp_orphan_retries)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<netns_ipv4>())).sysctl_tcp_fin_timeout as *const _ as usize
        },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv4),
            "::",
            stringify!(sysctl_tcp_fin_timeout)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<netns_ipv4>())).sysctl_tcp_notsent_lowat as *const _ as usize
        },
        420usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv4),
            "::",
            stringify!(sysctl_tcp_notsent_lowat)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_ipv4>())).sysctl_tcp_tw_reuse as *const _ as usize },
        424usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv4),
            "::",
            stringify!(sysctl_tcp_tw_reuse)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_ipv4>())).sysctl_tcp_sack as *const _ as usize },
        428usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv4),
            "::",
            stringify!(sysctl_tcp_sack)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<netns_ipv4>())).sysctl_tcp_window_scaling as *const _ as usize
        },
        432usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv4),
            "::",
            stringify!(sysctl_tcp_window_scaling)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<netns_ipv4>())).sysctl_tcp_timestamps as *const _ as usize
        },
        436usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv4),
            "::",
            stringify!(sysctl_tcp_timestamps)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<netns_ipv4>())).sysctl_tcp_early_retrans as *const _ as usize
        },
        440usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv4),
            "::",
            stringify!(sysctl_tcp_early_retrans)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_ipv4>())).sysctl_tcp_recovery as *const _ as usize },
        444usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv4),
            "::",
            stringify!(sysctl_tcp_recovery)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<netns_ipv4>())).sysctl_tcp_thin_linear_timeouts as *const _
                as usize
        },
        448usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv4),
            "::",
            stringify!(sysctl_tcp_thin_linear_timeouts)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<netns_ipv4>())).sysctl_tcp_slow_start_after_idle as *const _
                as usize
        },
        452usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv4),
            "::",
            stringify!(sysctl_tcp_slow_start_after_idle)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<netns_ipv4>())).sysctl_tcp_retrans_collapse as *const _ as usize
        },
        456usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv4),
            "::",
            stringify!(sysctl_tcp_retrans_collapse)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_ipv4>())).sysctl_tcp_stdurg as *const _ as usize },
        460usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv4),
            "::",
            stringify!(sysctl_tcp_stdurg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_ipv4>())).sysctl_tcp_rfc1337 as *const _ as usize },
        464usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv4),
            "::",
            stringify!(sysctl_tcp_rfc1337)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<netns_ipv4>())).sysctl_tcp_abort_on_overflow as *const _
                as usize
        },
        468usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv4),
            "::",
            stringify!(sysctl_tcp_abort_on_overflow)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_ipv4>())).sysctl_tcp_fack as *const _ as usize },
        472usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv4),
            "::",
            stringify!(sysctl_tcp_fack)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<netns_ipv4>())).sysctl_tcp_max_reordering as *const _ as usize
        },
        476usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv4),
            "::",
            stringify!(sysctl_tcp_max_reordering)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_ipv4>())).sysctl_tcp_dsack as *const _ as usize },
        480usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv4),
            "::",
            stringify!(sysctl_tcp_dsack)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_ipv4>())).sysctl_tcp_app_win as *const _ as usize },
        484usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv4),
            "::",
            stringify!(sysctl_tcp_app_win)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<netns_ipv4>())).sysctl_tcp_adv_win_scale as *const _ as usize
        },
        488usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv4),
            "::",
            stringify!(sysctl_tcp_adv_win_scale)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_ipv4>())).sysctl_tcp_frto as *const _ as usize },
        492usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv4),
            "::",
            stringify!(sysctl_tcp_frto)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<netns_ipv4>())).sysctl_tcp_nometrics_save as *const _ as usize
        },
        496usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv4),
            "::",
            stringify!(sysctl_tcp_nometrics_save)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<netns_ipv4>())).sysctl_tcp_moderate_rcvbuf as *const _ as usize
        },
        500usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv4),
            "::",
            stringify!(sysctl_tcp_moderate_rcvbuf)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<netns_ipv4>())).sysctl_tcp_tso_win_divisor as *const _ as usize
        },
        504usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv4),
            "::",
            stringify!(sysctl_tcp_tso_win_divisor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<netns_ipv4>())).sysctl_tcp_workaround_signed_windows as *const _
                as usize
        },
        508usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv4),
            "::",
            stringify!(sysctl_tcp_workaround_signed_windows)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<netns_ipv4>())).sysctl_tcp_limit_output_bytes as *const _
                as usize
        },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv4),
            "::",
            stringify!(sysctl_tcp_limit_output_bytes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<netns_ipv4>())).sysctl_tcp_challenge_ack_limit as *const _
                as usize
        },
        516usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv4),
            "::",
            stringify!(sysctl_tcp_challenge_ack_limit)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<netns_ipv4>())).sysctl_tcp_min_tso_segs as *const _ as usize
        },
        520usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv4),
            "::",
            stringify!(sysctl_tcp_min_tso_segs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<netns_ipv4>())).sysctl_tcp_min_rtt_wlen as *const _ as usize
        },
        524usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv4),
            "::",
            stringify!(sysctl_tcp_min_rtt_wlen)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<netns_ipv4>())).sysctl_tcp_autocorking as *const _ as usize
        },
        528usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv4),
            "::",
            stringify!(sysctl_tcp_autocorking)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<netns_ipv4>())).sysctl_tcp_invalid_ratelimit as *const _
                as usize
        },
        532usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv4),
            "::",
            stringify!(sysctl_tcp_invalid_ratelimit)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<netns_ipv4>())).sysctl_tcp_pacing_ss_ratio as *const _ as usize
        },
        536usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv4),
            "::",
            stringify!(sysctl_tcp_pacing_ss_ratio)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<netns_ipv4>())).sysctl_tcp_pacing_ca_ratio as *const _ as usize
        },
        540usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv4),
            "::",
            stringify!(sysctl_tcp_pacing_ca_ratio)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_ipv4>())).sysctl_tcp_wmem as *const _ as usize },
        544usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv4),
            "::",
            stringify!(sysctl_tcp_wmem)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_ipv4>())).sysctl_tcp_rmem as *const _ as usize },
        556usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv4),
            "::",
            stringify!(sysctl_tcp_rmem)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<netns_ipv4>())).sysctl_tcp_comp_sack_nr as *const _ as usize
        },
        568usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv4),
            "::",
            stringify!(sysctl_tcp_comp_sack_nr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<netns_ipv4>())).sysctl_tcp_comp_sack_delay_ns as *const _
                as usize
        },
        576usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv4),
            "::",
            stringify!(sysctl_tcp_comp_sack_delay_ns)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_ipv4>())).tcp_death_row as *const _ as usize },
        640usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv4),
            "::",
            stringify!(tcp_death_row)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<netns_ipv4>())).sysctl_max_syn_backlog as *const _ as usize
        },
        768usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv4),
            "::",
            stringify!(sysctl_max_syn_backlog)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_ipv4>())).sysctl_tcp_fastopen as *const _ as usize },
        772usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv4),
            "::",
            stringify!(sysctl_tcp_fastopen)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<netns_ipv4>())).tcp_congestion_control as *const _ as usize
        },
        776usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv4),
            "::",
            stringify!(tcp_congestion_control)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_ipv4>())).tcp_fastopen_ctx as *const _ as usize },
        784usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv4),
            "::",
            stringify!(tcp_fastopen_ctx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<netns_ipv4>())).tcp_fastopen_ctx_lock as *const _ as usize
        },
        792usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv4),
            "::",
            stringify!(tcp_fastopen_ctx_lock)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<netns_ipv4>())).sysctl_tcp_fastopen_blackhole_timeout
                as *const _ as usize
        },
        796usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv4),
            "::",
            stringify!(sysctl_tcp_fastopen_blackhole_timeout)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<netns_ipv4>())).tfo_active_disable_times as *const _ as usize
        },
        800usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv4),
            "::",
            stringify!(tfo_active_disable_times)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<netns_ipv4>())).tfo_active_disable_stamp as *const _ as usize
        },
        808usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv4),
            "::",
            stringify!(tfo_active_disable_stamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_ipv4>())).sysctl_udp_wmem_min as *const _ as usize },
        816usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv4),
            "::",
            stringify!(sysctl_udp_wmem_min)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_ipv4>())).sysctl_udp_rmem_min as *const _ as usize },
        820usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv4),
            "::",
            stringify!(sysctl_udp_rmem_min)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<netns_ipv4>())).sysctl_udp_l3mdev_accept as *const _ as usize
        },
        824usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv4),
            "::",
            stringify!(sysctl_udp_l3mdev_accept)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<netns_ipv4>())).sysctl_igmp_max_memberships as *const _ as usize
        },
        828usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv4),
            "::",
            stringify!(sysctl_igmp_max_memberships)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_ipv4>())).sysctl_igmp_max_msf as *const _ as usize },
        832usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv4),
            "::",
            stringify!(sysctl_igmp_max_msf)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<netns_ipv4>())).sysctl_igmp_llm_reports as *const _ as usize
        },
        836usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv4),
            "::",
            stringify!(sysctl_igmp_llm_reports)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_ipv4>())).sysctl_igmp_qrv as *const _ as usize },
        840usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv4),
            "::",
            stringify!(sysctl_igmp_qrv)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_ipv4>())).ping_group_range as *const _ as usize },
        844usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv4),
            "::",
            stringify!(ping_group_range)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_ipv4>())).dev_addr_genid as *const _ as usize },
        860usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv4),
            "::",
            stringify!(dev_addr_genid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<netns_ipv4>())).sysctl_local_reserved_ports as *const _ as usize
        },
        864usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv4),
            "::",
            stringify!(sysctl_local_reserved_ports)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_ipv4>())).sysctl_ip_prot_sock as *const _ as usize },
        872usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv4),
            "::",
            stringify!(sysctl_ip_prot_sock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_ipv4>())).mr_tables as *const _ as usize },
        880usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv4),
            "::",
            stringify!(mr_tables)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_ipv4>())).mr_rules_ops as *const _ as usize },
        896usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv4),
            "::",
            stringify!(mr_rules_ops)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<netns_ipv4>())).sysctl_fib_multipath_use_neigh as *const _
                as usize
        },
        904usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv4),
            "::",
            stringify!(sysctl_fib_multipath_use_neigh)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<netns_ipv4>())).sysctl_fib_multipath_hash_policy as *const _
                as usize
        },
        908usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv4),
            "::",
            stringify!(sysctl_fib_multipath_hash_policy)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_ipv4>())).notifier_ops as *const _ as usize },
        912usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv4),
            "::",
            stringify!(notifier_ops)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_ipv4>())).fib_seq as *const _ as usize },
        920usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv4),
            "::",
            stringify!(fib_seq)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_ipv4>())).ipmr_notifier_ops as *const _ as usize },
        928usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv4),
            "::",
            stringify!(ipmr_notifier_ops)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_ipv4>())).ipmr_seq as *const _ as usize },
        936usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv4),
            "::",
            stringify!(ipmr_seq)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_ipv4>())).rt_genid as *const _ as usize },
        940usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv4),
            "::",
            stringify!(rt_genid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_ipv4>())).ip_id_key as *const _ as usize },
        944usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv4),
            "::",
            stringify!(ip_id_key)
        )
    );
}
impl Default for netns_ipv4 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct dst_ops {
    pub family: c_types::c_ushort,
    pub gc_thresh: c_types::c_uint,
    pub gc: ::core::option::Option<unsafe extern "C" fn(ops: *mut dst_ops) -> c_types::c_int>,
    pub check: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut dst_entry, cookie: __u32) -> *mut dst_entry,
    >,
    pub default_advmss:
        ::core::option::Option<unsafe extern "C" fn(arg1: *const dst_entry) -> c_types::c_uint>,
    pub mtu:
        ::core::option::Option<unsafe extern "C" fn(arg1: *const dst_entry) -> c_types::c_uint>,
    pub cow_metrics: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut dst_entry, arg2: c_types::c_ulong) -> *mut u32_,
    >,
    pub destroy: ::core::option::Option<unsafe extern "C" fn(arg1: *mut dst_entry)>,
    pub ifdown: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut dst_entry, dev: *mut net_device, how: c_types::c_int),
    >,
    pub negative_advice:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut dst_entry) -> *mut dst_entry>,
    pub link_failure: ::core::option::Option<unsafe extern "C" fn(arg1: *mut sk_buff)>,
    pub update_pmtu: ::core::option::Option<
        unsafe extern "C" fn(
            dst: *mut dst_entry,
            sk: *mut sock,
            skb: *mut sk_buff,
            mtu: u32_,
            confirm_neigh: bool_,
        ),
    >,
    pub redirect: ::core::option::Option<
        unsafe extern "C" fn(dst: *mut dst_entry, sk: *mut sock, skb: *mut sk_buff),
    >,
    pub local_out: ::core::option::Option<
        unsafe extern "C" fn(net: *mut net, sk: *mut sock, skb: *mut sk_buff) -> c_types::c_int,
    >,
    pub neigh_lookup: ::core::option::Option<
        unsafe extern "C" fn(
            dst: *const dst_entry,
            skb: *mut sk_buff,
            daddr: *const c_types::c_void,
        ) -> *mut neighbour,
    >,
    pub confirm_neigh: ::core::option::Option<
        unsafe extern "C" fn(dst: *const dst_entry, daddr: *const c_types::c_void),
    >,
    pub kmem_cachep: *mut kmem_cache,
    pub pcpuc_entries: percpu_counter,
}
#[test]
fn bindgen_test_layout_dst_ops() {
    assert_eq!(
        ::core::mem::size_of::<dst_ops>(),
        192usize,
        concat!("Size of: ", stringify!(dst_ops))
    );
    assert_eq!(
        ::core::mem::align_of::<dst_ops>(),
        64usize,
        concat!("Alignment of ", stringify!(dst_ops))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dst_ops>())).family as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dst_ops),
            "::",
            stringify!(family)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dst_ops>())).gc_thresh as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(dst_ops),
            "::",
            stringify!(gc_thresh)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dst_ops>())).gc as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(dst_ops),
            "::",
            stringify!(gc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dst_ops>())).check as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(dst_ops),
            "::",
            stringify!(check)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dst_ops>())).default_advmss as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(dst_ops),
            "::",
            stringify!(default_advmss)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dst_ops>())).mtu as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(dst_ops),
            "::",
            stringify!(mtu)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dst_ops>())).cow_metrics as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(dst_ops),
            "::",
            stringify!(cow_metrics)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dst_ops>())).destroy as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(dst_ops),
            "::",
            stringify!(destroy)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dst_ops>())).ifdown as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(dst_ops),
            "::",
            stringify!(ifdown)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dst_ops>())).negative_advice as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(dst_ops),
            "::",
            stringify!(negative_advice)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dst_ops>())).link_failure as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(dst_ops),
            "::",
            stringify!(link_failure)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dst_ops>())).update_pmtu as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(dst_ops),
            "::",
            stringify!(update_pmtu)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dst_ops>())).redirect as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(dst_ops),
            "::",
            stringify!(redirect)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dst_ops>())).local_out as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(dst_ops),
            "::",
            stringify!(local_out)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dst_ops>())).neigh_lookup as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(dst_ops),
            "::",
            stringify!(neigh_lookup)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dst_ops>())).confirm_neigh as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(dst_ops),
            "::",
            stringify!(confirm_neigh)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dst_ops>())).kmem_cachep as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(dst_ops),
            "::",
            stringify!(kmem_cachep)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dst_ops>())).pcpuc_entries as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(dst_ops),
            "::",
            stringify!(pcpuc_entries)
        )
    );
}
impl Default for dst_ops {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct netns_sysctl_ipv6 {
    pub hdr: *mut ctl_table_header,
    pub route_hdr: *mut ctl_table_header,
    pub icmp_hdr: *mut ctl_table_header,
    pub frags_hdr: *mut ctl_table_header,
    pub xfrm6_hdr: *mut ctl_table_header,
    pub bindv6only: c_types::c_int,
    pub flush_delay: c_types::c_int,
    pub ip6_rt_max_size: c_types::c_int,
    pub ip6_rt_gc_min_interval: c_types::c_int,
    pub ip6_rt_gc_timeout: c_types::c_int,
    pub ip6_rt_gc_interval: c_types::c_int,
    pub ip6_rt_gc_elasticity: c_types::c_int,
    pub ip6_rt_mtu_expires: c_types::c_int,
    pub ip6_rt_min_advmss: c_types::c_int,
    pub multipath_hash_policy: c_types::c_int,
    pub flowlabel_consistency: c_types::c_int,
    pub auto_flowlabels: c_types::c_int,
    pub icmpv6_time: c_types::c_int,
    pub icmpv6_echo_ignore_all: c_types::c_int,
    pub icmpv6_echo_ignore_multicast: c_types::c_int,
    pub icmpv6_echo_ignore_anycast: c_types::c_int,
    pub icmpv6_ratemask: [c_types::c_ulong; 4usize],
    pub icmpv6_ratemask_ptr: *mut c_types::c_ulong,
    pub anycast_src_echo_reply: c_types::c_int,
    pub ip_nonlocal_bind: c_types::c_int,
    pub fwmark_reflect: c_types::c_int,
    pub idgen_retries: c_types::c_int,
    pub idgen_delay: c_types::c_int,
    pub flowlabel_state_ranges: c_types::c_int,
    pub flowlabel_reflect: c_types::c_int,
    pub max_dst_opts_cnt: c_types::c_int,
    pub max_hbh_opts_cnt: c_types::c_int,
    pub max_dst_opts_len: c_types::c_int,
    pub max_hbh_opts_len: c_types::c_int,
    pub seg6_flowlabel: c_types::c_int,
    pub skip_notify_on_dev_down: bool_,
}
#[test]
fn bindgen_test_layout_netns_sysctl_ipv6() {
    assert_eq!(
        ::core::mem::size_of::<netns_sysctl_ipv6>(),
        200usize,
        concat!("Size of: ", stringify!(netns_sysctl_ipv6))
    );
    assert_eq!(
        ::core::mem::align_of::<netns_sysctl_ipv6>(),
        8usize,
        concat!("Alignment of ", stringify!(netns_sysctl_ipv6))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_sysctl_ipv6>())).hdr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_sysctl_ipv6),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_sysctl_ipv6>())).route_hdr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_sysctl_ipv6),
            "::",
            stringify!(route_hdr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_sysctl_ipv6>())).icmp_hdr as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_sysctl_ipv6),
            "::",
            stringify!(icmp_hdr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_sysctl_ipv6>())).frags_hdr as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_sysctl_ipv6),
            "::",
            stringify!(frags_hdr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_sysctl_ipv6>())).xfrm6_hdr as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_sysctl_ipv6),
            "::",
            stringify!(xfrm6_hdr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_sysctl_ipv6>())).bindv6only as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_sysctl_ipv6),
            "::",
            stringify!(bindv6only)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_sysctl_ipv6>())).flush_delay as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_sysctl_ipv6),
            "::",
            stringify!(flush_delay)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<netns_sysctl_ipv6>())).ip6_rt_max_size as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_sysctl_ipv6),
            "::",
            stringify!(ip6_rt_max_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<netns_sysctl_ipv6>())).ip6_rt_gc_min_interval as *const _
                as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_sysctl_ipv6),
            "::",
            stringify!(ip6_rt_gc_min_interval)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<netns_sysctl_ipv6>())).ip6_rt_gc_timeout as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_sysctl_ipv6),
            "::",
            stringify!(ip6_rt_gc_timeout)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<netns_sysctl_ipv6>())).ip6_rt_gc_interval as *const _ as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_sysctl_ipv6),
            "::",
            stringify!(ip6_rt_gc_interval)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<netns_sysctl_ipv6>())).ip6_rt_gc_elasticity as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_sysctl_ipv6),
            "::",
            stringify!(ip6_rt_gc_elasticity)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<netns_sysctl_ipv6>())).ip6_rt_mtu_expires as *const _ as usize
        },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_sysctl_ipv6),
            "::",
            stringify!(ip6_rt_mtu_expires)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<netns_sysctl_ipv6>())).ip6_rt_min_advmss as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_sysctl_ipv6),
            "::",
            stringify!(ip6_rt_min_advmss)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<netns_sysctl_ipv6>())).multipath_hash_policy as *const _
                as usize
        },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_sysctl_ipv6),
            "::",
            stringify!(multipath_hash_policy)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<netns_sysctl_ipv6>())).flowlabel_consistency as *const _
                as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_sysctl_ipv6),
            "::",
            stringify!(flowlabel_consistency)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<netns_sysctl_ipv6>())).auto_flowlabels as *const _ as usize
        },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_sysctl_ipv6),
            "::",
            stringify!(auto_flowlabels)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_sysctl_ipv6>())).icmpv6_time as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_sysctl_ipv6),
            "::",
            stringify!(icmpv6_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<netns_sysctl_ipv6>())).icmpv6_echo_ignore_all as *const _
                as usize
        },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_sysctl_ipv6),
            "::",
            stringify!(icmpv6_echo_ignore_all)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<netns_sysctl_ipv6>())).icmpv6_echo_ignore_multicast as *const _
                as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_sysctl_ipv6),
            "::",
            stringify!(icmpv6_echo_ignore_multicast)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<netns_sysctl_ipv6>())).icmpv6_echo_ignore_anycast as *const _
                as usize
        },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_sysctl_ipv6),
            "::",
            stringify!(icmpv6_echo_ignore_anycast)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<netns_sysctl_ipv6>())).icmpv6_ratemask as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_sysctl_ipv6),
            "::",
            stringify!(icmpv6_ratemask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<netns_sysctl_ipv6>())).icmpv6_ratemask_ptr as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_sysctl_ipv6),
            "::",
            stringify!(icmpv6_ratemask_ptr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<netns_sysctl_ipv6>())).anycast_src_echo_reply as *const _
                as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_sysctl_ipv6),
            "::",
            stringify!(anycast_src_echo_reply)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<netns_sysctl_ipv6>())).ip_nonlocal_bind as *const _ as usize
        },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_sysctl_ipv6),
            "::",
            stringify!(ip_nonlocal_bind)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<netns_sysctl_ipv6>())).fwmark_reflect as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_sysctl_ipv6),
            "::",
            stringify!(fwmark_reflect)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<netns_sysctl_ipv6>())).idgen_retries as *const _ as usize
        },
        156usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_sysctl_ipv6),
            "::",
            stringify!(idgen_retries)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_sysctl_ipv6>())).idgen_delay as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_sysctl_ipv6),
            "::",
            stringify!(idgen_delay)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<netns_sysctl_ipv6>())).flowlabel_state_ranges as *const _
                as usize
        },
        164usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_sysctl_ipv6),
            "::",
            stringify!(flowlabel_state_ranges)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<netns_sysctl_ipv6>())).flowlabel_reflect as *const _ as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_sysctl_ipv6),
            "::",
            stringify!(flowlabel_reflect)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<netns_sysctl_ipv6>())).max_dst_opts_cnt as *const _ as usize
        },
        172usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_sysctl_ipv6),
            "::",
            stringify!(max_dst_opts_cnt)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<netns_sysctl_ipv6>())).max_hbh_opts_cnt as *const _ as usize
        },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_sysctl_ipv6),
            "::",
            stringify!(max_hbh_opts_cnt)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<netns_sysctl_ipv6>())).max_dst_opts_len as *const _ as usize
        },
        180usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_sysctl_ipv6),
            "::",
            stringify!(max_dst_opts_len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<netns_sysctl_ipv6>())).max_hbh_opts_len as *const _ as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_sysctl_ipv6),
            "::",
            stringify!(max_hbh_opts_len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<netns_sysctl_ipv6>())).seg6_flowlabel as *const _ as usize
        },
        188usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_sysctl_ipv6),
            "::",
            stringify!(seg6_flowlabel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<netns_sysctl_ipv6>())).skip_notify_on_dev_down as *const _
                as usize
        },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_sysctl_ipv6),
            "::",
            stringify!(skip_notify_on_dev_down)
        )
    );
}
impl Default for netns_sysctl_ipv6 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct netns_ipv6 {
    pub sysctl: netns_sysctl_ipv6,
    pub devconf_all: *mut ipv6_devconf,
    pub devconf_dflt: *mut ipv6_devconf,
    pub peers: *mut inet_peer_base,
    pub fqdir: *mut fqdir,
    pub ip6table_filter: *mut xt_table,
    pub ip6table_mangle: *mut xt_table,
    pub ip6table_raw: *mut xt_table,
    pub ip6table_security: *mut xt_table,
    pub ip6table_nat: *mut xt_table,
    pub fib6_null_entry: *mut fib6_info,
    pub ip6_null_entry: *mut rt6_info,
    pub rt6_stats: *mut rt6_statistics,
    pub ip6_fib_timer: timer_list,
    pub fib_table_hash: *mut hlist_head,
    pub fib6_main_tbl: *mut fib6_table,
    pub fib6_walkers: list_head,
    pub __bindgen_padding_0: [u64; 2usize],
    pub ip6_dst_ops: dst_ops,
    pub fib6_walker_lock: rwlock_t,
    pub fib6_gc_lock: spinlock_t,
    pub ip6_rt_gc_expire: c_types::c_uint,
    pub ip6_rt_last_gc: c_types::c_ulong,
    pub fib6_rules_require_fldissect: c_types::c_uint,
    pub fib6_has_custom_rules: bool_,
    pub ip6_prohibit_entry: *mut rt6_info,
    pub ip6_blk_hole_entry: *mut rt6_info,
    pub fib6_local_tbl: *mut fib6_table,
    pub fib6_rules_ops: *mut fib_rules_ops,
    pub icmp_sk: *mut *mut sock,
    pub ndisc_sk: *mut sock,
    pub tcp_sk: *mut sock,
    pub igmp_sk: *mut sock,
    pub mc_autojoin_sk: *mut sock,
    pub mr6_tables: list_head,
    pub mr6_rules_ops: *mut fib_rules_ops,
    pub dev_addr_genid: atomic_t,
    pub fib6_sernum: atomic_t,
    pub seg6_data: *mut seg6_pernet_data,
    pub notifier_ops: *mut fib_notifier_ops,
    pub ip6mr_notifier_ops: *mut fib_notifier_ops,
    pub ipmr_seq: c_types::c_uint,
    pub ip6addrlbl_table: netns_ipv6__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct netns_ipv6__bindgen_ty_1 {
    pub head: hlist_head,
    pub lock: spinlock_t,
    pub seq: u32_,
}
#[test]
fn bindgen_test_layout_netns_ipv6__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<netns_ipv6__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(netns_ipv6__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<netns_ipv6__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(netns_ipv6__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_ipv6__bindgen_ty_1>())).head as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv6__bindgen_ty_1),
            "::",
            stringify!(head)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_ipv6__bindgen_ty_1>())).lock as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv6__bindgen_ty_1),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_ipv6__bindgen_ty_1>())).seq as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv6__bindgen_ty_1),
            "::",
            stringify!(seq)
        )
    );
}
impl Default for netns_ipv6__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_netns_ipv6() {
    assert_eq!(
        ::core::mem::size_of::<netns_ipv6>(),
        768usize,
        concat!("Size of: ", stringify!(netns_ipv6))
    );
    assert_eq!(
        ::core::mem::align_of::<netns_ipv6>(),
        64usize,
        concat!("Alignment of ", stringify!(netns_ipv6))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_ipv6>())).sysctl as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv6),
            "::",
            stringify!(sysctl)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_ipv6>())).devconf_all as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv6),
            "::",
            stringify!(devconf_all)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_ipv6>())).devconf_dflt as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv6),
            "::",
            stringify!(devconf_dflt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_ipv6>())).peers as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv6),
            "::",
            stringify!(peers)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_ipv6>())).fqdir as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv6),
            "::",
            stringify!(fqdir)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_ipv6>())).ip6table_filter as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv6),
            "::",
            stringify!(ip6table_filter)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_ipv6>())).ip6table_mangle as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv6),
            "::",
            stringify!(ip6table_mangle)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_ipv6>())).ip6table_raw as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv6),
            "::",
            stringify!(ip6table_raw)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_ipv6>())).ip6table_security as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv6),
            "::",
            stringify!(ip6table_security)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_ipv6>())).ip6table_nat as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv6),
            "::",
            stringify!(ip6table_nat)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_ipv6>())).fib6_null_entry as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv6),
            "::",
            stringify!(fib6_null_entry)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_ipv6>())).ip6_null_entry as *const _ as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv6),
            "::",
            stringify!(ip6_null_entry)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_ipv6>())).rt6_stats as *const _ as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv6),
            "::",
            stringify!(rt6_stats)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_ipv6>())).ip6_fib_timer as *const _ as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv6),
            "::",
            stringify!(ip6_fib_timer)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_ipv6>())).fib_table_hash as *const _ as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv6),
            "::",
            stringify!(fib_table_hash)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_ipv6>())).fib6_main_tbl as *const _ as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv6),
            "::",
            stringify!(fib6_main_tbl)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_ipv6>())).fib6_walkers as *const _ as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv6),
            "::",
            stringify!(fib6_walkers)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_ipv6>())).ip6_dst_ops as *const _ as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv6),
            "::",
            stringify!(ip6_dst_ops)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_ipv6>())).fib6_walker_lock as *const _ as usize },
        576usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv6),
            "::",
            stringify!(fib6_walker_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_ipv6>())).fib6_gc_lock as *const _ as usize },
        584usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv6),
            "::",
            stringify!(fib6_gc_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_ipv6>())).ip6_rt_gc_expire as *const _ as usize },
        588usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv6),
            "::",
            stringify!(ip6_rt_gc_expire)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_ipv6>())).ip6_rt_last_gc as *const _ as usize },
        592usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv6),
            "::",
            stringify!(ip6_rt_last_gc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<netns_ipv6>())).fib6_rules_require_fldissect as *const _
                as usize
        },
        600usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv6),
            "::",
            stringify!(fib6_rules_require_fldissect)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<netns_ipv6>())).fib6_has_custom_rules as *const _ as usize
        },
        604usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv6),
            "::",
            stringify!(fib6_has_custom_rules)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_ipv6>())).ip6_prohibit_entry as *const _ as usize },
        608usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv6),
            "::",
            stringify!(ip6_prohibit_entry)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_ipv6>())).ip6_blk_hole_entry as *const _ as usize },
        616usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv6),
            "::",
            stringify!(ip6_blk_hole_entry)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_ipv6>())).fib6_local_tbl as *const _ as usize },
        624usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv6),
            "::",
            stringify!(fib6_local_tbl)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_ipv6>())).fib6_rules_ops as *const _ as usize },
        632usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv6),
            "::",
            stringify!(fib6_rules_ops)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_ipv6>())).icmp_sk as *const _ as usize },
        640usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv6),
            "::",
            stringify!(icmp_sk)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_ipv6>())).ndisc_sk as *const _ as usize },
        648usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv6),
            "::",
            stringify!(ndisc_sk)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_ipv6>())).tcp_sk as *const _ as usize },
        656usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv6),
            "::",
            stringify!(tcp_sk)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_ipv6>())).igmp_sk as *const _ as usize },
        664usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv6),
            "::",
            stringify!(igmp_sk)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_ipv6>())).mc_autojoin_sk as *const _ as usize },
        672usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv6),
            "::",
            stringify!(mc_autojoin_sk)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_ipv6>())).mr6_tables as *const _ as usize },
        680usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv6),
            "::",
            stringify!(mr6_tables)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_ipv6>())).mr6_rules_ops as *const _ as usize },
        696usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv6),
            "::",
            stringify!(mr6_rules_ops)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_ipv6>())).dev_addr_genid as *const _ as usize },
        704usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv6),
            "::",
            stringify!(dev_addr_genid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_ipv6>())).fib6_sernum as *const _ as usize },
        708usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv6),
            "::",
            stringify!(fib6_sernum)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_ipv6>())).seg6_data as *const _ as usize },
        712usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv6),
            "::",
            stringify!(seg6_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_ipv6>())).notifier_ops as *const _ as usize },
        720usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv6),
            "::",
            stringify!(notifier_ops)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_ipv6>())).ip6mr_notifier_ops as *const _ as usize },
        728usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv6),
            "::",
            stringify!(ip6mr_notifier_ops)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_ipv6>())).ipmr_seq as *const _ as usize },
        736usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv6),
            "::",
            stringify!(ipmr_seq)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_ipv6>())).ip6addrlbl_table as *const _ as usize },
        744usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ipv6),
            "::",
            stringify!(ip6addrlbl_table)
        )
    );
}
impl Default for netns_ipv6 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct netns_nf_frag {
    pub fqdir: *mut fqdir,
}
#[test]
fn bindgen_test_layout_netns_nf_frag() {
    assert_eq!(
        ::core::mem::size_of::<netns_nf_frag>(),
        8usize,
        concat!("Size of: ", stringify!(netns_nf_frag))
    );
    assert_eq!(
        ::core::mem::align_of::<netns_nf_frag>(),
        8usize,
        concat!("Alignment of ", stringify!(netns_nf_frag))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_nf_frag>())).fqdir as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_nf_frag),
            "::",
            stringify!(fqdir)
        )
    );
}
impl Default for netns_nf_frag {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct netns_nexthop {
    pub rb_root: rb_root,
    pub devhash: *mut hlist_head,
    pub seq: c_types::c_uint,
    pub last_id_allocated: u32_,
}
#[test]
fn bindgen_test_layout_netns_nexthop() {
    assert_eq!(
        ::core::mem::size_of::<netns_nexthop>(),
        24usize,
        concat!("Size of: ", stringify!(netns_nexthop))
    );
    assert_eq!(
        ::core::mem::align_of::<netns_nexthop>(),
        8usize,
        concat!("Alignment of ", stringify!(netns_nexthop))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_nexthop>())).rb_root as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_nexthop),
            "::",
            stringify!(rb_root)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_nexthop>())).devhash as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_nexthop),
            "::",
            stringify!(devhash)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_nexthop>())).seq as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_nexthop),
            "::",
            stringify!(seq)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<netns_nexthop>())).last_id_allocated as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_nexthop),
            "::",
            stringify!(last_id_allocated)
        )
    );
}
impl Default for netns_nexthop {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct netns_sysctl_lowpan {
    pub frags_hdr: *mut ctl_table_header,
}
#[test]
fn bindgen_test_layout_netns_sysctl_lowpan() {
    assert_eq!(
        ::core::mem::size_of::<netns_sysctl_lowpan>(),
        8usize,
        concat!("Size of: ", stringify!(netns_sysctl_lowpan))
    );
    assert_eq!(
        ::core::mem::align_of::<netns_sysctl_lowpan>(),
        8usize,
        concat!("Alignment of ", stringify!(netns_sysctl_lowpan))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_sysctl_lowpan>())).frags_hdr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_sysctl_lowpan),
            "::",
            stringify!(frags_hdr)
        )
    );
}
impl Default for netns_sysctl_lowpan {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct netns_ieee802154_lowpan {
    pub sysctl: netns_sysctl_lowpan,
    pub fqdir: *mut fqdir,
}
#[test]
fn bindgen_test_layout_netns_ieee802154_lowpan() {
    assert_eq!(
        ::core::mem::size_of::<netns_ieee802154_lowpan>(),
        16usize,
        concat!("Size of: ", stringify!(netns_ieee802154_lowpan))
    );
    assert_eq!(
        ::core::mem::align_of::<netns_ieee802154_lowpan>(),
        8usize,
        concat!("Alignment of ", stringify!(netns_ieee802154_lowpan))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_ieee802154_lowpan>())).sysctl as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ieee802154_lowpan),
            "::",
            stringify!(sysctl)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_ieee802154_lowpan>())).fqdir as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ieee802154_lowpan),
            "::",
            stringify!(fqdir)
        )
    );
}
impl Default for netns_ieee802154_lowpan {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct proc_dir_entry {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sctp_mib {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct netns_sctp {
    pub sctp_statistics: *mut sctp_mib,
    pub proc_net_sctp: *mut proc_dir_entry,
    pub sysctl_header: *mut ctl_table_header,
    pub ctl_sock: *mut sock,
    pub local_addr_list: list_head,
    pub addr_waitq: list_head,
    pub addr_wq_timer: timer_list,
    pub auto_asconf_splist: list_head,
    pub addr_wq_lock: spinlock_t,
    pub local_addr_lock: spinlock_t,
    pub rto_initial: c_types::c_uint,
    pub rto_min: c_types::c_uint,
    pub rto_max: c_types::c_uint,
    pub rto_alpha: c_types::c_int,
    pub rto_beta: c_types::c_int,
    pub max_burst: c_types::c_int,
    pub cookie_preserve_enable: c_types::c_int,
    pub sctp_hmac_alg: *mut c_types::c_char,
    pub valid_cookie_life: c_types::c_uint,
    pub sack_timeout: c_types::c_uint,
    pub hb_interval: c_types::c_uint,
    pub max_retrans_association: c_types::c_int,
    pub max_retrans_path: c_types::c_int,
    pub max_retrans_init: c_types::c_int,
    pub pf_retrans: c_types::c_int,
    pub pf_enable: c_types::c_int,
    pub sndbuf_policy: c_types::c_int,
    pub rcvbuf_policy: c_types::c_int,
    pub default_auto_asconf: c_types::c_int,
    pub addip_enable: c_types::c_int,
    pub addip_noauth: c_types::c_int,
    pub prsctp_enable: c_types::c_int,
    pub reconf_enable: c_types::c_int,
    pub auth_enable: c_types::c_int,
    pub intl_enable: c_types::c_int,
    pub ecn_enable: c_types::c_int,
    pub scope_policy: c_types::c_int,
    pub rwnd_upd_shift: c_types::c_int,
    pub max_autoclose: c_types::c_ulong,
}
#[test]
fn bindgen_test_layout_netns_sctp() {
    assert_eq!(
        ::core::mem::size_of::<netns_sctp>(),
        256usize,
        concat!("Size of: ", stringify!(netns_sctp))
    );
    assert_eq!(
        ::core::mem::align_of::<netns_sctp>(),
        8usize,
        concat!("Alignment of ", stringify!(netns_sctp))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_sctp>())).sctp_statistics as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_sctp),
            "::",
            stringify!(sctp_statistics)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_sctp>())).proc_net_sctp as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_sctp),
            "::",
            stringify!(proc_net_sctp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_sctp>())).sysctl_header as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_sctp),
            "::",
            stringify!(sysctl_header)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_sctp>())).ctl_sock as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_sctp),
            "::",
            stringify!(ctl_sock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_sctp>())).local_addr_list as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_sctp),
            "::",
            stringify!(local_addr_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_sctp>())).addr_waitq as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_sctp),
            "::",
            stringify!(addr_waitq)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_sctp>())).addr_wq_timer as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_sctp),
            "::",
            stringify!(addr_wq_timer)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_sctp>())).auto_asconf_splist as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_sctp),
            "::",
            stringify!(auto_asconf_splist)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_sctp>())).addr_wq_lock as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_sctp),
            "::",
            stringify!(addr_wq_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_sctp>())).local_addr_lock as *const _ as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_sctp),
            "::",
            stringify!(local_addr_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_sctp>())).rto_initial as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_sctp),
            "::",
            stringify!(rto_initial)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_sctp>())).rto_min as *const _ as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_sctp),
            "::",
            stringify!(rto_min)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_sctp>())).rto_max as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_sctp),
            "::",
            stringify!(rto_max)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_sctp>())).rto_alpha as *const _ as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_sctp),
            "::",
            stringify!(rto_alpha)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_sctp>())).rto_beta as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_sctp),
            "::",
            stringify!(rto_beta)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_sctp>())).max_burst as *const _ as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_sctp),
            "::",
            stringify!(max_burst)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<netns_sctp>())).cookie_preserve_enable as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_sctp),
            "::",
            stringify!(cookie_preserve_enable)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_sctp>())).sctp_hmac_alg as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_sctp),
            "::",
            stringify!(sctp_hmac_alg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_sctp>())).valid_cookie_life as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_sctp),
            "::",
            stringify!(valid_cookie_life)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_sctp>())).sack_timeout as *const _ as usize },
        172usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_sctp),
            "::",
            stringify!(sack_timeout)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_sctp>())).hb_interval as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_sctp),
            "::",
            stringify!(hb_interval)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<netns_sctp>())).max_retrans_association as *const _ as usize
        },
        180usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_sctp),
            "::",
            stringify!(max_retrans_association)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_sctp>())).max_retrans_path as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_sctp),
            "::",
            stringify!(max_retrans_path)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_sctp>())).max_retrans_init as *const _ as usize },
        188usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_sctp),
            "::",
            stringify!(max_retrans_init)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_sctp>())).pf_retrans as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_sctp),
            "::",
            stringify!(pf_retrans)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_sctp>())).pf_enable as *const _ as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_sctp),
            "::",
            stringify!(pf_enable)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_sctp>())).sndbuf_policy as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_sctp),
            "::",
            stringify!(sndbuf_policy)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_sctp>())).rcvbuf_policy as *const _ as usize },
        204usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_sctp),
            "::",
            stringify!(rcvbuf_policy)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_sctp>())).default_auto_asconf as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_sctp),
            "::",
            stringify!(default_auto_asconf)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_sctp>())).addip_enable as *const _ as usize },
        212usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_sctp),
            "::",
            stringify!(addip_enable)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_sctp>())).addip_noauth as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_sctp),
            "::",
            stringify!(addip_noauth)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_sctp>())).prsctp_enable as *const _ as usize },
        220usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_sctp),
            "::",
            stringify!(prsctp_enable)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_sctp>())).reconf_enable as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_sctp),
            "::",
            stringify!(reconf_enable)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_sctp>())).auth_enable as *const _ as usize },
        228usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_sctp),
            "::",
            stringify!(auth_enable)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_sctp>())).intl_enable as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_sctp),
            "::",
            stringify!(intl_enable)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_sctp>())).ecn_enable as *const _ as usize },
        236usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_sctp),
            "::",
            stringify!(ecn_enable)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_sctp>())).scope_policy as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_sctp),
            "::",
            stringify!(scope_policy)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_sctp>())).rwnd_upd_shift as *const _ as usize },
        244usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_sctp),
            "::",
            stringify!(rwnd_upd_shift)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_sctp>())).max_autoclose as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_sctp),
            "::",
            stringify!(max_autoclose)
        )
    );
}
impl Default for netns_sctp {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct netns_dccp {
    pub v4_ctl_sk: *mut sock,
    pub v6_ctl_sk: *mut sock,
}
#[test]
fn bindgen_test_layout_netns_dccp() {
    assert_eq!(
        ::core::mem::size_of::<netns_dccp>(),
        16usize,
        concat!("Size of: ", stringify!(netns_dccp))
    );
    assert_eq!(
        ::core::mem::align_of::<netns_dccp>(),
        8usize,
        concat!("Alignment of ", stringify!(netns_dccp))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_dccp>())).v4_ctl_sk as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_dccp),
            "::",
            stringify!(v4_ctl_sk)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_dccp>())).v6_ctl_sk as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_dccp),
            "::",
            stringify!(v6_ctl_sk)
        )
    );
}
impl Default for netns_dccp {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nf_logger {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nf_queue_handler {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct netns_nf {
    pub proc_netfilter: *mut proc_dir_entry,
    pub queue_handler: *const nf_queue_handler,
    pub nf_loggers: [*const nf_logger; 13usize],
    pub nf_log_dir_header: *mut ctl_table_header,
    pub hooks_ipv4: [*mut nf_hook_entries; 5usize],
    pub hooks_ipv6: [*mut nf_hook_entries; 5usize],
    pub hooks_arp: [*mut nf_hook_entries; 3usize],
    pub hooks_bridge: [*mut nf_hook_entries; 5usize],
    pub hooks_decnet: [*mut nf_hook_entries; 7usize],
    pub defrag_ipv4: bool_,
    pub defrag_ipv6: bool_,
}
#[test]
fn bindgen_test_layout_netns_nf() {
    assert_eq!(
        ::core::mem::size_of::<netns_nf>(),
        336usize,
        concat!("Size of: ", stringify!(netns_nf))
    );
    assert_eq!(
        ::core::mem::align_of::<netns_nf>(),
        8usize,
        concat!("Alignment of ", stringify!(netns_nf))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_nf>())).proc_netfilter as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_nf),
            "::",
            stringify!(proc_netfilter)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_nf>())).queue_handler as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_nf),
            "::",
            stringify!(queue_handler)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_nf>())).nf_loggers as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_nf),
            "::",
            stringify!(nf_loggers)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_nf>())).nf_log_dir_header as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_nf),
            "::",
            stringify!(nf_log_dir_header)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_nf>())).hooks_ipv4 as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_nf),
            "::",
            stringify!(hooks_ipv4)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_nf>())).hooks_ipv6 as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_nf),
            "::",
            stringify!(hooks_ipv6)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_nf>())).hooks_arp as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_nf),
            "::",
            stringify!(hooks_arp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_nf>())).hooks_bridge as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_nf),
            "::",
            stringify!(hooks_bridge)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_nf>())).hooks_decnet as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_nf),
            "::",
            stringify!(hooks_decnet)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_nf>())).defrag_ipv4 as *const _ as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_nf),
            "::",
            stringify!(defrag_ipv4)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_nf>())).defrag_ipv6 as *const _ as usize },
        329usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_nf),
            "::",
            stringify!(defrag_ipv6)
        )
    );
}
impl Default for netns_nf {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ebt_table {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct netns_xt {
    pub tables: [list_head; 13usize],
    pub notrack_deprecated_warning: bool_,
    pub clusterip_deprecated_warning: bool_,
    pub broute_table: *mut ebt_table,
    pub frame_filter: *mut ebt_table,
    pub frame_nat: *mut ebt_table,
}
#[test]
fn bindgen_test_layout_netns_xt() {
    assert_eq!(
        ::core::mem::size_of::<netns_xt>(),
        240usize,
        concat!("Size of: ", stringify!(netns_xt))
    );
    assert_eq!(
        ::core::mem::align_of::<netns_xt>(),
        8usize,
        concat!("Alignment of ", stringify!(netns_xt))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_xt>())).tables as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_xt),
            "::",
            stringify!(tables)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<netns_xt>())).notrack_deprecated_warning as *const _ as usize
        },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_xt),
            "::",
            stringify!(notrack_deprecated_warning)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<netns_xt>())).clusterip_deprecated_warning as *const _ as usize
        },
        209usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_xt),
            "::",
            stringify!(clusterip_deprecated_warning)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_xt>())).broute_table as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_xt),
            "::",
            stringify!(broute_table)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_xt>())).frame_filter as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_xt),
            "::",
            stringify!(frame_filter)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_xt>())).frame_nat as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_xt),
            "::",
            stringify!(frame_nat)
        )
    );
}
impl Default for netns_xt {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hlist_nulls_head {
    pub first: *mut hlist_nulls_node,
}
#[test]
fn bindgen_test_layout_hlist_nulls_head() {
    assert_eq!(
        ::core::mem::size_of::<hlist_nulls_head>(),
        8usize,
        concat!("Size of: ", stringify!(hlist_nulls_head))
    );
    assert_eq!(
        ::core::mem::align_of::<hlist_nulls_head>(),
        8usize,
        concat!("Alignment of ", stringify!(hlist_nulls_head))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hlist_nulls_head>())).first as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hlist_nulls_head),
            "::",
            stringify!(first)
        )
    );
}
impl Default for hlist_nulls_head {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hlist_nulls_node {
    pub next: *mut hlist_nulls_node,
    pub pprev: *mut *mut hlist_nulls_node,
}
#[test]
fn bindgen_test_layout_hlist_nulls_node() {
    assert_eq!(
        ::core::mem::size_of::<hlist_nulls_node>(),
        16usize,
        concat!("Size of: ", stringify!(hlist_nulls_node))
    );
    assert_eq!(
        ::core::mem::align_of::<hlist_nulls_node>(),
        8usize,
        concat!("Alignment of ", stringify!(hlist_nulls_node))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hlist_nulls_node>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hlist_nulls_node),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hlist_nulls_node>())).pprev as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hlist_nulls_node),
            "::",
            stringify!(pprev)
        )
    );
}
impl Default for hlist_nulls_node {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct nf_generic_net {
    pub timeout: c_types::c_uint,
}
#[test]
fn bindgen_test_layout_nf_generic_net() {
    assert_eq!(
        ::core::mem::size_of::<nf_generic_net>(),
        4usize,
        concat!("Size of: ", stringify!(nf_generic_net))
    );
    assert_eq!(
        ::core::mem::align_of::<nf_generic_net>(),
        4usize,
        concat!("Alignment of ", stringify!(nf_generic_net))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nf_generic_net>())).timeout as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nf_generic_net),
            "::",
            stringify!(timeout)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct nf_tcp_net {
    pub timeouts: [c_types::c_uint; 14usize],
    pub tcp_loose: c_types::c_int,
    pub tcp_be_liberal: c_types::c_int,
    pub tcp_max_retrans: c_types::c_int,
}
#[test]
fn bindgen_test_layout_nf_tcp_net() {
    assert_eq!(
        ::core::mem::size_of::<nf_tcp_net>(),
        68usize,
        concat!("Size of: ", stringify!(nf_tcp_net))
    );
    assert_eq!(
        ::core::mem::align_of::<nf_tcp_net>(),
        4usize,
        concat!("Alignment of ", stringify!(nf_tcp_net))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nf_tcp_net>())).timeouts as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nf_tcp_net),
            "::",
            stringify!(timeouts)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nf_tcp_net>())).tcp_loose as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(nf_tcp_net),
            "::",
            stringify!(tcp_loose)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nf_tcp_net>())).tcp_be_liberal as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(nf_tcp_net),
            "::",
            stringify!(tcp_be_liberal)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nf_tcp_net>())).tcp_max_retrans as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(nf_tcp_net),
            "::",
            stringify!(tcp_max_retrans)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct nf_udp_net {
    pub timeouts: [c_types::c_uint; 2usize],
}
#[test]
fn bindgen_test_layout_nf_udp_net() {
    assert_eq!(
        ::core::mem::size_of::<nf_udp_net>(),
        8usize,
        concat!("Size of: ", stringify!(nf_udp_net))
    );
    assert_eq!(
        ::core::mem::align_of::<nf_udp_net>(),
        4usize,
        concat!("Alignment of ", stringify!(nf_udp_net))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nf_udp_net>())).timeouts as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nf_udp_net),
            "::",
            stringify!(timeouts)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct nf_icmp_net {
    pub timeout: c_types::c_uint,
}
#[test]
fn bindgen_test_layout_nf_icmp_net() {
    assert_eq!(
        ::core::mem::size_of::<nf_icmp_net>(),
        4usize,
        concat!("Size of: ", stringify!(nf_icmp_net))
    );
    assert_eq!(
        ::core::mem::align_of::<nf_icmp_net>(),
        4usize,
        concat!("Alignment of ", stringify!(nf_icmp_net))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nf_icmp_net>())).timeout as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nf_icmp_net),
            "::",
            stringify!(timeout)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct nf_dccp_net {
    pub dccp_loose: c_types::c_int,
    pub dccp_timeout: [c_types::c_uint; 10usize],
}
#[test]
fn bindgen_test_layout_nf_dccp_net() {
    assert_eq!(
        ::core::mem::size_of::<nf_dccp_net>(),
        44usize,
        concat!("Size of: ", stringify!(nf_dccp_net))
    );
    assert_eq!(
        ::core::mem::align_of::<nf_dccp_net>(),
        4usize,
        concat!("Alignment of ", stringify!(nf_dccp_net))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nf_dccp_net>())).dccp_loose as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nf_dccp_net),
            "::",
            stringify!(dccp_loose)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nf_dccp_net>())).dccp_timeout as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nf_dccp_net),
            "::",
            stringify!(dccp_timeout)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct nf_sctp_net {
    pub timeouts: [c_types::c_uint; 10usize],
}
#[test]
fn bindgen_test_layout_nf_sctp_net() {
    assert_eq!(
        ::core::mem::size_of::<nf_sctp_net>(),
        40usize,
        concat!("Size of: ", stringify!(nf_sctp_net))
    );
    assert_eq!(
        ::core::mem::align_of::<nf_sctp_net>(),
        4usize,
        concat!("Alignment of ", stringify!(nf_sctp_net))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nf_sctp_net>())).timeouts as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nf_sctp_net),
            "::",
            stringify!(timeouts)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nf_gre_net {
    pub keymap_list: list_head,
    pub timeouts: [c_types::c_uint; 2usize],
}
#[test]
fn bindgen_test_layout_nf_gre_net() {
    assert_eq!(
        ::core::mem::size_of::<nf_gre_net>(),
        24usize,
        concat!("Size of: ", stringify!(nf_gre_net))
    );
    assert_eq!(
        ::core::mem::align_of::<nf_gre_net>(),
        8usize,
        concat!("Alignment of ", stringify!(nf_gre_net))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nf_gre_net>())).keymap_list as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nf_gre_net),
            "::",
            stringify!(keymap_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nf_gre_net>())).timeouts as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nf_gre_net),
            "::",
            stringify!(timeouts)
        )
    );
}
impl Default for nf_gre_net {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nf_ip_net {
    pub generic: nf_generic_net,
    pub tcp: nf_tcp_net,
    pub udp: nf_udp_net,
    pub icmp: nf_icmp_net,
    pub icmpv6: nf_icmp_net,
    pub dccp: nf_dccp_net,
    pub sctp: nf_sctp_net,
    pub gre: nf_gre_net,
}
#[test]
fn bindgen_test_layout_nf_ip_net() {
    assert_eq!(
        ::core::mem::size_of::<nf_ip_net>(),
        200usize,
        concat!("Size of: ", stringify!(nf_ip_net))
    );
    assert_eq!(
        ::core::mem::align_of::<nf_ip_net>(),
        8usize,
        concat!("Alignment of ", stringify!(nf_ip_net))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nf_ip_net>())).generic as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nf_ip_net),
            "::",
            stringify!(generic)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nf_ip_net>())).tcp as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nf_ip_net),
            "::",
            stringify!(tcp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nf_ip_net>())).udp as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(nf_ip_net),
            "::",
            stringify!(udp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nf_ip_net>())).icmp as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(nf_ip_net),
            "::",
            stringify!(icmp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nf_ip_net>())).icmpv6 as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(nf_ip_net),
            "::",
            stringify!(icmpv6)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nf_ip_net>())).dccp as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(nf_ip_net),
            "::",
            stringify!(dccp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nf_ip_net>())).sctp as *const _ as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(nf_ip_net),
            "::",
            stringify!(sctp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nf_ip_net>())).gre as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(nf_ip_net),
            "::",
            stringify!(gre)
        )
    );
}
impl Default for nf_ip_net {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ct_pcpu {
    pub lock: spinlock_t,
    pub unconfirmed: hlist_nulls_head,
    pub dying: hlist_nulls_head,
}
#[test]
fn bindgen_test_layout_ct_pcpu() {
    assert_eq!(
        ::core::mem::size_of::<ct_pcpu>(),
        24usize,
        concat!("Size of: ", stringify!(ct_pcpu))
    );
    assert_eq!(
        ::core::mem::align_of::<ct_pcpu>(),
        8usize,
        concat!("Alignment of ", stringify!(ct_pcpu))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ct_pcpu>())).lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ct_pcpu),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ct_pcpu>())).unconfirmed as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ct_pcpu),
            "::",
            stringify!(unconfirmed)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ct_pcpu>())).dying as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ct_pcpu),
            "::",
            stringify!(dying)
        )
    );
}
impl Default for ct_pcpu {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct netns_ct {
    pub count: atomic_t,
    pub expect_count: c_types::c_uint,
    pub ecache_dwork: delayed_work,
    pub ecache_dwork_pending: bool_,
    pub auto_assign_helper_warned: bool_,
    pub sysctl_header: *mut ctl_table_header,
    pub sysctl_log_invalid: c_types::c_uint,
    pub sysctl_events: c_types::c_int,
    pub sysctl_acct: c_types::c_int,
    pub sysctl_auto_assign_helper: c_types::c_int,
    pub sysctl_tstamp: c_types::c_int,
    pub sysctl_checksum: c_types::c_int,
    pub pcpu_lists: *mut ct_pcpu,
    pub stat: *mut ip_conntrack_stat,
    pub nf_conntrack_event_cb: *mut nf_ct_event_notifier,
    pub nf_expect_event_cb: *mut nf_exp_event_notifier,
    pub nf_ct_proto: nf_ip_net,
    pub labels_used: c_types::c_uint,
}
#[test]
fn bindgen_test_layout_netns_ct() {
    assert_eq!(
        ::core::mem::size_of::<netns_ct>(),
        376usize,
        concat!("Size of: ", stringify!(netns_ct))
    );
    assert_eq!(
        ::core::mem::align_of::<netns_ct>(),
        8usize,
        concat!("Alignment of ", stringify!(netns_ct))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_ct>())).count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ct),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_ct>())).expect_count as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ct),
            "::",
            stringify!(expect_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_ct>())).ecache_dwork as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ct),
            "::",
            stringify!(ecache_dwork)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_ct>())).ecache_dwork_pending as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ct),
            "::",
            stringify!(ecache_dwork_pending)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<netns_ct>())).auto_assign_helper_warned as *const _ as usize
        },
        97usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ct),
            "::",
            stringify!(auto_assign_helper_warned)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_ct>())).sysctl_header as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ct),
            "::",
            stringify!(sysctl_header)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_ct>())).sysctl_log_invalid as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ct),
            "::",
            stringify!(sysctl_log_invalid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_ct>())).sysctl_events as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ct),
            "::",
            stringify!(sysctl_events)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_ct>())).sysctl_acct as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ct),
            "::",
            stringify!(sysctl_acct)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<netns_ct>())).sysctl_auto_assign_helper as *const _ as usize
        },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ct),
            "::",
            stringify!(sysctl_auto_assign_helper)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_ct>())).sysctl_tstamp as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ct),
            "::",
            stringify!(sysctl_tstamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_ct>())).sysctl_checksum as *const _ as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ct),
            "::",
            stringify!(sysctl_checksum)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_ct>())).pcpu_lists as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ct),
            "::",
            stringify!(pcpu_lists)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_ct>())).stat as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ct),
            "::",
            stringify!(stat)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_ct>())).nf_conntrack_event_cb as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ct),
            "::",
            stringify!(nf_conntrack_event_cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_ct>())).nf_expect_event_cb as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ct),
            "::",
            stringify!(nf_expect_event_cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_ct>())).nf_ct_proto as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ct),
            "::",
            stringify!(nf_ct_proto)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_ct>())).labels_used as *const _ as usize },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_ct),
            "::",
            stringify!(labels_used)
        )
    );
}
impl Default for netns_ct {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct netns_nftables {
    pub tables: list_head,
    pub commit_list: list_head,
    pub module_list: list_head,
    pub commit_mutex: mutex,
    pub base_seq: c_types::c_uint,
    pub gencursor: u8_,
    pub validate_state: u8_,
}
#[test]
fn bindgen_test_layout_netns_nftables() {
    assert_eq!(
        ::core::mem::size_of::<netns_nftables>(),
        88usize,
        concat!("Size of: ", stringify!(netns_nftables))
    );
    assert_eq!(
        ::core::mem::align_of::<netns_nftables>(),
        8usize,
        concat!("Alignment of ", stringify!(netns_nftables))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_nftables>())).tables as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_nftables),
            "::",
            stringify!(tables)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_nftables>())).commit_list as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_nftables),
            "::",
            stringify!(commit_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_nftables>())).module_list as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_nftables),
            "::",
            stringify!(module_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_nftables>())).commit_mutex as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_nftables),
            "::",
            stringify!(commit_mutex)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_nftables>())).base_seq as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_nftables),
            "::",
            stringify!(base_seq)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_nftables>())).gencursor as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_nftables),
            "::",
            stringify!(gencursor)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_nftables>())).validate_state as *const _ as usize },
        85usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_nftables),
            "::",
            stringify!(validate_state)
        )
    );
}
impl Default for netns_nftables {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xfrm_policy_hash {
    pub table: *mut hlist_head,
    pub hmask: c_types::c_uint,
    pub dbits4: u8_,
    pub sbits4: u8_,
    pub dbits6: u8_,
    pub sbits6: u8_,
}
#[test]
fn bindgen_test_layout_xfrm_policy_hash() {
    assert_eq!(
        ::core::mem::size_of::<xfrm_policy_hash>(),
        16usize,
        concat!("Size of: ", stringify!(xfrm_policy_hash))
    );
    assert_eq!(
        ::core::mem::align_of::<xfrm_policy_hash>(),
        8usize,
        concat!("Alignment of ", stringify!(xfrm_policy_hash))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xfrm_policy_hash>())).table as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xfrm_policy_hash),
            "::",
            stringify!(table)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xfrm_policy_hash>())).hmask as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xfrm_policy_hash),
            "::",
            stringify!(hmask)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xfrm_policy_hash>())).dbits4 as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xfrm_policy_hash),
            "::",
            stringify!(dbits4)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xfrm_policy_hash>())).sbits4 as *const _ as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(xfrm_policy_hash),
            "::",
            stringify!(sbits4)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xfrm_policy_hash>())).dbits6 as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(xfrm_policy_hash),
            "::",
            stringify!(dbits6)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xfrm_policy_hash>())).sbits6 as *const _ as usize },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(xfrm_policy_hash),
            "::",
            stringify!(sbits6)
        )
    );
}
impl Default for xfrm_policy_hash {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct xfrm_policy_hthresh {
    pub work: work_struct,
    pub lock: seqlock_t,
    pub lbits4: u8_,
    pub rbits4: u8_,
    pub lbits6: u8_,
    pub rbits6: u8_,
}
#[test]
fn bindgen_test_layout_xfrm_policy_hthresh() {
    assert_eq!(
        ::core::mem::size_of::<xfrm_policy_hthresh>(),
        48usize,
        concat!("Size of: ", stringify!(xfrm_policy_hthresh))
    );
    assert_eq!(
        ::core::mem::align_of::<xfrm_policy_hthresh>(),
        8usize,
        concat!("Alignment of ", stringify!(xfrm_policy_hthresh))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xfrm_policy_hthresh>())).work as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xfrm_policy_hthresh),
            "::",
            stringify!(work)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xfrm_policy_hthresh>())).lock as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(xfrm_policy_hthresh),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xfrm_policy_hthresh>())).lbits4 as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(xfrm_policy_hthresh),
            "::",
            stringify!(lbits4)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xfrm_policy_hthresh>())).rbits4 as *const _ as usize },
        41usize,
        concat!(
            "Offset of field: ",
            stringify!(xfrm_policy_hthresh),
            "::",
            stringify!(rbits4)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xfrm_policy_hthresh>())).lbits6 as *const _ as usize },
        42usize,
        concat!(
            "Offset of field: ",
            stringify!(xfrm_policy_hthresh),
            "::",
            stringify!(lbits6)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xfrm_policy_hthresh>())).rbits6 as *const _ as usize },
        43usize,
        concat!(
            "Offset of field: ",
            stringify!(xfrm_policy_hthresh),
            "::",
            stringify!(rbits6)
        )
    );
}
impl Default for xfrm_policy_hthresh {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct netns_xfrm {
    pub state_all: list_head,
    pub state_bydst: *mut hlist_head,
    pub state_bysrc: *mut hlist_head,
    pub state_byspi: *mut hlist_head,
    pub state_hmask: c_types::c_uint,
    pub state_num: c_types::c_uint,
    pub state_hash_work: work_struct,
    pub policy_all: list_head,
    pub policy_byidx: *mut hlist_head,
    pub policy_idx_hmask: c_types::c_uint,
    pub policy_inexact: [hlist_head; 3usize],
    pub policy_bydst: [xfrm_policy_hash; 3usize],
    pub policy_count: [c_types::c_uint; 6usize],
    pub policy_hash_work: work_struct,
    pub policy_hthresh: xfrm_policy_hthresh,
    pub inexact_bins: list_head,
    pub nlsk: *mut sock,
    pub nlsk_stash: *mut sock,
    pub sysctl_aevent_etime: u32_,
    pub sysctl_aevent_rseqth: u32_,
    pub sysctl_larval_drop: c_types::c_int,
    pub sysctl_acq_expires: u32_,
    pub sysctl_hdr: *mut ctl_table_header,
    pub __bindgen_padding_0: [u64; 5usize],
    pub xfrm4_dst_ops: dst_ops,
    pub xfrm6_dst_ops: dst_ops,
    pub xfrm_state_lock: spinlock_t,
    pub xfrm_policy_lock: spinlock_t,
    pub xfrm_cfg_mutex: mutex,
}
#[test]
fn bindgen_test_layout_netns_xfrm() {
    assert_eq!(
        ::core::mem::size_of::<netns_xfrm>(),
        832usize,
        concat!("Size of: ", stringify!(netns_xfrm))
    );
    assert_eq!(
        ::core::mem::align_of::<netns_xfrm>(),
        64usize,
        concat!("Alignment of ", stringify!(netns_xfrm))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_xfrm>())).state_all as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_xfrm),
            "::",
            stringify!(state_all)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_xfrm>())).state_bydst as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_xfrm),
            "::",
            stringify!(state_bydst)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_xfrm>())).state_bysrc as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_xfrm),
            "::",
            stringify!(state_bysrc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_xfrm>())).state_byspi as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_xfrm),
            "::",
            stringify!(state_byspi)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_xfrm>())).state_hmask as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_xfrm),
            "::",
            stringify!(state_hmask)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_xfrm>())).state_num as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_xfrm),
            "::",
            stringify!(state_num)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_xfrm>())).state_hash_work as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_xfrm),
            "::",
            stringify!(state_hash_work)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_xfrm>())).policy_all as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_xfrm),
            "::",
            stringify!(policy_all)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_xfrm>())).policy_byidx as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_xfrm),
            "::",
            stringify!(policy_byidx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_xfrm>())).policy_idx_hmask as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_xfrm),
            "::",
            stringify!(policy_idx_hmask)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_xfrm>())).policy_inexact as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_xfrm),
            "::",
            stringify!(policy_inexact)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_xfrm>())).policy_bydst as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_xfrm),
            "::",
            stringify!(policy_bydst)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_xfrm>())).policy_count as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_xfrm),
            "::",
            stringify!(policy_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_xfrm>())).policy_hash_work as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_xfrm),
            "::",
            stringify!(policy_hash_work)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_xfrm>())).policy_hthresh as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_xfrm),
            "::",
            stringify!(policy_hthresh)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_xfrm>())).inexact_bins as *const _ as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_xfrm),
            "::",
            stringify!(inexact_bins)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_xfrm>())).nlsk as *const _ as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_xfrm),
            "::",
            stringify!(nlsk)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_xfrm>())).nlsk_stash as *const _ as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_xfrm),
            "::",
            stringify!(nlsk_stash)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_xfrm>())).sysctl_aevent_etime as *const _ as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_xfrm),
            "::",
            stringify!(sysctl_aevent_etime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<netns_xfrm>())).sysctl_aevent_rseqth as *const _ as usize
        },
        324usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_xfrm),
            "::",
            stringify!(sysctl_aevent_rseqth)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_xfrm>())).sysctl_larval_drop as *const _ as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_xfrm),
            "::",
            stringify!(sysctl_larval_drop)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_xfrm>())).sysctl_acq_expires as *const _ as usize },
        332usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_xfrm),
            "::",
            stringify!(sysctl_acq_expires)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_xfrm>())).sysctl_hdr as *const _ as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_xfrm),
            "::",
            stringify!(sysctl_hdr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_xfrm>())).xfrm4_dst_ops as *const _ as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_xfrm),
            "::",
            stringify!(xfrm4_dst_ops)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_xfrm>())).xfrm6_dst_ops as *const _ as usize },
        576usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_xfrm),
            "::",
            stringify!(xfrm6_dst_ops)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_xfrm>())).xfrm_state_lock as *const _ as usize },
        768usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_xfrm),
            "::",
            stringify!(xfrm_state_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_xfrm>())).xfrm_policy_lock as *const _ as usize },
        772usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_xfrm),
            "::",
            stringify!(xfrm_policy_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_xfrm>())).xfrm_cfg_mutex as *const _ as usize },
        776usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_xfrm),
            "::",
            stringify!(xfrm_cfg_mutex)
        )
    );
}
impl Default for netns_xfrm {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mpls_route {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct netns_mpls {
    pub ip_ttl_propagate: c_types::c_int,
    pub default_ttl: c_types::c_int,
    pub platform_labels: usize,
    pub platform_label: *mut *mut mpls_route,
    pub ctl: *mut ctl_table_header,
}
#[test]
fn bindgen_test_layout_netns_mpls() {
    assert_eq!(
        ::core::mem::size_of::<netns_mpls>(),
        32usize,
        concat!("Size of: ", stringify!(netns_mpls))
    );
    assert_eq!(
        ::core::mem::align_of::<netns_mpls>(),
        8usize,
        concat!("Alignment of ", stringify!(netns_mpls))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_mpls>())).ip_ttl_propagate as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_mpls),
            "::",
            stringify!(ip_ttl_propagate)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_mpls>())).default_ttl as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_mpls),
            "::",
            stringify!(default_ttl)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_mpls>())).platform_labels as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_mpls),
            "::",
            stringify!(platform_labels)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_mpls>())).platform_label as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_mpls),
            "::",
            stringify!(platform_label)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_mpls>())).ctl as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_mpls),
            "::",
            stringify!(ctl)
        )
    );
}
impl Default for netns_mpls {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct can_dev_rcv_lists {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct can_pkg_stats {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct can_rcv_lists_stats {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct netns_can {
    pub proc_dir: *mut proc_dir_entry,
    pub pde_version: *mut proc_dir_entry,
    pub pde_stats: *mut proc_dir_entry,
    pub pde_reset_stats: *mut proc_dir_entry,
    pub pde_rcvlist_all: *mut proc_dir_entry,
    pub pde_rcvlist_fil: *mut proc_dir_entry,
    pub pde_rcvlist_inv: *mut proc_dir_entry,
    pub pde_rcvlist_sff: *mut proc_dir_entry,
    pub pde_rcvlist_eff: *mut proc_dir_entry,
    pub pde_rcvlist_err: *mut proc_dir_entry,
    pub bcmproc_dir: *mut proc_dir_entry,
    pub rx_alldev_list: *mut can_dev_rcv_lists,
    pub rcvlists_lock: spinlock_t,
    pub stattimer: timer_list,
    pub pkg_stats: *mut can_pkg_stats,
    pub rcv_lists_stats: *mut can_rcv_lists_stats,
    pub cgw_list: hlist_head,
}
#[test]
fn bindgen_test_layout_netns_can() {
    assert_eq!(
        ::core::mem::size_of::<netns_can>(),
        168usize,
        concat!("Size of: ", stringify!(netns_can))
    );
    assert_eq!(
        ::core::mem::align_of::<netns_can>(),
        8usize,
        concat!("Alignment of ", stringify!(netns_can))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_can>())).proc_dir as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_can),
            "::",
            stringify!(proc_dir)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_can>())).pde_version as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_can),
            "::",
            stringify!(pde_version)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_can>())).pde_stats as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_can),
            "::",
            stringify!(pde_stats)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_can>())).pde_reset_stats as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_can),
            "::",
            stringify!(pde_reset_stats)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_can>())).pde_rcvlist_all as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_can),
            "::",
            stringify!(pde_rcvlist_all)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_can>())).pde_rcvlist_fil as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_can),
            "::",
            stringify!(pde_rcvlist_fil)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_can>())).pde_rcvlist_inv as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_can),
            "::",
            stringify!(pde_rcvlist_inv)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_can>())).pde_rcvlist_sff as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_can),
            "::",
            stringify!(pde_rcvlist_sff)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_can>())).pde_rcvlist_eff as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_can),
            "::",
            stringify!(pde_rcvlist_eff)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_can>())).pde_rcvlist_err as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_can),
            "::",
            stringify!(pde_rcvlist_err)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_can>())).bcmproc_dir as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_can),
            "::",
            stringify!(bcmproc_dir)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_can>())).rx_alldev_list as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_can),
            "::",
            stringify!(rx_alldev_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_can>())).rcvlists_lock as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_can),
            "::",
            stringify!(rcvlists_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_can>())).stattimer as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_can),
            "::",
            stringify!(stattimer)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_can>())).pkg_stats as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_can),
            "::",
            stringify!(pkg_stats)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_can>())).rcv_lists_stats as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_can),
            "::",
            stringify!(rcv_lists_stats)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_can>())).cgw_list as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_can),
            "::",
            stringify!(cgw_list)
        )
    );
}
impl Default for netns_can {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct netns_xdp {
    pub lock: mutex,
    pub list: hlist_head,
}
#[test]
fn bindgen_test_layout_netns_xdp() {
    assert_eq!(
        ::core::mem::size_of::<netns_xdp>(),
        40usize,
        concat!("Size of: ", stringify!(netns_xdp))
    );
    assert_eq!(
        ::core::mem::align_of::<netns_xdp>(),
        8usize,
        concat!("Alignment of ", stringify!(netns_xdp))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_xdp>())).lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_xdp),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netns_xdp>())).list as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(netns_xdp),
            "::",
            stringify!(list)
        )
    );
}
impl Default for netns_xdp {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct proc_ns_operations {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ns_common {
    pub stashed: atomic_long_t,
    pub ops: *const proc_ns_operations,
    pub inum: c_types::c_uint,
}
#[test]
fn bindgen_test_layout_ns_common() {
    assert_eq!(
        ::core::mem::size_of::<ns_common>(),
        24usize,
        concat!("Size of: ", stringify!(ns_common))
    );
    assert_eq!(
        ::core::mem::align_of::<ns_common>(),
        8usize,
        concat!("Alignment of ", stringify!(ns_common))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ns_common>())).stashed as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ns_common),
            "::",
            stringify!(stashed)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ns_common>())).ops as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ns_common),
            "::",
            stringify!(ops)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ns_common>())).inum as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ns_common),
            "::",
            stringify!(inum)
        )
    );
}
impl Default for ns_common {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct net_generic {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uevent_sock {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct netns_ipvs {
    _unused: [u8; 0],
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct net {
    pub passive: refcount_t,
    pub count: refcount_t,
    pub rules_mod_lock: spinlock_t,
    pub dev_unreg_count: c_types::c_uint,
    pub dev_base_seq: c_types::c_uint,
    pub ifindex: c_types::c_int,
    pub nsid_lock: spinlock_t,
    pub fnhe_genid: atomic_t,
    pub list: list_head,
    pub exit_list: list_head,
    pub cleanup_list: llist_node,
    pub key_domain: *mut key_tag,
    pub user_ns: *mut user_namespace,
    pub ucounts: *mut ucounts,
    pub netns_ids: idr,
    pub ns: ns_common,
    pub dev_base_head: list_head,
    pub proc_net: *mut proc_dir_entry,
    pub proc_net_stat: *mut proc_dir_entry,
    pub sysctls: ctl_table_set,
    pub rtnl: *mut sock,
    pub genl_sock: *mut sock,
    pub uevent_sock: *mut uevent_sock,
    pub dev_name_head: *mut hlist_head,
    pub dev_index_head: *mut hlist_head,
    pub hash_mix: u32_,
    pub loopback_dev: *mut net_device,
    pub rules_ops: list_head,
    pub core: netns_core,
    pub mib: netns_mib,
    pub packet: netns_packet,
    pub unx: netns_unix,
    pub nexthop: netns_nexthop,
    pub __bindgen_padding_0: u64,
    pub ipv4: netns_ipv4,
    pub ipv6: netns_ipv6,
    pub ieee802154_lowpan: netns_ieee802154_lowpan,
    pub sctp: netns_sctp,
    pub dccp: netns_dccp,
    pub nf: netns_nf,
    pub xt: netns_xt,
    pub ct: netns_ct,
    pub nft: netns_nftables,
    pub nf_frag: netns_nf_frag,
    pub nf_frag_frags_hdr: *mut ctl_table_header,
    pub nfnl: *mut sock,
    pub nfnl_stash: *mut sock,
    pub nfnl_acct_list: list_head,
    pub nfct_timeout_list: list_head,
    pub wext_nlevents: sk_buff_head,
    pub gen: *mut net_generic,
    pub flow_dissector_prog: *mut bpf_prog,
    pub __bindgen_padding_1: [u64; 5usize],
    pub xfrm: netns_xfrm,
    pub ipvs: *mut netns_ipvs,
    pub mpls: netns_mpls,
    pub can: netns_can,
    pub xdp: netns_xdp,
    pub crypto_nlsk: *mut sock,
    pub diag_nlsk: *mut sock,
}
#[test]
fn bindgen_test_layout_net() {
    assert_eq!(
        ::core::mem::size_of::<net>(),
        4928usize,
        concat!("Size of: ", stringify!(net))
    );
    assert_eq!(
        ::core::mem::align_of::<net>(),
        64usize,
        concat!("Alignment of ", stringify!(net))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net>())).passive as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(net),
            "::",
            stringify!(passive)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net>())).count as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(net),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net>())).rules_mod_lock as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(net),
            "::",
            stringify!(rules_mod_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net>())).dev_unreg_count as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(net),
            "::",
            stringify!(dev_unreg_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net>())).dev_base_seq as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(net),
            "::",
            stringify!(dev_base_seq)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net>())).ifindex as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(net),
            "::",
            stringify!(ifindex)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net>())).nsid_lock as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(net),
            "::",
            stringify!(nsid_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net>())).fnhe_genid as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(net),
            "::",
            stringify!(fnhe_genid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net>())).list as *const _ as usize },
        32usize,
        concat!("Offset of field: ", stringify!(net), "::", stringify!(list))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net>())).exit_list as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(net),
            "::",
            stringify!(exit_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net>())).cleanup_list as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(net),
            "::",
            stringify!(cleanup_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net>())).key_domain as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(net),
            "::",
            stringify!(key_domain)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net>())).user_ns as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(net),
            "::",
            stringify!(user_ns)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net>())).ucounts as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(net),
            "::",
            stringify!(ucounts)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net>())).netns_ids as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(net),
            "::",
            stringify!(netns_ids)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net>())).ns as *const _ as usize },
        120usize,
        concat!("Offset of field: ", stringify!(net), "::", stringify!(ns))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net>())).dev_base_head as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(net),
            "::",
            stringify!(dev_base_head)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net>())).proc_net as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(net),
            "::",
            stringify!(proc_net)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net>())).proc_net_stat as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(net),
            "::",
            stringify!(proc_net_stat)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net>())).sysctls as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(net),
            "::",
            stringify!(sysctls)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net>())).rtnl as *const _ as usize },
        272usize,
        concat!("Offset of field: ", stringify!(net), "::", stringify!(rtnl))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net>())).genl_sock as *const _ as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(net),
            "::",
            stringify!(genl_sock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net>())).uevent_sock as *const _ as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(net),
            "::",
            stringify!(uevent_sock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net>())).dev_name_head as *const _ as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(net),
            "::",
            stringify!(dev_name_head)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net>())).dev_index_head as *const _ as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(net),
            "::",
            stringify!(dev_index_head)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net>())).hash_mix as *const _ as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(net),
            "::",
            stringify!(hash_mix)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net>())).loopback_dev as *const _ as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(net),
            "::",
            stringify!(loopback_dev)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net>())).rules_ops as *const _ as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(net),
            "::",
            stringify!(rules_ops)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net>())).core as *const _ as usize },
        344usize,
        concat!("Offset of field: ", stringify!(net), "::", stringify!(core))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net>())).mib as *const _ as usize },
        376usize,
        concat!("Offset of field: ", stringify!(net), "::", stringify!(mib))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net>())).packet as *const _ as usize },
        488usize,
        concat!(
            "Offset of field: ",
            stringify!(net),
            "::",
            stringify!(packet)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net>())).unx as *const _ as usize },
        528usize,
        concat!("Offset of field: ", stringify!(net), "::", stringify!(unx))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net>())).nexthop as *const _ as usize },
        544usize,
        concat!(
            "Offset of field: ",
            stringify!(net),
            "::",
            stringify!(nexthop)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net>())).ipv4 as *const _ as usize },
        576usize,
        concat!("Offset of field: ", stringify!(net), "::", stringify!(ipv4))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net>())).ipv6 as *const _ as usize },
        1536usize,
        concat!("Offset of field: ", stringify!(net), "::", stringify!(ipv6))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net>())).ieee802154_lowpan as *const _ as usize },
        2304usize,
        concat!(
            "Offset of field: ",
            stringify!(net),
            "::",
            stringify!(ieee802154_lowpan)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net>())).sctp as *const _ as usize },
        2320usize,
        concat!("Offset of field: ", stringify!(net), "::", stringify!(sctp))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net>())).dccp as *const _ as usize },
        2576usize,
        concat!("Offset of field: ", stringify!(net), "::", stringify!(dccp))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net>())).nf as *const _ as usize },
        2592usize,
        concat!("Offset of field: ", stringify!(net), "::", stringify!(nf))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net>())).xt as *const _ as usize },
        2928usize,
        concat!("Offset of field: ", stringify!(net), "::", stringify!(xt))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net>())).ct as *const _ as usize },
        3168usize,
        concat!("Offset of field: ", stringify!(net), "::", stringify!(ct))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net>())).nft as *const _ as usize },
        3544usize,
        concat!("Offset of field: ", stringify!(net), "::", stringify!(nft))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net>())).nf_frag as *const _ as usize },
        3632usize,
        concat!(
            "Offset of field: ",
            stringify!(net),
            "::",
            stringify!(nf_frag)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net>())).nf_frag_frags_hdr as *const _ as usize },
        3640usize,
        concat!(
            "Offset of field: ",
            stringify!(net),
            "::",
            stringify!(nf_frag_frags_hdr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net>())).nfnl as *const _ as usize },
        3648usize,
        concat!("Offset of field: ", stringify!(net), "::", stringify!(nfnl))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net>())).nfnl_stash as *const _ as usize },
        3656usize,
        concat!(
            "Offset of field: ",
            stringify!(net),
            "::",
            stringify!(nfnl_stash)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net>())).nfnl_acct_list as *const _ as usize },
        3664usize,
        concat!(
            "Offset of field: ",
            stringify!(net),
            "::",
            stringify!(nfnl_acct_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net>())).nfct_timeout_list as *const _ as usize },
        3680usize,
        concat!(
            "Offset of field: ",
            stringify!(net),
            "::",
            stringify!(nfct_timeout_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net>())).wext_nlevents as *const _ as usize },
        3696usize,
        concat!(
            "Offset of field: ",
            stringify!(net),
            "::",
            stringify!(wext_nlevents)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net>())).gen as *const _ as usize },
        3720usize,
        concat!("Offset of field: ", stringify!(net), "::", stringify!(gen))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net>())).flow_dissector_prog as *const _ as usize },
        3728usize,
        concat!(
            "Offset of field: ",
            stringify!(net),
            "::",
            stringify!(flow_dissector_prog)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net>())).xfrm as *const _ as usize },
        3776usize,
        concat!("Offset of field: ", stringify!(net), "::", stringify!(xfrm))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net>())).ipvs as *const _ as usize },
        4608usize,
        concat!("Offset of field: ", stringify!(net), "::", stringify!(ipvs))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net>())).mpls as *const _ as usize },
        4616usize,
        concat!("Offset of field: ", stringify!(net), "::", stringify!(mpls))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net>())).can as *const _ as usize },
        4648usize,
        concat!("Offset of field: ", stringify!(net), "::", stringify!(can))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net>())).xdp as *const _ as usize },
        4816usize,
        concat!("Offset of field: ", stringify!(net), "::", stringify!(xdp))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net>())).crypto_nlsk as *const _ as usize },
        4856usize,
        concat!(
            "Offset of field: ",
            stringify!(net),
            "::",
            stringify!(crypto_nlsk)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net>())).diag_nlsk as *const _ as usize },
        4864usize,
        concat!(
            "Offset of field: ",
            stringify!(net),
            "::",
            stringify!(diag_nlsk)
        )
    );
}
impl Default for net {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct seq_file {
    pub buf: *mut c_types::c_char,
    pub size: usize,
    pub from: usize,
    pub count: usize,
    pub pad_until: usize,
    pub index: loff_t,
    pub read_pos: loff_t,
    pub version: u64_,
    pub lock: mutex,
    pub op: *const seq_operations,
    pub poll_event: c_types::c_int,
    pub file: *const file,
    pub private: *mut c_types::c_void,
}
#[test]
fn bindgen_test_layout_seq_file() {
    assert_eq!(
        ::core::mem::size_of::<seq_file>(),
        128usize,
        concat!("Size of: ", stringify!(seq_file))
    );
    assert_eq!(
        ::core::mem::align_of::<seq_file>(),
        8usize,
        concat!("Alignment of ", stringify!(seq_file))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<seq_file>())).buf as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(seq_file),
            "::",
            stringify!(buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<seq_file>())).size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(seq_file),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<seq_file>())).from as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(seq_file),
            "::",
            stringify!(from)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<seq_file>())).count as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(seq_file),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<seq_file>())).pad_until as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(seq_file),
            "::",
            stringify!(pad_until)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<seq_file>())).index as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(seq_file),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<seq_file>())).read_pos as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(seq_file),
            "::",
            stringify!(read_pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<seq_file>())).version as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(seq_file),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<seq_file>())).lock as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(seq_file),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<seq_file>())).op as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(seq_file),
            "::",
            stringify!(op)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<seq_file>())).poll_event as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(seq_file),
            "::",
            stringify!(poll_event)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<seq_file>())).file as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(seq_file),
            "::",
            stringify!(file)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<seq_file>())).private as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(seq_file),
            "::",
            stringify!(private)
        )
    );
}
impl Default for seq_file {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct possible_net_t {
    pub net: *mut net,
}
#[test]
fn bindgen_test_layout_possible_net_t() {
    assert_eq!(
        ::core::mem::size_of::<possible_net_t>(),
        8usize,
        concat!("Size of: ", stringify!(possible_net_t))
    );
    assert_eq!(
        ::core::mem::align_of::<possible_net_t>(),
        8usize,
        concat!("Alignment of ", stringify!(possible_net_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<possible_net_t>())).net as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(possible_net_t),
            "::",
            stringify!(net)
        )
    );
}
impl Default for possible_net_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ieee_ets {
    pub willing: __u8,
    pub ets_cap: __u8,
    pub cbs: __u8,
    pub tc_tx_bw: [__u8; 8usize],
    pub tc_rx_bw: [__u8; 8usize],
    pub tc_tsa: [__u8; 8usize],
    pub prio_tc: [__u8; 8usize],
    pub tc_reco_bw: [__u8; 8usize],
    pub tc_reco_tsa: [__u8; 8usize],
    pub reco_prio_tc: [__u8; 8usize],
}
#[test]
fn bindgen_test_layout_ieee_ets() {
    assert_eq!(
        ::core::mem::size_of::<ieee_ets>(),
        59usize,
        concat!("Size of: ", stringify!(ieee_ets))
    );
    assert_eq!(
        ::core::mem::align_of::<ieee_ets>(),
        1usize,
        concat!("Alignment of ", stringify!(ieee_ets))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ieee_ets>())).willing as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ieee_ets),
            "::",
            stringify!(willing)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ieee_ets>())).ets_cap as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(ieee_ets),
            "::",
            stringify!(ets_cap)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ieee_ets>())).cbs as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ieee_ets),
            "::",
            stringify!(cbs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ieee_ets>())).tc_tx_bw as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(ieee_ets),
            "::",
            stringify!(tc_tx_bw)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ieee_ets>())).tc_rx_bw as *const _ as usize },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(ieee_ets),
            "::",
            stringify!(tc_rx_bw)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ieee_ets>())).tc_tsa as *const _ as usize },
        19usize,
        concat!(
            "Offset of field: ",
            stringify!(ieee_ets),
            "::",
            stringify!(tc_tsa)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ieee_ets>())).prio_tc as *const _ as usize },
        27usize,
        concat!(
            "Offset of field: ",
            stringify!(ieee_ets),
            "::",
            stringify!(prio_tc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ieee_ets>())).tc_reco_bw as *const _ as usize },
        35usize,
        concat!(
            "Offset of field: ",
            stringify!(ieee_ets),
            "::",
            stringify!(tc_reco_bw)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ieee_ets>())).tc_reco_tsa as *const _ as usize },
        43usize,
        concat!(
            "Offset of field: ",
            stringify!(ieee_ets),
            "::",
            stringify!(tc_reco_tsa)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ieee_ets>())).reco_prio_tc as *const _ as usize },
        51usize,
        concat!(
            "Offset of field: ",
            stringify!(ieee_ets),
            "::",
            stringify!(reco_prio_tc)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ieee_maxrate {
    pub tc_maxrate: [__u64; 8usize],
}
#[test]
fn bindgen_test_layout_ieee_maxrate() {
    assert_eq!(
        ::core::mem::size_of::<ieee_maxrate>(),
        64usize,
        concat!("Size of: ", stringify!(ieee_maxrate))
    );
    assert_eq!(
        ::core::mem::align_of::<ieee_maxrate>(),
        8usize,
        concat!("Alignment of ", stringify!(ieee_maxrate))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ieee_maxrate>())).tc_maxrate as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ieee_maxrate),
            "::",
            stringify!(tc_maxrate)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ieee_qcn {
    pub rpg_enable: [__u8; 8usize],
    pub rppp_max_rps: [__u32; 8usize],
    pub rpg_time_reset: [__u32; 8usize],
    pub rpg_byte_reset: [__u32; 8usize],
    pub rpg_threshold: [__u32; 8usize],
    pub rpg_max_rate: [__u32; 8usize],
    pub rpg_ai_rate: [__u32; 8usize],
    pub rpg_hai_rate: [__u32; 8usize],
    pub rpg_gd: [__u32; 8usize],
    pub rpg_min_dec_fac: [__u32; 8usize],
    pub rpg_min_rate: [__u32; 8usize],
    pub cndd_state_machine: [__u32; 8usize],
}
#[test]
fn bindgen_test_layout_ieee_qcn() {
    assert_eq!(
        ::core::mem::size_of::<ieee_qcn>(),
        360usize,
        concat!("Size of: ", stringify!(ieee_qcn))
    );
    assert_eq!(
        ::core::mem::align_of::<ieee_qcn>(),
        4usize,
        concat!("Alignment of ", stringify!(ieee_qcn))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ieee_qcn>())).rpg_enable as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ieee_qcn),
            "::",
            stringify!(rpg_enable)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ieee_qcn>())).rppp_max_rps as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ieee_qcn),
            "::",
            stringify!(rppp_max_rps)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ieee_qcn>())).rpg_time_reset as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ieee_qcn),
            "::",
            stringify!(rpg_time_reset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ieee_qcn>())).rpg_byte_reset as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(ieee_qcn),
            "::",
            stringify!(rpg_byte_reset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ieee_qcn>())).rpg_threshold as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(ieee_qcn),
            "::",
            stringify!(rpg_threshold)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ieee_qcn>())).rpg_max_rate as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(ieee_qcn),
            "::",
            stringify!(rpg_max_rate)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ieee_qcn>())).rpg_ai_rate as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(ieee_qcn),
            "::",
            stringify!(rpg_ai_rate)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ieee_qcn>())).rpg_hai_rate as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(ieee_qcn),
            "::",
            stringify!(rpg_hai_rate)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ieee_qcn>())).rpg_gd as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(ieee_qcn),
            "::",
            stringify!(rpg_gd)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ieee_qcn>())).rpg_min_dec_fac as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(ieee_qcn),
            "::",
            stringify!(rpg_min_dec_fac)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ieee_qcn>())).rpg_min_rate as *const _ as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(ieee_qcn),
            "::",
            stringify!(rpg_min_rate)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ieee_qcn>())).cndd_state_machine as *const _ as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(ieee_qcn),
            "::",
            stringify!(cndd_state_machine)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ieee_qcn_stats {
    pub rppp_rp_centiseconds: [__u64; 8usize],
    pub rppp_created_rps: [__u32; 8usize],
}
#[test]
fn bindgen_test_layout_ieee_qcn_stats() {
    assert_eq!(
        ::core::mem::size_of::<ieee_qcn_stats>(),
        96usize,
        concat!("Size of: ", stringify!(ieee_qcn_stats))
    );
    assert_eq!(
        ::core::mem::align_of::<ieee_qcn_stats>(),
        8usize,
        concat!("Alignment of ", stringify!(ieee_qcn_stats))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ieee_qcn_stats>())).rppp_rp_centiseconds as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ieee_qcn_stats),
            "::",
            stringify!(rppp_rp_centiseconds)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ieee_qcn_stats>())).rppp_created_rps as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(ieee_qcn_stats),
            "::",
            stringify!(rppp_created_rps)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ieee_pfc {
    pub pfc_cap: __u8,
    pub pfc_en: __u8,
    pub mbc: __u8,
    pub delay: __u16,
    pub requests: [__u64; 8usize],
    pub indications: [__u64; 8usize],
}
#[test]
fn bindgen_test_layout_ieee_pfc() {
    assert_eq!(
        ::core::mem::size_of::<ieee_pfc>(),
        136usize,
        concat!("Size of: ", stringify!(ieee_pfc))
    );
    assert_eq!(
        ::core::mem::align_of::<ieee_pfc>(),
        8usize,
        concat!("Alignment of ", stringify!(ieee_pfc))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ieee_pfc>())).pfc_cap as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ieee_pfc),
            "::",
            stringify!(pfc_cap)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ieee_pfc>())).pfc_en as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(ieee_pfc),
            "::",
            stringify!(pfc_en)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ieee_pfc>())).mbc as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ieee_pfc),
            "::",
            stringify!(mbc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ieee_pfc>())).delay as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ieee_pfc),
            "::",
            stringify!(delay)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ieee_pfc>())).requests as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ieee_pfc),
            "::",
            stringify!(requests)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ieee_pfc>())).indications as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(ieee_pfc),
            "::",
            stringify!(indications)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct dcbnl_buffer {
    pub prio2buffer: [__u8; 8usize],
    pub buffer_size: [__u32; 8usize],
    pub total_size: __u32,
}
#[test]
fn bindgen_test_layout_dcbnl_buffer() {
    assert_eq!(
        ::core::mem::size_of::<dcbnl_buffer>(),
        44usize,
        concat!("Size of: ", stringify!(dcbnl_buffer))
    );
    assert_eq!(
        ::core::mem::align_of::<dcbnl_buffer>(),
        4usize,
        concat!("Alignment of ", stringify!(dcbnl_buffer))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dcbnl_buffer>())).prio2buffer as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dcbnl_buffer),
            "::",
            stringify!(prio2buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dcbnl_buffer>())).buffer_size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(dcbnl_buffer),
            "::",
            stringify!(buffer_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dcbnl_buffer>())).total_size as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(dcbnl_buffer),
            "::",
            stringify!(total_size)
        )
    );
}
#[doc = " struct cee_pg - CEE Priority-Group managed object"]
#[doc = ""]
#[doc = " @willing: willing bit in the PG tlv"]
#[doc = " @error: error bit in the PG tlv"]
#[doc = " @pg_en: enable bit of the PG feature"]
#[doc = " @tcs_supported: number of traffic classes supported"]
#[doc = " @pg_bw: bandwidth percentage for each priority group"]
#[doc = " @prio_pg: priority to PG mapping indexed by priority"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct cee_pg {
    pub willing: __u8,
    pub error: __u8,
    pub pg_en: __u8,
    pub tcs_supported: __u8,
    pub pg_bw: [__u8; 8usize],
    pub prio_pg: [__u8; 8usize],
}
#[test]
fn bindgen_test_layout_cee_pg() {
    assert_eq!(
        ::core::mem::size_of::<cee_pg>(),
        20usize,
        concat!("Size of: ", stringify!(cee_pg))
    );
    assert_eq!(
        ::core::mem::align_of::<cee_pg>(),
        1usize,
        concat!("Alignment of ", stringify!(cee_pg))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cee_pg>())).willing as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cee_pg),
            "::",
            stringify!(willing)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cee_pg>())).error as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(cee_pg),
            "::",
            stringify!(error)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cee_pg>())).pg_en as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(cee_pg),
            "::",
            stringify!(pg_en)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cee_pg>())).tcs_supported as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(cee_pg),
            "::",
            stringify!(tcs_supported)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cee_pg>())).pg_bw as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cee_pg),
            "::",
            stringify!(pg_bw)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cee_pg>())).prio_pg as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cee_pg),
            "::",
            stringify!(prio_pg)
        )
    );
}
#[doc = " struct cee_pfc - CEE PFC managed object"]
#[doc = ""]
#[doc = " @willing: willing bit in the PFC tlv"]
#[doc = " @error: error bit in the PFC tlv"]
#[doc = " @pfc_en: bitmap indicating pfc enabled traffic classes"]
#[doc = " @tcs_supported: number of traffic classes supported"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct cee_pfc {
    pub willing: __u8,
    pub error: __u8,
    pub pfc_en: __u8,
    pub tcs_supported: __u8,
}
#[test]
fn bindgen_test_layout_cee_pfc() {
    assert_eq!(
        ::core::mem::size_of::<cee_pfc>(),
        4usize,
        concat!("Size of: ", stringify!(cee_pfc))
    );
    assert_eq!(
        ::core::mem::align_of::<cee_pfc>(),
        1usize,
        concat!("Alignment of ", stringify!(cee_pfc))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cee_pfc>())).willing as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cee_pfc),
            "::",
            stringify!(willing)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cee_pfc>())).error as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(cee_pfc),
            "::",
            stringify!(error)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cee_pfc>())).pfc_en as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(cee_pfc),
            "::",
            stringify!(pfc_en)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cee_pfc>())).tcs_supported as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(cee_pfc),
            "::",
            stringify!(tcs_supported)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct dcb_app {
    pub selector: __u8,
    pub priority: __u8,
    pub protocol: __u16,
}
#[test]
fn bindgen_test_layout_dcb_app() {
    assert_eq!(
        ::core::mem::size_of::<dcb_app>(),
        4usize,
        concat!("Size of: ", stringify!(dcb_app))
    );
    assert_eq!(
        ::core::mem::align_of::<dcb_app>(),
        2usize,
        concat!("Alignment of ", stringify!(dcb_app))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dcb_app>())).selector as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dcb_app),
            "::",
            stringify!(selector)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dcb_app>())).priority as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(dcb_app),
            "::",
            stringify!(priority)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dcb_app>())).protocol as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(dcb_app),
            "::",
            stringify!(protocol)
        )
    );
}
#[doc = " struct dcb_peer_app_info - APP feature information sent by the peer"]
#[doc = ""]
#[doc = " @willing: willing bit in the peer APP tlv"]
#[doc = " @error: error bit in the peer APP tlv"]
#[doc = ""]
#[doc = " In addition to this information the full peer APP tlv also contains"]
#[doc = " a table of 'app_count' APP objects defined above."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct dcb_peer_app_info {
    pub willing: __u8,
    pub error: __u8,
}
#[test]
fn bindgen_test_layout_dcb_peer_app_info() {
    assert_eq!(
        ::core::mem::size_of::<dcb_peer_app_info>(),
        2usize,
        concat!("Size of: ", stringify!(dcb_peer_app_info))
    );
    assert_eq!(
        ::core::mem::align_of::<dcb_peer_app_info>(),
        1usize,
        concat!("Alignment of ", stringify!(dcb_peer_app_info))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dcb_peer_app_info>())).willing as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dcb_peer_app_info),
            "::",
            stringify!(willing)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dcb_peer_app_info>())).error as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(dcb_peer_app_info),
            "::",
            stringify!(error)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct dcbnl_rtnl_ops {
    pub ieee_getets: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut ieee_ets) -> c_types::c_int,
    >,
    pub ieee_setets: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut ieee_ets) -> c_types::c_int,
    >,
    pub ieee_getmaxrate: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut ieee_maxrate) -> c_types::c_int,
    >,
    pub ieee_setmaxrate: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut ieee_maxrate) -> c_types::c_int,
    >,
    pub ieee_getqcn: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut ieee_qcn) -> c_types::c_int,
    >,
    pub ieee_setqcn: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut ieee_qcn) -> c_types::c_int,
    >,
    pub ieee_getqcnstats: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut ieee_qcn_stats) -> c_types::c_int,
    >,
    pub ieee_getpfc: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut ieee_pfc) -> c_types::c_int,
    >,
    pub ieee_setpfc: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut ieee_pfc) -> c_types::c_int,
    >,
    pub ieee_getapp: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut dcb_app) -> c_types::c_int,
    >,
    pub ieee_setapp: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut dcb_app) -> c_types::c_int,
    >,
    pub ieee_delapp: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut dcb_app) -> c_types::c_int,
    >,
    pub ieee_peer_getets: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut ieee_ets) -> c_types::c_int,
    >,
    pub ieee_peer_getpfc: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut ieee_pfc) -> c_types::c_int,
    >,
    pub getstate: ::core::option::Option<unsafe extern "C" fn(arg1: *mut net_device) -> u8_>,
    pub setstate:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut net_device, arg2: u8_) -> u8_>,
    pub getpermhwaddr:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut u8_)>,
    pub setpgtccfgtx: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: c_types::c_int,
            arg3: u8_,
            arg4: u8_,
            arg5: u8_,
            arg6: u8_,
        ),
    >,
    pub setpgbwgcfgtx: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: c_types::c_int, arg3: u8_),
    >,
    pub setpgtccfgrx: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: c_types::c_int,
            arg3: u8_,
            arg4: u8_,
            arg5: u8_,
            arg6: u8_,
        ),
    >,
    pub setpgbwgcfgrx: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: c_types::c_int, arg3: u8_),
    >,
    pub getpgtccfgtx: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: c_types::c_int,
            arg3: *mut u8_,
            arg4: *mut u8_,
            arg5: *mut u8_,
            arg6: *mut u8_,
        ),
    >,
    pub getpgbwgcfgtx: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: c_types::c_int, arg3: *mut u8_),
    >,
    pub getpgtccfgrx: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: c_types::c_int,
            arg3: *mut u8_,
            arg4: *mut u8_,
            arg5: *mut u8_,
            arg6: *mut u8_,
        ),
    >,
    pub getpgbwgcfgrx: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: c_types::c_int, arg3: *mut u8_),
    >,
    pub setpfccfg: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: c_types::c_int, arg3: u8_),
    >,
    pub getpfccfg: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: c_types::c_int, arg3: *mut u8_),
    >,
    pub setall: ::core::option::Option<unsafe extern "C" fn(arg1: *mut net_device) -> u8_>,
    pub getcap: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: c_types::c_int, arg3: *mut u8_) -> u8_,
    >,
    pub getnumtcs: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: c_types::c_int,
            arg3: *mut u8_,
        ) -> c_types::c_int,
    >,
    pub setnumtcs: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: c_types::c_int,
            arg3: u8_,
        ) -> c_types::c_int,
    >,
    pub getpfcstate: ::core::option::Option<unsafe extern "C" fn(arg1: *mut net_device) -> u8_>,
    pub setpfcstate: ::core::option::Option<unsafe extern "C" fn(arg1: *mut net_device, arg2: u8_)>,
    pub getbcncfg: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: c_types::c_int, arg3: *mut u32_),
    >,
    pub setbcncfg: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: c_types::c_int, arg3: u32_),
    >,
    pub getbcnrp: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: c_types::c_int, arg3: *mut u8_),
    >,
    pub setbcnrp: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: c_types::c_int, arg3: u8_),
    >,
    pub setapp: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: u8_,
            arg3: u16_,
            arg4: u8_,
        ) -> c_types::c_int,
    >,
    pub getapp: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: u8_, arg3: u16_) -> c_types::c_int,
    >,
    pub getfeatcfg: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: c_types::c_int, arg3: *mut u8_) -> u8_,
    >,
    pub setfeatcfg: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: c_types::c_int, arg3: u8_) -> u8_,
    >,
    pub getdcbx: ::core::option::Option<unsafe extern "C" fn(arg1: *mut net_device) -> u8_>,
    pub setdcbx:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut net_device, arg2: u8_) -> u8_>,
    pub peer_getappinfo: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut dcb_peer_app_info,
            arg3: *mut u16_,
        ) -> c_types::c_int,
    >,
    pub peer_getapptable: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut dcb_app) -> c_types::c_int,
    >,
    pub cee_peer_getpg: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut cee_pg) -> c_types::c_int,
    >,
    pub cee_peer_getpfc: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut cee_pfc) -> c_types::c_int,
    >,
    pub dcbnl_getbuffer: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut dcbnl_buffer) -> c_types::c_int,
    >,
    pub dcbnl_setbuffer: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut dcbnl_buffer) -> c_types::c_int,
    >,
}
#[test]
fn bindgen_test_layout_dcbnl_rtnl_ops() {
    assert_eq!(
        ::core::mem::size_of::<dcbnl_rtnl_ops>(),
        392usize,
        concat!("Size of: ", stringify!(dcbnl_rtnl_ops))
    );
    assert_eq!(
        ::core::mem::align_of::<dcbnl_rtnl_ops>(),
        8usize,
        concat!("Alignment of ", stringify!(dcbnl_rtnl_ops))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dcbnl_rtnl_ops>())).ieee_getets as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dcbnl_rtnl_ops),
            "::",
            stringify!(ieee_getets)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dcbnl_rtnl_ops>())).ieee_setets as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(dcbnl_rtnl_ops),
            "::",
            stringify!(ieee_setets)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dcbnl_rtnl_ops>())).ieee_getmaxrate as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(dcbnl_rtnl_ops),
            "::",
            stringify!(ieee_getmaxrate)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dcbnl_rtnl_ops>())).ieee_setmaxrate as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(dcbnl_rtnl_ops),
            "::",
            stringify!(ieee_setmaxrate)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dcbnl_rtnl_ops>())).ieee_getqcn as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(dcbnl_rtnl_ops),
            "::",
            stringify!(ieee_getqcn)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dcbnl_rtnl_ops>())).ieee_setqcn as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(dcbnl_rtnl_ops),
            "::",
            stringify!(ieee_setqcn)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<dcbnl_rtnl_ops>())).ieee_getqcnstats as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(dcbnl_rtnl_ops),
            "::",
            stringify!(ieee_getqcnstats)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dcbnl_rtnl_ops>())).ieee_getpfc as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(dcbnl_rtnl_ops),
            "::",
            stringify!(ieee_getpfc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dcbnl_rtnl_ops>())).ieee_setpfc as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(dcbnl_rtnl_ops),
            "::",
            stringify!(ieee_setpfc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dcbnl_rtnl_ops>())).ieee_getapp as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(dcbnl_rtnl_ops),
            "::",
            stringify!(ieee_getapp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dcbnl_rtnl_ops>())).ieee_setapp as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(dcbnl_rtnl_ops),
            "::",
            stringify!(ieee_setapp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dcbnl_rtnl_ops>())).ieee_delapp as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(dcbnl_rtnl_ops),
            "::",
            stringify!(ieee_delapp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<dcbnl_rtnl_ops>())).ieee_peer_getets as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(dcbnl_rtnl_ops),
            "::",
            stringify!(ieee_peer_getets)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<dcbnl_rtnl_ops>())).ieee_peer_getpfc as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(dcbnl_rtnl_ops),
            "::",
            stringify!(ieee_peer_getpfc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dcbnl_rtnl_ops>())).getstate as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(dcbnl_rtnl_ops),
            "::",
            stringify!(getstate)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dcbnl_rtnl_ops>())).setstate as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(dcbnl_rtnl_ops),
            "::",
            stringify!(setstate)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dcbnl_rtnl_ops>())).getpermhwaddr as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(dcbnl_rtnl_ops),
            "::",
            stringify!(getpermhwaddr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dcbnl_rtnl_ops>())).setpgtccfgtx as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(dcbnl_rtnl_ops),
            "::",
            stringify!(setpgtccfgtx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dcbnl_rtnl_ops>())).setpgbwgcfgtx as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(dcbnl_rtnl_ops),
            "::",
            stringify!(setpgbwgcfgtx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dcbnl_rtnl_ops>())).setpgtccfgrx as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(dcbnl_rtnl_ops),
            "::",
            stringify!(setpgtccfgrx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dcbnl_rtnl_ops>())).setpgbwgcfgrx as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(dcbnl_rtnl_ops),
            "::",
            stringify!(setpgbwgcfgrx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dcbnl_rtnl_ops>())).getpgtccfgtx as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(dcbnl_rtnl_ops),
            "::",
            stringify!(getpgtccfgtx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dcbnl_rtnl_ops>())).getpgbwgcfgtx as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(dcbnl_rtnl_ops),
            "::",
            stringify!(getpgbwgcfgtx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dcbnl_rtnl_ops>())).getpgtccfgrx as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(dcbnl_rtnl_ops),
            "::",
            stringify!(getpgtccfgrx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dcbnl_rtnl_ops>())).getpgbwgcfgrx as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(dcbnl_rtnl_ops),
            "::",
            stringify!(getpgbwgcfgrx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dcbnl_rtnl_ops>())).setpfccfg as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(dcbnl_rtnl_ops),
            "::",
            stringify!(setpfccfg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dcbnl_rtnl_ops>())).getpfccfg as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(dcbnl_rtnl_ops),
            "::",
            stringify!(getpfccfg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dcbnl_rtnl_ops>())).setall as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(dcbnl_rtnl_ops),
            "::",
            stringify!(setall)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dcbnl_rtnl_ops>())).getcap as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(dcbnl_rtnl_ops),
            "::",
            stringify!(getcap)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dcbnl_rtnl_ops>())).getnumtcs as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(dcbnl_rtnl_ops),
            "::",
            stringify!(getnumtcs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dcbnl_rtnl_ops>())).setnumtcs as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(dcbnl_rtnl_ops),
            "::",
            stringify!(setnumtcs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dcbnl_rtnl_ops>())).getpfcstate as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(dcbnl_rtnl_ops),
            "::",
            stringify!(getpfcstate)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dcbnl_rtnl_ops>())).setpfcstate as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(dcbnl_rtnl_ops),
            "::",
            stringify!(setpfcstate)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dcbnl_rtnl_ops>())).getbcncfg as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(dcbnl_rtnl_ops),
            "::",
            stringify!(getbcncfg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dcbnl_rtnl_ops>())).setbcncfg as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(dcbnl_rtnl_ops),
            "::",
            stringify!(setbcncfg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dcbnl_rtnl_ops>())).getbcnrp as *const _ as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(dcbnl_rtnl_ops),
            "::",
            stringify!(getbcnrp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dcbnl_rtnl_ops>())).setbcnrp as *const _ as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(dcbnl_rtnl_ops),
            "::",
            stringify!(setbcnrp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dcbnl_rtnl_ops>())).setapp as *const _ as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(dcbnl_rtnl_ops),
            "::",
            stringify!(setapp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dcbnl_rtnl_ops>())).getapp as *const _ as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(dcbnl_rtnl_ops),
            "::",
            stringify!(getapp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dcbnl_rtnl_ops>())).getfeatcfg as *const _ as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(dcbnl_rtnl_ops),
            "::",
            stringify!(getfeatcfg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dcbnl_rtnl_ops>())).setfeatcfg as *const _ as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(dcbnl_rtnl_ops),
            "::",
            stringify!(setfeatcfg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dcbnl_rtnl_ops>())).getdcbx as *const _ as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(dcbnl_rtnl_ops),
            "::",
            stringify!(getdcbx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dcbnl_rtnl_ops>())).setdcbx as *const _ as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(dcbnl_rtnl_ops),
            "::",
            stringify!(setdcbx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dcbnl_rtnl_ops>())).peer_getappinfo as *const _ as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(dcbnl_rtnl_ops),
            "::",
            stringify!(peer_getappinfo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<dcbnl_rtnl_ops>())).peer_getapptable as *const _ as usize
        },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(dcbnl_rtnl_ops),
            "::",
            stringify!(peer_getapptable)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dcbnl_rtnl_ops>())).cee_peer_getpg as *const _ as usize },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(dcbnl_rtnl_ops),
            "::",
            stringify!(cee_peer_getpg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dcbnl_rtnl_ops>())).cee_peer_getpfc as *const _ as usize },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(dcbnl_rtnl_ops),
            "::",
            stringify!(cee_peer_getpfc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dcbnl_rtnl_ops>())).dcbnl_getbuffer as *const _ as usize },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(dcbnl_rtnl_ops),
            "::",
            stringify!(dcbnl_getbuffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dcbnl_rtnl_ops>())).dcbnl_setbuffer as *const _ as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(dcbnl_rtnl_ops),
            "::",
            stringify!(dcbnl_setbuffer)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct taskstats {
    pub version: __u16,
    pub ac_exitcode: __u32,
    pub ac_flag: __u8,
    pub ac_nice: __u8,
    pub cpu_count: __u64,
    pub cpu_delay_total: __u64,
    pub blkio_count: __u64,
    pub blkio_delay_total: __u64,
    pub swapin_count: __u64,
    pub swapin_delay_total: __u64,
    pub cpu_run_real_total: __u64,
    pub cpu_run_virtual_total: __u64,
    pub ac_comm: [c_types::c_char; 32usize],
    pub ac_sched: __u8,
    pub ac_pad: [__u8; 3usize],
    pub __bindgen_padding_0: u32,
    pub ac_uid: __u32,
    pub ac_gid: __u32,
    pub ac_pid: __u32,
    pub ac_ppid: __u32,
    pub ac_btime: __u32,
    pub ac_etime: __u64,
    pub ac_utime: __u64,
    pub ac_stime: __u64,
    pub ac_minflt: __u64,
    pub ac_majflt: __u64,
    pub coremem: __u64,
    pub virtmem: __u64,
    pub hiwater_rss: __u64,
    pub hiwater_vm: __u64,
    pub read_char: __u64,
    pub write_char: __u64,
    pub read_syscalls: __u64,
    pub write_syscalls: __u64,
    pub read_bytes: __u64,
    pub write_bytes: __u64,
    pub cancelled_write_bytes: __u64,
    pub nvcsw: __u64,
    pub nivcsw: __u64,
    pub ac_utimescaled: __u64,
    pub ac_stimescaled: __u64,
    pub cpu_scaled_run_real_total: __u64,
    pub freepages_count: __u64,
    pub freepages_delay_total: __u64,
    pub thrashing_count: __u64,
    pub thrashing_delay_total: __u64,
}
#[test]
fn bindgen_test_layout_taskstats() {
    assert_eq!(
        ::core::mem::size_of::<taskstats>(),
        344usize,
        concat!("Size of: ", stringify!(taskstats))
    );
    assert_eq!(
        ::core::mem::align_of::<taskstats>(),
        8usize,
        concat!("Alignment of ", stringify!(taskstats))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<taskstats>())).version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(taskstats),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<taskstats>())).ac_exitcode as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(taskstats),
            "::",
            stringify!(ac_exitcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<taskstats>())).ac_flag as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(taskstats),
            "::",
            stringify!(ac_flag)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<taskstats>())).ac_nice as *const _ as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(taskstats),
            "::",
            stringify!(ac_nice)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<taskstats>())).cpu_count as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(taskstats),
            "::",
            stringify!(cpu_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<taskstats>())).cpu_delay_total as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(taskstats),
            "::",
            stringify!(cpu_delay_total)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<taskstats>())).blkio_count as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(taskstats),
            "::",
            stringify!(blkio_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<taskstats>())).blkio_delay_total as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(taskstats),
            "::",
            stringify!(blkio_delay_total)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<taskstats>())).swapin_count as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(taskstats),
            "::",
            stringify!(swapin_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<taskstats>())).swapin_delay_total as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(taskstats),
            "::",
            stringify!(swapin_delay_total)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<taskstats>())).cpu_run_real_total as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(taskstats),
            "::",
            stringify!(cpu_run_real_total)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<taskstats>())).cpu_run_virtual_total as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(taskstats),
            "::",
            stringify!(cpu_run_virtual_total)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<taskstats>())).ac_comm as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(taskstats),
            "::",
            stringify!(ac_comm)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<taskstats>())).ac_sched as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(taskstats),
            "::",
            stringify!(ac_sched)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<taskstats>())).ac_pad as *const _ as usize },
        113usize,
        concat!(
            "Offset of field: ",
            stringify!(taskstats),
            "::",
            stringify!(ac_pad)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<taskstats>())).ac_uid as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(taskstats),
            "::",
            stringify!(ac_uid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<taskstats>())).ac_gid as *const _ as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(taskstats),
            "::",
            stringify!(ac_gid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<taskstats>())).ac_pid as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(taskstats),
            "::",
            stringify!(ac_pid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<taskstats>())).ac_ppid as *const _ as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(taskstats),
            "::",
            stringify!(ac_ppid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<taskstats>())).ac_btime as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(taskstats),
            "::",
            stringify!(ac_btime)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<taskstats>())).ac_etime as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(taskstats),
            "::",
            stringify!(ac_etime)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<taskstats>())).ac_utime as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(taskstats),
            "::",
            stringify!(ac_utime)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<taskstats>())).ac_stime as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(taskstats),
            "::",
            stringify!(ac_stime)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<taskstats>())).ac_minflt as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(taskstats),
            "::",
            stringify!(ac_minflt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<taskstats>())).ac_majflt as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(taskstats),
            "::",
            stringify!(ac_majflt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<taskstats>())).coremem as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(taskstats),
            "::",
            stringify!(coremem)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<taskstats>())).virtmem as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(taskstats),
            "::",
            stringify!(virtmem)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<taskstats>())).hiwater_rss as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(taskstats),
            "::",
            stringify!(hiwater_rss)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<taskstats>())).hiwater_vm as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(taskstats),
            "::",
            stringify!(hiwater_vm)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<taskstats>())).read_char as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(taskstats),
            "::",
            stringify!(read_char)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<taskstats>())).write_char as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(taskstats),
            "::",
            stringify!(write_char)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<taskstats>())).read_syscalls as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(taskstats),
            "::",
            stringify!(read_syscalls)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<taskstats>())).write_syscalls as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(taskstats),
            "::",
            stringify!(write_syscalls)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<taskstats>())).read_bytes as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(taskstats),
            "::",
            stringify!(read_bytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<taskstats>())).write_bytes as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(taskstats),
            "::",
            stringify!(write_bytes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<taskstats>())).cancelled_write_bytes as *const _ as usize
        },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(taskstats),
            "::",
            stringify!(cancelled_write_bytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<taskstats>())).nvcsw as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(taskstats),
            "::",
            stringify!(nvcsw)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<taskstats>())).nivcsw as *const _ as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(taskstats),
            "::",
            stringify!(nivcsw)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<taskstats>())).ac_utimescaled as *const _ as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(taskstats),
            "::",
            stringify!(ac_utimescaled)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<taskstats>())).ac_stimescaled as *const _ as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(taskstats),
            "::",
            stringify!(ac_stimescaled)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<taskstats>())).cpu_scaled_run_real_total as *const _ as usize
        },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(taskstats),
            "::",
            stringify!(cpu_scaled_run_real_total)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<taskstats>())).freepages_count as *const _ as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(taskstats),
            "::",
            stringify!(freepages_count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<taskstats>())).freepages_delay_total as *const _ as usize
        },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(taskstats),
            "::",
            stringify!(freepages_delay_total)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<taskstats>())).thrashing_count as *const _ as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(taskstats),
            "::",
            stringify!(thrashing_count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<taskstats>())).thrashing_delay_total as *const _ as usize
        },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(taskstats),
            "::",
            stringify!(thrashing_delay_total)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct uid_gid_extent {
    pub first: u32_,
    pub lower_first: u32_,
    pub count: u32_,
}
#[test]
fn bindgen_test_layout_uid_gid_extent() {
    assert_eq!(
        ::core::mem::size_of::<uid_gid_extent>(),
        12usize,
        concat!("Size of: ", stringify!(uid_gid_extent))
    );
    assert_eq!(
        ::core::mem::align_of::<uid_gid_extent>(),
        4usize,
        concat!("Alignment of ", stringify!(uid_gid_extent))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<uid_gid_extent>())).first as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uid_gid_extent),
            "::",
            stringify!(first)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<uid_gid_extent>())).lower_first as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(uid_gid_extent),
            "::",
            stringify!(lower_first)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<uid_gid_extent>())).count as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uid_gid_extent),
            "::",
            stringify!(count)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct uid_gid_map {
    pub nr_extents: u32_,
    pub __bindgen_anon_1: uid_gid_map__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union uid_gid_map__bindgen_ty_1 {
    pub extent: [uid_gid_extent; 5usize],
    pub __bindgen_anon_1: uid_gid_map__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: [u64; 8usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uid_gid_map__bindgen_ty_1__bindgen_ty_1 {
    pub forward: *mut uid_gid_extent,
    pub reverse: *mut uid_gid_extent,
}
#[test]
fn bindgen_test_layout_uid_gid_map__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<uid_gid_map__bindgen_ty_1__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(uid_gid_map__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<uid_gid_map__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(uid_gid_map__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<uid_gid_map__bindgen_ty_1__bindgen_ty_1>())).forward as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uid_gid_map__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(forward)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<uid_gid_map__bindgen_ty_1__bindgen_ty_1>())).reverse as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uid_gid_map__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(reverse)
        )
    );
}
impl Default for uid_gid_map__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_uid_gid_map__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<uid_gid_map__bindgen_ty_1>(),
        64usize,
        concat!("Size of: ", stringify!(uid_gid_map__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<uid_gid_map__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(uid_gid_map__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<uid_gid_map__bindgen_ty_1>())).extent as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uid_gid_map__bindgen_ty_1),
            "::",
            stringify!(extent)
        )
    );
}
impl Default for uid_gid_map__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_uid_gid_map() {
    assert_eq!(
        ::core::mem::size_of::<uid_gid_map>(),
        72usize,
        concat!("Size of: ", stringify!(uid_gid_map))
    );
    assert_eq!(
        ::core::mem::align_of::<uid_gid_map>(),
        8usize,
        concat!("Alignment of ", stringify!(uid_gid_map))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<uid_gid_map>())).nr_extents as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uid_gid_map),
            "::",
            stringify!(nr_extents)
        )
    );
}
impl Default for uid_gid_map {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ucounts {
    pub node: hlist_node,
    pub ns: *mut user_namespace,
    pub uid: kuid_t,
    pub count: c_types::c_int,
    pub ucount: [atomic_t; 9usize],
}
#[test]
fn bindgen_test_layout_ucounts() {
    assert_eq!(
        ::core::mem::size_of::<ucounts>(),
        72usize,
        concat!("Size of: ", stringify!(ucounts))
    );
    assert_eq!(
        ::core::mem::align_of::<ucounts>(),
        8usize,
        concat!("Alignment of ", stringify!(ucounts))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ucounts>())).node as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ucounts),
            "::",
            stringify!(node)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ucounts>())).ns as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ucounts),
            "::",
            stringify!(ns)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ucounts>())).uid as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ucounts),
            "::",
            stringify!(uid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ucounts>())).count as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ucounts),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ucounts>())).ucount as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ucounts),
            "::",
            stringify!(ucount)
        )
    );
}
impl Default for ucounts {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct bpf_insn {
    pub code: __u8,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub off: __s16,
    pub imm: __s32,
}
#[test]
fn bindgen_test_layout_bpf_insn() {
    assert_eq!(
        ::core::mem::size_of::<bpf_insn>(),
        8usize,
        concat!("Size of: ", stringify!(bpf_insn))
    );
    assert_eq!(
        ::core::mem::align_of::<bpf_insn>(),
        4usize,
        concat!("Alignment of ", stringify!(bpf_insn))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_insn>())).code as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_insn),
            "::",
            stringify!(code)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_insn>())).off as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_insn),
            "::",
            stringify!(off)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_insn>())).imm as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_insn),
            "::",
            stringify!(imm)
        )
    );
}
impl bpf_insn {
    #[inline]
    pub fn dst_reg(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_dst_reg(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn src_reg(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_src_reg(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(dst_reg: __u8, src_reg: __u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let dst_reg: u8 = unsafe { ::core::mem::transmute(dst_reg) };
            dst_reg as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let src_reg: u8 = unsafe { ::core::mem::transmute(src_reg) };
            src_reg as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct bpf_cgroup_storage_key {
    pub cgroup_inode_id: __u64,
    pub attach_type: __u32,
}
#[test]
fn bindgen_test_layout_bpf_cgroup_storage_key() {
    assert_eq!(
        ::core::mem::size_of::<bpf_cgroup_storage_key>(),
        16usize,
        concat!("Size of: ", stringify!(bpf_cgroup_storage_key))
    );
    assert_eq!(
        ::core::mem::align_of::<bpf_cgroup_storage_key>(),
        8usize,
        concat!("Alignment of ", stringify!(bpf_cgroup_storage_key))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bpf_cgroup_storage_key>())).cgroup_inode_id as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_cgroup_storage_key),
            "::",
            stringify!(cgroup_inode_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bpf_cgroup_storage_key>())).attach_type as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_cgroup_storage_key),
            "::",
            stringify!(attach_type)
        )
    );
}
pub const bpf_map_type_BPF_MAP_TYPE_UNSPEC: bpf_map_type = 0;
pub const bpf_map_type_BPF_MAP_TYPE_HASH: bpf_map_type = 1;
pub const bpf_map_type_BPF_MAP_TYPE_ARRAY: bpf_map_type = 2;
pub const bpf_map_type_BPF_MAP_TYPE_PROG_ARRAY: bpf_map_type = 3;
pub const bpf_map_type_BPF_MAP_TYPE_PERF_EVENT_ARRAY: bpf_map_type = 4;
pub const bpf_map_type_BPF_MAP_TYPE_PERCPU_HASH: bpf_map_type = 5;
pub const bpf_map_type_BPF_MAP_TYPE_PERCPU_ARRAY: bpf_map_type = 6;
pub const bpf_map_type_BPF_MAP_TYPE_STACK_TRACE: bpf_map_type = 7;
pub const bpf_map_type_BPF_MAP_TYPE_CGROUP_ARRAY: bpf_map_type = 8;
pub const bpf_map_type_BPF_MAP_TYPE_LRU_HASH: bpf_map_type = 9;
pub const bpf_map_type_BPF_MAP_TYPE_LRU_PERCPU_HASH: bpf_map_type = 10;
pub const bpf_map_type_BPF_MAP_TYPE_LPM_TRIE: bpf_map_type = 11;
pub const bpf_map_type_BPF_MAP_TYPE_ARRAY_OF_MAPS: bpf_map_type = 12;
pub const bpf_map_type_BPF_MAP_TYPE_HASH_OF_MAPS: bpf_map_type = 13;
pub const bpf_map_type_BPF_MAP_TYPE_DEVMAP: bpf_map_type = 14;
pub const bpf_map_type_BPF_MAP_TYPE_SOCKMAP: bpf_map_type = 15;
pub const bpf_map_type_BPF_MAP_TYPE_CPUMAP: bpf_map_type = 16;
pub const bpf_map_type_BPF_MAP_TYPE_XSKMAP: bpf_map_type = 17;
pub const bpf_map_type_BPF_MAP_TYPE_SOCKHASH: bpf_map_type = 18;
pub const bpf_map_type_BPF_MAP_TYPE_CGROUP_STORAGE: bpf_map_type = 19;
pub const bpf_map_type_BPF_MAP_TYPE_REUSEPORT_SOCKARRAY: bpf_map_type = 20;
pub const bpf_map_type_BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE: bpf_map_type = 21;
pub const bpf_map_type_BPF_MAP_TYPE_QUEUE: bpf_map_type = 22;
pub const bpf_map_type_BPF_MAP_TYPE_STACK: bpf_map_type = 23;
pub const bpf_map_type_BPF_MAP_TYPE_SK_STORAGE: bpf_map_type = 24;
pub const bpf_map_type_BPF_MAP_TYPE_DEVMAP_HASH: bpf_map_type = 25;
pub type bpf_map_type = c_types::c_uint;
pub const bpf_prog_type_BPF_PROG_TYPE_UNSPEC: bpf_prog_type = 0;
pub const bpf_prog_type_BPF_PROG_TYPE_SOCKET_FILTER: bpf_prog_type = 1;
pub const bpf_prog_type_BPF_PROG_TYPE_KPROBE: bpf_prog_type = 2;
pub const bpf_prog_type_BPF_PROG_TYPE_SCHED_CLS: bpf_prog_type = 3;
pub const bpf_prog_type_BPF_PROG_TYPE_SCHED_ACT: bpf_prog_type = 4;
pub const bpf_prog_type_BPF_PROG_TYPE_TRACEPOINT: bpf_prog_type = 5;
pub const bpf_prog_type_BPF_PROG_TYPE_XDP: bpf_prog_type = 6;
pub const bpf_prog_type_BPF_PROG_TYPE_PERF_EVENT: bpf_prog_type = 7;
pub const bpf_prog_type_BPF_PROG_TYPE_CGROUP_SKB: bpf_prog_type = 8;
pub const bpf_prog_type_BPF_PROG_TYPE_CGROUP_SOCK: bpf_prog_type = 9;
pub const bpf_prog_type_BPF_PROG_TYPE_LWT_IN: bpf_prog_type = 10;
pub const bpf_prog_type_BPF_PROG_TYPE_LWT_OUT: bpf_prog_type = 11;
pub const bpf_prog_type_BPF_PROG_TYPE_LWT_XMIT: bpf_prog_type = 12;
pub const bpf_prog_type_BPF_PROG_TYPE_SOCK_OPS: bpf_prog_type = 13;
pub const bpf_prog_type_BPF_PROG_TYPE_SK_SKB: bpf_prog_type = 14;
pub const bpf_prog_type_BPF_PROG_TYPE_CGROUP_DEVICE: bpf_prog_type = 15;
pub const bpf_prog_type_BPF_PROG_TYPE_SK_MSG: bpf_prog_type = 16;
pub const bpf_prog_type_BPF_PROG_TYPE_RAW_TRACEPOINT: bpf_prog_type = 17;
pub const bpf_prog_type_BPF_PROG_TYPE_CGROUP_SOCK_ADDR: bpf_prog_type = 18;
pub const bpf_prog_type_BPF_PROG_TYPE_LWT_SEG6LOCAL: bpf_prog_type = 19;
pub const bpf_prog_type_BPF_PROG_TYPE_LIRC_MODE2: bpf_prog_type = 20;
pub const bpf_prog_type_BPF_PROG_TYPE_SK_REUSEPORT: bpf_prog_type = 21;
pub const bpf_prog_type_BPF_PROG_TYPE_FLOW_DISSECTOR: bpf_prog_type = 22;
pub const bpf_prog_type_BPF_PROG_TYPE_CGROUP_SYSCTL: bpf_prog_type = 23;
pub const bpf_prog_type_BPF_PROG_TYPE_RAW_TRACEPOINT_WRITABLE: bpf_prog_type = 24;
pub const bpf_prog_type_BPF_PROG_TYPE_CGROUP_SOCKOPT: bpf_prog_type = 25;
pub type bpf_prog_type = c_types::c_uint;
pub const bpf_attach_type_BPF_CGROUP_INET_INGRESS: bpf_attach_type = 0;
pub const bpf_attach_type_BPF_CGROUP_INET_EGRESS: bpf_attach_type = 1;
pub const bpf_attach_type_BPF_CGROUP_INET_SOCK_CREATE: bpf_attach_type = 2;
pub const bpf_attach_type_BPF_CGROUP_SOCK_OPS: bpf_attach_type = 3;
pub const bpf_attach_type_BPF_SK_SKB_STREAM_PARSER: bpf_attach_type = 4;
pub const bpf_attach_type_BPF_SK_SKB_STREAM_VERDICT: bpf_attach_type = 5;
pub const bpf_attach_type_BPF_CGROUP_DEVICE: bpf_attach_type = 6;
pub const bpf_attach_type_BPF_SK_MSG_VERDICT: bpf_attach_type = 7;
pub const bpf_attach_type_BPF_CGROUP_INET4_BIND: bpf_attach_type = 8;
pub const bpf_attach_type_BPF_CGROUP_INET6_BIND: bpf_attach_type = 9;
pub const bpf_attach_type_BPF_CGROUP_INET4_CONNECT: bpf_attach_type = 10;
pub const bpf_attach_type_BPF_CGROUP_INET6_CONNECT: bpf_attach_type = 11;
pub const bpf_attach_type_BPF_CGROUP_INET4_POST_BIND: bpf_attach_type = 12;
pub const bpf_attach_type_BPF_CGROUP_INET6_POST_BIND: bpf_attach_type = 13;
pub const bpf_attach_type_BPF_CGROUP_UDP4_SENDMSG: bpf_attach_type = 14;
pub const bpf_attach_type_BPF_CGROUP_UDP6_SENDMSG: bpf_attach_type = 15;
pub const bpf_attach_type_BPF_LIRC_MODE2: bpf_attach_type = 16;
pub const bpf_attach_type_BPF_FLOW_DISSECTOR: bpf_attach_type = 17;
pub const bpf_attach_type_BPF_CGROUP_SYSCTL: bpf_attach_type = 18;
pub const bpf_attach_type_BPF_CGROUP_UDP4_RECVMSG: bpf_attach_type = 19;
pub const bpf_attach_type_BPF_CGROUP_UDP6_RECVMSG: bpf_attach_type = 20;
pub const bpf_attach_type_BPF_CGROUP_GETSOCKOPT: bpf_attach_type = 21;
pub const bpf_attach_type_BPF_CGROUP_SETSOCKOPT: bpf_attach_type = 22;
pub const bpf_attach_type___MAX_BPF_ATTACH_TYPE: bpf_attach_type = 23;
pub type bpf_attach_type = c_types::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_attr {
    pub __bindgen_anon_1: bpf_attr__bindgen_ty_1,
    pub __bindgen_anon_2: bpf_attr__bindgen_ty_2,
    pub __bindgen_anon_3: bpf_attr__bindgen_ty_3,
    pub __bindgen_anon_4: bpf_attr__bindgen_ty_4,
    pub __bindgen_anon_5: bpf_attr__bindgen_ty_5,
    pub test: bpf_attr__bindgen_ty_6,
    pub __bindgen_anon_6: bpf_attr__bindgen_ty_7,
    pub info: bpf_attr__bindgen_ty_8,
    pub query: bpf_attr__bindgen_ty_9,
    pub raw_tracepoint: bpf_attr__bindgen_ty_10,
    pub __bindgen_anon_7: bpf_attr__bindgen_ty_11,
    pub task_fd_query: bpf_attr__bindgen_ty_12,
    _bindgen_union_align: [u64; 14usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct bpf_attr__bindgen_ty_1 {
    pub map_type: __u32,
    pub key_size: __u32,
    pub value_size: __u32,
    pub max_entries: __u32,
    pub map_flags: __u32,
    pub inner_map_fd: __u32,
    pub numa_node: __u32,
    pub map_name: [c_types::c_char; 16usize],
    pub map_ifindex: __u32,
    pub btf_fd: __u32,
    pub btf_key_type_id: __u32,
    pub btf_value_type_id: __u32,
}
#[test]
fn bindgen_test_layout_bpf_attr__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<bpf_attr__bindgen_ty_1>(),
        60usize,
        concat!("Size of: ", stringify!(bpf_attr__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<bpf_attr__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(bpf_attr__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bpf_attr__bindgen_ty_1>())).map_type as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_attr__bindgen_ty_1),
            "::",
            stringify!(map_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bpf_attr__bindgen_ty_1>())).key_size as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_attr__bindgen_ty_1),
            "::",
            stringify!(key_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bpf_attr__bindgen_ty_1>())).value_size as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_attr__bindgen_ty_1),
            "::",
            stringify!(value_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bpf_attr__bindgen_ty_1>())).max_entries as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_attr__bindgen_ty_1),
            "::",
            stringify!(max_entries)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bpf_attr__bindgen_ty_1>())).map_flags as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_attr__bindgen_ty_1),
            "::",
            stringify!(map_flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bpf_attr__bindgen_ty_1>())).inner_map_fd as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_attr__bindgen_ty_1),
            "::",
            stringify!(inner_map_fd)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bpf_attr__bindgen_ty_1>())).numa_node as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_attr__bindgen_ty_1),
            "::",
            stringify!(numa_node)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bpf_attr__bindgen_ty_1>())).map_name as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_attr__bindgen_ty_1),
            "::",
            stringify!(map_name)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bpf_attr__bindgen_ty_1>())).map_ifindex as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_attr__bindgen_ty_1),
            "::",
            stringify!(map_ifindex)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_attr__bindgen_ty_1>())).btf_fd as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_attr__bindgen_ty_1),
            "::",
            stringify!(btf_fd)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bpf_attr__bindgen_ty_1>())).btf_key_type_id as *const _ as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_attr__bindgen_ty_1),
            "::",
            stringify!(btf_key_type_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bpf_attr__bindgen_ty_1>())).btf_value_type_id as *const _
                as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_attr__bindgen_ty_1),
            "::",
            stringify!(btf_value_type_id)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_attr__bindgen_ty_2 {
    pub map_fd: __u32,
    pub key: __u64,
    pub __bindgen_anon_1: bpf_attr__bindgen_ty_2__bindgen_ty_1,
    pub flags: __u64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_attr__bindgen_ty_2__bindgen_ty_1 {
    pub value: __u64,
    pub next_key: __u64,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_bpf_attr__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<bpf_attr__bindgen_ty_2__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(bpf_attr__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<bpf_attr__bindgen_ty_2__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(bpf_attr__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bpf_attr__bindgen_ty_2__bindgen_ty_1>())).value as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_attr__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bpf_attr__bindgen_ty_2__bindgen_ty_1>())).next_key as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_attr__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(next_key)
        )
    );
}
impl Default for bpf_attr__bindgen_ty_2__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_bpf_attr__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<bpf_attr__bindgen_ty_2>(),
        32usize,
        concat!("Size of: ", stringify!(bpf_attr__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<bpf_attr__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(bpf_attr__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_attr__bindgen_ty_2>())).map_fd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_attr__bindgen_ty_2),
            "::",
            stringify!(map_fd)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_attr__bindgen_ty_2>())).key as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_attr__bindgen_ty_2),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_attr__bindgen_ty_2>())).flags as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_attr__bindgen_ty_2),
            "::",
            stringify!(flags)
        )
    );
}
impl Default for bpf_attr__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct bpf_attr__bindgen_ty_3 {
    pub prog_type: __u32,
    pub insn_cnt: __u32,
    pub insns: __u64,
    pub license: __u64,
    pub log_level: __u32,
    pub log_size: __u32,
    pub log_buf: __u64,
    pub kern_version: __u32,
    pub prog_flags: __u32,
    pub prog_name: [c_types::c_char; 16usize],
    pub prog_ifindex: __u32,
    pub expected_attach_type: __u32,
    pub prog_btf_fd: __u32,
    pub func_info_rec_size: __u32,
    pub func_info: __u64,
    pub func_info_cnt: __u32,
    pub line_info_rec_size: __u32,
    pub line_info: __u64,
    pub line_info_cnt: __u32,
}
#[test]
fn bindgen_test_layout_bpf_attr__bindgen_ty_3() {
    assert_eq!(
        ::core::mem::size_of::<bpf_attr__bindgen_ty_3>(),
        112usize,
        concat!("Size of: ", stringify!(bpf_attr__bindgen_ty_3))
    );
    assert_eq!(
        ::core::mem::align_of::<bpf_attr__bindgen_ty_3>(),
        8usize,
        concat!("Alignment of ", stringify!(bpf_attr__bindgen_ty_3))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bpf_attr__bindgen_ty_3>())).prog_type as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_attr__bindgen_ty_3),
            "::",
            stringify!(prog_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bpf_attr__bindgen_ty_3>())).insn_cnt as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_attr__bindgen_ty_3),
            "::",
            stringify!(insn_cnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_attr__bindgen_ty_3>())).insns as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_attr__bindgen_ty_3),
            "::",
            stringify!(insns)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_attr__bindgen_ty_3>())).license as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_attr__bindgen_ty_3),
            "::",
            stringify!(license)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bpf_attr__bindgen_ty_3>())).log_level as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_attr__bindgen_ty_3),
            "::",
            stringify!(log_level)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bpf_attr__bindgen_ty_3>())).log_size as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_attr__bindgen_ty_3),
            "::",
            stringify!(log_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_attr__bindgen_ty_3>())).log_buf as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_attr__bindgen_ty_3),
            "::",
            stringify!(log_buf)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bpf_attr__bindgen_ty_3>())).kern_version as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_attr__bindgen_ty_3),
            "::",
            stringify!(kern_version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bpf_attr__bindgen_ty_3>())).prog_flags as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_attr__bindgen_ty_3),
            "::",
            stringify!(prog_flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bpf_attr__bindgen_ty_3>())).prog_name as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_attr__bindgen_ty_3),
            "::",
            stringify!(prog_name)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bpf_attr__bindgen_ty_3>())).prog_ifindex as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_attr__bindgen_ty_3),
            "::",
            stringify!(prog_ifindex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bpf_attr__bindgen_ty_3>())).expected_attach_type as *const _
                as usize
        },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_attr__bindgen_ty_3),
            "::",
            stringify!(expected_attach_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bpf_attr__bindgen_ty_3>())).prog_btf_fd as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_attr__bindgen_ty_3),
            "::",
            stringify!(prog_btf_fd)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bpf_attr__bindgen_ty_3>())).func_info_rec_size as *const _
                as usize
        },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_attr__bindgen_ty_3),
            "::",
            stringify!(func_info_rec_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bpf_attr__bindgen_ty_3>())).func_info as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_attr__bindgen_ty_3),
            "::",
            stringify!(func_info)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bpf_attr__bindgen_ty_3>())).func_info_cnt as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_attr__bindgen_ty_3),
            "::",
            stringify!(func_info_cnt)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bpf_attr__bindgen_ty_3>())).line_info_rec_size as *const _
                as usize
        },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_attr__bindgen_ty_3),
            "::",
            stringify!(line_info_rec_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bpf_attr__bindgen_ty_3>())).line_info as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_attr__bindgen_ty_3),
            "::",
            stringify!(line_info)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bpf_attr__bindgen_ty_3>())).line_info_cnt as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_attr__bindgen_ty_3),
            "::",
            stringify!(line_info_cnt)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct bpf_attr__bindgen_ty_4 {
    pub pathname: __u64,
    pub bpf_fd: __u32,
    pub file_flags: __u32,
}
#[test]
fn bindgen_test_layout_bpf_attr__bindgen_ty_4() {
    assert_eq!(
        ::core::mem::size_of::<bpf_attr__bindgen_ty_4>(),
        16usize,
        concat!("Size of: ", stringify!(bpf_attr__bindgen_ty_4))
    );
    assert_eq!(
        ::core::mem::align_of::<bpf_attr__bindgen_ty_4>(),
        8usize,
        concat!("Alignment of ", stringify!(bpf_attr__bindgen_ty_4))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bpf_attr__bindgen_ty_4>())).pathname as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_attr__bindgen_ty_4),
            "::",
            stringify!(pathname)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_attr__bindgen_ty_4>())).bpf_fd as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_attr__bindgen_ty_4),
            "::",
            stringify!(bpf_fd)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bpf_attr__bindgen_ty_4>())).file_flags as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_attr__bindgen_ty_4),
            "::",
            stringify!(file_flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct bpf_attr__bindgen_ty_5 {
    pub target_fd: __u32,
    pub attach_bpf_fd: __u32,
    pub attach_type: __u32,
    pub attach_flags: __u32,
}
#[test]
fn bindgen_test_layout_bpf_attr__bindgen_ty_5() {
    assert_eq!(
        ::core::mem::size_of::<bpf_attr__bindgen_ty_5>(),
        16usize,
        concat!("Size of: ", stringify!(bpf_attr__bindgen_ty_5))
    );
    assert_eq!(
        ::core::mem::align_of::<bpf_attr__bindgen_ty_5>(),
        4usize,
        concat!("Alignment of ", stringify!(bpf_attr__bindgen_ty_5))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bpf_attr__bindgen_ty_5>())).target_fd as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_attr__bindgen_ty_5),
            "::",
            stringify!(target_fd)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bpf_attr__bindgen_ty_5>())).attach_bpf_fd as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_attr__bindgen_ty_5),
            "::",
            stringify!(attach_bpf_fd)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bpf_attr__bindgen_ty_5>())).attach_type as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_attr__bindgen_ty_5),
            "::",
            stringify!(attach_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bpf_attr__bindgen_ty_5>())).attach_flags as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_attr__bindgen_ty_5),
            "::",
            stringify!(attach_flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct bpf_attr__bindgen_ty_6 {
    pub prog_fd: __u32,
    pub retval: __u32,
    pub data_size_in: __u32,
    pub data_size_out: __u32,
    pub data_in: __u64,
    pub data_out: __u64,
    pub repeat: __u32,
    pub duration: __u32,
    pub ctx_size_in: __u32,
    pub ctx_size_out: __u32,
    pub ctx_in: __u64,
    pub ctx_out: __u64,
}
#[test]
fn bindgen_test_layout_bpf_attr__bindgen_ty_6() {
    assert_eq!(
        ::core::mem::size_of::<bpf_attr__bindgen_ty_6>(),
        64usize,
        concat!("Size of: ", stringify!(bpf_attr__bindgen_ty_6))
    );
    assert_eq!(
        ::core::mem::align_of::<bpf_attr__bindgen_ty_6>(),
        8usize,
        concat!("Alignment of ", stringify!(bpf_attr__bindgen_ty_6))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_attr__bindgen_ty_6>())).prog_fd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_attr__bindgen_ty_6),
            "::",
            stringify!(prog_fd)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_attr__bindgen_ty_6>())).retval as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_attr__bindgen_ty_6),
            "::",
            stringify!(retval)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bpf_attr__bindgen_ty_6>())).data_size_in as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_attr__bindgen_ty_6),
            "::",
            stringify!(data_size_in)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bpf_attr__bindgen_ty_6>())).data_size_out as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_attr__bindgen_ty_6),
            "::",
            stringify!(data_size_out)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_attr__bindgen_ty_6>())).data_in as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_attr__bindgen_ty_6),
            "::",
            stringify!(data_in)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bpf_attr__bindgen_ty_6>())).data_out as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_attr__bindgen_ty_6),
            "::",
            stringify!(data_out)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_attr__bindgen_ty_6>())).repeat as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_attr__bindgen_ty_6),
            "::",
            stringify!(repeat)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bpf_attr__bindgen_ty_6>())).duration as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_attr__bindgen_ty_6),
            "::",
            stringify!(duration)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bpf_attr__bindgen_ty_6>())).ctx_size_in as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_attr__bindgen_ty_6),
            "::",
            stringify!(ctx_size_in)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bpf_attr__bindgen_ty_6>())).ctx_size_out as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_attr__bindgen_ty_6),
            "::",
            stringify!(ctx_size_out)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_attr__bindgen_ty_6>())).ctx_in as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_attr__bindgen_ty_6),
            "::",
            stringify!(ctx_in)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_attr__bindgen_ty_6>())).ctx_out as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_attr__bindgen_ty_6),
            "::",
            stringify!(ctx_out)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_attr__bindgen_ty_7 {
    pub __bindgen_anon_1: bpf_attr__bindgen_ty_7__bindgen_ty_1,
    pub next_id: __u32,
    pub open_flags: __u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_attr__bindgen_ty_7__bindgen_ty_1 {
    pub start_id: __u32,
    pub prog_id: __u32,
    pub map_id: __u32,
    pub btf_id: __u32,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_bpf_attr__bindgen_ty_7__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<bpf_attr__bindgen_ty_7__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(bpf_attr__bindgen_ty_7__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<bpf_attr__bindgen_ty_7__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(bpf_attr__bindgen_ty_7__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bpf_attr__bindgen_ty_7__bindgen_ty_1>())).start_id as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_attr__bindgen_ty_7__bindgen_ty_1),
            "::",
            stringify!(start_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bpf_attr__bindgen_ty_7__bindgen_ty_1>())).prog_id as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_attr__bindgen_ty_7__bindgen_ty_1),
            "::",
            stringify!(prog_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bpf_attr__bindgen_ty_7__bindgen_ty_1>())).map_id as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_attr__bindgen_ty_7__bindgen_ty_1),
            "::",
            stringify!(map_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bpf_attr__bindgen_ty_7__bindgen_ty_1>())).btf_id as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_attr__bindgen_ty_7__bindgen_ty_1),
            "::",
            stringify!(btf_id)
        )
    );
}
impl Default for bpf_attr__bindgen_ty_7__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_bpf_attr__bindgen_ty_7() {
    assert_eq!(
        ::core::mem::size_of::<bpf_attr__bindgen_ty_7>(),
        12usize,
        concat!("Size of: ", stringify!(bpf_attr__bindgen_ty_7))
    );
    assert_eq!(
        ::core::mem::align_of::<bpf_attr__bindgen_ty_7>(),
        4usize,
        concat!("Alignment of ", stringify!(bpf_attr__bindgen_ty_7))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_attr__bindgen_ty_7>())).next_id as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_attr__bindgen_ty_7),
            "::",
            stringify!(next_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bpf_attr__bindgen_ty_7>())).open_flags as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_attr__bindgen_ty_7),
            "::",
            stringify!(open_flags)
        )
    );
}
impl Default for bpf_attr__bindgen_ty_7 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct bpf_attr__bindgen_ty_8 {
    pub bpf_fd: __u32,
    pub info_len: __u32,
    pub info: __u64,
}
#[test]
fn bindgen_test_layout_bpf_attr__bindgen_ty_8() {
    assert_eq!(
        ::core::mem::size_of::<bpf_attr__bindgen_ty_8>(),
        16usize,
        concat!("Size of: ", stringify!(bpf_attr__bindgen_ty_8))
    );
    assert_eq!(
        ::core::mem::align_of::<bpf_attr__bindgen_ty_8>(),
        8usize,
        concat!("Alignment of ", stringify!(bpf_attr__bindgen_ty_8))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_attr__bindgen_ty_8>())).bpf_fd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_attr__bindgen_ty_8),
            "::",
            stringify!(bpf_fd)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bpf_attr__bindgen_ty_8>())).info_len as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_attr__bindgen_ty_8),
            "::",
            stringify!(info_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_attr__bindgen_ty_8>())).info as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_attr__bindgen_ty_8),
            "::",
            stringify!(info)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct bpf_attr__bindgen_ty_9 {
    pub target_fd: __u32,
    pub attach_type: __u32,
    pub query_flags: __u32,
    pub attach_flags: __u32,
    pub prog_ids: __u64,
    pub prog_cnt: __u32,
}
#[test]
fn bindgen_test_layout_bpf_attr__bindgen_ty_9() {
    assert_eq!(
        ::core::mem::size_of::<bpf_attr__bindgen_ty_9>(),
        32usize,
        concat!("Size of: ", stringify!(bpf_attr__bindgen_ty_9))
    );
    assert_eq!(
        ::core::mem::align_of::<bpf_attr__bindgen_ty_9>(),
        8usize,
        concat!("Alignment of ", stringify!(bpf_attr__bindgen_ty_9))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bpf_attr__bindgen_ty_9>())).target_fd as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_attr__bindgen_ty_9),
            "::",
            stringify!(target_fd)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bpf_attr__bindgen_ty_9>())).attach_type as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_attr__bindgen_ty_9),
            "::",
            stringify!(attach_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bpf_attr__bindgen_ty_9>())).query_flags as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_attr__bindgen_ty_9),
            "::",
            stringify!(query_flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bpf_attr__bindgen_ty_9>())).attach_flags as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_attr__bindgen_ty_9),
            "::",
            stringify!(attach_flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bpf_attr__bindgen_ty_9>())).prog_ids as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_attr__bindgen_ty_9),
            "::",
            stringify!(prog_ids)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bpf_attr__bindgen_ty_9>())).prog_cnt as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_attr__bindgen_ty_9),
            "::",
            stringify!(prog_cnt)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct bpf_attr__bindgen_ty_10 {
    pub name: __u64,
    pub prog_fd: __u32,
}
#[test]
fn bindgen_test_layout_bpf_attr__bindgen_ty_10() {
    assert_eq!(
        ::core::mem::size_of::<bpf_attr__bindgen_ty_10>(),
        16usize,
        concat!("Size of: ", stringify!(bpf_attr__bindgen_ty_10))
    );
    assert_eq!(
        ::core::mem::align_of::<bpf_attr__bindgen_ty_10>(),
        8usize,
        concat!("Alignment of ", stringify!(bpf_attr__bindgen_ty_10))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_attr__bindgen_ty_10>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_attr__bindgen_ty_10),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bpf_attr__bindgen_ty_10>())).prog_fd as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_attr__bindgen_ty_10),
            "::",
            stringify!(prog_fd)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct bpf_attr__bindgen_ty_11 {
    pub btf: __u64,
    pub btf_log_buf: __u64,
    pub btf_size: __u32,
    pub btf_log_size: __u32,
    pub btf_log_level: __u32,
}
#[test]
fn bindgen_test_layout_bpf_attr__bindgen_ty_11() {
    assert_eq!(
        ::core::mem::size_of::<bpf_attr__bindgen_ty_11>(),
        32usize,
        concat!("Size of: ", stringify!(bpf_attr__bindgen_ty_11))
    );
    assert_eq!(
        ::core::mem::align_of::<bpf_attr__bindgen_ty_11>(),
        8usize,
        concat!("Alignment of ", stringify!(bpf_attr__bindgen_ty_11))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_attr__bindgen_ty_11>())).btf as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_attr__bindgen_ty_11),
            "::",
            stringify!(btf)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bpf_attr__bindgen_ty_11>())).btf_log_buf as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_attr__bindgen_ty_11),
            "::",
            stringify!(btf_log_buf)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bpf_attr__bindgen_ty_11>())).btf_size as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_attr__bindgen_ty_11),
            "::",
            stringify!(btf_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bpf_attr__bindgen_ty_11>())).btf_log_size as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_attr__bindgen_ty_11),
            "::",
            stringify!(btf_log_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bpf_attr__bindgen_ty_11>())).btf_log_level as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_attr__bindgen_ty_11),
            "::",
            stringify!(btf_log_level)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct bpf_attr__bindgen_ty_12 {
    pub pid: __u32,
    pub fd: __u32,
    pub flags: __u32,
    pub buf_len: __u32,
    pub buf: __u64,
    pub prog_id: __u32,
    pub fd_type: __u32,
    pub probe_offset: __u64,
    pub probe_addr: __u64,
}
#[test]
fn bindgen_test_layout_bpf_attr__bindgen_ty_12() {
    assert_eq!(
        ::core::mem::size_of::<bpf_attr__bindgen_ty_12>(),
        48usize,
        concat!("Size of: ", stringify!(bpf_attr__bindgen_ty_12))
    );
    assert_eq!(
        ::core::mem::align_of::<bpf_attr__bindgen_ty_12>(),
        8usize,
        concat!("Alignment of ", stringify!(bpf_attr__bindgen_ty_12))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_attr__bindgen_ty_12>())).pid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_attr__bindgen_ty_12),
            "::",
            stringify!(pid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_attr__bindgen_ty_12>())).fd as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_attr__bindgen_ty_12),
            "::",
            stringify!(fd)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_attr__bindgen_ty_12>())).flags as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_attr__bindgen_ty_12),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bpf_attr__bindgen_ty_12>())).buf_len as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_attr__bindgen_ty_12),
            "::",
            stringify!(buf_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_attr__bindgen_ty_12>())).buf as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_attr__bindgen_ty_12),
            "::",
            stringify!(buf)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bpf_attr__bindgen_ty_12>())).prog_id as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_attr__bindgen_ty_12),
            "::",
            stringify!(prog_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bpf_attr__bindgen_ty_12>())).fd_type as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_attr__bindgen_ty_12),
            "::",
            stringify!(fd_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bpf_attr__bindgen_ty_12>())).probe_offset as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_attr__bindgen_ty_12),
            "::",
            stringify!(probe_offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bpf_attr__bindgen_ty_12>())).probe_addr as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_attr__bindgen_ty_12),
            "::",
            stringify!(probe_addr)
        )
    );
}
#[test]
fn bindgen_test_layout_bpf_attr() {
    assert_eq!(
        ::core::mem::size_of::<bpf_attr>(),
        112usize,
        concat!("Size of: ", stringify!(bpf_attr))
    );
    assert_eq!(
        ::core::mem::align_of::<bpf_attr>(),
        8usize,
        concat!("Alignment of ", stringify!(bpf_attr))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_attr>())).test as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_attr),
            "::",
            stringify!(test)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_attr>())).info as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_attr),
            "::",
            stringify!(info)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_attr>())).query as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_attr),
            "::",
            stringify!(query)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_attr>())).raw_tracepoint as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_attr),
            "::",
            stringify!(raw_tracepoint)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_attr>())).task_fd_query as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_attr),
            "::",
            stringify!(task_fd_query)
        )
    );
}
impl Default for bpf_attr {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct bpf_func_info {
    pub insn_off: __u32,
    pub type_id: __u32,
}
#[test]
fn bindgen_test_layout_bpf_func_info() {
    assert_eq!(
        ::core::mem::size_of::<bpf_func_info>(),
        8usize,
        concat!("Size of: ", stringify!(bpf_func_info))
    );
    assert_eq!(
        ::core::mem::align_of::<bpf_func_info>(),
        4usize,
        concat!("Alignment of ", stringify!(bpf_func_info))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_func_info>())).insn_off as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_func_info),
            "::",
            stringify!(insn_off)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_func_info>())).type_id as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_func_info),
            "::",
            stringify!(type_id)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct bpf_line_info {
    pub insn_off: __u32,
    pub file_name_off: __u32,
    pub line_off: __u32,
    pub line_col: __u32,
}
#[test]
fn bindgen_test_layout_bpf_line_info() {
    assert_eq!(
        ::core::mem::size_of::<bpf_line_info>(),
        16usize,
        concat!("Size of: ", stringify!(bpf_line_info))
    );
    assert_eq!(
        ::core::mem::align_of::<bpf_line_info>(),
        4usize,
        concat!("Alignment of ", stringify!(bpf_line_info))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_line_info>())).insn_off as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_line_info),
            "::",
            stringify!(insn_off)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_line_info>())).file_name_off as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_line_info),
            "::",
            stringify!(file_name_off)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_line_info>())).line_off as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_line_info),
            "::",
            stringify!(line_off)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_line_info>())).line_col as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_line_info),
            "::",
            stringify!(line_col)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct latch_tree_node {
    pub node: [rb_node; 2usize],
}
#[test]
fn bindgen_test_layout_latch_tree_node() {
    assert_eq!(
        ::core::mem::size_of::<latch_tree_node>(),
        48usize,
        concat!("Size of: ", stringify!(latch_tree_node))
    );
    assert_eq!(
        ::core::mem::align_of::<latch_tree_node>(),
        8usize,
        concat!("Alignment of ", stringify!(latch_tree_node))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<latch_tree_node>())).node as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(latch_tree_node),
            "::",
            stringify!(node)
        )
    );
}
impl Default for latch_tree_node {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btf {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btf_type {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct bpf_map_ops {
    pub map_alloc_check:
        ::core::option::Option<unsafe extern "C" fn(attr: *mut bpf_attr) -> c_types::c_int>,
    pub map_alloc:
        ::core::option::Option<unsafe extern "C" fn(attr: *mut bpf_attr) -> *mut bpf_map>,
    pub map_release:
        ::core::option::Option<unsafe extern "C" fn(map: *mut bpf_map, map_file: *mut file)>,
    pub map_free: ::core::option::Option<unsafe extern "C" fn(map: *mut bpf_map)>,
    pub map_get_next_key: ::core::option::Option<
        unsafe extern "C" fn(
            map: *mut bpf_map,
            key: *mut c_types::c_void,
            next_key: *mut c_types::c_void,
        ) -> c_types::c_int,
    >,
    pub map_release_uref: ::core::option::Option<unsafe extern "C" fn(map: *mut bpf_map)>,
    pub map_lookup_elem_sys_only: ::core::option::Option<
        unsafe extern "C" fn(map: *mut bpf_map, key: *mut c_types::c_void) -> *mut c_types::c_void,
    >,
    pub map_lookup_elem: ::core::option::Option<
        unsafe extern "C" fn(map: *mut bpf_map, key: *mut c_types::c_void) -> *mut c_types::c_void,
    >,
    pub map_update_elem: ::core::option::Option<
        unsafe extern "C" fn(
            map: *mut bpf_map,
            key: *mut c_types::c_void,
            value: *mut c_types::c_void,
            flags: u64_,
        ) -> c_types::c_int,
    >,
    pub map_delete_elem: ::core::option::Option<
        unsafe extern "C" fn(map: *mut bpf_map, key: *mut c_types::c_void) -> c_types::c_int,
    >,
    pub map_push_elem: ::core::option::Option<
        unsafe extern "C" fn(
            map: *mut bpf_map,
            value: *mut c_types::c_void,
            flags: u64_,
        ) -> c_types::c_int,
    >,
    pub map_pop_elem: ::core::option::Option<
        unsafe extern "C" fn(map: *mut bpf_map, value: *mut c_types::c_void) -> c_types::c_int,
    >,
    pub map_peek_elem: ::core::option::Option<
        unsafe extern "C" fn(map: *mut bpf_map, value: *mut c_types::c_void) -> c_types::c_int,
    >,
    pub map_fd_get_ptr: ::core::option::Option<
        unsafe extern "C" fn(
            map: *mut bpf_map,
            map_file: *mut file,
            fd: c_types::c_int,
        ) -> *mut c_types::c_void,
    >,
    pub map_fd_put_ptr: ::core::option::Option<unsafe extern "C" fn(ptr: *mut c_types::c_void)>,
    pub map_gen_lookup: ::core::option::Option<
        unsafe extern "C" fn(map: *mut bpf_map, insn_buf: *mut bpf_insn) -> u32_,
    >,
    pub map_fd_sys_lookup_elem:
        ::core::option::Option<unsafe extern "C" fn(ptr: *mut c_types::c_void) -> u32_>,
    pub map_seq_show_elem: ::core::option::Option<
        unsafe extern "C" fn(map: *mut bpf_map, key: *mut c_types::c_void, m: *mut seq_file),
    >,
    pub map_check_btf: ::core::option::Option<
        unsafe extern "C" fn(
            map: *const bpf_map,
            btf: *const btf,
            key_type: *const btf_type,
            value_type: *const btf_type,
        ) -> c_types::c_int,
    >,
    pub map_direct_value_addr: ::core::option::Option<
        unsafe extern "C" fn(map: *const bpf_map, imm: *mut u64_, off: u32_) -> c_types::c_int,
    >,
    pub map_direct_value_meta: ::core::option::Option<
        unsafe extern "C" fn(map: *const bpf_map, imm: u64_, off: *mut u32_) -> c_types::c_int,
    >,
}
#[test]
fn bindgen_test_layout_bpf_map_ops() {
    assert_eq!(
        ::core::mem::size_of::<bpf_map_ops>(),
        168usize,
        concat!("Size of: ", stringify!(bpf_map_ops))
    );
    assert_eq!(
        ::core::mem::align_of::<bpf_map_ops>(),
        8usize,
        concat!("Alignment of ", stringify!(bpf_map_ops))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_map_ops>())).map_alloc_check as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_map_ops),
            "::",
            stringify!(map_alloc_check)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_map_ops>())).map_alloc as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_map_ops),
            "::",
            stringify!(map_alloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_map_ops>())).map_release as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_map_ops),
            "::",
            stringify!(map_release)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_map_ops>())).map_free as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_map_ops),
            "::",
            stringify!(map_free)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_map_ops>())).map_get_next_key as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_map_ops),
            "::",
            stringify!(map_get_next_key)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_map_ops>())).map_release_uref as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_map_ops),
            "::",
            stringify!(map_release_uref)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bpf_map_ops>())).map_lookup_elem_sys_only as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_map_ops),
            "::",
            stringify!(map_lookup_elem_sys_only)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_map_ops>())).map_lookup_elem as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_map_ops),
            "::",
            stringify!(map_lookup_elem)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_map_ops>())).map_update_elem as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_map_ops),
            "::",
            stringify!(map_update_elem)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_map_ops>())).map_delete_elem as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_map_ops),
            "::",
            stringify!(map_delete_elem)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_map_ops>())).map_push_elem as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_map_ops),
            "::",
            stringify!(map_push_elem)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_map_ops>())).map_pop_elem as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_map_ops),
            "::",
            stringify!(map_pop_elem)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_map_ops>())).map_peek_elem as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_map_ops),
            "::",
            stringify!(map_peek_elem)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_map_ops>())).map_fd_get_ptr as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_map_ops),
            "::",
            stringify!(map_fd_get_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_map_ops>())).map_fd_put_ptr as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_map_ops),
            "::",
            stringify!(map_fd_put_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_map_ops>())).map_gen_lookup as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_map_ops),
            "::",
            stringify!(map_gen_lookup)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bpf_map_ops>())).map_fd_sys_lookup_elem as *const _ as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_map_ops),
            "::",
            stringify!(map_fd_sys_lookup_elem)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_map_ops>())).map_seq_show_elem as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_map_ops),
            "::",
            stringify!(map_seq_show_elem)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_map_ops>())).map_check_btf as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_map_ops),
            "::",
            stringify!(map_check_btf)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bpf_map_ops>())).map_direct_value_addr as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_map_ops),
            "::",
            stringify!(map_direct_value_addr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bpf_map_ops>())).map_direct_value_meta as *const _ as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_map_ops),
            "::",
            stringify!(map_direct_value_meta)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_map_memory {
    pub pages: u32_,
    pub user: *mut user_struct,
}
#[test]
fn bindgen_test_layout_bpf_map_memory() {
    assert_eq!(
        ::core::mem::size_of::<bpf_map_memory>(),
        16usize,
        concat!("Size of: ", stringify!(bpf_map_memory))
    );
    assert_eq!(
        ::core::mem::align_of::<bpf_map_memory>(),
        8usize,
        concat!("Alignment of ", stringify!(bpf_map_memory))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_map_memory>())).pages as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_map_memory),
            "::",
            stringify!(pages)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_map_memory>())).user as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_map_memory),
            "::",
            stringify!(user)
        )
    );
}
impl Default for bpf_map_memory {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct bpf_map {
    pub ops: *const bpf_map_ops,
    pub inner_map_meta: *mut bpf_map,
    pub security: *mut c_types::c_void,
    pub map_type: bpf_map_type,
    pub key_size: u32_,
    pub value_size: u32_,
    pub max_entries: u32_,
    pub map_flags: u32_,
    pub spin_lock_off: c_types::c_int,
    pub id: u32_,
    pub numa_node: c_types::c_int,
    pub btf_key_type_id: u32_,
    pub btf_value_type_id: u32_,
    pub btf: *mut btf,
    pub memory: bpf_map_memory,
    pub unpriv_array: bool_,
    pub frozen: bool_,
    pub __bindgen_padding_0: [u32; 9usize],
    pub refcnt: atomic_t,
    pub usercnt: atomic_t,
    pub work: work_struct,
    pub name: [c_types::c_char; 16usize],
}
#[test]
fn bindgen_test_layout_bpf_map() {
    assert_eq!(
        ::core::mem::size_of::<bpf_map>(),
        192usize,
        concat!("Size of: ", stringify!(bpf_map))
    );
    assert_eq!(
        ::core::mem::align_of::<bpf_map>(),
        64usize,
        concat!("Alignment of ", stringify!(bpf_map))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_map>())).ops as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_map),
            "::",
            stringify!(ops)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_map>())).inner_map_meta as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_map),
            "::",
            stringify!(inner_map_meta)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_map>())).security as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_map),
            "::",
            stringify!(security)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_map>())).map_type as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_map),
            "::",
            stringify!(map_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_map>())).key_size as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_map),
            "::",
            stringify!(key_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_map>())).value_size as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_map),
            "::",
            stringify!(value_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_map>())).max_entries as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_map),
            "::",
            stringify!(max_entries)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_map>())).map_flags as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_map),
            "::",
            stringify!(map_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_map>())).spin_lock_off as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_map),
            "::",
            stringify!(spin_lock_off)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_map>())).id as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_map),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_map>())).numa_node as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_map),
            "::",
            stringify!(numa_node)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_map>())).btf_key_type_id as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_map),
            "::",
            stringify!(btf_key_type_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_map>())).btf_value_type_id as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_map),
            "::",
            stringify!(btf_value_type_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_map>())).btf as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_map),
            "::",
            stringify!(btf)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_map>())).memory as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_map),
            "::",
            stringify!(memory)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_map>())).unpriv_array as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_map),
            "::",
            stringify!(unpriv_array)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_map>())).frozen as *const _ as usize },
        89usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_map),
            "::",
            stringify!(frozen)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_map>())).refcnt as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_map),
            "::",
            stringify!(refcnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_map>())).usercnt as *const _ as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_map),
            "::",
            stringify!(usercnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_map>())).work as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_map),
            "::",
            stringify!(work)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_map>())).name as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_map),
            "::",
            stringify!(name)
        )
    );
}
impl Default for bpf_map {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_offload_dev {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct bpf_map_dev_ops {
    pub map_get_next_key: ::core::option::Option<
        unsafe extern "C" fn(
            map: *mut bpf_offloaded_map,
            key: *mut c_types::c_void,
            next_key: *mut c_types::c_void,
        ) -> c_types::c_int,
    >,
    pub map_lookup_elem: ::core::option::Option<
        unsafe extern "C" fn(
            map: *mut bpf_offloaded_map,
            key: *mut c_types::c_void,
            value: *mut c_types::c_void,
        ) -> c_types::c_int,
    >,
    pub map_update_elem: ::core::option::Option<
        unsafe extern "C" fn(
            map: *mut bpf_offloaded_map,
            key: *mut c_types::c_void,
            value: *mut c_types::c_void,
            flags: u64_,
        ) -> c_types::c_int,
    >,
    pub map_delete_elem: ::core::option::Option<
        unsafe extern "C" fn(
            map: *mut bpf_offloaded_map,
            key: *mut c_types::c_void,
        ) -> c_types::c_int,
    >,
}
#[test]
fn bindgen_test_layout_bpf_map_dev_ops() {
    assert_eq!(
        ::core::mem::size_of::<bpf_map_dev_ops>(),
        32usize,
        concat!("Size of: ", stringify!(bpf_map_dev_ops))
    );
    assert_eq!(
        ::core::mem::align_of::<bpf_map_dev_ops>(),
        8usize,
        concat!("Alignment of ", stringify!(bpf_map_dev_ops))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bpf_map_dev_ops>())).map_get_next_key as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_map_dev_ops),
            "::",
            stringify!(map_get_next_key)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bpf_map_dev_ops>())).map_lookup_elem as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_map_dev_ops),
            "::",
            stringify!(map_lookup_elem)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bpf_map_dev_ops>())).map_update_elem as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_map_dev_ops),
            "::",
            stringify!(map_update_elem)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bpf_map_dev_ops>())).map_delete_elem as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_map_dev_ops),
            "::",
            stringify!(map_delete_elem)
        )
    );
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct bpf_offloaded_map {
    pub map: bpf_map,
    pub netdev: *mut net_device,
    pub dev_ops: *const bpf_map_dev_ops,
    pub dev_priv: *mut c_types::c_void,
    pub offloads: list_head,
}
#[test]
fn bindgen_test_layout_bpf_offloaded_map() {
    assert_eq!(
        ::core::mem::size_of::<bpf_offloaded_map>(),
        256usize,
        concat!("Size of: ", stringify!(bpf_offloaded_map))
    );
    assert_eq!(
        ::core::mem::align_of::<bpf_offloaded_map>(),
        64usize,
        concat!("Alignment of ", stringify!(bpf_offloaded_map))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_offloaded_map>())).map as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_offloaded_map),
            "::",
            stringify!(map)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_offloaded_map>())).netdev as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_offloaded_map),
            "::",
            stringify!(netdev)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_offloaded_map>())).dev_ops as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_offloaded_map),
            "::",
            stringify!(dev_ops)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_offloaded_map>())).dev_priv as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_offloaded_map),
            "::",
            stringify!(dev_priv)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_offloaded_map>())).offloads as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_offloaded_map),
            "::",
            stringify!(offloads)
        )
    );
}
impl Default for bpf_offloaded_map {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct bpf_prog_ops {
    pub test_run: ::core::option::Option<
        unsafe extern "C" fn(
            prog: *mut bpf_prog,
            kattr: *const bpf_attr,
            uattr: *mut bpf_attr,
        ) -> c_types::c_int,
    >,
}
#[test]
fn bindgen_test_layout_bpf_prog_ops() {
    assert_eq!(
        ::core::mem::size_of::<bpf_prog_ops>(),
        8usize,
        concat!("Size of: ", stringify!(bpf_prog_ops))
    );
    assert_eq!(
        ::core::mem::align_of::<bpf_prog_ops>(),
        8usize,
        concat!("Alignment of ", stringify!(bpf_prog_ops))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_prog_ops>())).test_run as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_prog_ops),
            "::",
            stringify!(test_run)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_prog_offload {
    pub prog: *mut bpf_prog,
    pub netdev: *mut net_device,
    pub offdev: *mut bpf_offload_dev,
    pub dev_priv: *mut c_types::c_void,
    pub offloads: list_head,
    pub dev_state: bool_,
    pub opt_failed: bool_,
    pub jited_image: *mut c_types::c_void,
    pub jited_len: u32_,
}
#[test]
fn bindgen_test_layout_bpf_prog_offload() {
    assert_eq!(
        ::core::mem::size_of::<bpf_prog_offload>(),
        72usize,
        concat!("Size of: ", stringify!(bpf_prog_offload))
    );
    assert_eq!(
        ::core::mem::align_of::<bpf_prog_offload>(),
        8usize,
        concat!("Alignment of ", stringify!(bpf_prog_offload))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_prog_offload>())).prog as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_prog_offload),
            "::",
            stringify!(prog)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_prog_offload>())).netdev as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_prog_offload),
            "::",
            stringify!(netdev)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_prog_offload>())).offdev as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_prog_offload),
            "::",
            stringify!(offdev)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_prog_offload>())).dev_priv as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_prog_offload),
            "::",
            stringify!(dev_priv)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_prog_offload>())).offloads as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_prog_offload),
            "::",
            stringify!(offloads)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_prog_offload>())).dev_state as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_prog_offload),
            "::",
            stringify!(dev_state)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_prog_offload>())).opt_failed as *const _ as usize },
        49usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_prog_offload),
            "::",
            stringify!(opt_failed)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_prog_offload>())).jited_image as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_prog_offload),
            "::",
            stringify!(jited_image)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_prog_offload>())).jited_len as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_prog_offload),
            "::",
            stringify!(jited_len)
        )
    );
}
impl Default for bpf_prog_offload {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct bpf_prog_stats {
    pub cnt: u64_,
    pub nsecs: u64_,
    pub syncp: u64_stats_sync,
}
#[test]
fn bindgen_test_layout_bpf_prog_stats() {
    assert_eq!(
        ::core::mem::size_of::<bpf_prog_stats>(),
        16usize,
        concat!("Size of: ", stringify!(bpf_prog_stats))
    );
    assert_eq!(
        ::core::mem::align_of::<bpf_prog_stats>(),
        8usize,
        concat!("Alignment of ", stringify!(bpf_prog_stats))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_prog_stats>())).cnt as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_prog_stats),
            "::",
            stringify!(cnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_prog_stats>())).nsecs as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_prog_stats),
            "::",
            stringify!(nsecs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_prog_stats>())).syncp as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_prog_stats),
            "::",
            stringify!(syncp)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_prog_aux {
    pub refcnt: atomic_t,
    pub used_map_cnt: u32_,
    pub max_ctx_offset: u32_,
    pub max_pkt_offset: u32_,
    pub max_tp_access: u32_,
    pub stack_depth: u32_,
    pub id: u32_,
    pub func_cnt: u32_,
    pub func_idx: u32_,
    pub verifier_zext: bool_,
    pub offload_requested: bool_,
    pub func: *mut *mut bpf_prog,
    pub jit_data: *mut c_types::c_void,
    pub ksym_tnode: latch_tree_node,
    pub ksym_lnode: list_head,
    pub ops: *const bpf_prog_ops,
    pub used_maps: *mut *mut bpf_map,
    pub prog: *mut bpf_prog,
    pub user: *mut user_struct,
    pub load_time: u64_,
    pub cgroup_storage: [*mut bpf_map; 2usize],
    pub name: [c_types::c_char; 16usize],
    pub security: *mut c_types::c_void,
    pub offload: *mut bpf_prog_offload,
    pub btf: *mut btf,
    pub func_info: *mut bpf_func_info,
    pub linfo: *mut bpf_line_info,
    pub jited_linfo: *mut *mut c_types::c_void,
    pub func_info_cnt: u32_,
    pub nr_linfo: u32_,
    pub linfo_idx: u32_,
    pub stats: *mut bpf_prog_stats,
    pub __bindgen_anon_1: bpf_prog_aux__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_prog_aux__bindgen_ty_1 {
    pub work: work_struct,
    pub rcu: callback_head,
    _bindgen_union_align: [u64; 4usize],
}
#[test]
fn bindgen_test_layout_bpf_prog_aux__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<bpf_prog_aux__bindgen_ty_1>(),
        32usize,
        concat!("Size of: ", stringify!(bpf_prog_aux__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<bpf_prog_aux__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(bpf_prog_aux__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bpf_prog_aux__bindgen_ty_1>())).work as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_prog_aux__bindgen_ty_1),
            "::",
            stringify!(work)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_prog_aux__bindgen_ty_1>())).rcu as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_prog_aux__bindgen_ty_1),
            "::",
            stringify!(rcu)
        )
    );
}
impl Default for bpf_prog_aux__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_bpf_prog_aux() {
    assert_eq!(
        ::core::mem::size_of::<bpf_prog_aux>(),
        296usize,
        concat!("Size of: ", stringify!(bpf_prog_aux))
    );
    assert_eq!(
        ::core::mem::align_of::<bpf_prog_aux>(),
        8usize,
        concat!("Alignment of ", stringify!(bpf_prog_aux))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_prog_aux>())).refcnt as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_prog_aux),
            "::",
            stringify!(refcnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_prog_aux>())).used_map_cnt as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_prog_aux),
            "::",
            stringify!(used_map_cnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_prog_aux>())).max_ctx_offset as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_prog_aux),
            "::",
            stringify!(max_ctx_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_prog_aux>())).max_pkt_offset as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_prog_aux),
            "::",
            stringify!(max_pkt_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_prog_aux>())).max_tp_access as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_prog_aux),
            "::",
            stringify!(max_tp_access)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_prog_aux>())).stack_depth as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_prog_aux),
            "::",
            stringify!(stack_depth)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_prog_aux>())).id as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_prog_aux),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_prog_aux>())).func_cnt as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_prog_aux),
            "::",
            stringify!(func_cnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_prog_aux>())).func_idx as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_prog_aux),
            "::",
            stringify!(func_idx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_prog_aux>())).verifier_zext as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_prog_aux),
            "::",
            stringify!(verifier_zext)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_prog_aux>())).offload_requested as *const _ as usize },
        37usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_prog_aux),
            "::",
            stringify!(offload_requested)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_prog_aux>())).func as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_prog_aux),
            "::",
            stringify!(func)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_prog_aux>())).jit_data as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_prog_aux),
            "::",
            stringify!(jit_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_prog_aux>())).ksym_tnode as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_prog_aux),
            "::",
            stringify!(ksym_tnode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_prog_aux>())).ksym_lnode as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_prog_aux),
            "::",
            stringify!(ksym_lnode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_prog_aux>())).ops as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_prog_aux),
            "::",
            stringify!(ops)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_prog_aux>())).used_maps as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_prog_aux),
            "::",
            stringify!(used_maps)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_prog_aux>())).prog as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_prog_aux),
            "::",
            stringify!(prog)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_prog_aux>())).user as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_prog_aux),
            "::",
            stringify!(user)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_prog_aux>())).load_time as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_prog_aux),
            "::",
            stringify!(load_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_prog_aux>())).cgroup_storage as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_prog_aux),
            "::",
            stringify!(cgroup_storage)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_prog_aux>())).name as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_prog_aux),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_prog_aux>())).security as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_prog_aux),
            "::",
            stringify!(security)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_prog_aux>())).offload as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_prog_aux),
            "::",
            stringify!(offload)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_prog_aux>())).btf as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_prog_aux),
            "::",
            stringify!(btf)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_prog_aux>())).func_info as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_prog_aux),
            "::",
            stringify!(func_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_prog_aux>())).linfo as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_prog_aux),
            "::",
            stringify!(linfo)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_prog_aux>())).jited_linfo as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_prog_aux),
            "::",
            stringify!(jited_linfo)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_prog_aux>())).func_info_cnt as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_prog_aux),
            "::",
            stringify!(func_info_cnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_prog_aux>())).nr_linfo as *const _ as usize },
        244usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_prog_aux),
            "::",
            stringify!(nr_linfo)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_prog_aux>())).linfo_idx as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_prog_aux),
            "::",
            stringify!(linfo_idx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_prog_aux>())).stats as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_prog_aux),
            "::",
            stringify!(stats)
        )
    );
}
impl Default for bpf_prog_aux {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_prog_array_item {
    pub prog: *mut bpf_prog,
    pub cgroup_storage: [*mut bpf_cgroup_storage; 2usize],
}
#[test]
fn bindgen_test_layout_bpf_prog_array_item() {
    assert_eq!(
        ::core::mem::size_of::<bpf_prog_array_item>(),
        24usize,
        concat!("Size of: ", stringify!(bpf_prog_array_item))
    );
    assert_eq!(
        ::core::mem::align_of::<bpf_prog_array_item>(),
        8usize,
        concat!("Alignment of ", stringify!(bpf_prog_array_item))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_prog_array_item>())).prog as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_prog_array_item),
            "::",
            stringify!(prog)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bpf_prog_array_item>())).cgroup_storage as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_prog_array_item),
            "::",
            stringify!(cgroup_storage)
        )
    );
}
impl Default for bpf_prog_array_item {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct bpf_prog_array {
    pub rcu: callback_head,
    pub items: __IncompleteArrayField<bpf_prog_array_item>,
}
#[test]
fn bindgen_test_layout_bpf_prog_array() {
    assert_eq!(
        ::core::mem::size_of::<bpf_prog_array>(),
        16usize,
        concat!("Size of: ", stringify!(bpf_prog_array))
    );
    assert_eq!(
        ::core::mem::align_of::<bpf_prog_array>(),
        8usize,
        concat!("Alignment of ", stringify!(bpf_prog_array))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_prog_array>())).rcu as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_prog_array),
            "::",
            stringify!(rcu)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_prog_array>())).items as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_prog_array),
            "::",
            stringify!(items)
        )
    );
}
impl Default for bpf_prog_array {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_cgroup_storage_map {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct bpf_storage_buffer {
    pub rcu: callback_head,
    pub data: __IncompleteArrayField<c_types::c_char>,
}
#[test]
fn bindgen_test_layout_bpf_storage_buffer() {
    assert_eq!(
        ::core::mem::size_of::<bpf_storage_buffer>(),
        16usize,
        concat!("Size of: ", stringify!(bpf_storage_buffer))
    );
    assert_eq!(
        ::core::mem::align_of::<bpf_storage_buffer>(),
        8usize,
        concat!("Alignment of ", stringify!(bpf_storage_buffer))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_storage_buffer>())).rcu as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_storage_buffer),
            "::",
            stringify!(rcu)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_storage_buffer>())).data as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_storage_buffer),
            "::",
            stringify!(data)
        )
    );
}
impl Default for bpf_storage_buffer {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_cgroup_storage {
    pub __bindgen_anon_1: bpf_cgroup_storage__bindgen_ty_1,
    pub map: *mut bpf_cgroup_storage_map,
    pub key: bpf_cgroup_storage_key,
    pub list: list_head,
    pub node: rb_node,
    pub rcu: callback_head,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_cgroup_storage__bindgen_ty_1 {
    pub buf: *mut bpf_storage_buffer,
    pub percpu_buf: *mut c_types::c_void,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_bpf_cgroup_storage__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<bpf_cgroup_storage__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(bpf_cgroup_storage__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<bpf_cgroup_storage__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(bpf_cgroup_storage__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bpf_cgroup_storage__bindgen_ty_1>())).buf as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_cgroup_storage__bindgen_ty_1),
            "::",
            stringify!(buf)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bpf_cgroup_storage__bindgen_ty_1>())).percpu_buf as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_cgroup_storage__bindgen_ty_1),
            "::",
            stringify!(percpu_buf)
        )
    );
}
impl Default for bpf_cgroup_storage__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_bpf_cgroup_storage() {
    assert_eq!(
        ::core::mem::size_of::<bpf_cgroup_storage>(),
        88usize,
        concat!("Size of: ", stringify!(bpf_cgroup_storage))
    );
    assert_eq!(
        ::core::mem::align_of::<bpf_cgroup_storage>(),
        8usize,
        concat!("Alignment of ", stringify!(bpf_cgroup_storage))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_cgroup_storage>())).map as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_cgroup_storage),
            "::",
            stringify!(map)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_cgroup_storage>())).key as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_cgroup_storage),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_cgroup_storage>())).list as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_cgroup_storage),
            "::",
            stringify!(list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_cgroup_storage>())).node as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_cgroup_storage),
            "::",
            stringify!(node)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_cgroup_storage>())).rcu as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_cgroup_storage),
            "::",
            stringify!(rcu)
        )
    );
}
impl Default for bpf_cgroup_storage {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cgroup_bpf {
    pub effective: [*mut bpf_prog_array; 23usize],
    pub progs: [list_head; 23usize],
    pub flags: [u32_; 23usize],
    pub inactive: *mut bpf_prog_array,
    pub refcnt: percpu_ref,
    pub release_work: work_struct,
}
#[test]
fn bindgen_test_layout_cgroup_bpf() {
    assert_eq!(
        ::core::mem::size_of::<cgroup_bpf>(),
        744usize,
        concat!("Size of: ", stringify!(cgroup_bpf))
    );
    assert_eq!(
        ::core::mem::align_of::<cgroup_bpf>(),
        8usize,
        concat!("Alignment of ", stringify!(cgroup_bpf))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cgroup_bpf>())).effective as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cgroup_bpf),
            "::",
            stringify!(effective)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cgroup_bpf>())).progs as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(cgroup_bpf),
            "::",
            stringify!(progs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cgroup_bpf>())).flags as *const _ as usize },
        552usize,
        concat!(
            "Offset of field: ",
            stringify!(cgroup_bpf),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cgroup_bpf>())).inactive as *const _ as usize },
        648usize,
        concat!(
            "Offset of field: ",
            stringify!(cgroup_bpf),
            "::",
            stringify!(inactive)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cgroup_bpf>())).refcnt as *const _ as usize },
        656usize,
        concat!(
            "Offset of field: ",
            stringify!(cgroup_bpf),
            "::",
            stringify!(refcnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cgroup_bpf>())).release_work as *const _ as usize },
        712usize,
        concat!(
            "Offset of field: ",
            stringify!(cgroup_bpf),
            "::",
            stringify!(release_work)
        )
    );
}
impl Default for cgroup_bpf {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type kthread_work_func_t =
    ::core::option::Option<unsafe extern "C" fn(work: *mut kthread_work)>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kthread_worker {
    pub flags: c_types::c_uint,
    pub lock: raw_spinlock_t,
    pub work_list: list_head,
    pub delayed_work_list: list_head,
    pub task: *mut task_struct,
    pub current_work: *mut kthread_work,
}
#[test]
fn bindgen_test_layout_kthread_worker() {
    assert_eq!(
        ::core::mem::size_of::<kthread_worker>(),
        56usize,
        concat!("Size of: ", stringify!(kthread_worker))
    );
    assert_eq!(
        ::core::mem::align_of::<kthread_worker>(),
        8usize,
        concat!("Alignment of ", stringify!(kthread_worker))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kthread_worker>())).flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kthread_worker),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kthread_worker>())).lock as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(kthread_worker),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kthread_worker>())).work_list as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(kthread_worker),
            "::",
            stringify!(work_list)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<kthread_worker>())).delayed_work_list as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(kthread_worker),
            "::",
            stringify!(delayed_work_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kthread_worker>())).task as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(kthread_worker),
            "::",
            stringify!(task)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kthread_worker>())).current_work as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(kthread_worker),
            "::",
            stringify!(current_work)
        )
    );
}
impl Default for kthread_worker {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kthread_work {
    pub node: list_head,
    pub func: kthread_work_func_t,
    pub worker: *mut kthread_worker,
    pub canceling: c_types::c_int,
}
#[test]
fn bindgen_test_layout_kthread_work() {
    assert_eq!(
        ::core::mem::size_of::<kthread_work>(),
        40usize,
        concat!("Size of: ", stringify!(kthread_work))
    );
    assert_eq!(
        ::core::mem::align_of::<kthread_work>(),
        8usize,
        concat!("Alignment of ", stringify!(kthread_work))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kthread_work>())).node as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kthread_work),
            "::",
            stringify!(node)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kthread_work>())).func as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(kthread_work),
            "::",
            stringify!(func)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kthread_work>())).worker as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(kthread_work),
            "::",
            stringify!(worker)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kthread_work>())).canceling as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(kthread_work),
            "::",
            stringify!(canceling)
        )
    );
}
impl Default for kthread_work {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kthread_delayed_work {
    pub work: kthread_work,
    pub timer: timer_list,
}
#[test]
fn bindgen_test_layout_kthread_delayed_work() {
    assert_eq!(
        ::core::mem::size_of::<kthread_delayed_work>(),
        80usize,
        concat!("Size of: ", stringify!(kthread_delayed_work))
    );
    assert_eq!(
        ::core::mem::align_of::<kthread_delayed_work>(),
        8usize,
        concat!("Alignment of ", stringify!(kthread_delayed_work))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kthread_delayed_work>())).work as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kthread_delayed_work),
            "::",
            stringify!(work)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kthread_delayed_work>())).timer as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(kthread_delayed_work),
            "::",
            stringify!(timer)
        )
    );
}
impl Default for kthread_delayed_work {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct psi_group_cpu {
    pub seq: seqcount_t,
    pub tasks: [c_types::c_uint; 3usize],
    pub state_mask: u32_,
    pub times: [u32_; 6usize],
    pub state_start: u64_,
    pub __bindgen_padding_0: [u32; 2usize],
    pub times_prev: [[u32_; 6usize]; 2usize],
}
#[test]
fn bindgen_test_layout_psi_group_cpu() {
    assert_eq!(
        ::core::mem::size_of::<psi_group_cpu>(),
        128usize,
        concat!("Size of: ", stringify!(psi_group_cpu))
    );
    assert_eq!(
        ::core::mem::align_of::<psi_group_cpu>(),
        64usize,
        concat!("Alignment of ", stringify!(psi_group_cpu))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<psi_group_cpu>())).seq as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(psi_group_cpu),
            "::",
            stringify!(seq)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<psi_group_cpu>())).tasks as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(psi_group_cpu),
            "::",
            stringify!(tasks)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<psi_group_cpu>())).state_mask as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(psi_group_cpu),
            "::",
            stringify!(state_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<psi_group_cpu>())).times as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(psi_group_cpu),
            "::",
            stringify!(times)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<psi_group_cpu>())).state_start as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(psi_group_cpu),
            "::",
            stringify!(state_start)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<psi_group_cpu>())).times_prev as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(psi_group_cpu),
            "::",
            stringify!(times_prev)
        )
    );
}
impl Default for psi_group_cpu {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct psi_group {
    pub avgs_lock: mutex,
    pub pcpu: *mut psi_group_cpu,
    pub avg_total: [u64_; 5usize],
    pub avg_last_update: u64_,
    pub avg_next_update: u64_,
    pub avgs_work: delayed_work,
    pub total: [[u64_; 5usize]; 2usize],
    pub avg: [[c_types::c_ulong; 3usize]; 5usize],
    pub poll_scheduled: atomic_t,
    pub poll_kworker: *mut kthread_worker,
    pub poll_work: kthread_delayed_work,
    pub trigger_lock: mutex,
    pub triggers: list_head,
    pub nr_triggers: [u32_; 5usize],
    pub poll_states: u32_,
    pub poll_min_period: u64_,
    pub polling_total: [u64_; 5usize],
    pub polling_next_update: u64_,
    pub polling_until: u64_,
}
#[test]
fn bindgen_test_layout_psi_group() {
    assert_eq!(
        ::core::mem::size_of::<psi_group>(),
        616usize,
        concat!("Size of: ", stringify!(psi_group))
    );
    assert_eq!(
        ::core::mem::align_of::<psi_group>(),
        8usize,
        concat!("Alignment of ", stringify!(psi_group))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<psi_group>())).avgs_lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(psi_group),
            "::",
            stringify!(avgs_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<psi_group>())).pcpu as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(psi_group),
            "::",
            stringify!(pcpu)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<psi_group>())).avg_total as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(psi_group),
            "::",
            stringify!(avg_total)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<psi_group>())).avg_last_update as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(psi_group),
            "::",
            stringify!(avg_last_update)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<psi_group>())).avg_next_update as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(psi_group),
            "::",
            stringify!(avg_next_update)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<psi_group>())).avgs_work as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(psi_group),
            "::",
            stringify!(avgs_work)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<psi_group>())).total as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(psi_group),
            "::",
            stringify!(total)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<psi_group>())).avg as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(psi_group),
            "::",
            stringify!(avg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<psi_group>())).poll_scheduled as *const _ as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(psi_group),
            "::",
            stringify!(poll_scheduled)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<psi_group>())).poll_kworker as *const _ as usize },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(psi_group),
            "::",
            stringify!(poll_kworker)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<psi_group>())).poll_work as *const _ as usize },
        400usize,
        concat!(
            "Offset of field: ",
            stringify!(psi_group),
            "::",
            stringify!(poll_work)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<psi_group>())).trigger_lock as *const _ as usize },
        480usize,
        concat!(
            "Offset of field: ",
            stringify!(psi_group),
            "::",
            stringify!(trigger_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<psi_group>())).triggers as *const _ as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(psi_group),
            "::",
            stringify!(triggers)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<psi_group>())).nr_triggers as *const _ as usize },
        528usize,
        concat!(
            "Offset of field: ",
            stringify!(psi_group),
            "::",
            stringify!(nr_triggers)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<psi_group>())).poll_states as *const _ as usize },
        548usize,
        concat!(
            "Offset of field: ",
            stringify!(psi_group),
            "::",
            stringify!(poll_states)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<psi_group>())).poll_min_period as *const _ as usize },
        552usize,
        concat!(
            "Offset of field: ",
            stringify!(psi_group),
            "::",
            stringify!(poll_min_period)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<psi_group>())).polling_total as *const _ as usize },
        560usize,
        concat!(
            "Offset of field: ",
            stringify!(psi_group),
            "::",
            stringify!(polling_total)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<psi_group>())).polling_next_update as *const _ as usize },
        600usize,
        concat!(
            "Offset of field: ",
            stringify!(psi_group),
            "::",
            stringify!(polling_next_update)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<psi_group>())).polling_until as *const _ as usize },
        608usize,
        concat!(
            "Offset of field: ",
            stringify!(psi_group),
            "::",
            stringify!(polling_until)
        )
    );
}
impl Default for psi_group {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cgroup_taskset {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cgroup_file {
    pub kn: *mut kernfs_node,
    pub notified_at: c_types::c_ulong,
    pub notify_timer: timer_list,
}
#[test]
fn bindgen_test_layout_cgroup_file() {
    assert_eq!(
        ::core::mem::size_of::<cgroup_file>(),
        56usize,
        concat!("Size of: ", stringify!(cgroup_file))
    );
    assert_eq!(
        ::core::mem::align_of::<cgroup_file>(),
        8usize,
        concat!("Alignment of ", stringify!(cgroup_file))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cgroup_file>())).kn as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cgroup_file),
            "::",
            stringify!(kn)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cgroup_file>())).notified_at as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cgroup_file),
            "::",
            stringify!(notified_at)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cgroup_file>())).notify_timer as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cgroup_file),
            "::",
            stringify!(notify_timer)
        )
    );
}
impl Default for cgroup_file {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cgroup_subsys_state {
    pub cgroup: *mut cgroup,
    pub ss: *mut cgroup_subsys,
    pub refcnt: percpu_ref,
    pub sibling: list_head,
    pub children: list_head,
    pub rstat_css_node: list_head,
    pub id: c_types::c_int,
    pub flags: c_types::c_uint,
    pub serial_nr: u64_,
    pub online_cnt: atomic_t,
    pub destroy_work: work_struct,
    pub destroy_rwork: rcu_work,
    pub parent: *mut cgroup_subsys_state,
}
#[test]
fn bindgen_test_layout_cgroup_subsys_state() {
    assert_eq!(
        ::core::mem::size_of::<cgroup_subsys_state>(),
        240usize,
        concat!("Size of: ", stringify!(cgroup_subsys_state))
    );
    assert_eq!(
        ::core::mem::align_of::<cgroup_subsys_state>(),
        8usize,
        concat!("Alignment of ", stringify!(cgroup_subsys_state))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cgroup_subsys_state>())).cgroup as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cgroup_subsys_state),
            "::",
            stringify!(cgroup)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cgroup_subsys_state>())).ss as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cgroup_subsys_state),
            "::",
            stringify!(ss)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cgroup_subsys_state>())).refcnt as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cgroup_subsys_state),
            "::",
            stringify!(refcnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cgroup_subsys_state>())).sibling as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(cgroup_subsys_state),
            "::",
            stringify!(sibling)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cgroup_subsys_state>())).children as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(cgroup_subsys_state),
            "::",
            stringify!(children)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<cgroup_subsys_state>())).rstat_css_node as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(cgroup_subsys_state),
            "::",
            stringify!(rstat_css_node)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cgroup_subsys_state>())).id as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(cgroup_subsys_state),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cgroup_subsys_state>())).flags as *const _ as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(cgroup_subsys_state),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cgroup_subsys_state>())).serial_nr as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(cgroup_subsys_state),
            "::",
            stringify!(serial_nr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cgroup_subsys_state>())).online_cnt as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(cgroup_subsys_state),
            "::",
            stringify!(online_cnt)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<cgroup_subsys_state>())).destroy_work as *const _ as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(cgroup_subsys_state),
            "::",
            stringify!(destroy_work)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<cgroup_subsys_state>())).destroy_rwork as *const _ as usize
        },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(cgroup_subsys_state),
            "::",
            stringify!(destroy_rwork)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cgroup_subsys_state>())).parent as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(cgroup_subsys_state),
            "::",
            stringify!(parent)
        )
    );
}
impl Default for cgroup_subsys_state {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct css_set {
    pub subsys: [*mut cgroup_subsys_state; 13usize],
    pub refcount: refcount_t,
    pub dom_cset: *mut css_set,
    pub dfl_cgrp: *mut cgroup,
    pub nr_tasks: c_types::c_int,
    pub tasks: list_head,
    pub mg_tasks: list_head,
    pub dying_tasks: list_head,
    pub task_iters: list_head,
    pub e_cset_node: [list_head; 13usize],
    pub threaded_csets: list_head,
    pub threaded_csets_node: list_head,
    pub hlist: hlist_node,
    pub cgrp_links: list_head,
    pub mg_preload_node: list_head,
    pub mg_node: list_head,
    pub mg_src_cgrp: *mut cgroup,
    pub mg_dst_cgrp: *mut cgroup,
    pub mg_dst_cset: *mut css_set,
    pub dead: bool_,
    pub callback_head: callback_head,
}
#[test]
fn bindgen_test_layout_css_set() {
    assert_eq!(
        ::core::mem::size_of::<css_set>(),
        552usize,
        concat!("Size of: ", stringify!(css_set))
    );
    assert_eq!(
        ::core::mem::align_of::<css_set>(),
        8usize,
        concat!("Alignment of ", stringify!(css_set))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<css_set>())).subsys as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(css_set),
            "::",
            stringify!(subsys)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<css_set>())).refcount as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(css_set),
            "::",
            stringify!(refcount)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<css_set>())).dom_cset as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(css_set),
            "::",
            stringify!(dom_cset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<css_set>())).dfl_cgrp as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(css_set),
            "::",
            stringify!(dfl_cgrp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<css_set>())).nr_tasks as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(css_set),
            "::",
            stringify!(nr_tasks)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<css_set>())).tasks as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(css_set),
            "::",
            stringify!(tasks)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<css_set>())).mg_tasks as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(css_set),
            "::",
            stringify!(mg_tasks)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<css_set>())).dying_tasks as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(css_set),
            "::",
            stringify!(dying_tasks)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<css_set>())).task_iters as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(css_set),
            "::",
            stringify!(task_iters)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<css_set>())).e_cset_node as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(css_set),
            "::",
            stringify!(e_cset_node)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<css_set>())).threaded_csets as *const _ as usize },
        408usize,
        concat!(
            "Offset of field: ",
            stringify!(css_set),
            "::",
            stringify!(threaded_csets)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<css_set>())).threaded_csets_node as *const _ as usize },
        424usize,
        concat!(
            "Offset of field: ",
            stringify!(css_set),
            "::",
            stringify!(threaded_csets_node)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<css_set>())).hlist as *const _ as usize },
        440usize,
        concat!(
            "Offset of field: ",
            stringify!(css_set),
            "::",
            stringify!(hlist)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<css_set>())).cgrp_links as *const _ as usize },
        456usize,
        concat!(
            "Offset of field: ",
            stringify!(css_set),
            "::",
            stringify!(cgrp_links)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<css_set>())).mg_preload_node as *const _ as usize },
        472usize,
        concat!(
            "Offset of field: ",
            stringify!(css_set),
            "::",
            stringify!(mg_preload_node)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<css_set>())).mg_node as *const _ as usize },
        488usize,
        concat!(
            "Offset of field: ",
            stringify!(css_set),
            "::",
            stringify!(mg_node)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<css_set>())).mg_src_cgrp as *const _ as usize },
        504usize,
        concat!(
            "Offset of field: ",
            stringify!(css_set),
            "::",
            stringify!(mg_src_cgrp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<css_set>())).mg_dst_cgrp as *const _ as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(css_set),
            "::",
            stringify!(mg_dst_cgrp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<css_set>())).mg_dst_cset as *const _ as usize },
        520usize,
        concat!(
            "Offset of field: ",
            stringify!(css_set),
            "::",
            stringify!(mg_dst_cset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<css_set>())).dead as *const _ as usize },
        528usize,
        concat!(
            "Offset of field: ",
            stringify!(css_set),
            "::",
            stringify!(dead)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<css_set>())).callback_head as *const _ as usize },
        536usize,
        concat!(
            "Offset of field: ",
            stringify!(css_set),
            "::",
            stringify!(callback_head)
        )
    );
}
impl Default for css_set {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct cgroup_base_stat {
    pub cputime: task_cputime,
}
#[test]
fn bindgen_test_layout_cgroup_base_stat() {
    assert_eq!(
        ::core::mem::size_of::<cgroup_base_stat>(),
        24usize,
        concat!("Size of: ", stringify!(cgroup_base_stat))
    );
    assert_eq!(
        ::core::mem::align_of::<cgroup_base_stat>(),
        8usize,
        concat!("Alignment of ", stringify!(cgroup_base_stat))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cgroup_base_stat>())).cputime as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cgroup_base_stat),
            "::",
            stringify!(cputime)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cgroup_rstat_cpu {
    pub bsync: u64_stats_sync,
    pub bstat: cgroup_base_stat,
    pub last_bstat: cgroup_base_stat,
    pub updated_children: *mut cgroup,
    pub updated_next: *mut cgroup,
}
#[test]
fn bindgen_test_layout_cgroup_rstat_cpu() {
    assert_eq!(
        ::core::mem::size_of::<cgroup_rstat_cpu>(),
        64usize,
        concat!("Size of: ", stringify!(cgroup_rstat_cpu))
    );
    assert_eq!(
        ::core::mem::align_of::<cgroup_rstat_cpu>(),
        8usize,
        concat!("Alignment of ", stringify!(cgroup_rstat_cpu))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cgroup_rstat_cpu>())).bsync as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cgroup_rstat_cpu),
            "::",
            stringify!(bsync)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cgroup_rstat_cpu>())).bstat as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cgroup_rstat_cpu),
            "::",
            stringify!(bstat)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cgroup_rstat_cpu>())).last_bstat as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cgroup_rstat_cpu),
            "::",
            stringify!(last_bstat)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<cgroup_rstat_cpu>())).updated_children as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(cgroup_rstat_cpu),
            "::",
            stringify!(updated_children)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cgroup_rstat_cpu>())).updated_next as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(cgroup_rstat_cpu),
            "::",
            stringify!(updated_next)
        )
    );
}
impl Default for cgroup_rstat_cpu {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct cgroup_freezer_state {
    pub freeze: bool_,
    pub e_freeze: c_types::c_int,
    pub nr_frozen_descendants: c_types::c_int,
    pub nr_frozen_tasks: c_types::c_int,
}
#[test]
fn bindgen_test_layout_cgroup_freezer_state() {
    assert_eq!(
        ::core::mem::size_of::<cgroup_freezer_state>(),
        16usize,
        concat!("Size of: ", stringify!(cgroup_freezer_state))
    );
    assert_eq!(
        ::core::mem::align_of::<cgroup_freezer_state>(),
        4usize,
        concat!("Alignment of ", stringify!(cgroup_freezer_state))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cgroup_freezer_state>())).freeze as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cgroup_freezer_state),
            "::",
            stringify!(freeze)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cgroup_freezer_state>())).e_freeze as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cgroup_freezer_state),
            "::",
            stringify!(e_freeze)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<cgroup_freezer_state>())).nr_frozen_descendants as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cgroup_freezer_state),
            "::",
            stringify!(nr_frozen_descendants)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<cgroup_freezer_state>())).nr_frozen_tasks as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cgroup_freezer_state),
            "::",
            stringify!(nr_frozen_tasks)
        )
    );
}
#[repr(C)]
pub struct cgroup {
    pub self_: cgroup_subsys_state,
    pub flags: c_types::c_ulong,
    pub id: c_types::c_int,
    pub level: c_types::c_int,
    pub max_depth: c_types::c_int,
    pub nr_descendants: c_types::c_int,
    pub nr_dying_descendants: c_types::c_int,
    pub max_descendants: c_types::c_int,
    pub nr_populated_csets: c_types::c_int,
    pub nr_populated_domain_children: c_types::c_int,
    pub nr_populated_threaded_children: c_types::c_int,
    pub nr_threaded_children: c_types::c_int,
    pub kn: *mut kernfs_node,
    pub procs_file: cgroup_file,
    pub events_file: cgroup_file,
    pub subtree_control: u16_,
    pub subtree_ss_mask: u16_,
    pub old_subtree_control: u16_,
    pub old_subtree_ss_mask: u16_,
    pub subsys: [*mut cgroup_subsys_state; 13usize],
    pub root: *mut cgroup_root,
    pub cset_links: list_head,
    pub e_csets: [list_head; 13usize],
    pub dom_cgrp: *mut cgroup,
    pub old_dom_cgrp: *mut cgroup,
    pub rstat_cpu: *mut cgroup_rstat_cpu,
    pub rstat_css_list: list_head,
    pub pending_bstat: cgroup_base_stat,
    pub bstat: cgroup_base_stat,
    pub prev_cputime: prev_cputime,
    pub pidlists: list_head,
    pub pidlist_mutex: mutex,
    pub offline_waitq: wait_queue_head_t,
    pub release_agent_work: work_struct,
    pub psi: psi_group,
    pub bpf: cgroup_bpf,
    pub congestion_count: atomic_t,
    pub freezer: cgroup_freezer_state,
    pub ancestor_ids: __IncompleteArrayField<c_types::c_int>,
}
#[test]
fn bindgen_test_layout_cgroup() {
    assert_eq!(
        ::core::mem::size_of::<cgroup>(),
        2352usize,
        concat!("Size of: ", stringify!(cgroup))
    );
    assert_eq!(
        ::core::mem::align_of::<cgroup>(),
        8usize,
        concat!("Alignment of ", stringify!(cgroup))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cgroup>())).self_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cgroup),
            "::",
            stringify!(self_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cgroup>())).flags as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(cgroup),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cgroup>())).id as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(cgroup),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cgroup>())).level as *const _ as usize },
        252usize,
        concat!(
            "Offset of field: ",
            stringify!(cgroup),
            "::",
            stringify!(level)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cgroup>())).max_depth as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(cgroup),
            "::",
            stringify!(max_depth)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cgroup>())).nr_descendants as *const _ as usize },
        260usize,
        concat!(
            "Offset of field: ",
            stringify!(cgroup),
            "::",
            stringify!(nr_descendants)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cgroup>())).nr_dying_descendants as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(cgroup),
            "::",
            stringify!(nr_dying_descendants)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cgroup>())).max_descendants as *const _ as usize },
        268usize,
        concat!(
            "Offset of field: ",
            stringify!(cgroup),
            "::",
            stringify!(max_descendants)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cgroup>())).nr_populated_csets as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(cgroup),
            "::",
            stringify!(nr_populated_csets)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<cgroup>())).nr_populated_domain_children as *const _ as usize
        },
        276usize,
        concat!(
            "Offset of field: ",
            stringify!(cgroup),
            "::",
            stringify!(nr_populated_domain_children)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<cgroup>())).nr_populated_threaded_children as *const _ as usize
        },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(cgroup),
            "::",
            stringify!(nr_populated_threaded_children)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cgroup>())).nr_threaded_children as *const _ as usize },
        284usize,
        concat!(
            "Offset of field: ",
            stringify!(cgroup),
            "::",
            stringify!(nr_threaded_children)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cgroup>())).kn as *const _ as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(cgroup),
            "::",
            stringify!(kn)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cgroup>())).procs_file as *const _ as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(cgroup),
            "::",
            stringify!(procs_file)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cgroup>())).events_file as *const _ as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(cgroup),
            "::",
            stringify!(events_file)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cgroup>())).subtree_control as *const _ as usize },
        408usize,
        concat!(
            "Offset of field: ",
            stringify!(cgroup),
            "::",
            stringify!(subtree_control)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cgroup>())).subtree_ss_mask as *const _ as usize },
        410usize,
        concat!(
            "Offset of field: ",
            stringify!(cgroup),
            "::",
            stringify!(subtree_ss_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cgroup>())).old_subtree_control as *const _ as usize },
        412usize,
        concat!(
            "Offset of field: ",
            stringify!(cgroup),
            "::",
            stringify!(old_subtree_control)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cgroup>())).old_subtree_ss_mask as *const _ as usize },
        414usize,
        concat!(
            "Offset of field: ",
            stringify!(cgroup),
            "::",
            stringify!(old_subtree_ss_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cgroup>())).subsys as *const _ as usize },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(cgroup),
            "::",
            stringify!(subsys)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cgroup>())).root as *const _ as usize },
        520usize,
        concat!(
            "Offset of field: ",
            stringify!(cgroup),
            "::",
            stringify!(root)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cgroup>())).cset_links as *const _ as usize },
        528usize,
        concat!(
            "Offset of field: ",
            stringify!(cgroup),
            "::",
            stringify!(cset_links)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cgroup>())).e_csets as *const _ as usize },
        544usize,
        concat!(
            "Offset of field: ",
            stringify!(cgroup),
            "::",
            stringify!(e_csets)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cgroup>())).dom_cgrp as *const _ as usize },
        752usize,
        concat!(
            "Offset of field: ",
            stringify!(cgroup),
            "::",
            stringify!(dom_cgrp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cgroup>())).old_dom_cgrp as *const _ as usize },
        760usize,
        concat!(
            "Offset of field: ",
            stringify!(cgroup),
            "::",
            stringify!(old_dom_cgrp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cgroup>())).rstat_cpu as *const _ as usize },
        768usize,
        concat!(
            "Offset of field: ",
            stringify!(cgroup),
            "::",
            stringify!(rstat_cpu)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cgroup>())).rstat_css_list as *const _ as usize },
        776usize,
        concat!(
            "Offset of field: ",
            stringify!(cgroup),
            "::",
            stringify!(rstat_css_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cgroup>())).pending_bstat as *const _ as usize },
        792usize,
        concat!(
            "Offset of field: ",
            stringify!(cgroup),
            "::",
            stringify!(pending_bstat)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cgroup>())).bstat as *const _ as usize },
        816usize,
        concat!(
            "Offset of field: ",
            stringify!(cgroup),
            "::",
            stringify!(bstat)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cgroup>())).prev_cputime as *const _ as usize },
        840usize,
        concat!(
            "Offset of field: ",
            stringify!(cgroup),
            "::",
            stringify!(prev_cputime)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cgroup>())).pidlists as *const _ as usize },
        864usize,
        concat!(
            "Offset of field: ",
            stringify!(cgroup),
            "::",
            stringify!(pidlists)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cgroup>())).pidlist_mutex as *const _ as usize },
        880usize,
        concat!(
            "Offset of field: ",
            stringify!(cgroup),
            "::",
            stringify!(pidlist_mutex)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cgroup>())).offline_waitq as *const _ as usize },
        912usize,
        concat!(
            "Offset of field: ",
            stringify!(cgroup),
            "::",
            stringify!(offline_waitq)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cgroup>())).release_agent_work as *const _ as usize },
        936usize,
        concat!(
            "Offset of field: ",
            stringify!(cgroup),
            "::",
            stringify!(release_agent_work)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cgroup>())).psi as *const _ as usize },
        968usize,
        concat!(
            "Offset of field: ",
            stringify!(cgroup),
            "::",
            stringify!(psi)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cgroup>())).bpf as *const _ as usize },
        1584usize,
        concat!(
            "Offset of field: ",
            stringify!(cgroup),
            "::",
            stringify!(bpf)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cgroup>())).congestion_count as *const _ as usize },
        2328usize,
        concat!(
            "Offset of field: ",
            stringify!(cgroup),
            "::",
            stringify!(congestion_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cgroup>())).freezer as *const _ as usize },
        2332usize,
        concat!(
            "Offset of field: ",
            stringify!(cgroup),
            "::",
            stringify!(freezer)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cgroup>())).ancestor_ids as *const _ as usize },
        2348usize,
        concat!(
            "Offset of field: ",
            stringify!(cgroup),
            "::",
            stringify!(ancestor_ids)
        )
    );
}
impl Default for cgroup {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct cgroup_root {
    pub kf_root: *mut kernfs_root,
    pub subsys_mask: c_types::c_uint,
    pub hierarchy_id: c_types::c_int,
    pub cgrp: cgroup,
    pub cgrp_ancestor_id_storage: c_types::c_int,
    pub nr_cgrps: atomic_t,
    pub root_list: list_head,
    pub flags: c_types::c_uint,
    pub cgroup_idr: idr,
    pub release_agent_path: [c_types::c_char; 4096usize],
    pub name: [c_types::c_char; 64usize],
}
#[test]
fn bindgen_test_layout_cgroup_root() {
    assert_eq!(
        ::core::mem::size_of::<cgroup_root>(),
        6584usize,
        concat!("Size of: ", stringify!(cgroup_root))
    );
    assert_eq!(
        ::core::mem::align_of::<cgroup_root>(),
        8usize,
        concat!("Alignment of ", stringify!(cgroup_root))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cgroup_root>())).kf_root as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cgroup_root),
            "::",
            stringify!(kf_root)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cgroup_root>())).subsys_mask as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cgroup_root),
            "::",
            stringify!(subsys_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cgroup_root>())).hierarchy_id as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cgroup_root),
            "::",
            stringify!(hierarchy_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cgroup_root>())).cgrp as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cgroup_root),
            "::",
            stringify!(cgrp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<cgroup_root>())).cgrp_ancestor_id_storage as *const _ as usize
        },
        2368usize,
        concat!(
            "Offset of field: ",
            stringify!(cgroup_root),
            "::",
            stringify!(cgrp_ancestor_id_storage)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cgroup_root>())).nr_cgrps as *const _ as usize },
        2372usize,
        concat!(
            "Offset of field: ",
            stringify!(cgroup_root),
            "::",
            stringify!(nr_cgrps)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cgroup_root>())).root_list as *const _ as usize },
        2376usize,
        concat!(
            "Offset of field: ",
            stringify!(cgroup_root),
            "::",
            stringify!(root_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cgroup_root>())).flags as *const _ as usize },
        2392usize,
        concat!(
            "Offset of field: ",
            stringify!(cgroup_root),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cgroup_root>())).cgroup_idr as *const _ as usize },
        2400usize,
        concat!(
            "Offset of field: ",
            stringify!(cgroup_root),
            "::",
            stringify!(cgroup_idr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cgroup_root>())).release_agent_path as *const _ as usize },
        2424usize,
        concat!(
            "Offset of field: ",
            stringify!(cgroup_root),
            "::",
            stringify!(release_agent_path)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cgroup_root>())).name as *const _ as usize },
        6520usize,
        concat!(
            "Offset of field: ",
            stringify!(cgroup_root),
            "::",
            stringify!(name)
        )
    );
}
impl Default for cgroup_root {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cftype {
    pub name: [c_types::c_char; 64usize],
    pub private: c_types::c_ulong,
    pub max_write_len: usize,
    pub flags: c_types::c_uint,
    pub file_offset: c_types::c_uint,
    pub ss: *mut cgroup_subsys,
    pub node: list_head,
    pub kf_ops: *mut kernfs_ops,
    pub open:
        ::core::option::Option<unsafe extern "C" fn(of: *mut kernfs_open_file) -> c_types::c_int>,
    pub release: ::core::option::Option<unsafe extern "C" fn(of: *mut kernfs_open_file)>,
    pub read_u64: ::core::option::Option<
        unsafe extern "C" fn(css: *mut cgroup_subsys_state, cft: *mut cftype) -> u64_,
    >,
    pub read_s64: ::core::option::Option<
        unsafe extern "C" fn(css: *mut cgroup_subsys_state, cft: *mut cftype) -> s64,
    >,
    pub seq_show: ::core::option::Option<
        unsafe extern "C" fn(sf: *mut seq_file, v: *mut c_types::c_void) -> c_types::c_int,
    >,
    pub seq_start: ::core::option::Option<
        unsafe extern "C" fn(sf: *mut seq_file, ppos: *mut loff_t) -> *mut c_types::c_void,
    >,
    pub seq_next: ::core::option::Option<
        unsafe extern "C" fn(
            sf: *mut seq_file,
            v: *mut c_types::c_void,
            ppos: *mut loff_t,
        ) -> *mut c_types::c_void,
    >,
    pub seq_stop:
        ::core::option::Option<unsafe extern "C" fn(sf: *mut seq_file, v: *mut c_types::c_void)>,
    pub write_u64: ::core::option::Option<
        unsafe extern "C" fn(
            css: *mut cgroup_subsys_state,
            cft: *mut cftype,
            val: u64_,
        ) -> c_types::c_int,
    >,
    pub write_s64: ::core::option::Option<
        unsafe extern "C" fn(
            css: *mut cgroup_subsys_state,
            cft: *mut cftype,
            val: s64,
        ) -> c_types::c_int,
    >,
    pub write: ::core::option::Option<
        unsafe extern "C" fn(
            of: *mut kernfs_open_file,
            buf: *mut c_types::c_char,
            nbytes: usize,
            off: loff_t,
        ) -> isize,
    >,
    pub poll: ::core::option::Option<
        unsafe extern "C" fn(of: *mut kernfs_open_file, pt: *mut poll_table_struct) -> __poll_t,
    >,
}
#[test]
fn bindgen_test_layout_cftype() {
    assert_eq!(
        ::core::mem::size_of::<cftype>(),
        216usize,
        concat!("Size of: ", stringify!(cftype))
    );
    assert_eq!(
        ::core::mem::align_of::<cftype>(),
        8usize,
        concat!("Alignment of ", stringify!(cftype))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cftype>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cftype),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cftype>())).private as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(cftype),
            "::",
            stringify!(private)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cftype>())).max_write_len as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(cftype),
            "::",
            stringify!(max_write_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cftype>())).flags as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(cftype),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cftype>())).file_offset as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(cftype),
            "::",
            stringify!(file_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cftype>())).ss as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(cftype),
            "::",
            stringify!(ss)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cftype>())).node as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(cftype),
            "::",
            stringify!(node)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cftype>())).kf_ops as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(cftype),
            "::",
            stringify!(kf_ops)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cftype>())).open as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(cftype),
            "::",
            stringify!(open)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cftype>())).release as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(cftype),
            "::",
            stringify!(release)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cftype>())).read_u64 as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(cftype),
            "::",
            stringify!(read_u64)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cftype>())).read_s64 as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(cftype),
            "::",
            stringify!(read_s64)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cftype>())).seq_show as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(cftype),
            "::",
            stringify!(seq_show)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cftype>())).seq_start as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(cftype),
            "::",
            stringify!(seq_start)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cftype>())).seq_next as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(cftype),
            "::",
            stringify!(seq_next)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cftype>())).seq_stop as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(cftype),
            "::",
            stringify!(seq_stop)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cftype>())).write_u64 as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(cftype),
            "::",
            stringify!(write_u64)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cftype>())).write_s64 as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(cftype),
            "::",
            stringify!(write_s64)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cftype>())).write as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(cftype),
            "::",
            stringify!(write)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cftype>())).poll as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(cftype),
            "::",
            stringify!(poll)
        )
    );
}
impl Default for cftype {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cgroup_subsys {
    pub css_alloc: ::core::option::Option<
        unsafe extern "C" fn(parent_css: *mut cgroup_subsys_state) -> *mut cgroup_subsys_state,
    >,
    pub css_online: ::core::option::Option<
        unsafe extern "C" fn(css: *mut cgroup_subsys_state) -> c_types::c_int,
    >,
    pub css_offline: ::core::option::Option<unsafe extern "C" fn(css: *mut cgroup_subsys_state)>,
    pub css_released: ::core::option::Option<unsafe extern "C" fn(css: *mut cgroup_subsys_state)>,
    pub css_free: ::core::option::Option<unsafe extern "C" fn(css: *mut cgroup_subsys_state)>,
    pub css_reset: ::core::option::Option<unsafe extern "C" fn(css: *mut cgroup_subsys_state)>,
    pub css_rstat_flush: ::core::option::Option<
        unsafe extern "C" fn(css: *mut cgroup_subsys_state, cpu: c_types::c_int),
    >,
    pub css_extra_stat_show: ::core::option::Option<
        unsafe extern "C" fn(seq: *mut seq_file, css: *mut cgroup_subsys_state) -> c_types::c_int,
    >,
    pub can_attach:
        ::core::option::Option<unsafe extern "C" fn(tset: *mut cgroup_taskset) -> c_types::c_int>,
    pub cancel_attach: ::core::option::Option<unsafe extern "C" fn(tset: *mut cgroup_taskset)>,
    pub attach: ::core::option::Option<unsafe extern "C" fn(tset: *mut cgroup_taskset)>,
    pub post_attach: ::core::option::Option<unsafe extern "C" fn()>,
    pub can_fork:
        ::core::option::Option<unsafe extern "C" fn(task: *mut task_struct) -> c_types::c_int>,
    pub cancel_fork: ::core::option::Option<unsafe extern "C" fn(task: *mut task_struct)>,
    pub fork: ::core::option::Option<unsafe extern "C" fn(task: *mut task_struct)>,
    pub exit: ::core::option::Option<unsafe extern "C" fn(task: *mut task_struct)>,
    pub release: ::core::option::Option<unsafe extern "C" fn(task: *mut task_struct)>,
    pub bind: ::core::option::Option<unsafe extern "C" fn(root_css: *mut cgroup_subsys_state)>,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub id: c_types::c_int,
    pub name: *const c_types::c_char,
    pub legacy_name: *const c_types::c_char,
    pub root: *mut cgroup_root,
    pub css_idr: idr,
    pub cfts: list_head,
    pub dfl_cftypes: *mut cftype,
    pub legacy_cftypes: *mut cftype,
    pub depends_on: c_types::c_uint,
}
#[test]
fn bindgen_test_layout_cgroup_subsys() {
    assert_eq!(
        ::core::mem::size_of::<cgroup_subsys>(),
        240usize,
        concat!("Size of: ", stringify!(cgroup_subsys))
    );
    assert_eq!(
        ::core::mem::align_of::<cgroup_subsys>(),
        8usize,
        concat!("Alignment of ", stringify!(cgroup_subsys))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cgroup_subsys>())).css_alloc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cgroup_subsys),
            "::",
            stringify!(css_alloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cgroup_subsys>())).css_online as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cgroup_subsys),
            "::",
            stringify!(css_online)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cgroup_subsys>())).css_offline as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cgroup_subsys),
            "::",
            stringify!(css_offline)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cgroup_subsys>())).css_released as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cgroup_subsys),
            "::",
            stringify!(css_released)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cgroup_subsys>())).css_free as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cgroup_subsys),
            "::",
            stringify!(css_free)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cgroup_subsys>())).css_reset as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cgroup_subsys),
            "::",
            stringify!(css_reset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cgroup_subsys>())).css_rstat_flush as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(cgroup_subsys),
            "::",
            stringify!(css_rstat_flush)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<cgroup_subsys>())).css_extra_stat_show as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(cgroup_subsys),
            "::",
            stringify!(css_extra_stat_show)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cgroup_subsys>())).can_attach as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(cgroup_subsys),
            "::",
            stringify!(can_attach)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cgroup_subsys>())).cancel_attach as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(cgroup_subsys),
            "::",
            stringify!(cancel_attach)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cgroup_subsys>())).attach as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(cgroup_subsys),
            "::",
            stringify!(attach)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cgroup_subsys>())).post_attach as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(cgroup_subsys),
            "::",
            stringify!(post_attach)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cgroup_subsys>())).can_fork as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(cgroup_subsys),
            "::",
            stringify!(can_fork)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cgroup_subsys>())).cancel_fork as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(cgroup_subsys),
            "::",
            stringify!(cancel_fork)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cgroup_subsys>())).fork as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(cgroup_subsys),
            "::",
            stringify!(fork)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cgroup_subsys>())).exit as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(cgroup_subsys),
            "::",
            stringify!(exit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cgroup_subsys>())).release as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(cgroup_subsys),
            "::",
            stringify!(release)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cgroup_subsys>())).bind as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(cgroup_subsys),
            "::",
            stringify!(bind)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cgroup_subsys>())).id as *const _ as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(cgroup_subsys),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cgroup_subsys>())).name as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(cgroup_subsys),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cgroup_subsys>())).legacy_name as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(cgroup_subsys),
            "::",
            stringify!(legacy_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cgroup_subsys>())).root as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(cgroup_subsys),
            "::",
            stringify!(root)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cgroup_subsys>())).css_idr as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(cgroup_subsys),
            "::",
            stringify!(css_idr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cgroup_subsys>())).cfts as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(cgroup_subsys),
            "::",
            stringify!(cfts)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cgroup_subsys>())).dfl_cftypes as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(cgroup_subsys),
            "::",
            stringify!(dfl_cftypes)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cgroup_subsys>())).legacy_cftypes as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(cgroup_subsys),
            "::",
            stringify!(legacy_cftypes)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cgroup_subsys>())).depends_on as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(cgroup_subsys),
            "::",
            stringify!(depends_on)
        )
    );
}
impl Default for cgroup_subsys {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl cgroup_subsys {
    #[inline]
    pub fn early_init(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_early_init(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn implicit_on_dfl(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_implicit_on_dfl(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn threaded(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_threaded(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn broken_hierarchy(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_broken_hierarchy(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn warned_broken_hierarchy(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_warned_broken_hierarchy(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        early_init: bool_,
        implicit_on_dfl: bool_,
        threaded: bool_,
        broken_hierarchy: bool_,
        warned_broken_hierarchy: bool_,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let early_init: u8 = unsafe { ::core::mem::transmute(early_init) };
            early_init as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let implicit_on_dfl: u8 = unsafe { ::core::mem::transmute(implicit_on_dfl) };
            implicit_on_dfl as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let threaded: u8 = unsafe { ::core::mem::transmute(threaded) };
            threaded as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let broken_hierarchy: u8 = unsafe { ::core::mem::transmute(broken_hierarchy) };
            broken_hierarchy as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let warned_broken_hierarchy: u8 =
                unsafe { ::core::mem::transmute(warned_broken_hierarchy) };
            warned_broken_hierarchy as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sock_cgroup_data {
    pub __bindgen_anon_1: sock_cgroup_data__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sock_cgroup_data__bindgen_ty_1 {
    pub __bindgen_anon_1: sock_cgroup_data__bindgen_ty_1__bindgen_ty_1,
    pub val: u64_,
    _bindgen_union_align: u64,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct sock_cgroup_data__bindgen_ty_1__bindgen_ty_1 {
    pub is_data: u8_,
    pub padding: u8_,
    pub prioidx: u16_,
    pub classid: u32_,
}
#[test]
fn bindgen_test_layout_sock_cgroup_data__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<sock_cgroup_data__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(sock_cgroup_data__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sock_cgroup_data__bindgen_ty_1__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sock_cgroup_data__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sock_cgroup_data__bindgen_ty_1__bindgen_ty_1>())).is_data
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sock_cgroup_data__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(is_data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sock_cgroup_data__bindgen_ty_1__bindgen_ty_1>())).padding
                as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(sock_cgroup_data__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(padding)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sock_cgroup_data__bindgen_ty_1__bindgen_ty_1>())).prioidx
                as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sock_cgroup_data__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(prioidx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sock_cgroup_data__bindgen_ty_1__bindgen_ty_1>())).classid
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sock_cgroup_data__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(classid)
        )
    );
}
#[test]
fn bindgen_test_layout_sock_cgroup_data__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<sock_cgroup_data__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(sock_cgroup_data__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<sock_cgroup_data__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(sock_cgroup_data__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sock_cgroup_data__bindgen_ty_1>())).val as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sock_cgroup_data__bindgen_ty_1),
            "::",
            stringify!(val)
        )
    );
}
impl Default for sock_cgroup_data__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_sock_cgroup_data() {
    assert_eq!(
        ::core::mem::size_of::<sock_cgroup_data>(),
        8usize,
        concat!("Size of: ", stringify!(sock_cgroup_data))
    );
    assert_eq!(
        ::core::mem::align_of::<sock_cgroup_data>(),
        8usize,
        concat!("Alignment of ", stringify!(sock_cgroup_data))
    );
}
impl Default for sock_cgroup_data {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cgroup_namespace {
    pub count: refcount_t,
    pub ns: ns_common,
    pub user_ns: *mut user_namespace,
    pub ucounts: *mut ucounts,
    pub root_cset: *mut css_set,
}
#[test]
fn bindgen_test_layout_cgroup_namespace() {
    assert_eq!(
        ::core::mem::size_of::<cgroup_namespace>(),
        56usize,
        concat!("Size of: ", stringify!(cgroup_namespace))
    );
    assert_eq!(
        ::core::mem::align_of::<cgroup_namespace>(),
        8usize,
        concat!("Alignment of ", stringify!(cgroup_namespace))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cgroup_namespace>())).count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cgroup_namespace),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cgroup_namespace>())).ns as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cgroup_namespace),
            "::",
            stringify!(ns)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cgroup_namespace>())).user_ns as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cgroup_namespace),
            "::",
            stringify!(user_ns)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cgroup_namespace>())).ucounts as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cgroup_namespace),
            "::",
            stringify!(ucounts)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cgroup_namespace>())).root_cset as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(cgroup_namespace),
            "::",
            stringify!(root_cset)
        )
    );
}
impl Default for cgroup_namespace {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct netprio_map {
    pub rcu: callback_head,
    pub priomap_len: u32_,
    pub priomap: __IncompleteArrayField<u32_>,
}
#[test]
fn bindgen_test_layout_netprio_map() {
    assert_eq!(
        ::core::mem::size_of::<netprio_map>(),
        24usize,
        concat!("Size of: ", stringify!(netprio_map))
    );
    assert_eq!(
        ::core::mem::align_of::<netprio_map>(),
        8usize,
        concat!("Alignment of ", stringify!(netprio_map))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netprio_map>())).rcu as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(netprio_map),
            "::",
            stringify!(rcu)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netprio_map>())).priomap_len as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(netprio_map),
            "::",
            stringify!(priomap_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netprio_map>())).priomap as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(netprio_map),
            "::",
            stringify!(priomap)
        )
    );
}
impl Default for netprio_map {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct xdp_mem_info {
    pub type_: u32_,
    pub id: u32_,
}
#[test]
fn bindgen_test_layout_xdp_mem_info() {
    assert_eq!(
        ::core::mem::size_of::<xdp_mem_info>(),
        8usize,
        concat!("Size of: ", stringify!(xdp_mem_info))
    );
    assert_eq!(
        ::core::mem::align_of::<xdp_mem_info>(),
        4usize,
        concat!("Alignment of ", stringify!(xdp_mem_info))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xdp_mem_info>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xdp_mem_info),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xdp_mem_info>())).id as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xdp_mem_info),
            "::",
            stringify!(id)
        )
    );
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct xdp_rxq_info {
    pub dev: *mut net_device,
    pub queue_index: u32_,
    pub reg_state: u32_,
    pub mem: xdp_mem_info,
}
#[test]
fn bindgen_test_layout_xdp_rxq_info() {
    assert_eq!(
        ::core::mem::size_of::<xdp_rxq_info>(),
        64usize,
        concat!("Size of: ", stringify!(xdp_rxq_info))
    );
    assert_eq!(
        ::core::mem::align_of::<xdp_rxq_info>(),
        64usize,
        concat!("Alignment of ", stringify!(xdp_rxq_info))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xdp_rxq_info>())).dev as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xdp_rxq_info),
            "::",
            stringify!(dev)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xdp_rxq_info>())).queue_index as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xdp_rxq_info),
            "::",
            stringify!(queue_index)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xdp_rxq_info>())).reg_state as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xdp_rxq_info),
            "::",
            stringify!(reg_state)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xdp_rxq_info>())).mem as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xdp_rxq_info),
            "::",
            stringify!(mem)
        )
    );
}
impl Default for xdp_rxq_info {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xdp_frame {
    pub data: *mut c_types::c_void,
    pub len: u16_,
    pub headroom: u16_,
    pub metasize: u16_,
    pub mem: xdp_mem_info,
    pub dev_rx: *mut net_device,
}
#[test]
fn bindgen_test_layout_xdp_frame() {
    assert_eq!(
        ::core::mem::size_of::<xdp_frame>(),
        32usize,
        concat!("Size of: ", stringify!(xdp_frame))
    );
    assert_eq!(
        ::core::mem::align_of::<xdp_frame>(),
        8usize,
        concat!("Alignment of ", stringify!(xdp_frame))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xdp_frame>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xdp_frame),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xdp_frame>())).len as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xdp_frame),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xdp_frame>())).headroom as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xdp_frame),
            "::",
            stringify!(headroom)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xdp_frame>())).metasize as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xdp_frame),
            "::",
            stringify!(metasize)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xdp_frame>())).mem as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xdp_frame),
            "::",
            stringify!(mem)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xdp_frame>())).dev_rx as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(xdp_frame),
            "::",
            stringify!(dev_rx)
        )
    );
}
impl Default for xdp_frame {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ndmsg {
    pub ndm_family: __u8,
    pub ndm_pad1: __u8,
    pub ndm_pad2: __u16,
    pub ndm_ifindex: __s32,
    pub ndm_state: __u16,
    pub ndm_flags: __u8,
    pub ndm_type: __u8,
}
#[test]
fn bindgen_test_layout_ndmsg() {
    assert_eq!(
        ::core::mem::size_of::<ndmsg>(),
        12usize,
        concat!("Size of: ", stringify!(ndmsg))
    );
    assert_eq!(
        ::core::mem::align_of::<ndmsg>(),
        4usize,
        concat!("Alignment of ", stringify!(ndmsg))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ndmsg>())).ndm_family as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ndmsg),
            "::",
            stringify!(ndm_family)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ndmsg>())).ndm_pad1 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(ndmsg),
            "::",
            stringify!(ndm_pad1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ndmsg>())).ndm_pad2 as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ndmsg),
            "::",
            stringify!(ndm_pad2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ndmsg>())).ndm_ifindex as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ndmsg),
            "::",
            stringify!(ndm_ifindex)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ndmsg>())).ndm_state as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ndmsg),
            "::",
            stringify!(ndm_state)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ndmsg>())).ndm_flags as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(ndmsg),
            "::",
            stringify!(ndm_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ndmsg>())).ndm_type as *const _ as usize },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(ndmsg),
            "::",
            stringify!(ndm_type)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rtnl_link_stats64 {
    pub rx_packets: __u64,
    pub tx_packets: __u64,
    pub rx_bytes: __u64,
    pub tx_bytes: __u64,
    pub rx_errors: __u64,
    pub tx_errors: __u64,
    pub rx_dropped: __u64,
    pub tx_dropped: __u64,
    pub multicast: __u64,
    pub collisions: __u64,
    pub rx_length_errors: __u64,
    pub rx_over_errors: __u64,
    pub rx_crc_errors: __u64,
    pub rx_frame_errors: __u64,
    pub rx_fifo_errors: __u64,
    pub rx_missed_errors: __u64,
    pub tx_aborted_errors: __u64,
    pub tx_carrier_errors: __u64,
    pub tx_fifo_errors: __u64,
    pub tx_heartbeat_errors: __u64,
    pub tx_window_errors: __u64,
    pub rx_compressed: __u64,
    pub tx_compressed: __u64,
    pub rx_nohandler: __u64,
}
#[test]
fn bindgen_test_layout_rtnl_link_stats64() {
    assert_eq!(
        ::core::mem::size_of::<rtnl_link_stats64>(),
        192usize,
        concat!("Size of: ", stringify!(rtnl_link_stats64))
    );
    assert_eq!(
        ::core::mem::align_of::<rtnl_link_stats64>(),
        8usize,
        concat!("Alignment of ", stringify!(rtnl_link_stats64))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rtnl_link_stats64>())).rx_packets as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rtnl_link_stats64),
            "::",
            stringify!(rx_packets)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rtnl_link_stats64>())).tx_packets as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rtnl_link_stats64),
            "::",
            stringify!(tx_packets)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rtnl_link_stats64>())).rx_bytes as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rtnl_link_stats64),
            "::",
            stringify!(rx_bytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rtnl_link_stats64>())).tx_bytes as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rtnl_link_stats64),
            "::",
            stringify!(tx_bytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rtnl_link_stats64>())).rx_errors as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rtnl_link_stats64),
            "::",
            stringify!(rx_errors)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rtnl_link_stats64>())).tx_errors as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rtnl_link_stats64),
            "::",
            stringify!(tx_errors)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rtnl_link_stats64>())).rx_dropped as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rtnl_link_stats64),
            "::",
            stringify!(rx_dropped)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rtnl_link_stats64>())).tx_dropped as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rtnl_link_stats64),
            "::",
            stringify!(tx_dropped)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rtnl_link_stats64>())).multicast as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rtnl_link_stats64),
            "::",
            stringify!(multicast)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rtnl_link_stats64>())).collisions as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rtnl_link_stats64),
            "::",
            stringify!(collisions)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rtnl_link_stats64>())).rx_length_errors as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rtnl_link_stats64),
            "::",
            stringify!(rx_length_errors)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rtnl_link_stats64>())).rx_over_errors as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rtnl_link_stats64),
            "::",
            stringify!(rx_over_errors)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rtnl_link_stats64>())).rx_crc_errors as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rtnl_link_stats64),
            "::",
            stringify!(rx_crc_errors)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rtnl_link_stats64>())).rx_frame_errors as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rtnl_link_stats64),
            "::",
            stringify!(rx_frame_errors)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rtnl_link_stats64>())).rx_fifo_errors as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rtnl_link_stats64),
            "::",
            stringify!(rx_fifo_errors)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rtnl_link_stats64>())).rx_missed_errors as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(rtnl_link_stats64),
            "::",
            stringify!(rx_missed_errors)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rtnl_link_stats64>())).tx_aborted_errors as *const _ as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(rtnl_link_stats64),
            "::",
            stringify!(tx_aborted_errors)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rtnl_link_stats64>())).tx_carrier_errors as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(rtnl_link_stats64),
            "::",
            stringify!(tx_carrier_errors)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rtnl_link_stats64>())).tx_fifo_errors as *const _ as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(rtnl_link_stats64),
            "::",
            stringify!(tx_fifo_errors)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rtnl_link_stats64>())).tx_heartbeat_errors as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(rtnl_link_stats64),
            "::",
            stringify!(tx_heartbeat_errors)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rtnl_link_stats64>())).tx_window_errors as *const _ as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(rtnl_link_stats64),
            "::",
            stringify!(tx_window_errors)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rtnl_link_stats64>())).rx_compressed as *const _ as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(rtnl_link_stats64),
            "::",
            stringify!(rx_compressed)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rtnl_link_stats64>())).tx_compressed as *const _ as usize
        },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(rtnl_link_stats64),
            "::",
            stringify!(tx_compressed)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rtnl_link_stats64>())).rx_nohandler as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(rtnl_link_stats64),
            "::",
            stringify!(rx_nohandler)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ifla_vf_stats {
    pub rx_packets: __u64,
    pub tx_packets: __u64,
    pub rx_bytes: __u64,
    pub tx_bytes: __u64,
    pub broadcast: __u64,
    pub multicast: __u64,
    pub rx_dropped: __u64,
    pub tx_dropped: __u64,
}
#[test]
fn bindgen_test_layout_ifla_vf_stats() {
    assert_eq!(
        ::core::mem::size_of::<ifla_vf_stats>(),
        64usize,
        concat!("Size of: ", stringify!(ifla_vf_stats))
    );
    assert_eq!(
        ::core::mem::align_of::<ifla_vf_stats>(),
        8usize,
        concat!("Alignment of ", stringify!(ifla_vf_stats))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ifla_vf_stats>())).rx_packets as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ifla_vf_stats),
            "::",
            stringify!(rx_packets)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ifla_vf_stats>())).tx_packets as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ifla_vf_stats),
            "::",
            stringify!(tx_packets)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ifla_vf_stats>())).rx_bytes as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ifla_vf_stats),
            "::",
            stringify!(rx_bytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ifla_vf_stats>())).tx_bytes as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ifla_vf_stats),
            "::",
            stringify!(tx_bytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ifla_vf_stats>())).broadcast as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ifla_vf_stats),
            "::",
            stringify!(broadcast)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ifla_vf_stats>())).multicast as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ifla_vf_stats),
            "::",
            stringify!(multicast)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ifla_vf_stats>())).rx_dropped as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ifla_vf_stats),
            "::",
            stringify!(rx_dropped)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ifla_vf_stats>())).tx_dropped as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ifla_vf_stats),
            "::",
            stringify!(tx_dropped)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ifla_vf_info {
    pub vf: __u32,
    pub mac: [__u8; 32usize],
    pub vlan: __u32,
    pub qos: __u32,
    pub spoofchk: __u32,
    pub linkstate: __u32,
    pub min_tx_rate: __u32,
    pub max_tx_rate: __u32,
    pub rss_query_en: __u32,
    pub trusted: __u32,
    pub vlan_proto: __be16,
}
#[test]
fn bindgen_test_layout_ifla_vf_info() {
    assert_eq!(
        ::core::mem::size_of::<ifla_vf_info>(),
        72usize,
        concat!("Size of: ", stringify!(ifla_vf_info))
    );
    assert_eq!(
        ::core::mem::align_of::<ifla_vf_info>(),
        4usize,
        concat!("Alignment of ", stringify!(ifla_vf_info))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ifla_vf_info>())).vf as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ifla_vf_info),
            "::",
            stringify!(vf)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ifla_vf_info>())).mac as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ifla_vf_info),
            "::",
            stringify!(mac)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ifla_vf_info>())).vlan as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(ifla_vf_info),
            "::",
            stringify!(vlan)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ifla_vf_info>())).qos as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ifla_vf_info),
            "::",
            stringify!(qos)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ifla_vf_info>())).spoofchk as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(ifla_vf_info),
            "::",
            stringify!(spoofchk)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ifla_vf_info>())).linkstate as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ifla_vf_info),
            "::",
            stringify!(linkstate)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ifla_vf_info>())).min_tx_rate as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(ifla_vf_info),
            "::",
            stringify!(min_tx_rate)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ifla_vf_info>())).max_tx_rate as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ifla_vf_info),
            "::",
            stringify!(max_tx_rate)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ifla_vf_info>())).rss_query_en as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(ifla_vf_info),
            "::",
            stringify!(rss_query_en)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ifla_vf_info>())).trusted as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(ifla_vf_info),
            "::",
            stringify!(trusted)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ifla_vf_info>())).vlan_proto as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(ifla_vf_info),
            "::",
            stringify!(vlan_proto)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct tc_stats {
    pub bytes: __u64,
    pub packets: __u32,
    pub drops: __u32,
    pub overlimits: __u32,
    pub bps: __u32,
    pub pps: __u32,
    pub qlen: __u32,
    pub backlog: __u32,
}
#[test]
fn bindgen_test_layout_tc_stats() {
    assert_eq!(
        ::core::mem::size_of::<tc_stats>(),
        40usize,
        concat!("Size of: ", stringify!(tc_stats))
    );
    assert_eq!(
        ::core::mem::align_of::<tc_stats>(),
        8usize,
        concat!("Alignment of ", stringify!(tc_stats))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tc_stats>())).bytes as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tc_stats),
            "::",
            stringify!(bytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tc_stats>())).packets as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tc_stats),
            "::",
            stringify!(packets)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tc_stats>())).drops as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(tc_stats),
            "::",
            stringify!(drops)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tc_stats>())).overlimits as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tc_stats),
            "::",
            stringify!(overlimits)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tc_stats>())).bps as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(tc_stats),
            "::",
            stringify!(bps)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tc_stats>())).pps as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(tc_stats),
            "::",
            stringify!(pps)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tc_stats>())).qlen as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(tc_stats),
            "::",
            stringify!(qlen)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tc_stats>())).backlog as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(tc_stats),
            "::",
            stringify!(backlog)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct tc_sizespec {
    pub cell_log: c_types::c_uchar,
    pub size_log: c_types::c_uchar,
    pub cell_align: c_types::c_short,
    pub overhead: c_types::c_int,
    pub linklayer: c_types::c_uint,
    pub mpu: c_types::c_uint,
    pub mtu: c_types::c_uint,
    pub tsize: c_types::c_uint,
}
#[test]
fn bindgen_test_layout_tc_sizespec() {
    assert_eq!(
        ::core::mem::size_of::<tc_sizespec>(),
        24usize,
        concat!("Size of: ", stringify!(tc_sizespec))
    );
    assert_eq!(
        ::core::mem::align_of::<tc_sizespec>(),
        4usize,
        concat!("Alignment of ", stringify!(tc_sizespec))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tc_sizespec>())).cell_log as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tc_sizespec),
            "::",
            stringify!(cell_log)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tc_sizespec>())).size_log as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(tc_sizespec),
            "::",
            stringify!(size_log)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tc_sizespec>())).cell_align as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(tc_sizespec),
            "::",
            stringify!(cell_align)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tc_sizespec>())).overhead as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tc_sizespec),
            "::",
            stringify!(overhead)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tc_sizespec>())).linklayer as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tc_sizespec),
            "::",
            stringify!(linklayer)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tc_sizespec>())).mpu as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(tc_sizespec),
            "::",
            stringify!(mpu)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tc_sizespec>())).mtu as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tc_sizespec),
            "::",
            stringify!(mtu)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tc_sizespec>())).tsize as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(tc_sizespec),
            "::",
            stringify!(tsize)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct netpoll_info {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct phy_device {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dsa_port {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sfp_bus {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wireless_dev {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wpan_dev {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mpls_dev {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct udp_tunnel_info {
    _unused: [u8; 0],
}
pub const netdev_tx___NETDEV_TX_MIN: netdev_tx = -2147483648;
pub const netdev_tx_NETDEV_TX_OK: netdev_tx = 0;
pub const netdev_tx_NETDEV_TX_BUSY: netdev_tx = 16;
pub type netdev_tx = c_types::c_int;
pub use self::netdev_tx as netdev_tx_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct net_device_stats {
    pub rx_packets: c_types::c_ulong,
    pub tx_packets: c_types::c_ulong,
    pub rx_bytes: c_types::c_ulong,
    pub tx_bytes: c_types::c_ulong,
    pub rx_errors: c_types::c_ulong,
    pub tx_errors: c_types::c_ulong,
    pub rx_dropped: c_types::c_ulong,
    pub tx_dropped: c_types::c_ulong,
    pub multicast: c_types::c_ulong,
    pub collisions: c_types::c_ulong,
    pub rx_length_errors: c_types::c_ulong,
    pub rx_over_errors: c_types::c_ulong,
    pub rx_crc_errors: c_types::c_ulong,
    pub rx_frame_errors: c_types::c_ulong,
    pub rx_fifo_errors: c_types::c_ulong,
    pub rx_missed_errors: c_types::c_ulong,
    pub tx_aborted_errors: c_types::c_ulong,
    pub tx_carrier_errors: c_types::c_ulong,
    pub tx_fifo_errors: c_types::c_ulong,
    pub tx_heartbeat_errors: c_types::c_ulong,
    pub tx_window_errors: c_types::c_ulong,
    pub rx_compressed: c_types::c_ulong,
    pub tx_compressed: c_types::c_ulong,
}
#[test]
fn bindgen_test_layout_net_device_stats() {
    assert_eq!(
        ::core::mem::size_of::<net_device_stats>(),
        184usize,
        concat!("Size of: ", stringify!(net_device_stats))
    );
    assert_eq!(
        ::core::mem::align_of::<net_device_stats>(),
        8usize,
        concat!("Alignment of ", stringify!(net_device_stats))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device_stats>())).rx_packets as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device_stats),
            "::",
            stringify!(rx_packets)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device_stats>())).tx_packets as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device_stats),
            "::",
            stringify!(tx_packets)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device_stats>())).rx_bytes as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device_stats),
            "::",
            stringify!(rx_bytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device_stats>())).tx_bytes as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device_stats),
            "::",
            stringify!(tx_bytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device_stats>())).rx_errors as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device_stats),
            "::",
            stringify!(rx_errors)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device_stats>())).tx_errors as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device_stats),
            "::",
            stringify!(tx_errors)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device_stats>())).rx_dropped as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device_stats),
            "::",
            stringify!(rx_dropped)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device_stats>())).tx_dropped as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device_stats),
            "::",
            stringify!(tx_dropped)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device_stats>())).multicast as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device_stats),
            "::",
            stringify!(multicast)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device_stats>())).collisions as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device_stats),
            "::",
            stringify!(collisions)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<net_device_stats>())).rx_length_errors as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device_stats),
            "::",
            stringify!(rx_length_errors)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<net_device_stats>())).rx_over_errors as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device_stats),
            "::",
            stringify!(rx_over_errors)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device_stats>())).rx_crc_errors as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device_stats),
            "::",
            stringify!(rx_crc_errors)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<net_device_stats>())).rx_frame_errors as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device_stats),
            "::",
            stringify!(rx_frame_errors)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<net_device_stats>())).rx_fifo_errors as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device_stats),
            "::",
            stringify!(rx_fifo_errors)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<net_device_stats>())).rx_missed_errors as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device_stats),
            "::",
            stringify!(rx_missed_errors)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<net_device_stats>())).tx_aborted_errors as *const _ as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device_stats),
            "::",
            stringify!(tx_aborted_errors)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<net_device_stats>())).tx_carrier_errors as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device_stats),
            "::",
            stringify!(tx_carrier_errors)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<net_device_stats>())).tx_fifo_errors as *const _ as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device_stats),
            "::",
            stringify!(tx_fifo_errors)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<net_device_stats>())).tx_heartbeat_errors as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device_stats),
            "::",
            stringify!(tx_heartbeat_errors)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<net_device_stats>())).tx_window_errors as *const _ as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device_stats),
            "::",
            stringify!(tx_window_errors)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device_stats>())).rx_compressed as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device_stats),
            "::",
            stringify!(rx_compressed)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device_stats>())).tx_compressed as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device_stats),
            "::",
            stringify!(tx_compressed)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct netdev_hw_addr_list {
    pub list: list_head,
    pub count: c_types::c_int,
}
#[test]
fn bindgen_test_layout_netdev_hw_addr_list() {
    assert_eq!(
        ::core::mem::size_of::<netdev_hw_addr_list>(),
        24usize,
        concat!("Size of: ", stringify!(netdev_hw_addr_list))
    );
    assert_eq!(
        ::core::mem::align_of::<netdev_hw_addr_list>(),
        8usize,
        concat!("Alignment of ", stringify!(netdev_hw_addr_list))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netdev_hw_addr_list>())).list as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(netdev_hw_addr_list),
            "::",
            stringify!(list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netdev_hw_addr_list>())).count as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(netdev_hw_addr_list),
            "::",
            stringify!(count)
        )
    );
}
impl Default for netdev_hw_addr_list {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hh_cache {
    pub hh_len: c_types::c_uint,
    pub hh_lock: seqlock_t,
    pub hh_data: [c_types::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout_hh_cache() {
    assert_eq!(
        ::core::mem::size_of::<hh_cache>(),
        144usize,
        concat!("Size of: ", stringify!(hh_cache))
    );
    assert_eq!(
        ::core::mem::align_of::<hh_cache>(),
        8usize,
        concat!("Alignment of ", stringify!(hh_cache))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hh_cache>())).hh_len as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hh_cache),
            "::",
            stringify!(hh_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hh_cache>())).hh_lock as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(hh_cache),
            "::",
            stringify!(hh_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hh_cache>())).hh_data as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hh_cache),
            "::",
            stringify!(hh_data)
        )
    );
}
impl Default for hh_cache {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct header_ops {
    pub create: ::core::option::Option<
        unsafe extern "C" fn(
            skb: *mut sk_buff,
            dev: *mut net_device,
            type_: c_types::c_ushort,
            daddr: *const c_types::c_void,
            saddr: *const c_types::c_void,
            len: c_types::c_uint,
        ) -> c_types::c_int,
    >,
    pub parse: ::core::option::Option<
        unsafe extern "C" fn(skb: *const sk_buff, haddr: *mut c_types::c_uchar) -> c_types::c_int,
    >,
    pub cache: ::core::option::Option<
        unsafe extern "C" fn(
            neigh: *const neighbour,
            hh: *mut hh_cache,
            type_: __be16,
        ) -> c_types::c_int,
    >,
    pub cache_update: ::core::option::Option<
        unsafe extern "C" fn(
            hh: *mut hh_cache,
            dev: *const net_device,
            haddr: *const c_types::c_uchar,
        ),
    >,
    pub validate: ::core::option::Option<
        unsafe extern "C" fn(ll_header: *const c_types::c_char, len: c_types::c_uint) -> bool_,
    >,
    pub parse_protocol: ::core::option::Option<unsafe extern "C" fn(skb: *const sk_buff) -> __be16>,
}
#[test]
fn bindgen_test_layout_header_ops() {
    assert_eq!(
        ::core::mem::size_of::<header_ops>(),
        48usize,
        concat!("Size of: ", stringify!(header_ops))
    );
    assert_eq!(
        ::core::mem::align_of::<header_ops>(),
        8usize,
        concat!("Alignment of ", stringify!(header_ops))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<header_ops>())).create as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(header_ops),
            "::",
            stringify!(create)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<header_ops>())).parse as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(header_ops),
            "::",
            stringify!(parse)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<header_ops>())).cache as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(header_ops),
            "::",
            stringify!(cache)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<header_ops>())).cache_update as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(header_ops),
            "::",
            stringify!(cache_update)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<header_ops>())).validate as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(header_ops),
            "::",
            stringify!(validate)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<header_ops>())).parse_protocol as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(header_ops),
            "::",
            stringify!(parse_protocol)
        )
    );
}
pub const rx_handler_result_RX_HANDLER_CONSUMED: rx_handler_result = 0;
pub const rx_handler_result_RX_HANDLER_ANOTHER: rx_handler_result = 1;
pub const rx_handler_result_RX_HANDLER_EXACT: rx_handler_result = 2;
pub const rx_handler_result_RX_HANDLER_PASS: rx_handler_result = 3;
pub type rx_handler_result = c_types::c_uint;
pub use self::rx_handler_result as rx_handler_result_t;
pub type rx_handler_func_t =
    ::core::option::Option<unsafe extern "C" fn(pskb: *mut *mut sk_buff) -> rx_handler_result_t>;
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct netdev_queue {
    pub dev: *mut net_device,
    pub qdisc: *mut Qdisc,
    pub qdisc_sleeping: *mut Qdisc,
    pub kobj: kobject,
    pub numa_node: c_types::c_int,
    pub tx_maxrate: c_types::c_ulong,
    pub trans_timeout: c_types::c_ulong,
    pub sb_dev: *mut net_device,
    pub umem: *mut xdp_umem,
    pub _xmit_lock: spinlock_t,
    pub xmit_lock_owner: c_types::c_int,
    pub trans_start: c_types::c_ulong,
    pub state: c_types::c_ulong,
    pub __bindgen_padding_0: [u64; 5usize],
    pub dql: dql,
}
#[test]
fn bindgen_test_layout_netdev_queue() {
    assert_eq!(
        ::core::mem::size_of::<netdev_queue>(),
        320usize,
        concat!("Size of: ", stringify!(netdev_queue))
    );
    assert_eq!(
        ::core::mem::align_of::<netdev_queue>(),
        64usize,
        concat!("Alignment of ", stringify!(netdev_queue))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netdev_queue>())).dev as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(netdev_queue),
            "::",
            stringify!(dev)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netdev_queue>())).qdisc as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(netdev_queue),
            "::",
            stringify!(qdisc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netdev_queue>())).qdisc_sleeping as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(netdev_queue),
            "::",
            stringify!(qdisc_sleeping)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netdev_queue>())).kobj as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(netdev_queue),
            "::",
            stringify!(kobj)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netdev_queue>())).numa_node as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(netdev_queue),
            "::",
            stringify!(numa_node)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netdev_queue>())).tx_maxrate as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(netdev_queue),
            "::",
            stringify!(tx_maxrate)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netdev_queue>())).trans_timeout as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(netdev_queue),
            "::",
            stringify!(trans_timeout)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netdev_queue>())).sb_dev as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(netdev_queue),
            "::",
            stringify!(sb_dev)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netdev_queue>())).umem as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(netdev_queue),
            "::",
            stringify!(umem)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netdev_queue>()))._xmit_lock as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(netdev_queue),
            "::",
            stringify!(_xmit_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netdev_queue>())).xmit_lock_owner as *const _ as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(netdev_queue),
            "::",
            stringify!(xmit_lock_owner)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netdev_queue>())).trans_start as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(netdev_queue),
            "::",
            stringify!(trans_start)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netdev_queue>())).state as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(netdev_queue),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netdev_queue>())).dql as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(netdev_queue),
            "::",
            stringify!(dql)
        )
    );
}
impl Default for netdev_queue {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct rps_map {
    pub len: c_types::c_uint,
    pub rcu: callback_head,
    pub cpus: __IncompleteArrayField<u16_>,
}
#[test]
fn bindgen_test_layout_rps_map() {
    assert_eq!(
        ::core::mem::size_of::<rps_map>(),
        24usize,
        concat!("Size of: ", stringify!(rps_map))
    );
    assert_eq!(
        ::core::mem::align_of::<rps_map>(),
        8usize,
        concat!("Alignment of ", stringify!(rps_map))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rps_map>())).len as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_map),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rps_map>())).rcu as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_map),
            "::",
            stringify!(rcu)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rps_map>())).cpus as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_map),
            "::",
            stringify!(cpus)
        )
    );
}
impl Default for rps_map {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rps_dev_flow {
    pub cpu: u16_,
    pub filter: u16_,
    pub last_qtail: c_types::c_uint,
}
#[test]
fn bindgen_test_layout_rps_dev_flow() {
    assert_eq!(
        ::core::mem::size_of::<rps_dev_flow>(),
        8usize,
        concat!("Size of: ", stringify!(rps_dev_flow))
    );
    assert_eq!(
        ::core::mem::align_of::<rps_dev_flow>(),
        4usize,
        concat!("Alignment of ", stringify!(rps_dev_flow))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rps_dev_flow>())).cpu as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_dev_flow),
            "::",
            stringify!(cpu)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rps_dev_flow>())).filter as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_dev_flow),
            "::",
            stringify!(filter)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rps_dev_flow>())).last_qtail as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_dev_flow),
            "::",
            stringify!(last_qtail)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct rps_dev_flow_table {
    pub mask: c_types::c_uint,
    pub rcu: callback_head,
    pub flows: __IncompleteArrayField<rps_dev_flow>,
}
#[test]
fn bindgen_test_layout_rps_dev_flow_table() {
    assert_eq!(
        ::core::mem::size_of::<rps_dev_flow_table>(),
        24usize,
        concat!("Size of: ", stringify!(rps_dev_flow_table))
    );
    assert_eq!(
        ::core::mem::align_of::<rps_dev_flow_table>(),
        8usize,
        concat!("Alignment of ", stringify!(rps_dev_flow_table))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rps_dev_flow_table>())).mask as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_dev_flow_table),
            "::",
            stringify!(mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rps_dev_flow_table>())).rcu as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_dev_flow_table),
            "::",
            stringify!(rcu)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rps_dev_flow_table>())).flows as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_dev_flow_table),
            "::",
            stringify!(flows)
        )
    );
}
impl Default for rps_dev_flow_table {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct netdev_rx_queue {
    pub rps_map: *mut rps_map,
    pub rps_flow_table: *mut rps_dev_flow_table,
    pub kobj: kobject,
    pub dev: *mut net_device,
    pub __bindgen_padding_0: [u64; 5usize],
    pub xdp_rxq: xdp_rxq_info,
    pub umem: *mut xdp_umem,
}
#[test]
fn bindgen_test_layout_netdev_rx_queue() {
    assert_eq!(
        ::core::mem::size_of::<netdev_rx_queue>(),
        256usize,
        concat!("Size of: ", stringify!(netdev_rx_queue))
    );
    assert_eq!(
        ::core::mem::align_of::<netdev_rx_queue>(),
        64usize,
        concat!("Alignment of ", stringify!(netdev_rx_queue))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netdev_rx_queue>())).rps_map as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(netdev_rx_queue),
            "::",
            stringify!(rps_map)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netdev_rx_queue>())).rps_flow_table as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(netdev_rx_queue),
            "::",
            stringify!(rps_flow_table)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netdev_rx_queue>())).kobj as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(netdev_rx_queue),
            "::",
            stringify!(kobj)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netdev_rx_queue>())).dev as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(netdev_rx_queue),
            "::",
            stringify!(dev)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netdev_rx_queue>())).xdp_rxq as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(netdev_rx_queue),
            "::",
            stringify!(xdp_rxq)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netdev_rx_queue>())).umem as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(netdev_rx_queue),
            "::",
            stringify!(umem)
        )
    );
}
impl Default for netdev_rx_queue {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct xps_map {
    pub len: c_types::c_uint,
    pub alloc_len: c_types::c_uint,
    pub rcu: callback_head,
    pub queues: __IncompleteArrayField<u16_>,
}
#[test]
fn bindgen_test_layout_xps_map() {
    assert_eq!(
        ::core::mem::size_of::<xps_map>(),
        24usize,
        concat!("Size of: ", stringify!(xps_map))
    );
    assert_eq!(
        ::core::mem::align_of::<xps_map>(),
        8usize,
        concat!("Alignment of ", stringify!(xps_map))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xps_map>())).len as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xps_map),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xps_map>())).alloc_len as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xps_map),
            "::",
            stringify!(alloc_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xps_map>())).rcu as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xps_map),
            "::",
            stringify!(rcu)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xps_map>())).queues as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(xps_map),
            "::",
            stringify!(queues)
        )
    );
}
impl Default for xps_map {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct xps_dev_maps {
    pub rcu: callback_head,
    pub attr_map: __IncompleteArrayField<*mut xps_map>,
}
#[test]
fn bindgen_test_layout_xps_dev_maps() {
    assert_eq!(
        ::core::mem::size_of::<xps_dev_maps>(),
        16usize,
        concat!("Size of: ", stringify!(xps_dev_maps))
    );
    assert_eq!(
        ::core::mem::align_of::<xps_dev_maps>(),
        8usize,
        concat!("Alignment of ", stringify!(xps_dev_maps))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xps_dev_maps>())).rcu as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xps_dev_maps),
            "::",
            stringify!(rcu)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xps_dev_maps>())).attr_map as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xps_dev_maps),
            "::",
            stringify!(attr_map)
        )
    );
}
impl Default for xps_dev_maps {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct netdev_tc_txq {
    pub count: u16_,
    pub offset: u16_,
}
#[test]
fn bindgen_test_layout_netdev_tc_txq() {
    assert_eq!(
        ::core::mem::size_of::<netdev_tc_txq>(),
        4usize,
        concat!("Size of: ", stringify!(netdev_tc_txq))
    );
    assert_eq!(
        ::core::mem::align_of::<netdev_tc_txq>(),
        2usize,
        concat!("Alignment of ", stringify!(netdev_tc_txq))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netdev_tc_txq>())).count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(netdev_tc_txq),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netdev_tc_txq>())).offset as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(netdev_tc_txq),
            "::",
            stringify!(offset)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct netdev_fcoe_hbainfo {
    pub manufacturer: [c_types::c_char; 64usize],
    pub serial_number: [c_types::c_char; 64usize],
    pub hardware_version: [c_types::c_char; 64usize],
    pub driver_version: [c_types::c_char; 64usize],
    pub optionrom_version: [c_types::c_char; 64usize],
    pub firmware_version: [c_types::c_char; 64usize],
    pub model: [c_types::c_char; 256usize],
    pub model_description: [c_types::c_char; 256usize],
}
#[test]
fn bindgen_test_layout_netdev_fcoe_hbainfo() {
    assert_eq!(
        ::core::mem::size_of::<netdev_fcoe_hbainfo>(),
        896usize,
        concat!("Size of: ", stringify!(netdev_fcoe_hbainfo))
    );
    assert_eq!(
        ::core::mem::align_of::<netdev_fcoe_hbainfo>(),
        1usize,
        concat!("Alignment of ", stringify!(netdev_fcoe_hbainfo))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<netdev_fcoe_hbainfo>())).manufacturer as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(netdev_fcoe_hbainfo),
            "::",
            stringify!(manufacturer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<netdev_fcoe_hbainfo>())).serial_number as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(netdev_fcoe_hbainfo),
            "::",
            stringify!(serial_number)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<netdev_fcoe_hbainfo>())).hardware_version as *const _ as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(netdev_fcoe_hbainfo),
            "::",
            stringify!(hardware_version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<netdev_fcoe_hbainfo>())).driver_version as *const _ as usize
        },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(netdev_fcoe_hbainfo),
            "::",
            stringify!(driver_version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<netdev_fcoe_hbainfo>())).optionrom_version as *const _ as usize
        },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(netdev_fcoe_hbainfo),
            "::",
            stringify!(optionrom_version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<netdev_fcoe_hbainfo>())).firmware_version as *const _ as usize
        },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(netdev_fcoe_hbainfo),
            "::",
            stringify!(firmware_version)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netdev_fcoe_hbainfo>())).model as *const _ as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(netdev_fcoe_hbainfo),
            "::",
            stringify!(model)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<netdev_fcoe_hbainfo>())).model_description as *const _ as usize
        },
        640usize,
        concat!(
            "Offset of field: ",
            stringify!(netdev_fcoe_hbainfo),
            "::",
            stringify!(model_description)
        )
    );
}
impl Default for netdev_fcoe_hbainfo {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct netdev_phys_item_id {
    pub id: [c_types::c_uchar; 32usize],
    pub id_len: c_types::c_uchar,
}
#[test]
fn bindgen_test_layout_netdev_phys_item_id() {
    assert_eq!(
        ::core::mem::size_of::<netdev_phys_item_id>(),
        33usize,
        concat!("Size of: ", stringify!(netdev_phys_item_id))
    );
    assert_eq!(
        ::core::mem::align_of::<netdev_phys_item_id>(),
        1usize,
        concat!("Alignment of ", stringify!(netdev_phys_item_id))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netdev_phys_item_id>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(netdev_phys_item_id),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netdev_phys_item_id>())).id_len as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(netdev_phys_item_id),
            "::",
            stringify!(id_len)
        )
    );
}
pub const tc_setup_type_TC_SETUP_QDISC_MQPRIO: tc_setup_type = 0;
pub const tc_setup_type_TC_SETUP_CLSU32: tc_setup_type = 1;
pub const tc_setup_type_TC_SETUP_CLSFLOWER: tc_setup_type = 2;
pub const tc_setup_type_TC_SETUP_CLSMATCHALL: tc_setup_type = 3;
pub const tc_setup_type_TC_SETUP_CLSBPF: tc_setup_type = 4;
pub const tc_setup_type_TC_SETUP_BLOCK: tc_setup_type = 5;
pub const tc_setup_type_TC_SETUP_QDISC_CBS: tc_setup_type = 6;
pub const tc_setup_type_TC_SETUP_QDISC_RED: tc_setup_type = 7;
pub const tc_setup_type_TC_SETUP_QDISC_PRIO: tc_setup_type = 8;
pub const tc_setup_type_TC_SETUP_QDISC_MQ: tc_setup_type = 9;
pub const tc_setup_type_TC_SETUP_QDISC_ETF: tc_setup_type = 10;
pub const tc_setup_type_TC_SETUP_ROOT_QDISC: tc_setup_type = 11;
pub const tc_setup_type_TC_SETUP_QDISC_GRED: tc_setup_type = 12;
pub const tc_setup_type_TC_SETUP_QDISC_TAPRIO: tc_setup_type = 13;
pub type tc_setup_type = c_types::c_uint;
pub const bpf_netdev_command_XDP_SETUP_PROG: bpf_netdev_command = 0;
pub const bpf_netdev_command_XDP_SETUP_PROG_HW: bpf_netdev_command = 1;
pub const bpf_netdev_command_XDP_QUERY_PROG: bpf_netdev_command = 2;
pub const bpf_netdev_command_XDP_QUERY_PROG_HW: bpf_netdev_command = 3;
pub const bpf_netdev_command_BPF_OFFLOAD_MAP_ALLOC: bpf_netdev_command = 4;
pub const bpf_netdev_command_BPF_OFFLOAD_MAP_FREE: bpf_netdev_command = 5;
pub const bpf_netdev_command_XDP_SETUP_XSK_UMEM: bpf_netdev_command = 6;
pub type bpf_netdev_command = c_types::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xdp_umem {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct netdev_bpf {
    pub command: bpf_netdev_command,
    pub __bindgen_anon_1: netdev_bpf__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union netdev_bpf__bindgen_ty_1 {
    pub __bindgen_anon_1: netdev_bpf__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: netdev_bpf__bindgen_ty_1__bindgen_ty_2,
    pub __bindgen_anon_3: netdev_bpf__bindgen_ty_1__bindgen_ty_3,
    pub xsk: netdev_bpf__bindgen_ty_1__bindgen_ty_4,
    _bindgen_union_align: [u64; 3usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct netdev_bpf__bindgen_ty_1__bindgen_ty_1 {
    pub flags: u32_,
    pub prog: *mut bpf_prog,
    pub extack: *mut netlink_ext_ack,
}
#[test]
fn bindgen_test_layout_netdev_bpf__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<netdev_bpf__bindgen_ty_1__bindgen_ty_1>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(netdev_bpf__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<netdev_bpf__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(netdev_bpf__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<netdev_bpf__bindgen_ty_1__bindgen_ty_1>())).flags as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(netdev_bpf__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<netdev_bpf__bindgen_ty_1__bindgen_ty_1>())).prog as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(netdev_bpf__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(prog)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<netdev_bpf__bindgen_ty_1__bindgen_ty_1>())).extack as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(netdev_bpf__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(extack)
        )
    );
}
impl Default for netdev_bpf__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct netdev_bpf__bindgen_ty_1__bindgen_ty_2 {
    pub prog_id: u32_,
    pub prog_flags: u32_,
}
#[test]
fn bindgen_test_layout_netdev_bpf__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<netdev_bpf__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(netdev_bpf__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<netdev_bpf__bindgen_ty_1__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(netdev_bpf__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<netdev_bpf__bindgen_ty_1__bindgen_ty_2>())).prog_id as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(netdev_bpf__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(prog_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<netdev_bpf__bindgen_ty_1__bindgen_ty_2>())).prog_flags
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(netdev_bpf__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(prog_flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct netdev_bpf__bindgen_ty_1__bindgen_ty_3 {
    pub offmap: *mut bpf_offloaded_map,
}
#[test]
fn bindgen_test_layout_netdev_bpf__bindgen_ty_1__bindgen_ty_3() {
    assert_eq!(
        ::core::mem::size_of::<netdev_bpf__bindgen_ty_1__bindgen_ty_3>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(netdev_bpf__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<netdev_bpf__bindgen_ty_1__bindgen_ty_3>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(netdev_bpf__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<netdev_bpf__bindgen_ty_1__bindgen_ty_3>())).offmap as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(netdev_bpf__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(offmap)
        )
    );
}
impl Default for netdev_bpf__bindgen_ty_1__bindgen_ty_3 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct netdev_bpf__bindgen_ty_1__bindgen_ty_4 {
    pub umem: *mut xdp_umem,
    pub queue_id: u16_,
}
#[test]
fn bindgen_test_layout_netdev_bpf__bindgen_ty_1__bindgen_ty_4() {
    assert_eq!(
        ::core::mem::size_of::<netdev_bpf__bindgen_ty_1__bindgen_ty_4>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(netdev_bpf__bindgen_ty_1__bindgen_ty_4)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<netdev_bpf__bindgen_ty_1__bindgen_ty_4>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(netdev_bpf__bindgen_ty_1__bindgen_ty_4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<netdev_bpf__bindgen_ty_1__bindgen_ty_4>())).umem as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(netdev_bpf__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(umem)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<netdev_bpf__bindgen_ty_1__bindgen_ty_4>())).queue_id as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(netdev_bpf__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(queue_id)
        )
    );
}
impl Default for netdev_bpf__bindgen_ty_1__bindgen_ty_4 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_netdev_bpf__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<netdev_bpf__bindgen_ty_1>(),
        24usize,
        concat!("Size of: ", stringify!(netdev_bpf__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<netdev_bpf__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(netdev_bpf__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netdev_bpf__bindgen_ty_1>())).xsk as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(netdev_bpf__bindgen_ty_1),
            "::",
            stringify!(xsk)
        )
    );
}
impl Default for netdev_bpf__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_netdev_bpf() {
    assert_eq!(
        ::core::mem::size_of::<netdev_bpf>(),
        32usize,
        concat!("Size of: ", stringify!(netdev_bpf))
    );
    assert_eq!(
        ::core::mem::align_of::<netdev_bpf>(),
        8usize,
        concat!("Alignment of ", stringify!(netdev_bpf))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netdev_bpf>())).command as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(netdev_bpf),
            "::",
            stringify!(command)
        )
    );
}
impl Default for netdev_bpf {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct xfrmdev_ops {
    pub xdo_dev_state_add:
        ::core::option::Option<unsafe extern "C" fn(x: *mut xfrm_state) -> c_types::c_int>,
    pub xdo_dev_state_delete: ::core::option::Option<unsafe extern "C" fn(x: *mut xfrm_state)>,
    pub xdo_dev_state_free: ::core::option::Option<unsafe extern "C" fn(x: *mut xfrm_state)>,
    pub xdo_dev_offload_ok: ::core::option::Option<
        unsafe extern "C" fn(skb: *mut sk_buff, x: *mut xfrm_state) -> bool_,
    >,
    pub xdo_dev_state_advance_esn: ::core::option::Option<unsafe extern "C" fn(x: *mut xfrm_state)>,
}
#[test]
fn bindgen_test_layout_xfrmdev_ops() {
    assert_eq!(
        ::core::mem::size_of::<xfrmdev_ops>(),
        40usize,
        concat!("Size of: ", stringify!(xfrmdev_ops))
    );
    assert_eq!(
        ::core::mem::align_of::<xfrmdev_ops>(),
        8usize,
        concat!("Alignment of ", stringify!(xfrmdev_ops))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xfrmdev_ops>())).xdo_dev_state_add as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xfrmdev_ops),
            "::",
            stringify!(xdo_dev_state_add)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xfrmdev_ops>())).xdo_dev_state_delete as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xfrmdev_ops),
            "::",
            stringify!(xdo_dev_state_delete)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xfrmdev_ops>())).xdo_dev_state_free as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xfrmdev_ops),
            "::",
            stringify!(xdo_dev_state_free)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xfrmdev_ops>())).xdo_dev_offload_ok as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(xfrmdev_ops),
            "::",
            stringify!(xdo_dev_offload_ok)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xfrmdev_ops>())).xdo_dev_state_advance_esn as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(xfrmdev_ops),
            "::",
            stringify!(xdo_dev_state_advance_esn)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct dev_ifalias {
    pub rcuhead: callback_head,
    pub ifalias: __IncompleteArrayField<c_types::c_char>,
}
#[test]
fn bindgen_test_layout_dev_ifalias() {
    assert_eq!(
        ::core::mem::size_of::<dev_ifalias>(),
        16usize,
        concat!("Size of: ", stringify!(dev_ifalias))
    );
    assert_eq!(
        ::core::mem::align_of::<dev_ifalias>(),
        8usize,
        concat!("Alignment of ", stringify!(dev_ifalias))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dev_ifalias>())).rcuhead as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_ifalias),
            "::",
            stringify!(rcuhead)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dev_ifalias>())).ifalias as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_ifalias),
            "::",
            stringify!(ifalias)
        )
    );
}
impl Default for dev_ifalias {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tlsdev_ops {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct net_device_ops {
    pub ndo_init:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut net_device) -> c_types::c_int>,
    pub ndo_uninit: ::core::option::Option<unsafe extern "C" fn(dev: *mut net_device)>,
    pub ndo_open:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut net_device) -> c_types::c_int>,
    pub ndo_stop:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut net_device) -> c_types::c_int>,
    pub ndo_start_xmit: ::core::option::Option<
        unsafe extern "C" fn(skb: *mut sk_buff, dev: *mut net_device) -> netdev_tx_t,
    >,
    pub ndo_features_check: ::core::option::Option<
        unsafe extern "C" fn(
            skb: *mut sk_buff,
            dev: *mut net_device,
            features: netdev_features_t,
        ) -> netdev_features_t,
    >,
    pub ndo_select_queue: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut net_device,
            skb: *mut sk_buff,
            sb_dev: *mut net_device,
        ) -> u16_,
    >,
    pub ndo_change_rx_flags:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut net_device, flags: c_types::c_int)>,
    pub ndo_set_rx_mode: ::core::option::Option<unsafe extern "C" fn(dev: *mut net_device)>,
    pub ndo_set_mac_address: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut net_device, addr: *mut c_types::c_void) -> c_types::c_int,
    >,
    pub ndo_validate_addr:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut net_device) -> c_types::c_int>,
    pub ndo_do_ioctl: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut net_device,
            ifr: *mut ifreq,
            cmd: c_types::c_int,
        ) -> c_types::c_int,
    >,
    pub ndo_set_config: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut net_device, map: *mut ifmap) -> c_types::c_int,
    >,
    pub ndo_change_mtu: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut net_device, new_mtu: c_types::c_int) -> c_types::c_int,
    >,
    pub ndo_neigh_setup: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut net_device, arg1: *mut neigh_parms) -> c_types::c_int,
    >,
    pub ndo_tx_timeout: ::core::option::Option<unsafe extern "C" fn(dev: *mut net_device)>,
    pub ndo_get_stats64: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut net_device, storage: *mut rtnl_link_stats64),
    >,
    pub ndo_has_offload_stats: ::core::option::Option<
        unsafe extern "C" fn(dev: *const net_device, attr_id: c_types::c_int) -> bool_,
    >,
    pub ndo_get_offload_stats: ::core::option::Option<
        unsafe extern "C" fn(
            attr_id: c_types::c_int,
            dev: *const net_device,
            attr_data: *mut c_types::c_void,
        ) -> c_types::c_int,
    >,
    pub ndo_get_stats:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut net_device) -> *mut net_device_stats>,
    pub ndo_vlan_rx_add_vid: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut net_device, proto: __be16, vid: u16_) -> c_types::c_int,
    >,
    pub ndo_vlan_rx_kill_vid: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut net_device, proto: __be16, vid: u16_) -> c_types::c_int,
    >,
    pub ndo_poll_controller: ::core::option::Option<unsafe extern "C" fn(dev: *mut net_device)>,
    pub ndo_netpoll_setup: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut net_device, info: *mut netpoll_info) -> c_types::c_int,
    >,
    pub ndo_netpoll_cleanup: ::core::option::Option<unsafe extern "C" fn(dev: *mut net_device)>,
    pub ndo_set_vf_mac: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut net_device,
            queue: c_types::c_int,
            mac: *mut u8_,
        ) -> c_types::c_int,
    >,
    pub ndo_set_vf_vlan: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut net_device,
            queue: c_types::c_int,
            vlan: u16_,
            qos: u8_,
            proto: __be16,
        ) -> c_types::c_int,
    >,
    pub ndo_set_vf_rate: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut net_device,
            vf: c_types::c_int,
            min_tx_rate: c_types::c_int,
            max_tx_rate: c_types::c_int,
        ) -> c_types::c_int,
    >,
    pub ndo_set_vf_spoofchk: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut net_device,
            vf: c_types::c_int,
            setting: bool_,
        ) -> c_types::c_int,
    >,
    pub ndo_set_vf_trust: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut net_device,
            vf: c_types::c_int,
            setting: bool_,
        ) -> c_types::c_int,
    >,
    pub ndo_get_vf_config: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut net_device,
            vf: c_types::c_int,
            ivf: *mut ifla_vf_info,
        ) -> c_types::c_int,
    >,
    pub ndo_set_vf_link_state: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut net_device,
            vf: c_types::c_int,
            link_state: c_types::c_int,
        ) -> c_types::c_int,
    >,
    pub ndo_get_vf_stats: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut net_device,
            vf: c_types::c_int,
            vf_stats: *mut ifla_vf_stats,
        ) -> c_types::c_int,
    >,
    pub ndo_set_vf_port: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut net_device,
            vf: c_types::c_int,
            port: *mut *mut nlattr,
        ) -> c_types::c_int,
    >,
    pub ndo_get_vf_port: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut net_device,
            vf: c_types::c_int,
            skb: *mut sk_buff,
        ) -> c_types::c_int,
    >,
    pub ndo_set_vf_guid: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut net_device,
            vf: c_types::c_int,
            guid: u64_,
            guid_type: c_types::c_int,
        ) -> c_types::c_int,
    >,
    pub ndo_set_vf_rss_query_en: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut net_device,
            vf: c_types::c_int,
            setting: bool_,
        ) -> c_types::c_int,
    >,
    pub ndo_setup_tc: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut net_device,
            type_: tc_setup_type,
            type_data: *mut c_types::c_void,
        ) -> c_types::c_int,
    >,
    pub ndo_fcoe_enable:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut net_device) -> c_types::c_int>,
    pub ndo_fcoe_disable:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut net_device) -> c_types::c_int>,
    pub ndo_fcoe_ddp_setup: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut net_device,
            xid: u16_,
            sgl: *mut scatterlist,
            sgc: c_types::c_uint,
        ) -> c_types::c_int,
    >,
    pub ndo_fcoe_ddp_done: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut net_device, xid: u16_) -> c_types::c_int,
    >,
    pub ndo_fcoe_ddp_target: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut net_device,
            xid: u16_,
            sgl: *mut scatterlist,
            sgc: c_types::c_uint,
        ) -> c_types::c_int,
    >,
    pub ndo_fcoe_get_hbainfo: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut net_device,
            hbainfo: *mut netdev_fcoe_hbainfo,
        ) -> c_types::c_int,
    >,
    pub ndo_fcoe_get_wwn: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut net_device,
            wwn: *mut u64_,
            type_: c_types::c_int,
        ) -> c_types::c_int,
    >,
    pub ndo_rx_flow_steer: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut net_device,
            skb: *const sk_buff,
            rxq_index: u16_,
            flow_id: u32_,
        ) -> c_types::c_int,
    >,
    pub ndo_add_slave: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut net_device,
            slave_dev: *mut net_device,
            extack: *mut netlink_ext_ack,
        ) -> c_types::c_int,
    >,
    pub ndo_del_slave: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut net_device, slave_dev: *mut net_device) -> c_types::c_int,
    >,
    pub ndo_fix_features: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut net_device,
            features: netdev_features_t,
        ) -> netdev_features_t,
    >,
    pub ndo_set_features: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut net_device, features: netdev_features_t) -> c_types::c_int,
    >,
    pub ndo_neigh_construct: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut net_device, n: *mut neighbour) -> c_types::c_int,
    >,
    pub ndo_neigh_destroy:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut net_device, n: *mut neighbour)>,
    pub ndo_fdb_add: ::core::option::Option<
        unsafe extern "C" fn(
            ndm: *mut ndmsg,
            tb: *mut *mut nlattr,
            dev: *mut net_device,
            addr: *const c_types::c_uchar,
            vid: u16_,
            flags: u16_,
            extack: *mut netlink_ext_ack,
        ) -> c_types::c_int,
    >,
    pub ndo_fdb_del: ::core::option::Option<
        unsafe extern "C" fn(
            ndm: *mut ndmsg,
            tb: *mut *mut nlattr,
            dev: *mut net_device,
            addr: *const c_types::c_uchar,
            vid: u16_,
        ) -> c_types::c_int,
    >,
    pub ndo_fdb_dump: ::core::option::Option<
        unsafe extern "C" fn(
            skb: *mut sk_buff,
            cb: *mut netlink_callback,
            dev: *mut net_device,
            filter_dev: *mut net_device,
            idx: *mut c_types::c_int,
        ) -> c_types::c_int,
    >,
    pub ndo_fdb_get: ::core::option::Option<
        unsafe extern "C" fn(
            skb: *mut sk_buff,
            tb: *mut *mut nlattr,
            dev: *mut net_device,
            addr: *const c_types::c_uchar,
            vid: u16_,
            portid: u32_,
            seq: u32_,
            extack: *mut netlink_ext_ack,
        ) -> c_types::c_int,
    >,
    pub ndo_bridge_setlink: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut net_device,
            nlh: *mut nlmsghdr,
            flags: u16_,
            extack: *mut netlink_ext_ack,
        ) -> c_types::c_int,
    >,
    pub ndo_bridge_getlink: ::core::option::Option<
        unsafe extern "C" fn(
            skb: *mut sk_buff,
            pid: u32_,
            seq: u32_,
            dev: *mut net_device,
            filter_mask: u32_,
            nlflags: c_types::c_int,
        ) -> c_types::c_int,
    >,
    pub ndo_bridge_dellink: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut net_device,
            nlh: *mut nlmsghdr,
            flags: u16_,
        ) -> c_types::c_int,
    >,
    pub ndo_change_carrier: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut net_device, new_carrier: bool_) -> c_types::c_int,
    >,
    pub ndo_get_phys_port_id: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut net_device,
            ppid: *mut netdev_phys_item_id,
        ) -> c_types::c_int,
    >,
    pub ndo_get_port_parent_id: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut net_device,
            ppid: *mut netdev_phys_item_id,
        ) -> c_types::c_int,
    >,
    pub ndo_get_phys_port_name: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut net_device,
            name: *mut c_types::c_char,
            len: usize,
        ) -> c_types::c_int,
    >,
    pub ndo_udp_tunnel_add: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut net_device, ti: *mut udp_tunnel_info),
    >,
    pub ndo_udp_tunnel_del: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut net_device, ti: *mut udp_tunnel_info),
    >,
    pub ndo_dfwd_add_station: ::core::option::Option<
        unsafe extern "C" fn(pdev: *mut net_device, dev: *mut net_device) -> *mut c_types::c_void,
    >,
    pub ndo_dfwd_del_station: ::core::option::Option<
        unsafe extern "C" fn(pdev: *mut net_device, priv_: *mut c_types::c_void),
    >,
    pub ndo_set_tx_maxrate: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut net_device,
            queue_index: c_types::c_int,
            maxrate: u32_,
        ) -> c_types::c_int,
    >,
    pub ndo_get_iflink:
        ::core::option::Option<unsafe extern "C" fn(dev: *const net_device) -> c_types::c_int>,
    pub ndo_change_proto_down: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut net_device, proto_down: bool_) -> c_types::c_int,
    >,
    pub ndo_fill_metadata_dst: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut net_device, skb: *mut sk_buff) -> c_types::c_int,
    >,
    pub ndo_set_rx_headroom: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut net_device, needed_headroom: c_types::c_int),
    >,
    pub ndo_bpf: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut net_device, bpf: *mut netdev_bpf) -> c_types::c_int,
    >,
    pub ndo_xdp_xmit: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut net_device,
            n: c_types::c_int,
            xdp: *mut *mut xdp_frame,
            flags: u32_,
        ) -> c_types::c_int,
    >,
    pub ndo_xsk_wakeup: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut net_device, queue_id: u32_, flags: u32_) -> c_types::c_int,
    >,
    pub ndo_get_devlink_port:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut net_device) -> *mut devlink_port>,
}
#[test]
fn bindgen_test_layout_net_device_ops() {
    assert_eq!(
        ::core::mem::size_of::<net_device_ops>(),
        608usize,
        concat!("Size of: ", stringify!(net_device_ops))
    );
    assert_eq!(
        ::core::mem::align_of::<net_device_ops>(),
        8usize,
        concat!("Alignment of ", stringify!(net_device_ops))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device_ops>())).ndo_init as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device_ops),
            "::",
            stringify!(ndo_init)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device_ops>())).ndo_uninit as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device_ops),
            "::",
            stringify!(ndo_uninit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device_ops>())).ndo_open as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device_ops),
            "::",
            stringify!(ndo_open)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device_ops>())).ndo_stop as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device_ops),
            "::",
            stringify!(ndo_stop)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device_ops>())).ndo_start_xmit as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device_ops),
            "::",
            stringify!(ndo_start_xmit)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<net_device_ops>())).ndo_features_check as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device_ops),
            "::",
            stringify!(ndo_features_check)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<net_device_ops>())).ndo_select_queue as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device_ops),
            "::",
            stringify!(ndo_select_queue)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<net_device_ops>())).ndo_change_rx_flags as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device_ops),
            "::",
            stringify!(ndo_change_rx_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device_ops>())).ndo_set_rx_mode as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device_ops),
            "::",
            stringify!(ndo_set_rx_mode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<net_device_ops>())).ndo_set_mac_address as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device_ops),
            "::",
            stringify!(ndo_set_mac_address)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<net_device_ops>())).ndo_validate_addr as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device_ops),
            "::",
            stringify!(ndo_validate_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device_ops>())).ndo_do_ioctl as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device_ops),
            "::",
            stringify!(ndo_do_ioctl)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device_ops>())).ndo_set_config as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device_ops),
            "::",
            stringify!(ndo_set_config)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device_ops>())).ndo_change_mtu as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device_ops),
            "::",
            stringify!(ndo_change_mtu)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device_ops>())).ndo_neigh_setup as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device_ops),
            "::",
            stringify!(ndo_neigh_setup)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device_ops>())).ndo_tx_timeout as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device_ops),
            "::",
            stringify!(ndo_tx_timeout)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device_ops>())).ndo_get_stats64 as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device_ops),
            "::",
            stringify!(ndo_get_stats64)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<net_device_ops>())).ndo_has_offload_stats as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device_ops),
            "::",
            stringify!(ndo_has_offload_stats)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<net_device_ops>())).ndo_get_offload_stats as *const _ as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device_ops),
            "::",
            stringify!(ndo_get_offload_stats)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device_ops>())).ndo_get_stats as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device_ops),
            "::",
            stringify!(ndo_get_stats)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<net_device_ops>())).ndo_vlan_rx_add_vid as *const _ as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device_ops),
            "::",
            stringify!(ndo_vlan_rx_add_vid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<net_device_ops>())).ndo_vlan_rx_kill_vid as *const _ as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device_ops),
            "::",
            stringify!(ndo_vlan_rx_kill_vid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<net_device_ops>())).ndo_poll_controller as *const _ as usize
        },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device_ops),
            "::",
            stringify!(ndo_poll_controller)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<net_device_ops>())).ndo_netpoll_setup as *const _ as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device_ops),
            "::",
            stringify!(ndo_netpoll_setup)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<net_device_ops>())).ndo_netpoll_cleanup as *const _ as usize
        },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device_ops),
            "::",
            stringify!(ndo_netpoll_cleanup)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device_ops>())).ndo_set_vf_mac as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device_ops),
            "::",
            stringify!(ndo_set_vf_mac)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device_ops>())).ndo_set_vf_vlan as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device_ops),
            "::",
            stringify!(ndo_set_vf_vlan)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device_ops>())).ndo_set_vf_rate as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device_ops),
            "::",
            stringify!(ndo_set_vf_rate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<net_device_ops>())).ndo_set_vf_spoofchk as *const _ as usize
        },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device_ops),
            "::",
            stringify!(ndo_set_vf_spoofchk)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<net_device_ops>())).ndo_set_vf_trust as *const _ as usize
        },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device_ops),
            "::",
            stringify!(ndo_set_vf_trust)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<net_device_ops>())).ndo_get_vf_config as *const _ as usize
        },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device_ops),
            "::",
            stringify!(ndo_get_vf_config)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<net_device_ops>())).ndo_set_vf_link_state as *const _ as usize
        },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device_ops),
            "::",
            stringify!(ndo_set_vf_link_state)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<net_device_ops>())).ndo_get_vf_stats as *const _ as usize
        },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device_ops),
            "::",
            stringify!(ndo_get_vf_stats)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device_ops>())).ndo_set_vf_port as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device_ops),
            "::",
            stringify!(ndo_set_vf_port)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device_ops>())).ndo_get_vf_port as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device_ops),
            "::",
            stringify!(ndo_get_vf_port)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device_ops>())).ndo_set_vf_guid as *const _ as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device_ops),
            "::",
            stringify!(ndo_set_vf_guid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<net_device_ops>())).ndo_set_vf_rss_query_en as *const _ as usize
        },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device_ops),
            "::",
            stringify!(ndo_set_vf_rss_query_en)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device_ops>())).ndo_setup_tc as *const _ as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device_ops),
            "::",
            stringify!(ndo_setup_tc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device_ops>())).ndo_fcoe_enable as *const _ as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device_ops),
            "::",
            stringify!(ndo_fcoe_enable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<net_device_ops>())).ndo_fcoe_disable as *const _ as usize
        },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device_ops),
            "::",
            stringify!(ndo_fcoe_disable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<net_device_ops>())).ndo_fcoe_ddp_setup as *const _ as usize
        },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device_ops),
            "::",
            stringify!(ndo_fcoe_ddp_setup)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<net_device_ops>())).ndo_fcoe_ddp_done as *const _ as usize
        },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device_ops),
            "::",
            stringify!(ndo_fcoe_ddp_done)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<net_device_ops>())).ndo_fcoe_ddp_target as *const _ as usize
        },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device_ops),
            "::",
            stringify!(ndo_fcoe_ddp_target)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<net_device_ops>())).ndo_fcoe_get_hbainfo as *const _ as usize
        },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device_ops),
            "::",
            stringify!(ndo_fcoe_get_hbainfo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<net_device_ops>())).ndo_fcoe_get_wwn as *const _ as usize
        },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device_ops),
            "::",
            stringify!(ndo_fcoe_get_wwn)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<net_device_ops>())).ndo_rx_flow_steer as *const _ as usize
        },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device_ops),
            "::",
            stringify!(ndo_rx_flow_steer)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device_ops>())).ndo_add_slave as *const _ as usize },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device_ops),
            "::",
            stringify!(ndo_add_slave)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device_ops>())).ndo_del_slave as *const _ as usize },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device_ops),
            "::",
            stringify!(ndo_del_slave)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<net_device_ops>())).ndo_fix_features as *const _ as usize
        },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device_ops),
            "::",
            stringify!(ndo_fix_features)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<net_device_ops>())).ndo_set_features as *const _ as usize
        },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device_ops),
            "::",
            stringify!(ndo_set_features)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<net_device_ops>())).ndo_neigh_construct as *const _ as usize
        },
        400usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device_ops),
            "::",
            stringify!(ndo_neigh_construct)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<net_device_ops>())).ndo_neigh_destroy as *const _ as usize
        },
        408usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device_ops),
            "::",
            stringify!(ndo_neigh_destroy)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device_ops>())).ndo_fdb_add as *const _ as usize },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device_ops),
            "::",
            stringify!(ndo_fdb_add)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device_ops>())).ndo_fdb_del as *const _ as usize },
        424usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device_ops),
            "::",
            stringify!(ndo_fdb_del)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device_ops>())).ndo_fdb_dump as *const _ as usize },
        432usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device_ops),
            "::",
            stringify!(ndo_fdb_dump)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device_ops>())).ndo_fdb_get as *const _ as usize },
        440usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device_ops),
            "::",
            stringify!(ndo_fdb_get)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<net_device_ops>())).ndo_bridge_setlink as *const _ as usize
        },
        448usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device_ops),
            "::",
            stringify!(ndo_bridge_setlink)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<net_device_ops>())).ndo_bridge_getlink as *const _ as usize
        },
        456usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device_ops),
            "::",
            stringify!(ndo_bridge_getlink)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<net_device_ops>())).ndo_bridge_dellink as *const _ as usize
        },
        464usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device_ops),
            "::",
            stringify!(ndo_bridge_dellink)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<net_device_ops>())).ndo_change_carrier as *const _ as usize
        },
        472usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device_ops),
            "::",
            stringify!(ndo_change_carrier)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<net_device_ops>())).ndo_get_phys_port_id as *const _ as usize
        },
        480usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device_ops),
            "::",
            stringify!(ndo_get_phys_port_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<net_device_ops>())).ndo_get_port_parent_id as *const _ as usize
        },
        488usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device_ops),
            "::",
            stringify!(ndo_get_port_parent_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<net_device_ops>())).ndo_get_phys_port_name as *const _ as usize
        },
        496usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device_ops),
            "::",
            stringify!(ndo_get_phys_port_name)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<net_device_ops>())).ndo_udp_tunnel_add as *const _ as usize
        },
        504usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device_ops),
            "::",
            stringify!(ndo_udp_tunnel_add)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<net_device_ops>())).ndo_udp_tunnel_del as *const _ as usize
        },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device_ops),
            "::",
            stringify!(ndo_udp_tunnel_del)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<net_device_ops>())).ndo_dfwd_add_station as *const _ as usize
        },
        520usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device_ops),
            "::",
            stringify!(ndo_dfwd_add_station)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<net_device_ops>())).ndo_dfwd_del_station as *const _ as usize
        },
        528usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device_ops),
            "::",
            stringify!(ndo_dfwd_del_station)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<net_device_ops>())).ndo_set_tx_maxrate as *const _ as usize
        },
        536usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device_ops),
            "::",
            stringify!(ndo_set_tx_maxrate)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device_ops>())).ndo_get_iflink as *const _ as usize },
        544usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device_ops),
            "::",
            stringify!(ndo_get_iflink)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<net_device_ops>())).ndo_change_proto_down as *const _ as usize
        },
        552usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device_ops),
            "::",
            stringify!(ndo_change_proto_down)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<net_device_ops>())).ndo_fill_metadata_dst as *const _ as usize
        },
        560usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device_ops),
            "::",
            stringify!(ndo_fill_metadata_dst)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<net_device_ops>())).ndo_set_rx_headroom as *const _ as usize
        },
        568usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device_ops),
            "::",
            stringify!(ndo_set_rx_headroom)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device_ops>())).ndo_bpf as *const _ as usize },
        576usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device_ops),
            "::",
            stringify!(ndo_bpf)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device_ops>())).ndo_xdp_xmit as *const _ as usize },
        584usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device_ops),
            "::",
            stringify!(ndo_xdp_xmit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device_ops>())).ndo_xsk_wakeup as *const _ as usize },
        592usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device_ops),
            "::",
            stringify!(ndo_xsk_wakeup)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<net_device_ops>())).ndo_get_devlink_port as *const _ as usize
        },
        600usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device_ops),
            "::",
            stringify!(ndo_get_devlink_port)
        )
    );
}
#[doc = "\tstruct net_device - The DEVICE structure."]
#[doc = ""]
#[doc = "\tActually, this whole structure is a big mistake.  It mixes I/O"]
#[doc = "\tdata with strictly \"high-level\" data, and it has to know about"]
#[doc = "\talmost every data structure used in the INET module."]
#[doc = ""]
#[doc = "\t@name:\tThis is the first field of the \"visible\" part of this structure"]
#[doc = "\t\t(i.e. as seen by users in the \"Space.c\" file).  It is the name"]
#[doc = "\t\tof the interface."]
#[doc = ""]
#[doc = "\t@name_hlist: \tDevice name hash chain, please keep it close to name[]"]
#[doc = "\t@ifalias:\tSNMP alias"]
#[doc = "\t@mem_end:\tShared memory end"]
#[doc = "\t@mem_start:\tShared memory start"]
#[doc = "\t@base_addr:\tDevice I/O address"]
#[doc = "\t@irq:\t\tDevice IRQ number"]
#[doc = ""]
#[doc = "\t@state:\t\tGeneric network queuing layer state, see netdev_state_t"]
#[doc = "\t@dev_list:\tThe global list of network devices"]
#[doc = "\t@napi_list:\tList entry used for polling NAPI devices"]
#[doc = "\t@unreg_list:\tList entry  when we are unregistering the"]
#[doc = "\t\t\tdevice; see the function unregister_netdev"]
#[doc = "\t@close_list:\tList entry used when we are closing the device"]
#[doc = "\t@ptype_all:     Device-specific packet handlers for all protocols"]
#[doc = "\t@ptype_specific: Device-specific, protocol-specific packet handlers"]
#[doc = ""]
#[doc = "\t@adj_list:\tDirectly linked devices, like slaves for bonding"]
#[doc = "\t@features:\tCurrently active device features"]
#[doc = "\t@hw_features:\tUser-changeable features"]
#[doc = ""]
#[doc = "\t@wanted_features:\tUser-requested features"]
#[doc = "\t@vlan_features:\t\tMask of features inheritable by VLAN devices"]
#[doc = ""]
#[doc = "\t@hw_enc_features:\tMask of features inherited by encapsulating devices"]
#[doc = "\t\t\t\tThis field indicates what encapsulation"]
#[doc = "\t\t\t\toffloads the hardware is capable of doing,"]
#[doc = "\t\t\t\tand drivers will need to set them appropriately."]
#[doc = ""]
#[doc = "\t@mpls_features:\tMask of features inheritable by MPLS"]
#[doc = ""]
#[doc = "\t@ifindex:\tinterface index"]
#[doc = "\t@group:\t\tThe group the device belongs to"]
#[doc = ""]
#[doc = "\t@stats:\t\tStatistics struct, which was left as a legacy, use"]
#[doc = "\t\t\trtnl_link_stats64 instead"]
#[doc = ""]
#[doc = "\t@rx_dropped:\tDropped packets by core network,"]
#[doc = "\t\t\tdo not use this in drivers"]
#[doc = "\t@tx_dropped:\tDropped packets by core network,"]
#[doc = "\t\t\tdo not use this in drivers"]
#[doc = "\t@rx_nohandler:\tnohandler dropped packets by core network on"]
#[doc = "\t\t\tinactive devices, do not use this in drivers"]
#[doc = "\t@carrier_up_count:\tNumber of times the carrier has been up"]
#[doc = "\t@carrier_down_count:\tNumber of times the carrier has been down"]
#[doc = ""]
#[doc = "\t@wireless_handlers:\tList of functions to handle Wireless Extensions,"]
#[doc = "\t\t\t\tinstead of ioctl,"]
#[doc = "\t\t\t\tsee <net/iw_handler.h> for details."]
#[doc = "\t@wireless_data:\tInstance data managed by the core of wireless extensions"]
#[doc = ""]
#[doc = "\t@netdev_ops:\tIncludes several pointers to callbacks,"]
#[doc = "\t\t\tif one wants to override the ndo_*() functions"]
#[doc = "\t@ethtool_ops:\tManagement operations"]
#[doc = "\t@ndisc_ops:\tIncludes callbacks for different IPv6 neighbour"]
#[doc = "\t\t\tdiscovery handling. Necessary for e.g. 6LoWPAN."]
#[doc = "\t@header_ops:\tIncludes callbacks for creating,parsing,caching,etc"]
#[doc = "\t\t\tof Layer 2 headers."]
#[doc = ""]
#[doc = "\t@flags:\t\tInterface flags (a la BSD)"]
#[doc = "\t@priv_flags:\tLike 'flags' but invisible to userspace,"]
#[doc = "\t\t\tsee if.h for the definitions"]
#[doc = "\t@gflags:\tGlobal flags ( kept as legacy )"]
#[doc = "\t@padded:\tHow much padding added by alloc_netdev()"]
#[doc = "\t@operstate:\tRFC2863 operstate"]
#[doc = "\t@link_mode:\tMapping policy to operstate"]
#[doc = "\t@if_port:\tSelectable AUI, TP, ..."]
#[doc = "\t@dma:\t\tDMA channel"]
#[doc = "\t@mtu:\t\tInterface MTU value"]
#[doc = "\t@min_mtu:\tInterface Minimum MTU value"]
#[doc = "\t@max_mtu:\tInterface Maximum MTU value"]
#[doc = "\t@type:\t\tInterface hardware type"]
#[doc = "\t@hard_header_len: Maximum hardware header length."]
#[doc = "\t@min_header_len:  Minimum hardware header length"]
#[doc = ""]
#[doc = "\t@needed_headroom: Extra headroom the hardware may need, but not in all"]
#[doc = "\t\t\t  cases can this be guaranteed"]
#[doc = "\t@needed_tailroom: Extra tailroom the hardware may need, but not in all"]
#[doc = "\t\t\t  cases can this be guaranteed. Some cases also use"]
#[doc = "\t\t\t  LL_MAX_HEADER instead to allocate the skb"]
#[doc = ""]
#[doc = "\tinterface address info:"]
#[doc = ""]
#[doc = " \t@perm_addr:\t\tPermanent hw address"]
#[doc = " \t@addr_assign_type:\tHw address assignment type"]
#[doc = " \t@addr_len:\t\tHardware address length"]
#[doc = "\t@upper_level:\t\tMaximum depth level of upper devices."]
#[doc = "\t@lower_level:\t\tMaximum depth level of lower devices."]
#[doc = "\t@neigh_priv_len:\tUsed in neigh_alloc()"]
#[doc = " \t@dev_id:\t\tUsed to differentiate devices that share"]
#[doc = " \t\t\t\tthe same link layer address"]
#[doc = " \t@dev_port:\t\tUsed to differentiate devices that share"]
#[doc = " \t\t\t\tthe same function"]
#[doc = "\t@addr_list_lock:\tXXX: need comments on this one"]
#[doc = "\t@uc_promisc:\t\tCounter that indicates promiscuous mode"]
#[doc = "\t\t\t\thas been enabled due to the need to listen to"]
#[doc = "\t\t\t\tadditional unicast addresses in a device that"]
#[doc = "\t\t\t\tdoes not implement ndo_set_rx_mode()"]
#[doc = "\t@uc:\t\t\tunicast mac addresses"]
#[doc = "\t@mc:\t\t\tmulticast mac addresses"]
#[doc = "\t@dev_addrs:\t\tlist of device hw addresses"]
#[doc = "\t@queues_kset:\t\tGroup of all Kobjects in the Tx and RX queues"]
#[doc = "\t@promiscuity:\t\tNumber of times the NIC is told to work in"]
#[doc = "\t\t\t\tpromiscuous mode; if it becomes 0 the NIC will"]
#[doc = "\t\t\t\texit promiscuous mode"]
#[doc = "\t@allmulti:\t\tCounter, enables or disables allmulticast mode"]
#[doc = ""]
#[doc = "\t@vlan_info:\tVLAN info"]
#[doc = "\t@dsa_ptr:\tdsa specific data"]
#[doc = "\t@tipc_ptr:\tTIPC specific data"]
#[doc = "\t@atalk_ptr:\tAppleTalk link"]
#[doc = "\t@ip_ptr:\tIPv4 specific data"]
#[doc = "\t@dn_ptr:\tDECnet specific data"]
#[doc = "\t@ip6_ptr:\tIPv6 specific data"]
#[doc = "\t@ax25_ptr:\tAX.25 specific data"]
#[doc = "\t@ieee80211_ptr:\tIEEE 802.11 specific data, assign before registering"]
#[doc = ""]
#[doc = "\t@dev_addr:\tHw address (before bcast,"]
#[doc = "\t\t\tbecause most packets are unicast)"]
#[doc = ""]
#[doc = "\t@_rx:\t\t\tArray of RX queues"]
#[doc = "\t@num_rx_queues:\t\tNumber of RX queues"]
#[doc = "\t\t\t\tallocated at register_netdev() time"]
#[doc = "\t@real_num_rx_queues: \tNumber of RX queues currently active in device"]
#[doc = ""]
#[doc = "\t@rx_handler:\t\thandler for received packets"]
#[doc = "\t@rx_handler_data: \tXXX: need comments on this one"]
#[doc = "\t@miniq_ingress:\t\tingress/clsact qdisc specific data for"]
#[doc = "\t\t\t\tingress processing"]
#[doc = "\t@ingress_queue:\t\tXXX: need comments on this one"]
#[doc = "\t@broadcast:\t\thw bcast address"]
#[doc = ""]
#[doc = "\t@rx_cpu_rmap:\tCPU reverse-mapping for RX completion interrupts,"]
#[doc = "\t\t\tindexed by RX queue number. Assigned by driver."]
#[doc = "\t\t\tThis must only be set if the ndo_rx_flow_steer"]
#[doc = "\t\t\toperation is defined"]
#[doc = "\t@index_hlist:\t\tDevice index hash chain"]
#[doc = ""]
#[doc = "\t@_tx:\t\t\tArray of TX queues"]
#[doc = "\t@num_tx_queues:\t\tNumber of TX queues allocated at alloc_netdev_mq() time"]
#[doc = "\t@real_num_tx_queues: \tNumber of TX queues currently active in device"]
#[doc = "\t@qdisc:\t\t\tRoot qdisc from userspace point of view"]
#[doc = "\t@tx_queue_len:\t\tMax frames per queue allowed"]
#[doc = "\t@tx_global_lock: \tXXX: need comments on this one"]
#[doc = ""]
#[doc = "\t@xps_maps:\tXXX: need comments on this one"]
#[doc = "\t@miniq_egress:\t\tclsact qdisc specific data for"]
#[doc = "\t\t\t\tegress processing"]
#[doc = "\t@watchdog_timeo:\tRepresents the timeout that is used by"]
#[doc = "\t\t\t\tthe watchdog (see dev_watchdog())"]
#[doc = "\t@watchdog_timer:\tList of timers"]
#[doc = ""]
#[doc = "\t@pcpu_refcnt:\t\tNumber of references to this device"]
#[doc = "\t@todo_list:\t\tDelayed register/unregister"]
#[doc = "\t@link_watch_list:\tXXX: need comments on this one"]
#[doc = ""]
#[doc = "\t@reg_state:\t\tRegister/unregister state machine"]
#[doc = "\t@dismantle:\t\tDevice is going to be freed"]
#[doc = "\t@rtnl_link_state:\tThis enum represents the phases of creating"]
#[doc = "\t\t\t\ta new link"]
#[doc = ""]
#[doc = "\t@needs_free_netdev:\tShould unregister perform free_netdev?"]
#[doc = "\t@priv_destructor:\tCalled from unregister"]
#[doc = "\t@npinfo:\t\tXXX: need comments on this one"]
#[doc = " \t@nd_net:\t\tNetwork namespace this network device is inside"]
#[doc = ""]
#[doc = " \t@ml_priv:\tMid-layer private"]
#[doc = " \t@lstats:\tLoopback statistics"]
#[doc = " \t@tstats:\tTunnel statistics"]
#[doc = " \t@dstats:\tDummy statistics"]
#[doc = " \t@vstats:\tVirtual ethernet statistics"]
#[doc = ""]
#[doc = "\t@garp_port:\tGARP"]
#[doc = "\t@mrp_port:\tMRP"]
#[doc = ""]
#[doc = "\t@dev:\t\tClass/net/name entry"]
#[doc = "\t@sysfs_groups:\tSpace for optional device, statistics and wireless"]
#[doc = "\t\t\tsysfs groups"]
#[doc = ""]
#[doc = "\t@sysfs_rx_queue_group:\tSpace for optional per-rx queue attributes"]
#[doc = "\t@rtnl_link_ops:\tRtnl_link_ops"]
#[doc = ""]
#[doc = "\t@gso_max_size:\tMaximum size of generic segmentation offload"]
#[doc = "\t@gso_max_segs:\tMaximum number of segments that can be passed to the"]
#[doc = "\t\t\tNIC for GSO"]
#[doc = ""]
#[doc = "\t@dcbnl_ops:\tData Center Bridging netlink ops"]
#[doc = "\t@num_tc:\tNumber of traffic classes in the net device"]
#[doc = "\t@tc_to_txq:\tXXX: need comments on this one"]
#[doc = "\t@prio_tc_map:\tXXX: need comments on this one"]
#[doc = ""]
#[doc = "\t@fcoe_ddp_xid:\tMax exchange id for FCoE LRO by ddp"]
#[doc = ""]
#[doc = "\t@priomap:\tXXX: need comments on this one"]
#[doc = "\t@phydev:\tPhysical device may attach itself"]
#[doc = "\t\t\tfor hardware timestamping"]
#[doc = "\t@sfp_bus:\tattached &struct sfp_bus structure."]
#[doc = "\t@qdisc_tx_busylock_key: lockdep class annotating Qdisc->busylock"]
#[doc = "\t\t\t\tspinlock"]
#[doc = "\t@qdisc_running_key:\tlockdep class annotating Qdisc->running seqcount"]
#[doc = "\t@qdisc_xmit_lock_key:\tlockdep class annotating"]
#[doc = "\t\t\t\tnetdev_queue->_xmit_lock spinlock"]
#[doc = "\t@addr_list_lock_key:\tlockdep class annotating"]
#[doc = "\t\t\t\tnet_device->addr_list_lock spinlock"]
#[doc = ""]
#[doc = "\t@proto_down:\tprotocol port state information can be sent to the"]
#[doc = "\t\t\tswitch driver and used to set the phys state of the"]
#[doc = "\t\t\tswitch port."]
#[doc = ""]
#[doc = "\t@wol_enabled:\tWake-on-LAN is enabled"]
#[doc = ""]
#[doc = "\tFIXME: cleanup struct net_device such that network protocol info"]
#[doc = "\tmoves out."]
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct net_device {
    pub name: [c_types::c_char; 16usize],
    pub name_hlist: hlist_node,
    pub ifalias: *mut dev_ifalias,
    pub mem_end: c_types::c_ulong,
    pub mem_start: c_types::c_ulong,
    pub base_addr: c_types::c_ulong,
    pub irq: c_types::c_int,
    pub state: c_types::c_ulong,
    pub dev_list: list_head,
    pub napi_list: list_head,
    pub unreg_list: list_head,
    pub close_list: list_head,
    pub ptype_all: list_head,
    pub ptype_specific: list_head,
    pub adj_list: net_device__bindgen_ty_1,
    pub features: netdev_features_t,
    pub hw_features: netdev_features_t,
    pub wanted_features: netdev_features_t,
    pub vlan_features: netdev_features_t,
    pub hw_enc_features: netdev_features_t,
    pub mpls_features: netdev_features_t,
    pub gso_partial_features: netdev_features_t,
    pub ifindex: c_types::c_int,
    pub group: c_types::c_int,
    pub stats: net_device_stats,
    pub rx_dropped: atomic_long_t,
    pub tx_dropped: atomic_long_t,
    pub rx_nohandler: atomic_long_t,
    pub carrier_up_count: atomic_t,
    pub carrier_down_count: atomic_t,
    pub wireless_handlers: *mut iw_handler_def,
    pub wireless_data: *mut iw_public_data,
    pub netdev_ops: *const net_device_ops,
    pub ethtool_ops: *const ethtool_ops,
    pub l3mdev_ops: *const l3mdev_ops,
    pub ndisc_ops: *mut ndisc_ops,
    pub xfrmdev_ops: *const xfrmdev_ops,
    pub tlsdev_ops: *const tlsdev_ops,
    pub header_ops: *const header_ops,
    pub flags: c_types::c_uint,
    pub priv_flags: c_types::c_uint,
    pub gflags: c_types::c_ushort,
    pub padded: c_types::c_ushort,
    pub operstate: c_types::c_uchar,
    pub link_mode: c_types::c_uchar,
    pub if_port: c_types::c_uchar,
    pub dma: c_types::c_uchar,
    pub mtu: c_types::c_uint,
    pub min_mtu: c_types::c_uint,
    pub max_mtu: c_types::c_uint,
    pub type_: c_types::c_ushort,
    pub hard_header_len: c_types::c_ushort,
    pub min_header_len: c_types::c_uchar,
    pub needed_headroom: c_types::c_ushort,
    pub needed_tailroom: c_types::c_ushort,
    pub perm_addr: [c_types::c_uchar; 32usize],
    pub addr_assign_type: c_types::c_uchar,
    pub addr_len: c_types::c_uchar,
    pub upper_level: c_types::c_uchar,
    pub lower_level: c_types::c_uchar,
    pub neigh_priv_len: c_types::c_ushort,
    pub dev_id: c_types::c_ushort,
    pub dev_port: c_types::c_ushort,
    pub addr_list_lock: spinlock_t,
    pub name_assign_type: c_types::c_uchar,
    pub uc_promisc: bool_,
    pub uc: netdev_hw_addr_list,
    pub mc: netdev_hw_addr_list,
    pub dev_addrs: netdev_hw_addr_list,
    pub queues_kset: *mut kset,
    pub promiscuity: c_types::c_uint,
    pub allmulti: c_types::c_uint,
    pub vlan_info: *mut vlan_info,
    pub dsa_ptr: *mut dsa_port,
    pub tipc_ptr: *mut tipc_bearer,
    pub atalk_ptr: *mut c_types::c_void,
    pub ip_ptr: *mut in_device,
    pub dn_ptr: *mut dn_dev,
    pub ip6_ptr: *mut inet6_dev,
    pub ax25_ptr: *mut c_types::c_void,
    pub ieee80211_ptr: *mut wireless_dev,
    pub ieee802154_ptr: *mut wpan_dev,
    pub mpls_ptr: *mut mpls_dev,
    pub dev_addr: *mut c_types::c_uchar,
    pub _rx: *mut netdev_rx_queue,
    pub num_rx_queues: c_types::c_uint,
    pub real_num_rx_queues: c_types::c_uint,
    pub xdp_prog: *mut bpf_prog,
    pub gro_flush_timeout: c_types::c_ulong,
    pub rx_handler: rx_handler_func_t,
    pub rx_handler_data: *mut c_types::c_void,
    pub miniq_ingress: *mut mini_Qdisc,
    pub ingress_queue: *mut netdev_queue,
    pub nf_hooks_ingress: *mut nf_hook_entries,
    pub broadcast: [c_types::c_uchar; 32usize],
    pub rx_cpu_rmap: *mut cpu_rmap,
    pub index_hlist: hlist_node,
    pub _tx: *mut netdev_queue,
    pub num_tx_queues: c_types::c_uint,
    pub real_num_tx_queues: c_types::c_uint,
    pub qdisc: *mut Qdisc,
    pub qdisc_hash: [hlist_head; 16usize],
    pub tx_queue_len: c_types::c_uint,
    pub tx_global_lock: spinlock_t,
    pub watchdog_timeo: c_types::c_int,
    pub xps_cpus_map: *mut xps_dev_maps,
    pub xps_rxqs_map: *mut xps_dev_maps,
    pub miniq_egress: *mut mini_Qdisc,
    pub watchdog_timer: timer_list,
    pub pcpu_refcnt: *mut c_types::c_int,
    pub todo_list: list_head,
    pub link_watch_list: list_head,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub dismantle: bool_,
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 2usize], u16>,
    pub needs_free_netdev: bool_,
    pub priv_destructor: ::core::option::Option<unsafe extern "C" fn(dev: *mut net_device)>,
    pub npinfo: *mut netpoll_info,
    pub nd_net: possible_net_t,
    pub __bindgen_anon_1: net_device__bindgen_ty_4,
    pub garp_port: *mut garp_port,
    pub mrp_port: *mut mrp_port,
    pub dev: device,
    pub sysfs_groups: [*const attribute_group; 4usize],
    pub sysfs_rx_queue_group: *const attribute_group,
    pub rtnl_link_ops: *const rtnl_link_ops,
    pub gso_max_size: c_types::c_uint,
    pub gso_max_segs: u16_,
    pub dcbnl_ops: *const dcbnl_rtnl_ops,
    pub num_tc: s16,
    pub tc_to_txq: [netdev_tc_txq; 16usize],
    pub prio_tc_map: [u8_; 16usize],
    pub fcoe_ddp_xid: c_types::c_uint,
    pub priomap: *mut netprio_map,
    pub phydev: *mut phy_device,
    pub sfp_bus: *mut sfp_bus,
    pub qdisc_tx_busylock_key: lock_class_key,
    pub qdisc_running_key: lock_class_key,
    pub qdisc_xmit_lock_key: lock_class_key,
    pub addr_list_lock_key: lock_class_key,
    pub proto_down: bool_,
    pub _bitfield_3: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u16; 27usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct net_device__bindgen_ty_1 {
    pub upper: list_head,
    pub lower: list_head,
}
#[test]
fn bindgen_test_layout_net_device__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<net_device__bindgen_ty_1>(),
        32usize,
        concat!("Size of: ", stringify!(net_device__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<net_device__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(net_device__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device__bindgen_ty_1>())).upper as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device__bindgen_ty_1),
            "::",
            stringify!(upper)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device__bindgen_ty_1>())).lower as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device__bindgen_ty_1),
            "::",
            stringify!(lower)
        )
    );
}
impl Default for net_device__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub const net_device_NETREG_UNINITIALIZED: c_types::c_uint = 0;
pub const net_device_NETREG_REGISTERED: c_types::c_uint = 1;
pub const net_device_NETREG_UNREGISTERING: c_types::c_uint = 2;
pub const net_device_NETREG_UNREGISTERED: c_types::c_uint = 3;
pub const net_device_NETREG_RELEASED: c_types::c_uint = 4;
pub const net_device_NETREG_DUMMY: c_types::c_uint = 5;
pub type net_device__bindgen_ty_2 = c_types::c_uint;
pub const net_device_RTNL_LINK_INITIALIZED: c_types::c_uint = 0;
pub const net_device_RTNL_LINK_INITIALIZING: c_types::c_uint = 1;
pub type net_device__bindgen_ty_3 = c_types::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub union net_device__bindgen_ty_4 {
    pub ml_priv: *mut c_types::c_void,
    pub lstats: *mut pcpu_lstats,
    pub tstats: *mut pcpu_sw_netstats,
    pub dstats: *mut pcpu_dstats,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_net_device__bindgen_ty_4() {
    assert_eq!(
        ::core::mem::size_of::<net_device__bindgen_ty_4>(),
        8usize,
        concat!("Size of: ", stringify!(net_device__bindgen_ty_4))
    );
    assert_eq!(
        ::core::mem::align_of::<net_device__bindgen_ty_4>(),
        8usize,
        concat!("Alignment of ", stringify!(net_device__bindgen_ty_4))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<net_device__bindgen_ty_4>())).ml_priv as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device__bindgen_ty_4),
            "::",
            stringify!(ml_priv)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<net_device__bindgen_ty_4>())).lstats as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device__bindgen_ty_4),
            "::",
            stringify!(lstats)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<net_device__bindgen_ty_4>())).tstats as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device__bindgen_ty_4),
            "::",
            stringify!(tstats)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<net_device__bindgen_ty_4>())).dstats as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device__bindgen_ty_4),
            "::",
            stringify!(dstats)
        )
    );
}
impl Default for net_device__bindgen_ty_4 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_net_device() {
    assert_eq!(
        ::core::mem::size_of::<net_device>(),
        2240usize,
        concat!("Size of: ", stringify!(net_device))
    );
    assert_eq!(
        ::core::mem::align_of::<net_device>(),
        64usize,
        concat!("Alignment of ", stringify!(net_device))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device>())).name_hlist as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device),
            "::",
            stringify!(name_hlist)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device>())).ifalias as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device),
            "::",
            stringify!(ifalias)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device>())).mem_end as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device),
            "::",
            stringify!(mem_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device>())).mem_start as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device),
            "::",
            stringify!(mem_start)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device>())).base_addr as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device),
            "::",
            stringify!(base_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device>())).irq as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device),
            "::",
            stringify!(irq)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device>())).state as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device>())).dev_list as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device),
            "::",
            stringify!(dev_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device>())).napi_list as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device),
            "::",
            stringify!(napi_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device>())).unreg_list as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device),
            "::",
            stringify!(unreg_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device>())).close_list as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device),
            "::",
            stringify!(close_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device>())).ptype_all as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device),
            "::",
            stringify!(ptype_all)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device>())).ptype_specific as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device),
            "::",
            stringify!(ptype_specific)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device>())).adj_list as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device),
            "::",
            stringify!(adj_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device>())).features as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device),
            "::",
            stringify!(features)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device>())).hw_features as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device),
            "::",
            stringify!(hw_features)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device>())).wanted_features as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device),
            "::",
            stringify!(wanted_features)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device>())).vlan_features as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device),
            "::",
            stringify!(vlan_features)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device>())).hw_enc_features as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device),
            "::",
            stringify!(hw_enc_features)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device>())).mpls_features as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device),
            "::",
            stringify!(mpls_features)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<net_device>())).gso_partial_features as *const _ as usize
        },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device),
            "::",
            stringify!(gso_partial_features)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device>())).ifindex as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device),
            "::",
            stringify!(ifindex)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device>())).group as *const _ as usize },
        268usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device),
            "::",
            stringify!(group)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device>())).stats as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device),
            "::",
            stringify!(stats)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device>())).rx_dropped as *const _ as usize },
        456usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device),
            "::",
            stringify!(rx_dropped)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device>())).tx_dropped as *const _ as usize },
        464usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device),
            "::",
            stringify!(tx_dropped)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device>())).rx_nohandler as *const _ as usize },
        472usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device),
            "::",
            stringify!(rx_nohandler)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device>())).carrier_up_count as *const _ as usize },
        480usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device),
            "::",
            stringify!(carrier_up_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device>())).carrier_down_count as *const _ as usize },
        484usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device),
            "::",
            stringify!(carrier_down_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device>())).wireless_handlers as *const _ as usize },
        488usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device),
            "::",
            stringify!(wireless_handlers)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device>())).wireless_data as *const _ as usize },
        496usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device),
            "::",
            stringify!(wireless_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device>())).netdev_ops as *const _ as usize },
        504usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device),
            "::",
            stringify!(netdev_ops)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device>())).ethtool_ops as *const _ as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device),
            "::",
            stringify!(ethtool_ops)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device>())).l3mdev_ops as *const _ as usize },
        520usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device),
            "::",
            stringify!(l3mdev_ops)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device>())).ndisc_ops as *const _ as usize },
        528usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device),
            "::",
            stringify!(ndisc_ops)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device>())).xfrmdev_ops as *const _ as usize },
        536usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device),
            "::",
            stringify!(xfrmdev_ops)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device>())).tlsdev_ops as *const _ as usize },
        544usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device),
            "::",
            stringify!(tlsdev_ops)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device>())).header_ops as *const _ as usize },
        552usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device),
            "::",
            stringify!(header_ops)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device>())).flags as *const _ as usize },
        560usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device>())).priv_flags as *const _ as usize },
        564usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device),
            "::",
            stringify!(priv_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device>())).gflags as *const _ as usize },
        568usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device),
            "::",
            stringify!(gflags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device>())).padded as *const _ as usize },
        570usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device),
            "::",
            stringify!(padded)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device>())).operstate as *const _ as usize },
        572usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device),
            "::",
            stringify!(operstate)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device>())).link_mode as *const _ as usize },
        573usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device),
            "::",
            stringify!(link_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device>())).if_port as *const _ as usize },
        574usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device),
            "::",
            stringify!(if_port)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device>())).dma as *const _ as usize },
        575usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device),
            "::",
            stringify!(dma)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device>())).mtu as *const _ as usize },
        576usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device),
            "::",
            stringify!(mtu)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device>())).min_mtu as *const _ as usize },
        580usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device),
            "::",
            stringify!(min_mtu)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device>())).max_mtu as *const _ as usize },
        584usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device),
            "::",
            stringify!(max_mtu)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device>())).type_ as *const _ as usize },
        588usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device>())).hard_header_len as *const _ as usize },
        590usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device),
            "::",
            stringify!(hard_header_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device>())).min_header_len as *const _ as usize },
        592usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device),
            "::",
            stringify!(min_header_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device>())).needed_headroom as *const _ as usize },
        594usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device),
            "::",
            stringify!(needed_headroom)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device>())).needed_tailroom as *const _ as usize },
        596usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device),
            "::",
            stringify!(needed_tailroom)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device>())).perm_addr as *const _ as usize },
        598usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device),
            "::",
            stringify!(perm_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device>())).addr_assign_type as *const _ as usize },
        630usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device),
            "::",
            stringify!(addr_assign_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device>())).addr_len as *const _ as usize },
        631usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device),
            "::",
            stringify!(addr_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device>())).upper_level as *const _ as usize },
        632usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device),
            "::",
            stringify!(upper_level)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device>())).lower_level as *const _ as usize },
        633usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device),
            "::",
            stringify!(lower_level)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device>())).neigh_priv_len as *const _ as usize },
        634usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device),
            "::",
            stringify!(neigh_priv_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device>())).dev_id as *const _ as usize },
        636usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device),
            "::",
            stringify!(dev_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device>())).dev_port as *const _ as usize },
        638usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device),
            "::",
            stringify!(dev_port)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device>())).addr_list_lock as *const _ as usize },
        640usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device),
            "::",
            stringify!(addr_list_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device>())).name_assign_type as *const _ as usize },
        644usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device),
            "::",
            stringify!(name_assign_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device>())).uc_promisc as *const _ as usize },
        645usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device),
            "::",
            stringify!(uc_promisc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device>())).uc as *const _ as usize },
        648usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device),
            "::",
            stringify!(uc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device>())).mc as *const _ as usize },
        672usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device),
            "::",
            stringify!(mc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device>())).dev_addrs as *const _ as usize },
        696usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device),
            "::",
            stringify!(dev_addrs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device>())).queues_kset as *const _ as usize },
        720usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device),
            "::",
            stringify!(queues_kset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device>())).promiscuity as *const _ as usize },
        728usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device),
            "::",
            stringify!(promiscuity)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device>())).allmulti as *const _ as usize },
        732usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device),
            "::",
            stringify!(allmulti)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device>())).vlan_info as *const _ as usize },
        736usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device),
            "::",
            stringify!(vlan_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device>())).dsa_ptr as *const _ as usize },
        744usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device),
            "::",
            stringify!(dsa_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device>())).tipc_ptr as *const _ as usize },
        752usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device),
            "::",
            stringify!(tipc_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device>())).atalk_ptr as *const _ as usize },
        760usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device),
            "::",
            stringify!(atalk_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device>())).ip_ptr as *const _ as usize },
        768usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device),
            "::",
            stringify!(ip_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device>())).dn_ptr as *const _ as usize },
        776usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device),
            "::",
            stringify!(dn_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device>())).ip6_ptr as *const _ as usize },
        784usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device),
            "::",
            stringify!(ip6_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device>())).ax25_ptr as *const _ as usize },
        792usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device),
            "::",
            stringify!(ax25_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device>())).ieee80211_ptr as *const _ as usize },
        800usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device),
            "::",
            stringify!(ieee80211_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device>())).ieee802154_ptr as *const _ as usize },
        808usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device),
            "::",
            stringify!(ieee802154_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device>())).mpls_ptr as *const _ as usize },
        816usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device),
            "::",
            stringify!(mpls_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device>())).dev_addr as *const _ as usize },
        824usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device),
            "::",
            stringify!(dev_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device>()))._rx as *const _ as usize },
        832usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device),
            "::",
            stringify!(_rx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device>())).num_rx_queues as *const _ as usize },
        840usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device),
            "::",
            stringify!(num_rx_queues)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device>())).real_num_rx_queues as *const _ as usize },
        844usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device),
            "::",
            stringify!(real_num_rx_queues)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device>())).xdp_prog as *const _ as usize },
        848usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device),
            "::",
            stringify!(xdp_prog)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device>())).gro_flush_timeout as *const _ as usize },
        856usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device),
            "::",
            stringify!(gro_flush_timeout)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device>())).rx_handler as *const _ as usize },
        864usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device),
            "::",
            stringify!(rx_handler)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device>())).rx_handler_data as *const _ as usize },
        872usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device),
            "::",
            stringify!(rx_handler_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device>())).miniq_ingress as *const _ as usize },
        880usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device),
            "::",
            stringify!(miniq_ingress)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device>())).ingress_queue as *const _ as usize },
        888usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device),
            "::",
            stringify!(ingress_queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device>())).nf_hooks_ingress as *const _ as usize },
        896usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device),
            "::",
            stringify!(nf_hooks_ingress)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device>())).broadcast as *const _ as usize },
        904usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device),
            "::",
            stringify!(broadcast)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device>())).rx_cpu_rmap as *const _ as usize },
        936usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device),
            "::",
            stringify!(rx_cpu_rmap)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device>())).index_hlist as *const _ as usize },
        944usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device),
            "::",
            stringify!(index_hlist)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device>()))._tx as *const _ as usize },
        960usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device),
            "::",
            stringify!(_tx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device>())).num_tx_queues as *const _ as usize },
        968usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device),
            "::",
            stringify!(num_tx_queues)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device>())).real_num_tx_queues as *const _ as usize },
        972usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device),
            "::",
            stringify!(real_num_tx_queues)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device>())).qdisc as *const _ as usize },
        976usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device),
            "::",
            stringify!(qdisc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device>())).qdisc_hash as *const _ as usize },
        984usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device),
            "::",
            stringify!(qdisc_hash)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device>())).tx_queue_len as *const _ as usize },
        1112usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device),
            "::",
            stringify!(tx_queue_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device>())).tx_global_lock as *const _ as usize },
        1116usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device),
            "::",
            stringify!(tx_global_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device>())).watchdog_timeo as *const _ as usize },
        1120usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device),
            "::",
            stringify!(watchdog_timeo)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device>())).xps_cpus_map as *const _ as usize },
        1128usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device),
            "::",
            stringify!(xps_cpus_map)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device>())).xps_rxqs_map as *const _ as usize },
        1136usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device),
            "::",
            stringify!(xps_rxqs_map)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device>())).miniq_egress as *const _ as usize },
        1144usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device),
            "::",
            stringify!(miniq_egress)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device>())).watchdog_timer as *const _ as usize },
        1152usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device),
            "::",
            stringify!(watchdog_timer)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device>())).pcpu_refcnt as *const _ as usize },
        1192usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device),
            "::",
            stringify!(pcpu_refcnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device>())).todo_list as *const _ as usize },
        1200usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device),
            "::",
            stringify!(todo_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device>())).link_watch_list as *const _ as usize },
        1216usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device),
            "::",
            stringify!(link_watch_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device>())).dismantle as *const _ as usize },
        1233usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device),
            "::",
            stringify!(dismantle)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device>())).needs_free_netdev as *const _ as usize },
        1236usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device),
            "::",
            stringify!(needs_free_netdev)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device>())).priv_destructor as *const _ as usize },
        1240usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device),
            "::",
            stringify!(priv_destructor)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device>())).npinfo as *const _ as usize },
        1248usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device),
            "::",
            stringify!(npinfo)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device>())).nd_net as *const _ as usize },
        1256usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device),
            "::",
            stringify!(nd_net)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device>())).garp_port as *const _ as usize },
        1272usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device),
            "::",
            stringify!(garp_port)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device>())).mrp_port as *const _ as usize },
        1280usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device),
            "::",
            stringify!(mrp_port)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device>())).dev as *const _ as usize },
        1288usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device),
            "::",
            stringify!(dev)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device>())).sysfs_groups as *const _ as usize },
        2008usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device),
            "::",
            stringify!(sysfs_groups)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<net_device>())).sysfs_rx_queue_group as *const _ as usize
        },
        2040usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device),
            "::",
            stringify!(sysfs_rx_queue_group)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device>())).rtnl_link_ops as *const _ as usize },
        2048usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device),
            "::",
            stringify!(rtnl_link_ops)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device>())).gso_max_size as *const _ as usize },
        2056usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device),
            "::",
            stringify!(gso_max_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device>())).gso_max_segs as *const _ as usize },
        2060usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device),
            "::",
            stringify!(gso_max_segs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device>())).dcbnl_ops as *const _ as usize },
        2064usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device),
            "::",
            stringify!(dcbnl_ops)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device>())).num_tc as *const _ as usize },
        2072usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device),
            "::",
            stringify!(num_tc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device>())).tc_to_txq as *const _ as usize },
        2074usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device),
            "::",
            stringify!(tc_to_txq)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device>())).prio_tc_map as *const _ as usize },
        2138usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device),
            "::",
            stringify!(prio_tc_map)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device>())).fcoe_ddp_xid as *const _ as usize },
        2156usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device),
            "::",
            stringify!(fcoe_ddp_xid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device>())).priomap as *const _ as usize },
        2160usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device),
            "::",
            stringify!(priomap)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device>())).phydev as *const _ as usize },
        2168usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device),
            "::",
            stringify!(phydev)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device>())).sfp_bus as *const _ as usize },
        2176usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device),
            "::",
            stringify!(sfp_bus)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<net_device>())).qdisc_tx_busylock_key as *const _ as usize
        },
        2184usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device),
            "::",
            stringify!(qdisc_tx_busylock_key)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device>())).qdisc_running_key as *const _ as usize },
        2184usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device),
            "::",
            stringify!(qdisc_running_key)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device>())).qdisc_xmit_lock_key as *const _ as usize },
        2184usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device),
            "::",
            stringify!(qdisc_xmit_lock_key)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device>())).addr_list_lock_key as *const _ as usize },
        2184usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device),
            "::",
            stringify!(addr_list_lock_key)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_device>())).proto_down as *const _ as usize },
        2184usize,
        concat!(
            "Offset of field: ",
            stringify!(net_device),
            "::",
            stringify!(proto_down)
        )
    );
}
impl Default for net_device {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl net_device {
    #[inline]
    pub fn reg_state(&self) -> net_device__bindgen_ty_2 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_reg_state(&mut self, val: net_device__bindgen_ty_2) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reg_state: net_device__bindgen_ty_2,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let reg_state: u32 = unsafe { ::core::mem::transmute(reg_state) };
            reg_state as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn rtnl_link_state(&self) -> net_device__bindgen_ty_3 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_rtnl_link_state(&mut self, val: net_device__bindgen_ty_3) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_2(
        rtnl_link_state: net_device__bindgen_ty_3,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let rtnl_link_state: u32 = unsafe { ::core::mem::transmute(rtnl_link_state) };
            rtnl_link_state as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn wol_enabled(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wol_enabled(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_3.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_3(wol_enabled: c_types::c_uint) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let wol_enabled: u32 = unsafe { ::core::mem::transmute(wol_enabled) };
            wol_enabled as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(32))]
#[derive(Debug, Default, Copy, Clone)]
pub struct pcpu_sw_netstats {
    pub rx_packets: u64_,
    pub rx_bytes: u64_,
    pub tx_packets: u64_,
    pub tx_bytes: u64_,
    pub syncp: u64_stats_sync,
}
#[test]
fn bindgen_test_layout_pcpu_sw_netstats() {
    assert_eq!(
        ::core::mem::size_of::<pcpu_sw_netstats>(),
        32usize,
        concat!("Size of: ", stringify!(pcpu_sw_netstats))
    );
    assert_eq!(
        ::core::mem::align_of::<pcpu_sw_netstats>(),
        32usize,
        concat!("Alignment of ", stringify!(pcpu_sw_netstats))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pcpu_sw_netstats>())).rx_packets as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pcpu_sw_netstats),
            "::",
            stringify!(rx_packets)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pcpu_sw_netstats>())).rx_bytes as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pcpu_sw_netstats),
            "::",
            stringify!(rx_bytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pcpu_sw_netstats>())).tx_packets as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pcpu_sw_netstats),
            "::",
            stringify!(tx_packets)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pcpu_sw_netstats>())).tx_bytes as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(pcpu_sw_netstats),
            "::",
            stringify!(tx_bytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pcpu_sw_netstats>())).syncp as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(pcpu_sw_netstats),
            "::",
            stringify!(syncp)
        )
    );
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Default, Copy, Clone)]
pub struct pcpu_lstats {
    pub packets: u64_,
    pub bytes: u64_,
    pub syncp: u64_stats_sync,
}
#[test]
fn bindgen_test_layout_pcpu_lstats() {
    assert_eq!(
        ::core::mem::size_of::<pcpu_lstats>(),
        16usize,
        concat!("Size of: ", stringify!(pcpu_lstats))
    );
    assert_eq!(
        ::core::mem::align_of::<pcpu_lstats>(),
        16usize,
        concat!("Alignment of ", stringify!(pcpu_lstats))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pcpu_lstats>())).packets as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pcpu_lstats),
            "::",
            stringify!(packets)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pcpu_lstats>())).bytes as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pcpu_lstats),
            "::",
            stringify!(bytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pcpu_lstats>())).syncp as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pcpu_lstats),
            "::",
            stringify!(syncp)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nf_hook_state {
    pub hook: c_types::c_uint,
    pub pf: u_int8_t,
    pub in_: *mut net_device,
    pub out: *mut net_device,
    pub sk: *mut sock,
    pub net: *mut net,
    pub okfn: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net, arg2: *mut sock, arg3: *mut sk_buff) -> c_types::c_int,
    >,
}
#[test]
fn bindgen_test_layout_nf_hook_state() {
    assert_eq!(
        ::core::mem::size_of::<nf_hook_state>(),
        48usize,
        concat!("Size of: ", stringify!(nf_hook_state))
    );
    assert_eq!(
        ::core::mem::align_of::<nf_hook_state>(),
        8usize,
        concat!("Alignment of ", stringify!(nf_hook_state))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nf_hook_state>())).hook as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nf_hook_state),
            "::",
            stringify!(hook)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nf_hook_state>())).pf as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nf_hook_state),
            "::",
            stringify!(pf)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nf_hook_state>())).in_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nf_hook_state),
            "::",
            stringify!(in_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nf_hook_state>())).out as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nf_hook_state),
            "::",
            stringify!(out)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nf_hook_state>())).sk as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(nf_hook_state),
            "::",
            stringify!(sk)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nf_hook_state>())).net as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(nf_hook_state),
            "::",
            stringify!(net)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nf_hook_state>())).okfn as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(nf_hook_state),
            "::",
            stringify!(okfn)
        )
    );
}
impl Default for nf_hook_state {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type nf_hookfn = ::core::option::Option<
    unsafe extern "C" fn(
        priv_: *mut c_types::c_void,
        skb: *mut sk_buff,
        state: *const nf_hook_state,
    ) -> c_types::c_uint,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nf_hook_ops {
    pub hook: nf_hookfn,
    pub dev: *mut net_device,
    pub priv_: *mut c_types::c_void,
    pub pf: u_int8_t,
    pub hooknum: c_types::c_uint,
    pub priority: c_types::c_int,
}
#[test]
fn bindgen_test_layout_nf_hook_ops() {
    assert_eq!(
        ::core::mem::size_of::<nf_hook_ops>(),
        40usize,
        concat!("Size of: ", stringify!(nf_hook_ops))
    );
    assert_eq!(
        ::core::mem::align_of::<nf_hook_ops>(),
        8usize,
        concat!("Alignment of ", stringify!(nf_hook_ops))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nf_hook_ops>())).hook as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nf_hook_ops),
            "::",
            stringify!(hook)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nf_hook_ops>())).dev as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nf_hook_ops),
            "::",
            stringify!(dev)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nf_hook_ops>())).priv_ as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nf_hook_ops),
            "::",
            stringify!(priv_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nf_hook_ops>())).pf as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(nf_hook_ops),
            "::",
            stringify!(pf)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nf_hook_ops>())).hooknum as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(nf_hook_ops),
            "::",
            stringify!(hooknum)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nf_hook_ops>())).priority as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(nf_hook_ops),
            "::",
            stringify!(priority)
        )
    );
}
impl Default for nf_hook_ops {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nf_hook_entry {
    pub hook: nf_hookfn,
    pub priv_: *mut c_types::c_void,
}
#[test]
fn bindgen_test_layout_nf_hook_entry() {
    assert_eq!(
        ::core::mem::size_of::<nf_hook_entry>(),
        16usize,
        concat!("Size of: ", stringify!(nf_hook_entry))
    );
    assert_eq!(
        ::core::mem::align_of::<nf_hook_entry>(),
        8usize,
        concat!("Alignment of ", stringify!(nf_hook_entry))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nf_hook_entry>())).hook as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nf_hook_entry),
            "::",
            stringify!(hook)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nf_hook_entry>())).priv_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nf_hook_entry),
            "::",
            stringify!(priv_)
        )
    );
}
impl Default for nf_hook_entry {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct nf_hook_entries {
    pub num_hook_entries: u16_,
    pub hooks: __IncompleteArrayField<nf_hook_entry>,
}
#[test]
fn bindgen_test_layout_nf_hook_entries() {
    assert_eq!(
        ::core::mem::size_of::<nf_hook_entries>(),
        8usize,
        concat!("Size of: ", stringify!(nf_hook_entries))
    );
    assert_eq!(
        ::core::mem::align_of::<nf_hook_entries>(),
        8usize,
        concat!("Alignment of ", stringify!(nf_hook_entries))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<nf_hook_entries>())).num_hook_entries as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nf_hook_entries),
            "::",
            stringify!(num_hook_entries)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nf_hook_entries>())).hooks as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nf_hook_entries),
            "::",
            stringify!(hooks)
        )
    );
}
impl Default for nf_hook_entries {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn nf_register_net_hook(net: *mut net, ops: *const nf_hook_ops) -> c_types::c_int;
}
extern "C" {
    pub fn nf_unregister_net_hook(net: *mut net, ops: *const nf_hook_ops);
}
pub const nf_ip_hook_priorities_NF_IP_PRI_FIRST: nf_ip_hook_priorities = -2147483648;
pub const nf_ip_hook_priorities_NF_IP_PRI_RAW_BEFORE_DEFRAG: nf_ip_hook_priorities = -450;
pub const nf_ip_hook_priorities_NF_IP_PRI_CONNTRACK_DEFRAG: nf_ip_hook_priorities = -400;
pub const nf_ip_hook_priorities_NF_IP_PRI_RAW: nf_ip_hook_priorities = -300;
pub const nf_ip_hook_priorities_NF_IP_PRI_SELINUX_FIRST: nf_ip_hook_priorities = -225;
pub const nf_ip_hook_priorities_NF_IP_PRI_CONNTRACK: nf_ip_hook_priorities = -200;
pub const nf_ip_hook_priorities_NF_IP_PRI_MANGLE: nf_ip_hook_priorities = -150;
pub const nf_ip_hook_priorities_NF_IP_PRI_NAT_DST: nf_ip_hook_priorities = -100;
pub const nf_ip_hook_priorities_NF_IP_PRI_FILTER: nf_ip_hook_priorities = 0;
pub const nf_ip_hook_priorities_NF_IP_PRI_SECURITY: nf_ip_hook_priorities = 50;
pub const nf_ip_hook_priorities_NF_IP_PRI_NAT_SRC: nf_ip_hook_priorities = 100;
pub const nf_ip_hook_priorities_NF_IP_PRI_SELINUX_LAST: nf_ip_hook_priorities = 225;
pub const nf_ip_hook_priorities_NF_IP_PRI_CONNTRACK_HELPER: nf_ip_hook_priorities = 300;
pub const nf_ip_hook_priorities_NF_IP_PRI_CONNTRACK_CONFIRM: nf_ip_hook_priorities = 2147483647;
pub const nf_ip_hook_priorities_NF_IP_PRI_LAST: nf_ip_hook_priorities = 2147483647;
pub type nf_ip_hook_priorities = c_types::c_int;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct iphdr {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub tos: __u8,
    pub tot_len: __be16,
    pub id: __be16,
    pub frag_off: __be16,
    pub ttl: __u8,
    pub protocol: __u8,
    pub check: __sum16,
    pub saddr: __be32,
    pub daddr: __be32,
}
#[test]
fn bindgen_test_layout_iphdr() {
    assert_eq!(
        ::core::mem::size_of::<iphdr>(),
        20usize,
        concat!("Size of: ", stringify!(iphdr))
    );
    assert_eq!(
        ::core::mem::align_of::<iphdr>(),
        4usize,
        concat!("Alignment of ", stringify!(iphdr))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<iphdr>())).tos as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(iphdr),
            "::",
            stringify!(tos)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<iphdr>())).tot_len as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(iphdr),
            "::",
            stringify!(tot_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<iphdr>())).id as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(iphdr), "::", stringify!(id))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<iphdr>())).frag_off as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(iphdr),
            "::",
            stringify!(frag_off)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<iphdr>())).ttl as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(iphdr),
            "::",
            stringify!(ttl)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<iphdr>())).protocol as *const _ as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(iphdr),
            "::",
            stringify!(protocol)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<iphdr>())).check as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(iphdr),
            "::",
            stringify!(check)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<iphdr>())).saddr as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(iphdr),
            "::",
            stringify!(saddr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<iphdr>())).daddr as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(iphdr),
            "::",
            stringify!(daddr)
        )
    );
}
impl iphdr {
    #[inline]
    pub fn ihl(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_ihl(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn version(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_version(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(ihl: __u8, version: __u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let ihl: u8 = unsafe { ::core::mem::transmute(ihl) };
            ihl as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let version: u8 = unsafe { ::core::mem::transmute(version) };
            version as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct page_counter {
    pub usage: atomic_long_t,
    pub min: c_types::c_ulong,
    pub low: c_types::c_ulong,
    pub max: c_types::c_ulong,
    pub parent: *mut page_counter,
    pub emin: c_types::c_ulong,
    pub min_usage: atomic_long_t,
    pub children_min_usage: atomic_long_t,
    pub elow: c_types::c_ulong,
    pub low_usage: atomic_long_t,
    pub children_low_usage: atomic_long_t,
    pub watermark: c_types::c_ulong,
    pub failcnt: c_types::c_ulong,
}
#[test]
fn bindgen_test_layout_page_counter() {
    assert_eq!(
        ::core::mem::size_of::<page_counter>(),
        104usize,
        concat!("Size of: ", stringify!(page_counter))
    );
    assert_eq!(
        ::core::mem::align_of::<page_counter>(),
        8usize,
        concat!("Alignment of ", stringify!(page_counter))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<page_counter>())).usage as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(page_counter),
            "::",
            stringify!(usage)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<page_counter>())).min as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(page_counter),
            "::",
            stringify!(min)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<page_counter>())).low as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(page_counter),
            "::",
            stringify!(low)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<page_counter>())).max as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(page_counter),
            "::",
            stringify!(max)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<page_counter>())).parent as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(page_counter),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<page_counter>())).emin as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(page_counter),
            "::",
            stringify!(emin)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<page_counter>())).min_usage as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(page_counter),
            "::",
            stringify!(min_usage)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<page_counter>())).children_min_usage as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(page_counter),
            "::",
            stringify!(children_min_usage)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<page_counter>())).elow as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(page_counter),
            "::",
            stringify!(elow)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<page_counter>())).low_usage as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(page_counter),
            "::",
            stringify!(low_usage)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<page_counter>())).children_low_usage as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(page_counter),
            "::",
            stringify!(children_low_usage)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<page_counter>())).watermark as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(page_counter),
            "::",
            stringify!(watermark)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<page_counter>())).failcnt as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(page_counter),
            "::",
            stringify!(failcnt)
        )
    );
}
impl Default for page_counter {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct eventfd_ctx {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct vmpressure {
    pub scanned: c_types::c_ulong,
    pub reclaimed: c_types::c_ulong,
    pub tree_scanned: c_types::c_ulong,
    pub tree_reclaimed: c_types::c_ulong,
    pub sr_lock: spinlock_t,
    pub events: list_head,
    pub events_lock: mutex,
    pub work: work_struct,
}
#[test]
fn bindgen_test_layout_vmpressure() {
    assert_eq!(
        ::core::mem::size_of::<vmpressure>(),
        120usize,
        concat!("Size of: ", stringify!(vmpressure))
    );
    assert_eq!(
        ::core::mem::align_of::<vmpressure>(),
        8usize,
        concat!("Alignment of ", stringify!(vmpressure))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vmpressure>())).scanned as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vmpressure),
            "::",
            stringify!(scanned)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vmpressure>())).reclaimed as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vmpressure),
            "::",
            stringify!(reclaimed)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vmpressure>())).tree_scanned as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vmpressure),
            "::",
            stringify!(tree_scanned)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vmpressure>())).tree_reclaimed as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(vmpressure),
            "::",
            stringify!(tree_reclaimed)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vmpressure>())).sr_lock as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(vmpressure),
            "::",
            stringify!(sr_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vmpressure>())).events as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(vmpressure),
            "::",
            stringify!(events)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vmpressure>())).events_lock as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(vmpressure),
            "::",
            stringify!(events_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vmpressure>())).work as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(vmpressure),
            "::",
            stringify!(work)
        )
    );
}
impl Default for vmpressure {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fprop_global {
    pub events: percpu_counter,
    pub period: c_types::c_uint,
    pub sequence: seqcount_t,
}
#[test]
fn bindgen_test_layout_fprop_global() {
    assert_eq!(
        ::core::mem::size_of::<fprop_global>(),
        48usize,
        concat!("Size of: ", stringify!(fprop_global))
    );
    assert_eq!(
        ::core::mem::align_of::<fprop_global>(),
        8usize,
        concat!("Alignment of ", stringify!(fprop_global))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fprop_global>())).events as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fprop_global),
            "::",
            stringify!(events)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fprop_global>())).period as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(fprop_global),
            "::",
            stringify!(period)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fprop_global>())).sequence as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(fprop_global),
            "::",
            stringify!(sequence)
        )
    );
}
impl Default for fprop_global {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fprop_local_percpu {
    pub events: percpu_counter,
    pub period: c_types::c_uint,
    pub lock: raw_spinlock_t,
}
#[test]
fn bindgen_test_layout_fprop_local_percpu() {
    assert_eq!(
        ::core::mem::size_of::<fprop_local_percpu>(),
        48usize,
        concat!("Size of: ", stringify!(fprop_local_percpu))
    );
    assert_eq!(
        ::core::mem::align_of::<fprop_local_percpu>(),
        8usize,
        concat!("Alignment of ", stringify!(fprop_local_percpu))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fprop_local_percpu>())).events as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fprop_local_percpu),
            "::",
            stringify!(events)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fprop_local_percpu>())).period as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(fprop_local_percpu),
            "::",
            stringify!(period)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fprop_local_percpu>())).lock as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(fprop_local_percpu),
            "::",
            stringify!(lock)
        )
    );
}
impl Default for fprop_local_percpu {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type congested_fn = ::core::option::Option<
    unsafe extern "C" fn(arg1: *mut c_types::c_void, arg2: c_types::c_int) -> c_types::c_int,
>;
pub const wb_reason_WB_REASON_BACKGROUND: wb_reason = 0;
pub const wb_reason_WB_REASON_VMSCAN: wb_reason = 1;
pub const wb_reason_WB_REASON_SYNC: wb_reason = 2;
pub const wb_reason_WB_REASON_PERIODIC: wb_reason = 3;
pub const wb_reason_WB_REASON_LAPTOP_TIMER: wb_reason = 4;
pub const wb_reason_WB_REASON_FREE_MORE_MEM: wb_reason = 5;
pub const wb_reason_WB_REASON_FS_FREE_SPACE: wb_reason = 6;
pub const wb_reason_WB_REASON_FORKER_THREAD: wb_reason = 7;
pub const wb_reason_WB_REASON_FOREIGN_FLUSH: wb_reason = 8;
pub const wb_reason_WB_REASON_MAX: wb_reason = 9;
pub type wb_reason = c_types::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wb_completion {
    pub cnt: atomic_t,
    pub waitq: *mut wait_queue_head_t,
}
#[test]
fn bindgen_test_layout_wb_completion() {
    assert_eq!(
        ::core::mem::size_of::<wb_completion>(),
        16usize,
        concat!("Size of: ", stringify!(wb_completion))
    );
    assert_eq!(
        ::core::mem::align_of::<wb_completion>(),
        8usize,
        concat!("Alignment of ", stringify!(wb_completion))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<wb_completion>())).cnt as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wb_completion),
            "::",
            stringify!(cnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<wb_completion>())).waitq as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wb_completion),
            "::",
            stringify!(waitq)
        )
    );
}
impl Default for wb_completion {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bdi_writeback_congested {
    pub state: c_types::c_ulong,
    pub refcnt: refcount_t,
    pub __bdi: *mut backing_dev_info,
    pub blkcg_id: c_types::c_int,
    pub rb_node: rb_node,
}
#[test]
fn bindgen_test_layout_bdi_writeback_congested() {
    assert_eq!(
        ::core::mem::size_of::<bdi_writeback_congested>(),
        56usize,
        concat!("Size of: ", stringify!(bdi_writeback_congested))
    );
    assert_eq!(
        ::core::mem::align_of::<bdi_writeback_congested>(),
        8usize,
        concat!("Alignment of ", stringify!(bdi_writeback_congested))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bdi_writeback_congested>())).state as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bdi_writeback_congested),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bdi_writeback_congested>())).refcnt as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bdi_writeback_congested),
            "::",
            stringify!(refcnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bdi_writeback_congested>())).__bdi as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(bdi_writeback_congested),
            "::",
            stringify!(__bdi)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bdi_writeback_congested>())).blkcg_id as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(bdi_writeback_congested),
            "::",
            stringify!(blkcg_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bdi_writeback_congested>())).rb_node as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(bdi_writeback_congested),
            "::",
            stringify!(rb_node)
        )
    );
}
impl Default for bdi_writeback_congested {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bdi_writeback {
    pub bdi: *mut backing_dev_info,
    pub state: c_types::c_ulong,
    pub last_old_flush: c_types::c_ulong,
    pub b_dirty: list_head,
    pub b_io: list_head,
    pub b_more_io: list_head,
    pub b_dirty_time: list_head,
    pub list_lock: spinlock_t,
    pub stat: [percpu_counter; 4usize],
    pub congested: *mut bdi_writeback_congested,
    pub bw_time_stamp: c_types::c_ulong,
    pub dirtied_stamp: c_types::c_ulong,
    pub written_stamp: c_types::c_ulong,
    pub write_bandwidth: c_types::c_ulong,
    pub avg_write_bandwidth: c_types::c_ulong,
    pub dirty_ratelimit: c_types::c_ulong,
    pub balanced_dirty_ratelimit: c_types::c_ulong,
    pub completions: fprop_local_percpu,
    pub dirty_exceeded: c_types::c_int,
    pub start_all_reason: wb_reason,
    pub work_lock: spinlock_t,
    pub work_list: list_head,
    pub dwork: delayed_work,
    pub dirty_sleep: c_types::c_ulong,
    pub bdi_node: list_head,
    pub refcnt: percpu_ref,
    pub memcg_completions: fprop_local_percpu,
    pub memcg_css: *mut cgroup_subsys_state,
    pub blkcg_css: *mut cgroup_subsys_state,
    pub memcg_node: list_head,
    pub blkcg_node: list_head,
    pub __bindgen_anon_1: bdi_writeback__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bdi_writeback__bindgen_ty_1 {
    pub release_work: work_struct,
    pub rcu: callback_head,
    _bindgen_union_align: [u64; 4usize],
}
#[test]
fn bindgen_test_layout_bdi_writeback__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<bdi_writeback__bindgen_ty_1>(),
        32usize,
        concat!("Size of: ", stringify!(bdi_writeback__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<bdi_writeback__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(bdi_writeback__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bdi_writeback__bindgen_ty_1>())).release_work as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bdi_writeback__bindgen_ty_1),
            "::",
            stringify!(release_work)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bdi_writeback__bindgen_ty_1>())).rcu as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bdi_writeback__bindgen_ty_1),
            "::",
            stringify!(rcu)
        )
    );
}
impl Default for bdi_writeback__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_bdi_writeback() {
    assert_eq!(
        ::core::mem::size_of::<bdi_writeback>(),
        696usize,
        concat!("Size of: ", stringify!(bdi_writeback))
    );
    assert_eq!(
        ::core::mem::align_of::<bdi_writeback>(),
        8usize,
        concat!("Alignment of ", stringify!(bdi_writeback))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bdi_writeback>())).bdi as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bdi_writeback),
            "::",
            stringify!(bdi)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bdi_writeback>())).state as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bdi_writeback),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bdi_writeback>())).last_old_flush as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(bdi_writeback),
            "::",
            stringify!(last_old_flush)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bdi_writeback>())).b_dirty as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(bdi_writeback),
            "::",
            stringify!(b_dirty)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bdi_writeback>())).b_io as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(bdi_writeback),
            "::",
            stringify!(b_io)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bdi_writeback>())).b_more_io as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(bdi_writeback),
            "::",
            stringify!(b_more_io)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bdi_writeback>())).b_dirty_time as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(bdi_writeback),
            "::",
            stringify!(b_dirty_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bdi_writeback>())).list_lock as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(bdi_writeback),
            "::",
            stringify!(list_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bdi_writeback>())).stat as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(bdi_writeback),
            "::",
            stringify!(stat)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bdi_writeback>())).congested as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(bdi_writeback),
            "::",
            stringify!(congested)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bdi_writeback>())).bw_time_stamp as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(bdi_writeback),
            "::",
            stringify!(bw_time_stamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bdi_writeback>())).dirtied_stamp as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(bdi_writeback),
            "::",
            stringify!(dirtied_stamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bdi_writeback>())).written_stamp as *const _ as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(bdi_writeback),
            "::",
            stringify!(written_stamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bdi_writeback>())).write_bandwidth as *const _ as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(bdi_writeback),
            "::",
            stringify!(write_bandwidth)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bdi_writeback>())).avg_write_bandwidth as *const _ as usize
        },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(bdi_writeback),
            "::",
            stringify!(avg_write_bandwidth)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bdi_writeback>())).dirty_ratelimit as *const _ as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(bdi_writeback),
            "::",
            stringify!(dirty_ratelimit)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bdi_writeback>())).balanced_dirty_ratelimit as *const _ as usize
        },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(bdi_writeback),
            "::",
            stringify!(balanced_dirty_ratelimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bdi_writeback>())).completions as *const _ as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(bdi_writeback),
            "::",
            stringify!(completions)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bdi_writeback>())).dirty_exceeded as *const _ as usize },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(bdi_writeback),
            "::",
            stringify!(dirty_exceeded)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bdi_writeback>())).start_all_reason as *const _ as usize },
        372usize,
        concat!(
            "Offset of field: ",
            stringify!(bdi_writeback),
            "::",
            stringify!(start_all_reason)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bdi_writeback>())).work_lock as *const _ as usize },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(bdi_writeback),
            "::",
            stringify!(work_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bdi_writeback>())).work_list as *const _ as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(bdi_writeback),
            "::",
            stringify!(work_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bdi_writeback>())).dwork as *const _ as usize },
        400usize,
        concat!(
            "Offset of field: ",
            stringify!(bdi_writeback),
            "::",
            stringify!(dwork)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bdi_writeback>())).dirty_sleep as *const _ as usize },
        488usize,
        concat!(
            "Offset of field: ",
            stringify!(bdi_writeback),
            "::",
            stringify!(dirty_sleep)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bdi_writeback>())).bdi_node as *const _ as usize },
        496usize,
        concat!(
            "Offset of field: ",
            stringify!(bdi_writeback),
            "::",
            stringify!(bdi_node)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bdi_writeback>())).refcnt as *const _ as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(bdi_writeback),
            "::",
            stringify!(refcnt)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bdi_writeback>())).memcg_completions as *const _ as usize
        },
        568usize,
        concat!(
            "Offset of field: ",
            stringify!(bdi_writeback),
            "::",
            stringify!(memcg_completions)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bdi_writeback>())).memcg_css as *const _ as usize },
        616usize,
        concat!(
            "Offset of field: ",
            stringify!(bdi_writeback),
            "::",
            stringify!(memcg_css)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bdi_writeback>())).blkcg_css as *const _ as usize },
        624usize,
        concat!(
            "Offset of field: ",
            stringify!(bdi_writeback),
            "::",
            stringify!(blkcg_css)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bdi_writeback>())).memcg_node as *const _ as usize },
        632usize,
        concat!(
            "Offset of field: ",
            stringify!(bdi_writeback),
            "::",
            stringify!(memcg_node)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bdi_writeback>())).blkcg_node as *const _ as usize },
        648usize,
        concat!(
            "Offset of field: ",
            stringify!(bdi_writeback),
            "::",
            stringify!(blkcg_node)
        )
    );
}
impl Default for bdi_writeback {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct backing_dev_info {
    pub id: u64_,
    pub rb_node: rb_node,
    pub bdi_list: list_head,
    pub ra_pages: c_types::c_ulong,
    pub io_pages: c_types::c_ulong,
    pub congested_fn: congested_fn,
    pub congested_data: *mut c_types::c_void,
    pub name: *const c_types::c_char,
    pub refcnt: kref,
    pub capabilities: c_types::c_uint,
    pub min_ratio: c_types::c_uint,
    pub max_ratio: c_types::c_uint,
    pub max_prop_frac: c_types::c_uint,
    pub tot_write_bandwidth: atomic_long_t,
    pub wb: bdi_writeback,
    pub wb_list: list_head,
    pub cgwb_tree: xarray,
    pub cgwb_congested_tree: rb_root,
    pub cgwb_release_mutex: mutex,
    pub wb_switch_rwsem: rw_semaphore,
    pub wb_waitq: wait_queue_head_t,
    pub dev: *mut device,
    pub owner: *mut device,
    pub laptop_mode_wb_timer: timer_list,
    pub debug_dir: *mut dentry,
}
#[test]
fn bindgen_test_layout_backing_dev_info() {
    assert_eq!(
        ::core::mem::size_of::<backing_dev_info>(),
        1016usize,
        concat!("Size of: ", stringify!(backing_dev_info))
    );
    assert_eq!(
        ::core::mem::align_of::<backing_dev_info>(),
        8usize,
        concat!("Alignment of ", stringify!(backing_dev_info))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<backing_dev_info>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(backing_dev_info),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<backing_dev_info>())).rb_node as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(backing_dev_info),
            "::",
            stringify!(rb_node)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<backing_dev_info>())).bdi_list as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(backing_dev_info),
            "::",
            stringify!(bdi_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<backing_dev_info>())).ra_pages as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(backing_dev_info),
            "::",
            stringify!(ra_pages)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<backing_dev_info>())).io_pages as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(backing_dev_info),
            "::",
            stringify!(io_pages)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<backing_dev_info>())).congested_fn as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(backing_dev_info),
            "::",
            stringify!(congested_fn)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<backing_dev_info>())).congested_data as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(backing_dev_info),
            "::",
            stringify!(congested_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<backing_dev_info>())).name as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(backing_dev_info),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<backing_dev_info>())).refcnt as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(backing_dev_info),
            "::",
            stringify!(refcnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<backing_dev_info>())).capabilities as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(backing_dev_info),
            "::",
            stringify!(capabilities)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<backing_dev_info>())).min_ratio as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(backing_dev_info),
            "::",
            stringify!(min_ratio)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<backing_dev_info>())).max_ratio as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(backing_dev_info),
            "::",
            stringify!(max_ratio)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<backing_dev_info>())).max_prop_frac as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(backing_dev_info),
            "::",
            stringify!(max_prop_frac)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<backing_dev_info>())).tot_write_bandwidth as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(backing_dev_info),
            "::",
            stringify!(tot_write_bandwidth)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<backing_dev_info>())).wb as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(backing_dev_info),
            "::",
            stringify!(wb)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<backing_dev_info>())).wb_list as *const _ as usize },
        816usize,
        concat!(
            "Offset of field: ",
            stringify!(backing_dev_info),
            "::",
            stringify!(wb_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<backing_dev_info>())).cgwb_tree as *const _ as usize },
        832usize,
        concat!(
            "Offset of field: ",
            stringify!(backing_dev_info),
            "::",
            stringify!(cgwb_tree)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<backing_dev_info>())).cgwb_congested_tree as *const _ as usize
        },
        848usize,
        concat!(
            "Offset of field: ",
            stringify!(backing_dev_info),
            "::",
            stringify!(cgwb_congested_tree)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<backing_dev_info>())).cgwb_release_mutex as *const _ as usize
        },
        856usize,
        concat!(
            "Offset of field: ",
            stringify!(backing_dev_info),
            "::",
            stringify!(cgwb_release_mutex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<backing_dev_info>())).wb_switch_rwsem as *const _ as usize
        },
        888usize,
        concat!(
            "Offset of field: ",
            stringify!(backing_dev_info),
            "::",
            stringify!(wb_switch_rwsem)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<backing_dev_info>())).wb_waitq as *const _ as usize },
        928usize,
        concat!(
            "Offset of field: ",
            stringify!(backing_dev_info),
            "::",
            stringify!(wb_waitq)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<backing_dev_info>())).dev as *const _ as usize },
        952usize,
        concat!(
            "Offset of field: ",
            stringify!(backing_dev_info),
            "::",
            stringify!(dev)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<backing_dev_info>())).owner as *const _ as usize },
        960usize,
        concat!(
            "Offset of field: ",
            stringify!(backing_dev_info),
            "::",
            stringify!(owner)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<backing_dev_info>())).laptop_mode_wb_timer as *const _ as usize
        },
        968usize,
        concat!(
            "Offset of field: ",
            stringify!(backing_dev_info),
            "::",
            stringify!(laptop_mode_wb_timer)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<backing_dev_info>())).debug_dir as *const _ as usize },
        1008usize,
        concat!(
            "Offset of field: ",
            stringify!(backing_dev_info),
            "::",
            stringify!(debug_dir)
        )
    );
}
impl Default for backing_dev_info {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type bio_end_io_t = ::core::option::Option<unsafe extern "C" fn(arg1: *mut bio)>;
pub type blk_status_t = u8_;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct bio_issue {
    pub value: u64_,
}
#[test]
fn bindgen_test_layout_bio_issue() {
    assert_eq!(
        ::core::mem::size_of::<bio_issue>(),
        8usize,
        concat!("Size of: ", stringify!(bio_issue))
    );
    assert_eq!(
        ::core::mem::align_of::<bio_issue>(),
        8usize,
        concat!("Alignment of ", stringify!(bio_issue))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bio_issue>())).value as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bio_issue),
            "::",
            stringify!(value)
        )
    );
}
#[repr(C)]
pub struct bio {
    pub bi_next: *mut bio,
    pub bi_disk: *mut gendisk,
    pub bi_opf: c_types::c_uint,
    pub bi_flags: c_types::c_ushort,
    pub bi_ioprio: c_types::c_ushort,
    pub bi_write_hint: c_types::c_ushort,
    pub bi_status: blk_status_t,
    pub bi_partno: u8_,
    pub bi_iter: bvec_iter,
    pub __bi_remaining: atomic_t,
    pub bi_end_io: bio_end_io_t,
    pub bi_private: *mut c_types::c_void,
    pub bi_blkg: *mut blkcg_gq,
    pub bi_issue: bio_issue,
    pub bi_iocost_cost: u64_,
    pub __bindgen_anon_1: bio__bindgen_ty_1,
    pub bi_vcnt: c_types::c_ushort,
    pub bi_max_vecs: c_types::c_ushort,
    pub __bi_cnt: atomic_t,
    pub bi_io_vec: *mut bio_vec,
    pub bi_pool: *mut bio_set,
    pub bi_inline_vecs: __IncompleteArrayField<bio_vec>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bio__bindgen_ty_1 {
    pub bi_integrity: *mut bio_integrity_payload,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_bio__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<bio__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(bio__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<bio__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(bio__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bio__bindgen_ty_1>())).bi_integrity as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bio__bindgen_ty_1),
            "::",
            stringify!(bi_integrity)
        )
    );
}
impl Default for bio__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_bio() {
    assert_eq!(
        ::core::mem::size_of::<bio>(),
        136usize,
        concat!("Size of: ", stringify!(bio))
    );
    assert_eq!(
        ::core::mem::align_of::<bio>(),
        8usize,
        concat!("Alignment of ", stringify!(bio))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bio>())).bi_next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bio),
            "::",
            stringify!(bi_next)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bio>())).bi_disk as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bio),
            "::",
            stringify!(bi_disk)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bio>())).bi_opf as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(bio),
            "::",
            stringify!(bi_opf)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bio>())).bi_flags as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(bio),
            "::",
            stringify!(bi_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bio>())).bi_ioprio as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(bio),
            "::",
            stringify!(bi_ioprio)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bio>())).bi_write_hint as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(bio),
            "::",
            stringify!(bi_write_hint)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bio>())).bi_status as *const _ as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(bio),
            "::",
            stringify!(bi_status)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bio>())).bi_partno as *const _ as usize },
        27usize,
        concat!(
            "Offset of field: ",
            stringify!(bio),
            "::",
            stringify!(bi_partno)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bio>())).bi_iter as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(bio),
            "::",
            stringify!(bi_iter)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bio>())).__bi_remaining as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(bio),
            "::",
            stringify!(__bi_remaining)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bio>())).bi_end_io as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(bio),
            "::",
            stringify!(bi_end_io)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bio>())).bi_private as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(bio),
            "::",
            stringify!(bi_private)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bio>())).bi_blkg as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(bio),
            "::",
            stringify!(bi_blkg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bio>())).bi_issue as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(bio),
            "::",
            stringify!(bi_issue)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bio>())).bi_iocost_cost as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(bio),
            "::",
            stringify!(bi_iocost_cost)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bio>())).bi_vcnt as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(bio),
            "::",
            stringify!(bi_vcnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bio>())).bi_max_vecs as *const _ as usize },
        114usize,
        concat!(
            "Offset of field: ",
            stringify!(bio),
            "::",
            stringify!(bi_max_vecs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bio>())).__bi_cnt as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(bio),
            "::",
            stringify!(__bi_cnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bio>())).bi_io_vec as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(bio),
            "::",
            stringify!(bi_io_vec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bio>())).bi_pool as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(bio),
            "::",
            stringify!(bi_pool)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bio>())).bi_inline_vecs as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(bio),
            "::",
            stringify!(bi_inline_vecs)
        )
    );
}
impl Default for bio {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type blk_qc_t = c_types::c_uint;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct blk_rq_stat {
    pub mean: u64_,
    pub min: u64_,
    pub max: u64_,
    pub nr_samples: u32_,
    pub batch: u64_,
}
#[test]
fn bindgen_test_layout_blk_rq_stat() {
    assert_eq!(
        ::core::mem::size_of::<blk_rq_stat>(),
        40usize,
        concat!("Size of: ", stringify!(blk_rq_stat))
    );
    assert_eq!(
        ::core::mem::align_of::<blk_rq_stat>(),
        8usize,
        concat!("Alignment of ", stringify!(blk_rq_stat))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blk_rq_stat>())).mean as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(blk_rq_stat),
            "::",
            stringify!(mean)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blk_rq_stat>())).min as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(blk_rq_stat),
            "::",
            stringify!(min)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blk_rq_stat>())).max as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(blk_rq_stat),
            "::",
            stringify!(max)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blk_rq_stat>())).nr_samples as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(blk_rq_stat),
            "::",
            stringify!(nr_samples)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blk_rq_stat>())).batch as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(blk_rq_stat),
            "::",
            stringify!(batch)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct local_t {
    pub a: atomic_long_t,
}
#[test]
fn bindgen_test_layout_local_t() {
    assert_eq!(
        ::core::mem::size_of::<local_t>(),
        8usize,
        concat!("Size of: ", stringify!(local_t))
    );
    assert_eq!(
        ::core::mem::align_of::<local_t>(),
        8usize,
        concat!("Alignment of ", stringify!(local_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<local_t>())).a as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(local_t),
            "::",
            stringify!(a)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct disk_stats {
    pub nsecs: [u64_; 3usize],
    pub sectors: [c_types::c_ulong; 3usize],
    pub ios: [c_types::c_ulong; 3usize],
    pub merges: [c_types::c_ulong; 3usize],
    pub io_ticks: c_types::c_ulong,
    pub time_in_queue: c_types::c_ulong,
    pub in_flight: [local_t; 2usize],
}
#[test]
fn bindgen_test_layout_disk_stats() {
    assert_eq!(
        ::core::mem::size_of::<disk_stats>(),
        128usize,
        concat!("Size of: ", stringify!(disk_stats))
    );
    assert_eq!(
        ::core::mem::align_of::<disk_stats>(),
        8usize,
        concat!("Alignment of ", stringify!(disk_stats))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<disk_stats>())).nsecs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(disk_stats),
            "::",
            stringify!(nsecs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<disk_stats>())).sectors as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(disk_stats),
            "::",
            stringify!(sectors)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<disk_stats>())).ios as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(disk_stats),
            "::",
            stringify!(ios)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<disk_stats>())).merges as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(disk_stats),
            "::",
            stringify!(merges)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<disk_stats>())).io_ticks as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(disk_stats),
            "::",
            stringify!(io_ticks)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<disk_stats>())).time_in_queue as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(disk_stats),
            "::",
            stringify!(time_in_queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<disk_stats>())).in_flight as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(disk_stats),
            "::",
            stringify!(in_flight)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct partition_meta_info {
    pub uuid: [c_types::c_char; 37usize],
    pub volname: [u8_; 64usize],
}
#[test]
fn bindgen_test_layout_partition_meta_info() {
    assert_eq!(
        ::core::mem::size_of::<partition_meta_info>(),
        101usize,
        concat!("Size of: ", stringify!(partition_meta_info))
    );
    assert_eq!(
        ::core::mem::align_of::<partition_meta_info>(),
        1usize,
        concat!("Alignment of ", stringify!(partition_meta_info))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<partition_meta_info>())).uuid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(partition_meta_info),
            "::",
            stringify!(uuid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<partition_meta_info>())).volname as *const _ as usize },
        37usize,
        concat!(
            "Offset of field: ",
            stringify!(partition_meta_info),
            "::",
            stringify!(volname)
        )
    );
}
impl Default for partition_meta_info {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hd_struct {
    pub start_sect: sector_t,
    pub nr_sects: sector_t,
    pub nr_sects_seq: seqcount_t,
    pub alignment_offset: sector_t,
    pub discard_alignment: c_types::c_uint,
    pub __dev: device,
    pub holder_dir: *mut kobject,
    pub policy: c_types::c_int,
    pub partno: c_types::c_int,
    pub info: *mut partition_meta_info,
    pub stamp: c_types::c_ulong,
    pub dkstats: *mut disk_stats,
    pub ref_: percpu_ref,
    pub rcu_work: rcu_work,
}
#[test]
fn bindgen_test_layout_hd_struct() {
    assert_eq!(
        ::core::mem::size_of::<hd_struct>(),
        912usize,
        concat!("Size of: ", stringify!(hd_struct))
    );
    assert_eq!(
        ::core::mem::align_of::<hd_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(hd_struct))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hd_struct>())).start_sect as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hd_struct),
            "::",
            stringify!(start_sect)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hd_struct>())).nr_sects as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hd_struct),
            "::",
            stringify!(nr_sects)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hd_struct>())).nr_sects_seq as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hd_struct),
            "::",
            stringify!(nr_sects_seq)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hd_struct>())).alignment_offset as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(hd_struct),
            "::",
            stringify!(alignment_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hd_struct>())).discard_alignment as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(hd_struct),
            "::",
            stringify!(discard_alignment)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hd_struct>())).__dev as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(hd_struct),
            "::",
            stringify!(__dev)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hd_struct>())).holder_dir as *const _ as usize },
        760usize,
        concat!(
            "Offset of field: ",
            stringify!(hd_struct),
            "::",
            stringify!(holder_dir)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hd_struct>())).policy as *const _ as usize },
        768usize,
        concat!(
            "Offset of field: ",
            stringify!(hd_struct),
            "::",
            stringify!(policy)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hd_struct>())).partno as *const _ as usize },
        772usize,
        concat!(
            "Offset of field: ",
            stringify!(hd_struct),
            "::",
            stringify!(partno)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hd_struct>())).info as *const _ as usize },
        776usize,
        concat!(
            "Offset of field: ",
            stringify!(hd_struct),
            "::",
            stringify!(info)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hd_struct>())).stamp as *const _ as usize },
        784usize,
        concat!(
            "Offset of field: ",
            stringify!(hd_struct),
            "::",
            stringify!(stamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hd_struct>())).dkstats as *const _ as usize },
        792usize,
        concat!(
            "Offset of field: ",
            stringify!(hd_struct),
            "::",
            stringify!(dkstats)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hd_struct>())).ref_ as *const _ as usize },
        800usize,
        concat!(
            "Offset of field: ",
            stringify!(hd_struct),
            "::",
            stringify!(ref_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hd_struct>())).rcu_work as *const _ as usize },
        856usize,
        concat!(
            "Offset of field: ",
            stringify!(hd_struct),
            "::",
            stringify!(rcu_work)
        )
    );
}
impl Default for hd_struct {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct disk_part_tbl {
    pub callback_head: callback_head,
    pub len: c_types::c_int,
    pub last_lookup: *mut hd_struct,
    pub part: __IncompleteArrayField<*mut hd_struct>,
}
#[test]
fn bindgen_test_layout_disk_part_tbl() {
    assert_eq!(
        ::core::mem::size_of::<disk_part_tbl>(),
        32usize,
        concat!("Size of: ", stringify!(disk_part_tbl))
    );
    assert_eq!(
        ::core::mem::align_of::<disk_part_tbl>(),
        8usize,
        concat!("Alignment of ", stringify!(disk_part_tbl))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<disk_part_tbl>())).callback_head as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(disk_part_tbl),
            "::",
            stringify!(callback_head)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<disk_part_tbl>())).len as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(disk_part_tbl),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<disk_part_tbl>())).last_lookup as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(disk_part_tbl),
            "::",
            stringify!(last_lookup)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<disk_part_tbl>())).part as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(disk_part_tbl),
            "::",
            stringify!(part)
        )
    );
}
impl Default for disk_part_tbl {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct disk_events {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct badblocks {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct blk_integrity {
    pub profile: *const blk_integrity_profile,
    pub flags: c_types::c_uchar,
    pub tuple_size: c_types::c_uchar,
    pub interval_exp: c_types::c_uchar,
    pub tag_size: c_types::c_uchar,
}
#[test]
fn bindgen_test_layout_blk_integrity() {
    assert_eq!(
        ::core::mem::size_of::<blk_integrity>(),
        16usize,
        concat!("Size of: ", stringify!(blk_integrity))
    );
    assert_eq!(
        ::core::mem::align_of::<blk_integrity>(),
        8usize,
        concat!("Alignment of ", stringify!(blk_integrity))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blk_integrity>())).profile as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(blk_integrity),
            "::",
            stringify!(profile)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blk_integrity>())).flags as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(blk_integrity),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blk_integrity>())).tuple_size as *const _ as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(blk_integrity),
            "::",
            stringify!(tuple_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blk_integrity>())).interval_exp as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(blk_integrity),
            "::",
            stringify!(interval_exp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blk_integrity>())).tag_size as *const _ as usize },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(blk_integrity),
            "::",
            stringify!(tag_size)
        )
    );
}
impl Default for blk_integrity {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct gendisk {
    pub major: c_types::c_int,
    pub first_minor: c_types::c_int,
    pub minors: c_types::c_int,
    pub disk_name: [c_types::c_char; 32usize],
    pub devnode: ::core::option::Option<
        unsafe extern "C" fn(gd: *mut gendisk, mode: *mut umode_t) -> *mut c_types::c_char,
    >,
    pub events: c_types::c_ushort,
    pub event_flags: c_types::c_ushort,
    pub part_tbl: *mut disk_part_tbl,
    pub part0: hd_struct,
    pub fops: *const block_device_operations,
    pub queue: *mut request_queue,
    pub private_data: *mut c_types::c_void,
    pub flags: c_types::c_int,
    pub lookup_sem: rw_semaphore,
    pub slave_dir: *mut kobject,
    pub random: *mut timer_rand_state,
    pub sync_io: atomic_t,
    pub ev: *mut disk_events,
    pub integrity_kobj: kobject,
    pub node_id: c_types::c_int,
    pub bb: *mut badblocks,
    pub lockdep_map: lockdep_map,
}
#[test]
fn bindgen_test_layout_gendisk() {
    assert_eq!(
        ::core::mem::size_of::<gendisk>(),
        1168usize,
        concat!("Size of: ", stringify!(gendisk))
    );
    assert_eq!(
        ::core::mem::align_of::<gendisk>(),
        8usize,
        concat!("Alignment of ", stringify!(gendisk))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<gendisk>())).major as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gendisk),
            "::",
            stringify!(major)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<gendisk>())).first_minor as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(gendisk),
            "::",
            stringify!(first_minor)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<gendisk>())).minors as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(gendisk),
            "::",
            stringify!(minors)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<gendisk>())).disk_name as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(gendisk),
            "::",
            stringify!(disk_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<gendisk>())).devnode as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(gendisk),
            "::",
            stringify!(devnode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<gendisk>())).events as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(gendisk),
            "::",
            stringify!(events)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<gendisk>())).event_flags as *const _ as usize },
        58usize,
        concat!(
            "Offset of field: ",
            stringify!(gendisk),
            "::",
            stringify!(event_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<gendisk>())).part_tbl as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(gendisk),
            "::",
            stringify!(part_tbl)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<gendisk>())).part0 as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(gendisk),
            "::",
            stringify!(part0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<gendisk>())).fops as *const _ as usize },
        984usize,
        concat!(
            "Offset of field: ",
            stringify!(gendisk),
            "::",
            stringify!(fops)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<gendisk>())).queue as *const _ as usize },
        992usize,
        concat!(
            "Offset of field: ",
            stringify!(gendisk),
            "::",
            stringify!(queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<gendisk>())).private_data as *const _ as usize },
        1000usize,
        concat!(
            "Offset of field: ",
            stringify!(gendisk),
            "::",
            stringify!(private_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<gendisk>())).flags as *const _ as usize },
        1008usize,
        concat!(
            "Offset of field: ",
            stringify!(gendisk),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<gendisk>())).lookup_sem as *const _ as usize },
        1016usize,
        concat!(
            "Offset of field: ",
            stringify!(gendisk),
            "::",
            stringify!(lookup_sem)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<gendisk>())).slave_dir as *const _ as usize },
        1056usize,
        concat!(
            "Offset of field: ",
            stringify!(gendisk),
            "::",
            stringify!(slave_dir)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<gendisk>())).random as *const _ as usize },
        1064usize,
        concat!(
            "Offset of field: ",
            stringify!(gendisk),
            "::",
            stringify!(random)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<gendisk>())).sync_io as *const _ as usize },
        1072usize,
        concat!(
            "Offset of field: ",
            stringify!(gendisk),
            "::",
            stringify!(sync_io)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<gendisk>())).ev as *const _ as usize },
        1080usize,
        concat!(
            "Offset of field: ",
            stringify!(gendisk),
            "::",
            stringify!(ev)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<gendisk>())).integrity_kobj as *const _ as usize },
        1088usize,
        concat!(
            "Offset of field: ",
            stringify!(gendisk),
            "::",
            stringify!(integrity_kobj)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<gendisk>())).node_id as *const _ as usize },
        1152usize,
        concat!(
            "Offset of field: ",
            stringify!(gendisk),
            "::",
            stringify!(node_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<gendisk>())).bb as *const _ as usize },
        1160usize,
        concat!(
            "Offset of field: ",
            stringify!(gendisk),
            "::",
            stringify!(bb)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<gendisk>())).lockdep_map as *const _ as usize },
        1168usize,
        concat!(
            "Offset of field: ",
            stringify!(gendisk),
            "::",
            stringify!(lockdep_map)
        )
    );
}
impl Default for gendisk {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type mempool_alloc_t = ::core::option::Option<
    unsafe extern "C" fn(gfp_mask: gfp_t, pool_data: *mut c_types::c_void) -> *mut c_types::c_void,
>;
pub type mempool_free_t = ::core::option::Option<
    unsafe extern "C" fn(element: *mut c_types::c_void, pool_data: *mut c_types::c_void),
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mempool_s {
    pub lock: spinlock_t,
    pub min_nr: c_types::c_int,
    pub curr_nr: c_types::c_int,
    pub elements: *mut *mut c_types::c_void,
    pub pool_data: *mut c_types::c_void,
    pub alloc: mempool_alloc_t,
    pub free: mempool_free_t,
    pub wait: wait_queue_head_t,
}
#[test]
fn bindgen_test_layout_mempool_s() {
    assert_eq!(
        ::core::mem::size_of::<mempool_s>(),
        72usize,
        concat!("Size of: ", stringify!(mempool_s))
    );
    assert_eq!(
        ::core::mem::align_of::<mempool_s>(),
        8usize,
        concat!("Alignment of ", stringify!(mempool_s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mempool_s>())).lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mempool_s),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mempool_s>())).min_nr as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(mempool_s),
            "::",
            stringify!(min_nr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mempool_s>())).curr_nr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mempool_s),
            "::",
            stringify!(curr_nr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mempool_s>())).elements as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(mempool_s),
            "::",
            stringify!(elements)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mempool_s>())).pool_data as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(mempool_s),
            "::",
            stringify!(pool_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mempool_s>())).alloc as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(mempool_s),
            "::",
            stringify!(alloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mempool_s>())).free as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(mempool_s),
            "::",
            stringify!(free)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mempool_s>())).wait as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(mempool_s),
            "::",
            stringify!(wait)
        )
    );
}
impl Default for mempool_s {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type mempool_t = mempool_s;
#[repr(C)]
#[derive(Debug)]
pub struct bio_integrity_payload {
    pub bip_bio: *mut bio,
    pub bip_iter: bvec_iter,
    pub bip_slab: c_types::c_ushort,
    pub bip_vcnt: c_types::c_ushort,
    pub bip_max_vcnt: c_types::c_ushort,
    pub bip_flags: c_types::c_ushort,
    pub bio_iter: bvec_iter,
    pub bip_work: work_struct,
    pub bip_vec: *mut bio_vec,
    pub bip_inline_vecs: __IncompleteArrayField<bio_vec>,
}
#[test]
fn bindgen_test_layout_bio_integrity_payload() {
    assert_eq!(
        ::core::mem::size_of::<bio_integrity_payload>(),
        104usize,
        concat!("Size of: ", stringify!(bio_integrity_payload))
    );
    assert_eq!(
        ::core::mem::align_of::<bio_integrity_payload>(),
        8usize,
        concat!("Alignment of ", stringify!(bio_integrity_payload))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bio_integrity_payload>())).bip_bio as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bio_integrity_payload),
            "::",
            stringify!(bip_bio)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bio_integrity_payload>())).bip_iter as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bio_integrity_payload),
            "::",
            stringify!(bip_iter)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bio_integrity_payload>())).bip_slab as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(bio_integrity_payload),
            "::",
            stringify!(bip_slab)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bio_integrity_payload>())).bip_vcnt as *const _ as usize },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(bio_integrity_payload),
            "::",
            stringify!(bip_vcnt)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bio_integrity_payload>())).bip_max_vcnt as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(bio_integrity_payload),
            "::",
            stringify!(bip_max_vcnt)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bio_integrity_payload>())).bip_flags as *const _ as usize
        },
        38usize,
        concat!(
            "Offset of field: ",
            stringify!(bio_integrity_payload),
            "::",
            stringify!(bip_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bio_integrity_payload>())).bio_iter as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(bio_integrity_payload),
            "::",
            stringify!(bio_iter)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bio_integrity_payload>())).bip_work as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(bio_integrity_payload),
            "::",
            stringify!(bip_work)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bio_integrity_payload>())).bip_vec as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(bio_integrity_payload),
            "::",
            stringify!(bip_vec)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bio_integrity_payload>())).bip_inline_vecs as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(bio_integrity_payload),
            "::",
            stringify!(bip_inline_vecs)
        )
    );
}
impl Default for bio_integrity_payload {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bio_set {
    pub bio_slab: *mut kmem_cache,
    pub front_pad: c_types::c_uint,
    pub bio_pool: mempool_t,
    pub bvec_pool: mempool_t,
    pub bio_integrity_pool: mempool_t,
    pub bvec_integrity_pool: mempool_t,
    pub rescue_lock: spinlock_t,
    pub rescue_list: bio_list,
    pub rescue_work: work_struct,
    pub rescue_workqueue: *mut workqueue_struct,
}
#[test]
fn bindgen_test_layout_bio_set() {
    assert_eq!(
        ::core::mem::size_of::<bio_set>(),
        368usize,
        concat!("Size of: ", stringify!(bio_set))
    );
    assert_eq!(
        ::core::mem::align_of::<bio_set>(),
        8usize,
        concat!("Alignment of ", stringify!(bio_set))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bio_set>())).bio_slab as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bio_set),
            "::",
            stringify!(bio_slab)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bio_set>())).front_pad as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bio_set),
            "::",
            stringify!(front_pad)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bio_set>())).bio_pool as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(bio_set),
            "::",
            stringify!(bio_pool)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bio_set>())).bvec_pool as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(bio_set),
            "::",
            stringify!(bvec_pool)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bio_set>())).bio_integrity_pool as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(bio_set),
            "::",
            stringify!(bio_integrity_pool)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bio_set>())).bvec_integrity_pool as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(bio_set),
            "::",
            stringify!(bvec_integrity_pool)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bio_set>())).rescue_lock as *const _ as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(bio_set),
            "::",
            stringify!(rescue_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bio_set>())).rescue_list as *const _ as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(bio_set),
            "::",
            stringify!(rescue_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bio_set>())).rescue_work as *const _ as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(bio_set),
            "::",
            stringify!(rescue_work)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bio_set>())).rescue_workqueue as *const _ as usize },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(bio_set),
            "::",
            stringify!(rescue_workqueue)
        )
    );
}
impl Default for bio_set {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bio_list {
    pub head: *mut bio,
    pub tail: *mut bio,
}
#[test]
fn bindgen_test_layout_bio_list() {
    assert_eq!(
        ::core::mem::size_of::<bio_list>(),
        16usize,
        concat!("Size of: ", stringify!(bio_list))
    );
    assert_eq!(
        ::core::mem::align_of::<bio_list>(),
        8usize,
        concat!("Alignment of ", stringify!(bio_list))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bio_list>())).head as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bio_list),
            "::",
            stringify!(head)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bio_list>())).tail as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bio_list),
            "::",
            stringify!(tail)
        )
    );
}
impl Default for bio_list {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct sg_io_v4 {
    pub guard: __s32,
    pub protocol: __u32,
    pub subprotocol: __u32,
    pub request_len: __u32,
    pub request: __u64,
    pub request_tag: __u64,
    pub request_attr: __u32,
    pub request_priority: __u32,
    pub request_extra: __u32,
    pub max_response_len: __u32,
    pub response: __u64,
    pub dout_iovec_count: __u32,
    pub dout_xfer_len: __u32,
    pub din_iovec_count: __u32,
    pub din_xfer_len: __u32,
    pub dout_xferp: __u64,
    pub din_xferp: __u64,
    pub timeout: __u32,
    pub flags: __u32,
    pub usr_ptr: __u64,
    pub spare_in: __u32,
    pub driver_status: __u32,
    pub transport_status: __u32,
    pub device_status: __u32,
    pub retry_delay: __u32,
    pub info: __u32,
    pub duration: __u32,
    pub response_len: __u32,
    pub din_resid: __s32,
    pub dout_resid: __s32,
    pub generated_tag: __u64,
    pub spare_out: __u32,
    pub padding: __u32,
}
#[test]
fn bindgen_test_layout_sg_io_v4() {
    assert_eq!(
        ::core::mem::size_of::<sg_io_v4>(),
        160usize,
        concat!("Size of: ", stringify!(sg_io_v4))
    );
    assert_eq!(
        ::core::mem::align_of::<sg_io_v4>(),
        8usize,
        concat!("Alignment of ", stringify!(sg_io_v4))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sg_io_v4>())).guard as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_io_v4),
            "::",
            stringify!(guard)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sg_io_v4>())).protocol as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_io_v4),
            "::",
            stringify!(protocol)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sg_io_v4>())).subprotocol as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_io_v4),
            "::",
            stringify!(subprotocol)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sg_io_v4>())).request_len as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_io_v4),
            "::",
            stringify!(request_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sg_io_v4>())).request as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_io_v4),
            "::",
            stringify!(request)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sg_io_v4>())).request_tag as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_io_v4),
            "::",
            stringify!(request_tag)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sg_io_v4>())).request_attr as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_io_v4),
            "::",
            stringify!(request_attr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sg_io_v4>())).request_priority as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_io_v4),
            "::",
            stringify!(request_priority)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sg_io_v4>())).request_extra as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_io_v4),
            "::",
            stringify!(request_extra)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sg_io_v4>())).max_response_len as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_io_v4),
            "::",
            stringify!(max_response_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sg_io_v4>())).response as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_io_v4),
            "::",
            stringify!(response)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sg_io_v4>())).dout_iovec_count as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_io_v4),
            "::",
            stringify!(dout_iovec_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sg_io_v4>())).dout_xfer_len as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_io_v4),
            "::",
            stringify!(dout_xfer_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sg_io_v4>())).din_iovec_count as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_io_v4),
            "::",
            stringify!(din_iovec_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sg_io_v4>())).din_xfer_len as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_io_v4),
            "::",
            stringify!(din_xfer_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sg_io_v4>())).dout_xferp as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_io_v4),
            "::",
            stringify!(dout_xferp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sg_io_v4>())).din_xferp as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_io_v4),
            "::",
            stringify!(din_xferp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sg_io_v4>())).timeout as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_io_v4),
            "::",
            stringify!(timeout)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sg_io_v4>())).flags as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_io_v4),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sg_io_v4>())).usr_ptr as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_io_v4),
            "::",
            stringify!(usr_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sg_io_v4>())).spare_in as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_io_v4),
            "::",
            stringify!(spare_in)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sg_io_v4>())).driver_status as *const _ as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_io_v4),
            "::",
            stringify!(driver_status)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sg_io_v4>())).transport_status as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_io_v4),
            "::",
            stringify!(transport_status)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sg_io_v4>())).device_status as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_io_v4),
            "::",
            stringify!(device_status)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sg_io_v4>())).retry_delay as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_io_v4),
            "::",
            stringify!(retry_delay)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sg_io_v4>())).info as *const _ as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_io_v4),
            "::",
            stringify!(info)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sg_io_v4>())).duration as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_io_v4),
            "::",
            stringify!(duration)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sg_io_v4>())).response_len as *const _ as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_io_v4),
            "::",
            stringify!(response_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sg_io_v4>())).din_resid as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_io_v4),
            "::",
            stringify!(din_resid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sg_io_v4>())).dout_resid as *const _ as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_io_v4),
            "::",
            stringify!(dout_resid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sg_io_v4>())).generated_tag as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_io_v4),
            "::",
            stringify!(generated_tag)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sg_io_v4>())).spare_out as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_io_v4),
            "::",
            stringify!(spare_out)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sg_io_v4>())).padding as *const _ as usize },
        156usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_io_v4),
            "::",
            stringify!(padding)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct bsg_ops {
    pub check_proto:
        ::core::option::Option<unsafe extern "C" fn(hdr: *mut sg_io_v4) -> c_types::c_int>,
    pub fill_hdr: ::core::option::Option<
        unsafe extern "C" fn(rq: *mut request, hdr: *mut sg_io_v4, mode: fmode_t) -> c_types::c_int,
    >,
    pub complete_rq: ::core::option::Option<
        unsafe extern "C" fn(rq: *mut request, hdr: *mut sg_io_v4) -> c_types::c_int,
    >,
    pub free_rq: ::core::option::Option<unsafe extern "C" fn(rq: *mut request)>,
}
#[test]
fn bindgen_test_layout_bsg_ops() {
    assert_eq!(
        ::core::mem::size_of::<bsg_ops>(),
        32usize,
        concat!("Size of: ", stringify!(bsg_ops))
    );
    assert_eq!(
        ::core::mem::align_of::<bsg_ops>(),
        8usize,
        concat!("Alignment of ", stringify!(bsg_ops))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bsg_ops>())).check_proto as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bsg_ops),
            "::",
            stringify!(check_proto)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bsg_ops>())).fill_hdr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bsg_ops),
            "::",
            stringify!(fill_hdr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bsg_ops>())).complete_rq as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(bsg_ops),
            "::",
            stringify!(complete_rq)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bsg_ops>())).free_rq as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(bsg_ops),
            "::",
            stringify!(free_rq)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bsg_class_device {
    pub class_dev: *mut device,
    pub minor: c_types::c_int,
    pub queue: *mut request_queue,
    pub ops: *const bsg_ops,
}
#[test]
fn bindgen_test_layout_bsg_class_device() {
    assert_eq!(
        ::core::mem::size_of::<bsg_class_device>(),
        32usize,
        concat!("Size of: ", stringify!(bsg_class_device))
    );
    assert_eq!(
        ::core::mem::align_of::<bsg_class_device>(),
        8usize,
        concat!("Alignment of ", stringify!(bsg_class_device))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bsg_class_device>())).class_dev as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bsg_class_device),
            "::",
            stringify!(class_dev)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bsg_class_device>())).minor as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bsg_class_device),
            "::",
            stringify!(minor)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bsg_class_device>())).queue as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(bsg_class_device),
            "::",
            stringify!(queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bsg_class_device>())).ops as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(bsg_class_device),
            "::",
            stringify!(ops)
        )
    );
}
impl Default for bsg_class_device {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[doc = " struct blk_zone - Zone descriptor for BLKREPORTZONE ioctl."]
#[doc = ""]
#[doc = " @start: Zone start in 512 B sector units"]
#[doc = " @len: Zone length in 512 B sector units"]
#[doc = " @wp: Zone write pointer location in 512 B sector units"]
#[doc = " @type: see enum blk_zone_type for possible values"]
#[doc = " @cond: see enum blk_zone_cond for possible values"]
#[doc = " @non_seq: Flag indicating that the zone is using non-sequential resources"]
#[doc = "           (for host-aware zoned block devices only)."]
#[doc = " @reset: Flag indicating that a zone reset is recommended."]
#[doc = " @reserved: Padding to 64 B to match the ZBC/ZAC defined zone descriptor size."]
#[doc = ""]
#[doc = " start, len and wp use the regular 512 B sector unit, regardless of the"]
#[doc = " device logical block size. The overall structure size is 64 B to match the"]
#[doc = " ZBC/ZAC defined zone descriptor and allow support for future additional"]
#[doc = " zone information."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct blk_zone {
    pub start: __u64,
    pub len: __u64,
    pub wp: __u64,
    pub type_: __u8,
    pub cond: __u8,
    pub non_seq: __u8,
    pub reset: __u8,
    pub reserved: [__u8; 36usize],
}
#[test]
fn bindgen_test_layout_blk_zone() {
    assert_eq!(
        ::core::mem::size_of::<blk_zone>(),
        64usize,
        concat!("Size of: ", stringify!(blk_zone))
    );
    assert_eq!(
        ::core::mem::align_of::<blk_zone>(),
        8usize,
        concat!("Alignment of ", stringify!(blk_zone))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blk_zone>())).start as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(blk_zone),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blk_zone>())).len as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(blk_zone),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blk_zone>())).wp as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(blk_zone),
            "::",
            stringify!(wp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blk_zone>())).type_ as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(blk_zone),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blk_zone>())).cond as *const _ as usize },
        25usize,
        concat!(
            "Offset of field: ",
            stringify!(blk_zone),
            "::",
            stringify!(cond)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blk_zone>())).non_seq as *const _ as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(blk_zone),
            "::",
            stringify!(non_seq)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blk_zone>())).reset as *const _ as usize },
        27usize,
        concat!(
            "Offset of field: ",
            stringify!(blk_zone),
            "::",
            stringify!(reset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blk_zone>())).reserved as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(blk_zone),
            "::",
            stringify!(reserved)
        )
    );
}
impl Default for blk_zone {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct blk_trace {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct blk_flush_queue {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pr_ops {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rq_qos {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct blk_queue_stats {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct blk_stat_callback {
    _unused: [u8; 0],
}
pub type rq_end_io_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut request, arg2: blk_status_t)>;
pub type req_flags_t = __u32;
pub const mq_rq_state_MQ_RQ_IDLE: mq_rq_state = 0;
pub const mq_rq_state_MQ_RQ_IN_FLIGHT: mq_rq_state = 1;
pub const mq_rq_state_MQ_RQ_COMPLETE: mq_rq_state = 2;
pub type mq_rq_state = c_types::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct request {
    pub q: *mut request_queue,
    pub mq_ctx: *mut blk_mq_ctx,
    pub mq_hctx: *mut blk_mq_hw_ctx,
    pub cmd_flags: c_types::c_uint,
    pub rq_flags: req_flags_t,
    pub tag: c_types::c_int,
    pub internal_tag: c_types::c_int,
    pub __data_len: c_types::c_uint,
    pub __sector: sector_t,
    pub bio: *mut bio,
    pub biotail: *mut bio,
    pub queuelist: list_head,
    pub __bindgen_anon_1: request__bindgen_ty_1,
    pub __bindgen_anon_2: request__bindgen_ty_2,
    pub __bindgen_anon_3: request__bindgen_ty_3,
    pub rq_disk: *mut gendisk,
    pub part: *mut hd_struct,
    pub alloc_time_ns: u64_,
    pub start_time_ns: u64_,
    pub io_start_time_ns: u64_,
    pub wbt_flags: c_types::c_ushort,
    pub stats_sectors: c_types::c_ushort,
    pub nr_phys_segments: c_types::c_ushort,
    pub nr_integrity_segments: c_types::c_ushort,
    pub write_hint: c_types::c_ushort,
    pub ioprio: c_types::c_ushort,
    pub extra_len: c_types::c_uint,
    pub state: mq_rq_state,
    pub ref_: refcount_t,
    pub timeout: c_types::c_uint,
    pub deadline: c_types::c_ulong,
    pub __bindgen_anon_4: request__bindgen_ty_4,
    pub end_io: rq_end_io_fn,
    pub end_io_data: *mut c_types::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union request__bindgen_ty_1 {
    pub hash: hlist_node,
    pub ipi_list: list_head,
    _bindgen_union_align: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_request__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<request__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(request__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<request__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(request__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request__bindgen_ty_1>())).hash as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(request__bindgen_ty_1),
            "::",
            stringify!(hash)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request__bindgen_ty_1>())).ipi_list as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(request__bindgen_ty_1),
            "::",
            stringify!(ipi_list)
        )
    );
}
impl Default for request__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union request__bindgen_ty_2 {
    pub rb_node: rb_node,
    pub special_vec: bio_vec,
    pub completion_data: *mut c_types::c_void,
    pub error_count: c_types::c_int,
    _bindgen_union_align: [u64; 3usize],
}
#[test]
fn bindgen_test_layout_request__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<request__bindgen_ty_2>(),
        24usize,
        concat!("Size of: ", stringify!(request__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<request__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(request__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request__bindgen_ty_2>())).rb_node as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(request__bindgen_ty_2),
            "::",
            stringify!(rb_node)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<request__bindgen_ty_2>())).special_vec as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(request__bindgen_ty_2),
            "::",
            stringify!(special_vec)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<request__bindgen_ty_2>())).completion_data as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(request__bindgen_ty_2),
            "::",
            stringify!(completion_data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<request__bindgen_ty_2>())).error_count as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(request__bindgen_ty_2),
            "::",
            stringify!(error_count)
        )
    );
}
impl Default for request__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union request__bindgen_ty_3 {
    pub elv: request__bindgen_ty_3__bindgen_ty_1,
    pub flush: request__bindgen_ty_3__bindgen_ty_2,
    _bindgen_union_align: [u64; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct request__bindgen_ty_3__bindgen_ty_1 {
    pub icq: *mut io_cq,
    pub priv_: [*mut c_types::c_void; 2usize],
}
#[test]
fn bindgen_test_layout_request__bindgen_ty_3__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<request__bindgen_ty_3__bindgen_ty_1>(),
        24usize,
        concat!("Size of: ", stringify!(request__bindgen_ty_3__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<request__bindgen_ty_3__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(request__bindgen_ty_3__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<request__bindgen_ty_3__bindgen_ty_1>())).icq as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(request__bindgen_ty_3__bindgen_ty_1),
            "::",
            stringify!(icq)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<request__bindgen_ty_3__bindgen_ty_1>())).priv_ as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(request__bindgen_ty_3__bindgen_ty_1),
            "::",
            stringify!(priv_)
        )
    );
}
impl Default for request__bindgen_ty_3__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct request__bindgen_ty_3__bindgen_ty_2 {
    pub seq: c_types::c_uint,
    pub list: list_head,
    pub saved_end_io: rq_end_io_fn,
}
#[test]
fn bindgen_test_layout_request__bindgen_ty_3__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<request__bindgen_ty_3__bindgen_ty_2>(),
        32usize,
        concat!("Size of: ", stringify!(request__bindgen_ty_3__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<request__bindgen_ty_3__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(request__bindgen_ty_3__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<request__bindgen_ty_3__bindgen_ty_2>())).seq as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(request__bindgen_ty_3__bindgen_ty_2),
            "::",
            stringify!(seq)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<request__bindgen_ty_3__bindgen_ty_2>())).list as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(request__bindgen_ty_3__bindgen_ty_2),
            "::",
            stringify!(list)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<request__bindgen_ty_3__bindgen_ty_2>())).saved_end_io
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(request__bindgen_ty_3__bindgen_ty_2),
            "::",
            stringify!(saved_end_io)
        )
    );
}
impl Default for request__bindgen_ty_3__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_request__bindgen_ty_3() {
    assert_eq!(
        ::core::mem::size_of::<request__bindgen_ty_3>(),
        32usize,
        concat!("Size of: ", stringify!(request__bindgen_ty_3))
    );
    assert_eq!(
        ::core::mem::align_of::<request__bindgen_ty_3>(),
        8usize,
        concat!("Alignment of ", stringify!(request__bindgen_ty_3))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request__bindgen_ty_3>())).elv as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(request__bindgen_ty_3),
            "::",
            stringify!(elv)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request__bindgen_ty_3>())).flush as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(request__bindgen_ty_3),
            "::",
            stringify!(flush)
        )
    );
}
impl Default for request__bindgen_ty_3 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union request__bindgen_ty_4 {
    pub csd: __call_single_data,
    pub fifo_time: u64_,
    _bindgen_union_align: [u64; 4usize],
}
#[test]
fn bindgen_test_layout_request__bindgen_ty_4() {
    assert_eq!(
        ::core::mem::size_of::<request__bindgen_ty_4>(),
        32usize,
        concat!("Size of: ", stringify!(request__bindgen_ty_4))
    );
    assert_eq!(
        ::core::mem::align_of::<request__bindgen_ty_4>(),
        8usize,
        concat!("Alignment of ", stringify!(request__bindgen_ty_4))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request__bindgen_ty_4>())).csd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(request__bindgen_ty_4),
            "::",
            stringify!(csd)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<request__bindgen_ty_4>())).fifo_time as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(request__bindgen_ty_4),
            "::",
            stringify!(fifo_time)
        )
    );
}
impl Default for request__bindgen_ty_4 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_request() {
    assert_eq!(
        ::core::mem::size_of::<request>(),
        288usize,
        concat!("Size of: ", stringify!(request))
    );
    assert_eq!(
        ::core::mem::align_of::<request>(),
        8usize,
        concat!("Alignment of ", stringify!(request))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request>())).q as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(request),
            "::",
            stringify!(q)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request>())).mq_ctx as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(request),
            "::",
            stringify!(mq_ctx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request>())).mq_hctx as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(request),
            "::",
            stringify!(mq_hctx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request>())).cmd_flags as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(request),
            "::",
            stringify!(cmd_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request>())).rq_flags as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(request),
            "::",
            stringify!(rq_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request>())).tag as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(request),
            "::",
            stringify!(tag)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request>())).internal_tag as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(request),
            "::",
            stringify!(internal_tag)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request>())).__data_len as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(request),
            "::",
            stringify!(__data_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request>())).__sector as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(request),
            "::",
            stringify!(__sector)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request>())).bio as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(request),
            "::",
            stringify!(bio)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request>())).biotail as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(request),
            "::",
            stringify!(biotail)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request>())).queuelist as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(request),
            "::",
            stringify!(queuelist)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request>())).rq_disk as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(request),
            "::",
            stringify!(rq_disk)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request>())).part as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(request),
            "::",
            stringify!(part)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request>())).alloc_time_ns as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(request),
            "::",
            stringify!(alloc_time_ns)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request>())).start_time_ns as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(request),
            "::",
            stringify!(start_time_ns)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request>())).io_start_time_ns as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(request),
            "::",
            stringify!(io_start_time_ns)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request>())).wbt_flags as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(request),
            "::",
            stringify!(wbt_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request>())).stats_sectors as *const _ as usize },
        202usize,
        concat!(
            "Offset of field: ",
            stringify!(request),
            "::",
            stringify!(stats_sectors)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request>())).nr_phys_segments as *const _ as usize },
        204usize,
        concat!(
            "Offset of field: ",
            stringify!(request),
            "::",
            stringify!(nr_phys_segments)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request>())).nr_integrity_segments as *const _ as usize },
        206usize,
        concat!(
            "Offset of field: ",
            stringify!(request),
            "::",
            stringify!(nr_integrity_segments)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request>())).write_hint as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(request),
            "::",
            stringify!(write_hint)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request>())).ioprio as *const _ as usize },
        210usize,
        concat!(
            "Offset of field: ",
            stringify!(request),
            "::",
            stringify!(ioprio)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request>())).extra_len as *const _ as usize },
        212usize,
        concat!(
            "Offset of field: ",
            stringify!(request),
            "::",
            stringify!(extra_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request>())).state as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(request),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request>())).ref_ as *const _ as usize },
        220usize,
        concat!(
            "Offset of field: ",
            stringify!(request),
            "::",
            stringify!(ref_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request>())).timeout as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(request),
            "::",
            stringify!(timeout)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request>())).deadline as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(request),
            "::",
            stringify!(deadline)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request>())).end_io as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(request),
            "::",
            stringify!(end_io)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request>())).end_io_data as *const _ as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(request),
            "::",
            stringify!(end_io_data)
        )
    );
}
impl Default for request {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct blk_mq_debugfs_attr {
    _unused: [u8; 0],
}
pub const elv_merge_ELEVATOR_NO_MERGE: elv_merge = 0;
pub const elv_merge_ELEVATOR_FRONT_MERGE: elv_merge = 1;
pub const elv_merge_ELEVATOR_BACK_MERGE: elv_merge = 2;
pub const elv_merge_ELEVATOR_DISCARD_MERGE: elv_merge = 3;
pub type elv_merge = c_types::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct blk_mq_alloc_data {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct blk_mq_hw_ctx {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct elevator_mq_ops {
    pub init_sched: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut request_queue, arg2: *mut elevator_type) -> c_types::c_int,
    >,
    pub exit_sched: ::core::option::Option<unsafe extern "C" fn(arg1: *mut elevator_queue)>,
    pub init_hctx: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut blk_mq_hw_ctx, arg2: c_types::c_uint) -> c_types::c_int,
    >,
    pub exit_hctx: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut blk_mq_hw_ctx, arg2: c_types::c_uint),
    >,
    pub depth_updated: ::core::option::Option<unsafe extern "C" fn(arg1: *mut blk_mq_hw_ctx)>,
    pub allow_merge: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut request_queue, arg2: *mut request, arg3: *mut bio) -> bool_,
    >,
    pub bio_merge: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut blk_mq_hw_ctx,
            arg2: *mut bio,
            arg3: c_types::c_uint,
        ) -> bool_,
    >,
    pub request_merge: ::core::option::Option<
        unsafe extern "C" fn(
            q: *mut request_queue,
            arg1: *mut *mut request,
            arg2: *mut bio,
        ) -> c_types::c_int,
    >,
    pub request_merged: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut request_queue, arg2: *mut request, arg3: elv_merge),
    >,
    pub requests_merged: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut request_queue, arg2: *mut request, arg3: *mut request),
    >,
    pub limit_depth: ::core::option::Option<
        unsafe extern "C" fn(arg1: c_types::c_uint, arg2: *mut blk_mq_alloc_data),
    >,
    pub prepare_request:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut request, bio: *mut bio)>,
    pub finish_request: ::core::option::Option<unsafe extern "C" fn(arg1: *mut request)>,
    pub insert_requests: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut blk_mq_hw_ctx, arg2: *mut list_head, arg3: bool_),
    >,
    pub dispatch_request:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut blk_mq_hw_ctx) -> *mut request>,
    pub has_work: ::core::option::Option<unsafe extern "C" fn(arg1: *mut blk_mq_hw_ctx) -> bool_>,
    pub completed_request:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut request, arg2: u64_)>,
    pub requeue_request: ::core::option::Option<unsafe extern "C" fn(arg1: *mut request)>,
    pub former_request: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut request_queue, arg2: *mut request) -> *mut request,
    >,
    pub next_request: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut request_queue, arg2: *mut request) -> *mut request,
    >,
    pub init_icq: ::core::option::Option<unsafe extern "C" fn(arg1: *mut io_cq)>,
    pub exit_icq: ::core::option::Option<unsafe extern "C" fn(arg1: *mut io_cq)>,
}
#[test]
fn bindgen_test_layout_elevator_mq_ops() {
    assert_eq!(
        ::core::mem::size_of::<elevator_mq_ops>(),
        176usize,
        concat!("Size of: ", stringify!(elevator_mq_ops))
    );
    assert_eq!(
        ::core::mem::align_of::<elevator_mq_ops>(),
        8usize,
        concat!("Alignment of ", stringify!(elevator_mq_ops))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elevator_mq_ops>())).init_sched as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(elevator_mq_ops),
            "::",
            stringify!(init_sched)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elevator_mq_ops>())).exit_sched as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(elevator_mq_ops),
            "::",
            stringify!(exit_sched)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elevator_mq_ops>())).init_hctx as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(elevator_mq_ops),
            "::",
            stringify!(init_hctx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elevator_mq_ops>())).exit_hctx as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(elevator_mq_ops),
            "::",
            stringify!(exit_hctx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elevator_mq_ops>())).depth_updated as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(elevator_mq_ops),
            "::",
            stringify!(depth_updated)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elevator_mq_ops>())).allow_merge as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(elevator_mq_ops),
            "::",
            stringify!(allow_merge)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elevator_mq_ops>())).bio_merge as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(elevator_mq_ops),
            "::",
            stringify!(bio_merge)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elevator_mq_ops>())).request_merge as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(elevator_mq_ops),
            "::",
            stringify!(request_merge)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elevator_mq_ops>())).request_merged as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(elevator_mq_ops),
            "::",
            stringify!(request_merged)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<elevator_mq_ops>())).requests_merged as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(elevator_mq_ops),
            "::",
            stringify!(requests_merged)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elevator_mq_ops>())).limit_depth as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(elevator_mq_ops),
            "::",
            stringify!(limit_depth)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<elevator_mq_ops>())).prepare_request as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(elevator_mq_ops),
            "::",
            stringify!(prepare_request)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elevator_mq_ops>())).finish_request as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(elevator_mq_ops),
            "::",
            stringify!(finish_request)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<elevator_mq_ops>())).insert_requests as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(elevator_mq_ops),
            "::",
            stringify!(insert_requests)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<elevator_mq_ops>())).dispatch_request as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(elevator_mq_ops),
            "::",
            stringify!(dispatch_request)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elevator_mq_ops>())).has_work as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(elevator_mq_ops),
            "::",
            stringify!(has_work)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<elevator_mq_ops>())).completed_request as *const _ as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(elevator_mq_ops),
            "::",
            stringify!(completed_request)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<elevator_mq_ops>())).requeue_request as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(elevator_mq_ops),
            "::",
            stringify!(requeue_request)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elevator_mq_ops>())).former_request as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(elevator_mq_ops),
            "::",
            stringify!(former_request)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elevator_mq_ops>())).next_request as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(elevator_mq_ops),
            "::",
            stringify!(next_request)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elevator_mq_ops>())).init_icq as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(elevator_mq_ops),
            "::",
            stringify!(init_icq)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elevator_mq_ops>())).exit_icq as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(elevator_mq_ops),
            "::",
            stringify!(exit_icq)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct elv_fs_entry {
    pub attr: attribute,
    pub show: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut elevator_queue, arg2: *mut c_types::c_char) -> isize,
    >,
    pub store: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut elevator_queue,
            arg2: *const c_types::c_char,
            arg3: usize,
        ) -> isize,
    >,
}
#[test]
fn bindgen_test_layout_elv_fs_entry() {
    assert_eq!(
        ::core::mem::size_of::<elv_fs_entry>(),
        32usize,
        concat!("Size of: ", stringify!(elv_fs_entry))
    );
    assert_eq!(
        ::core::mem::align_of::<elv_fs_entry>(),
        8usize,
        concat!("Alignment of ", stringify!(elv_fs_entry))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elv_fs_entry>())).attr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(elv_fs_entry),
            "::",
            stringify!(attr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elv_fs_entry>())).show as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(elv_fs_entry),
            "::",
            stringify!(show)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elv_fs_entry>())).store as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(elv_fs_entry),
            "::",
            stringify!(store)
        )
    );
}
impl Default for elv_fs_entry {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct elevator_type {
    pub icq_cache: *mut kmem_cache,
    pub ops: elevator_mq_ops,
    pub icq_size: usize,
    pub icq_align: usize,
    pub elevator_attrs: *mut elv_fs_entry,
    pub elevator_name: *const c_types::c_char,
    pub elevator_alias: *const c_types::c_char,
    pub elevator_features: c_types::c_uint,
    pub elevator_owner: *mut module,
    pub queue_debugfs_attrs: *const blk_mq_debugfs_attr,
    pub hctx_debugfs_attrs: *const blk_mq_debugfs_attr,
    pub icq_cache_name: [c_types::c_char; 22usize],
    pub list: list_head,
}
#[test]
fn bindgen_test_layout_elevator_type() {
    assert_eq!(
        ::core::mem::size_of::<elevator_type>(),
        296usize,
        concat!("Size of: ", stringify!(elevator_type))
    );
    assert_eq!(
        ::core::mem::align_of::<elevator_type>(),
        8usize,
        concat!("Alignment of ", stringify!(elevator_type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elevator_type>())).icq_cache as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(elevator_type),
            "::",
            stringify!(icq_cache)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elevator_type>())).ops as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(elevator_type),
            "::",
            stringify!(ops)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elevator_type>())).icq_size as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(elevator_type),
            "::",
            stringify!(icq_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elevator_type>())).icq_align as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(elevator_type),
            "::",
            stringify!(icq_align)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elevator_type>())).elevator_attrs as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(elevator_type),
            "::",
            stringify!(elevator_attrs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elevator_type>())).elevator_name as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(elevator_type),
            "::",
            stringify!(elevator_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elevator_type>())).elevator_alias as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(elevator_type),
            "::",
            stringify!(elevator_alias)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<elevator_type>())).elevator_features as *const _ as usize
        },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(elevator_type),
            "::",
            stringify!(elevator_features)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elevator_type>())).elevator_owner as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(elevator_type),
            "::",
            stringify!(elevator_owner)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<elevator_type>())).queue_debugfs_attrs as *const _ as usize
        },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(elevator_type),
            "::",
            stringify!(queue_debugfs_attrs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<elevator_type>())).hctx_debugfs_attrs as *const _ as usize
        },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(elevator_type),
            "::",
            stringify!(hctx_debugfs_attrs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elevator_type>())).icq_cache_name as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(elevator_type),
            "::",
            stringify!(icq_cache_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elevator_type>())).list as *const _ as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(elevator_type),
            "::",
            stringify!(list)
        )
    );
}
impl Default for elevator_type {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct elevator_queue {
    pub type_: *mut elevator_type,
    pub elevator_data: *mut c_types::c_void,
    pub kobj: kobject,
    pub sysfs_lock: mutex,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub hash: [hlist_head; 64usize],
}
#[test]
fn bindgen_test_layout_elevator_queue() {
    assert_eq!(
        ::core::mem::size_of::<elevator_queue>(),
        632usize,
        concat!("Size of: ", stringify!(elevator_queue))
    );
    assert_eq!(
        ::core::mem::align_of::<elevator_queue>(),
        8usize,
        concat!("Alignment of ", stringify!(elevator_queue))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elevator_queue>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(elevator_queue),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elevator_queue>())).elevator_data as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(elevator_queue),
            "::",
            stringify!(elevator_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elevator_queue>())).kobj as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(elevator_queue),
            "::",
            stringify!(kobj)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elevator_queue>())).sysfs_lock as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(elevator_queue),
            "::",
            stringify!(sysfs_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elevator_queue>())).hash as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(elevator_queue),
            "::",
            stringify!(hash)
        )
    );
}
impl Default for elevator_queue {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl elevator_queue {
    #[inline]
    pub fn registered(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_registered(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(registered: c_types::c_uint) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let registered: u32 = unsafe { ::core::mem::transmute(registered) };
            registered as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type make_request_fn =
    ::core::option::Option<unsafe extern "C" fn(q: *mut request_queue, bio: *mut bio) -> blk_qc_t>;
pub type dma_drain_needed_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut request) -> c_types::c_int>;
pub const blk_zoned_model_BLK_ZONED_NONE: blk_zoned_model = 0;
pub const blk_zoned_model_BLK_ZONED_HA: blk_zoned_model = 1;
pub const blk_zoned_model_BLK_ZONED_HM: blk_zoned_model = 2;
pub type blk_zoned_model = c_types::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct queue_limits {
    pub bounce_pfn: c_types::c_ulong,
    pub seg_boundary_mask: c_types::c_ulong,
    pub virt_boundary_mask: c_types::c_ulong,
    pub max_hw_sectors: c_types::c_uint,
    pub max_dev_sectors: c_types::c_uint,
    pub chunk_sectors: c_types::c_uint,
    pub max_sectors: c_types::c_uint,
    pub max_segment_size: c_types::c_uint,
    pub physical_block_size: c_types::c_uint,
    pub logical_block_size: c_types::c_uint,
    pub alignment_offset: c_types::c_uint,
    pub io_min: c_types::c_uint,
    pub io_opt: c_types::c_uint,
    pub max_discard_sectors: c_types::c_uint,
    pub max_hw_discard_sectors: c_types::c_uint,
    pub max_write_same_sectors: c_types::c_uint,
    pub max_write_zeroes_sectors: c_types::c_uint,
    pub discard_granularity: c_types::c_uint,
    pub discard_alignment: c_types::c_uint,
    pub max_segments: c_types::c_ushort,
    pub max_integrity_segments: c_types::c_ushort,
    pub max_discard_segments: c_types::c_ushort,
    pub misaligned: c_types::c_uchar,
    pub discard_misaligned: c_types::c_uchar,
    pub raid_partial_stripes_expensive: c_types::c_uchar,
    pub zoned: blk_zoned_model,
}
#[test]
fn bindgen_test_layout_queue_limits() {
    assert_eq!(
        ::core::mem::size_of::<queue_limits>(),
        104usize,
        concat!("Size of: ", stringify!(queue_limits))
    );
    assert_eq!(
        ::core::mem::align_of::<queue_limits>(),
        8usize,
        concat!("Alignment of ", stringify!(queue_limits))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<queue_limits>())).bounce_pfn as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(queue_limits),
            "::",
            stringify!(bounce_pfn)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<queue_limits>())).seg_boundary_mask as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(queue_limits),
            "::",
            stringify!(seg_boundary_mask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<queue_limits>())).virt_boundary_mask as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(queue_limits),
            "::",
            stringify!(virt_boundary_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<queue_limits>())).max_hw_sectors as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(queue_limits),
            "::",
            stringify!(max_hw_sectors)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<queue_limits>())).max_dev_sectors as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(queue_limits),
            "::",
            stringify!(max_dev_sectors)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<queue_limits>())).chunk_sectors as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(queue_limits),
            "::",
            stringify!(chunk_sectors)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<queue_limits>())).max_sectors as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(queue_limits),
            "::",
            stringify!(max_sectors)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<queue_limits>())).max_segment_size as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(queue_limits),
            "::",
            stringify!(max_segment_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<queue_limits>())).physical_block_size as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(queue_limits),
            "::",
            stringify!(physical_block_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<queue_limits>())).logical_block_size as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(queue_limits),
            "::",
            stringify!(logical_block_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<queue_limits>())).alignment_offset as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(queue_limits),
            "::",
            stringify!(alignment_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<queue_limits>())).io_min as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(queue_limits),
            "::",
            stringify!(io_min)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<queue_limits>())).io_opt as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(queue_limits),
            "::",
            stringify!(io_opt)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<queue_limits>())).max_discard_sectors as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(queue_limits),
            "::",
            stringify!(max_discard_sectors)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<queue_limits>())).max_hw_discard_sectors as *const _ as usize
        },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(queue_limits),
            "::",
            stringify!(max_hw_discard_sectors)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<queue_limits>())).max_write_same_sectors as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(queue_limits),
            "::",
            stringify!(max_write_same_sectors)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<queue_limits>())).max_write_zeroes_sectors as *const _ as usize
        },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(queue_limits),
            "::",
            stringify!(max_write_zeroes_sectors)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<queue_limits>())).discard_granularity as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(queue_limits),
            "::",
            stringify!(discard_granularity)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<queue_limits>())).discard_alignment as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(queue_limits),
            "::",
            stringify!(discard_alignment)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<queue_limits>())).max_segments as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(queue_limits),
            "::",
            stringify!(max_segments)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<queue_limits>())).max_integrity_segments as *const _ as usize
        },
        90usize,
        concat!(
            "Offset of field: ",
            stringify!(queue_limits),
            "::",
            stringify!(max_integrity_segments)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<queue_limits>())).max_discard_segments as *const _ as usize
        },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(queue_limits),
            "::",
            stringify!(max_discard_segments)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<queue_limits>())).misaligned as *const _ as usize },
        94usize,
        concat!(
            "Offset of field: ",
            stringify!(queue_limits),
            "::",
            stringify!(misaligned)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<queue_limits>())).discard_misaligned as *const _ as usize
        },
        95usize,
        concat!(
            "Offset of field: ",
            stringify!(queue_limits),
            "::",
            stringify!(discard_misaligned)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<queue_limits>())).raid_partial_stripes_expensive as *const _
                as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(queue_limits),
            "::",
            stringify!(raid_partial_stripes_expensive)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<queue_limits>())).zoned as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(queue_limits),
            "::",
            stringify!(zoned)
        )
    );
}
impl Default for queue_limits {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct request_queue {
    pub last_merge: *mut request,
    pub elevator: *mut elevator_queue,
    pub stats: *mut blk_queue_stats,
    pub rq_qos: *mut rq_qos,
    pub make_request_fn: make_request_fn,
    pub dma_drain_needed: dma_drain_needed_fn,
    pub mq_ops: *mut blk_mq_ops,
    pub queue_ctx: *mut blk_mq_ctx,
    pub nr_queues: c_types::c_uint,
    pub queue_depth: c_types::c_uint,
    pub queue_hw_ctx: *mut *mut blk_mq_hw_ctx,
    pub nr_hw_queues: c_types::c_uint,
    pub backing_dev_info: *mut backing_dev_info,
    pub queuedata: *mut c_types::c_void,
    pub queue_flags: c_types::c_ulong,
    pub pm_only: atomic_t,
    pub id: c_types::c_int,
    pub bounce_gfp: gfp_t,
    pub queue_lock: spinlock_t,
    pub kobj: kobject,
    pub mq_kobj: *mut kobject,
    pub integrity: blk_integrity,
    pub dev: *mut device,
    pub rpm_status: c_types::c_int,
    pub nr_pending: c_types::c_uint,
    pub nr_requests: c_types::c_ulong,
    pub dma_drain_size: c_types::c_uint,
    pub dma_drain_buffer: *mut c_types::c_void,
    pub dma_pad_mask: c_types::c_uint,
    pub dma_alignment: c_types::c_uint,
    pub rq_timeout: c_types::c_uint,
    pub poll_nsec: c_types::c_int,
    pub poll_cb: *mut blk_stat_callback,
    pub poll_stat: [blk_rq_stat; 16usize],
    pub timeout: timer_list,
    pub timeout_work: work_struct,
    pub icq_list: list_head,
    pub blkcg_pols: [c_types::c_ulong; 1usize],
    pub root_blkg: *mut blkcg_gq,
    pub blkg_list: list_head,
    pub limits: queue_limits,
    pub required_elevator_features: c_types::c_uint,
    pub nr_zones: c_types::c_uint,
    pub seq_zones_bitmap: *mut c_types::c_ulong,
    pub seq_zones_wlock: *mut c_types::c_ulong,
    pub sg_timeout: c_types::c_uint,
    pub sg_reserved_size: c_types::c_uint,
    pub node: c_types::c_int,
    pub blk_trace: *mut blk_trace,
    pub blk_trace_mutex: mutex,
    pub fq: *mut blk_flush_queue,
    pub requeue_list: list_head,
    pub requeue_lock: spinlock_t,
    pub requeue_work: delayed_work,
    pub sysfs_lock: mutex,
    pub sysfs_dir_lock: mutex,
    pub unused_hctx_list: list_head,
    pub unused_hctx_lock: spinlock_t,
    pub mq_freeze_depth: c_types::c_int,
    pub bsg_dev: bsg_class_device,
    pub td: *mut throtl_data,
    pub callback_head: callback_head,
    pub mq_freeze_wq: wait_queue_head_t,
    pub mq_freeze_lock: mutex,
    pub q_usage_counter: percpu_ref,
    pub tag_set: *mut blk_mq_tag_set,
    pub tag_set_list: list_head,
    pub bio_split: bio_set,
    pub debugfs_dir: *mut dentry,
    pub sched_debugfs_dir: *mut dentry,
    pub rqos_debugfs_dir: *mut dentry,
    pub mq_sysfs_init_done: bool_,
    pub cmd_size: usize,
    pub release_work: work_struct,
    pub write_hints: [u64_; 5usize],
}
#[test]
fn bindgen_test_layout_request_queue() {
    assert_eq!(
        ::core::mem::size_of::<request_queue>(),
        2104usize,
        concat!("Size of: ", stringify!(request_queue))
    );
    assert_eq!(
        ::core::mem::align_of::<request_queue>(),
        8usize,
        concat!("Alignment of ", stringify!(request_queue))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).last_merge as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(last_merge)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).elevator as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(elevator)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).stats as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(stats)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).rq_qos as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(rq_qos)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).make_request_fn as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(make_request_fn)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).dma_drain_needed as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(dma_drain_needed)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).mq_ops as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(mq_ops)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).queue_ctx as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(queue_ctx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).nr_queues as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(nr_queues)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).queue_depth as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(queue_depth)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).queue_hw_ctx as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(queue_hw_ctx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).nr_hw_queues as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(nr_hw_queues)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).backing_dev_info as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(backing_dev_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).queuedata as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(queuedata)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).queue_flags as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(queue_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).pm_only as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(pm_only)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).id as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).bounce_gfp as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(bounce_gfp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).queue_lock as *const _ as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(queue_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).kobj as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(kobj)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).mq_kobj as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(mq_kobj)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).integrity as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(integrity)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).dev as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(dev)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).rpm_status as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(rpm_status)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).nr_pending as *const _ as usize },
        228usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(nr_pending)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).nr_requests as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(nr_requests)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).dma_drain_size as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(dma_drain_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).dma_drain_buffer as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(dma_drain_buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).dma_pad_mask as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(dma_pad_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).dma_alignment as *const _ as usize },
        260usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(dma_alignment)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).rq_timeout as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(rq_timeout)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).poll_nsec as *const _ as usize },
        268usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(poll_nsec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).poll_cb as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(poll_cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).poll_stat as *const _ as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(poll_stat)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).timeout as *const _ as usize },
        920usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(timeout)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).timeout_work as *const _ as usize },
        960usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(timeout_work)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).icq_list as *const _ as usize },
        992usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(icq_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).blkcg_pols as *const _ as usize },
        1008usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(blkcg_pols)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).root_blkg as *const _ as usize },
        1016usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(root_blkg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).blkg_list as *const _ as usize },
        1024usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(blkg_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).limits as *const _ as usize },
        1040usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(limits)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<request_queue>())).required_elevator_features as *const _
                as usize
        },
        1144usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(required_elevator_features)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).nr_zones as *const _ as usize },
        1148usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(nr_zones)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).seq_zones_bitmap as *const _ as usize },
        1152usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(seq_zones_bitmap)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).seq_zones_wlock as *const _ as usize },
        1160usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(seq_zones_wlock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).sg_timeout as *const _ as usize },
        1168usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(sg_timeout)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).sg_reserved_size as *const _ as usize },
        1172usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(sg_reserved_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).node as *const _ as usize },
        1176usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(node)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).blk_trace as *const _ as usize },
        1184usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(blk_trace)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).blk_trace_mutex as *const _ as usize },
        1192usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(blk_trace_mutex)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).fq as *const _ as usize },
        1224usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(fq)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).requeue_list as *const _ as usize },
        1232usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(requeue_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).requeue_lock as *const _ as usize },
        1248usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(requeue_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).requeue_work as *const _ as usize },
        1256usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(requeue_work)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).sysfs_lock as *const _ as usize },
        1344usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(sysfs_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).sysfs_dir_lock as *const _ as usize },
        1376usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(sysfs_dir_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).unused_hctx_list as *const _ as usize },
        1408usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(unused_hctx_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).unused_hctx_lock as *const _ as usize },
        1424usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(unused_hctx_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).mq_freeze_depth as *const _ as usize },
        1428usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(mq_freeze_depth)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).bsg_dev as *const _ as usize },
        1432usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(bsg_dev)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).td as *const _ as usize },
        1464usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(td)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).callback_head as *const _ as usize },
        1472usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(callback_head)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).mq_freeze_wq as *const _ as usize },
        1488usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(mq_freeze_wq)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).mq_freeze_lock as *const _ as usize },
        1512usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(mq_freeze_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).q_usage_counter as *const _ as usize },
        1544usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(q_usage_counter)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).tag_set as *const _ as usize },
        1600usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(tag_set)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).tag_set_list as *const _ as usize },
        1608usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(tag_set_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).bio_split as *const _ as usize },
        1624usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(bio_split)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).debugfs_dir as *const _ as usize },
        1992usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(debugfs_dir)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<request_queue>())).sched_debugfs_dir as *const _ as usize
        },
        2000usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(sched_debugfs_dir)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).rqos_debugfs_dir as *const _ as usize },
        2008usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(rqos_debugfs_dir)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<request_queue>())).mq_sysfs_init_done as *const _ as usize
        },
        2016usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(mq_sysfs_init_done)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).cmd_size as *const _ as usize },
        2024usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(cmd_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).release_work as *const _ as usize },
        2032usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(release_work)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_queue>())).write_hints as *const _ as usize },
        2064usize,
        concat!(
            "Offset of field: ",
            stringify!(request_queue),
            "::",
            stringify!(write_hints)
        )
    );
}
impl Default for request_queue {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct blk_plug {
    pub mq_list: list_head,
    pub cb_list: list_head,
    pub rq_count: c_types::c_ushort,
    pub multiple_queues: bool_,
}
#[test]
fn bindgen_test_layout_blk_plug() {
    assert_eq!(
        ::core::mem::size_of::<blk_plug>(),
        40usize,
        concat!("Size of: ", stringify!(blk_plug))
    );
    assert_eq!(
        ::core::mem::align_of::<blk_plug>(),
        8usize,
        concat!("Alignment of ", stringify!(blk_plug))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blk_plug>())).mq_list as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(blk_plug),
            "::",
            stringify!(mq_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blk_plug>())).cb_list as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(blk_plug),
            "::",
            stringify!(cb_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blk_plug>())).rq_count as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(blk_plug),
            "::",
            stringify!(rq_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blk_plug>())).multiple_queues as *const _ as usize },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(blk_plug),
            "::",
            stringify!(multiple_queues)
        )
    );
}
impl Default for blk_plug {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct blk_integrity_iter {
    pub prot_buf: *mut c_types::c_void,
    pub data_buf: *mut c_types::c_void,
    pub seed: sector_t,
    pub data_size: c_types::c_uint,
    pub interval: c_types::c_ushort,
    pub disk_name: *const c_types::c_char,
}
#[test]
fn bindgen_test_layout_blk_integrity_iter() {
    assert_eq!(
        ::core::mem::size_of::<blk_integrity_iter>(),
        40usize,
        concat!("Size of: ", stringify!(blk_integrity_iter))
    );
    assert_eq!(
        ::core::mem::align_of::<blk_integrity_iter>(),
        8usize,
        concat!("Alignment of ", stringify!(blk_integrity_iter))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blk_integrity_iter>())).prot_buf as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(blk_integrity_iter),
            "::",
            stringify!(prot_buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blk_integrity_iter>())).data_buf as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(blk_integrity_iter),
            "::",
            stringify!(data_buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blk_integrity_iter>())).seed as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(blk_integrity_iter),
            "::",
            stringify!(seed)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blk_integrity_iter>())).data_size as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(blk_integrity_iter),
            "::",
            stringify!(data_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blk_integrity_iter>())).interval as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(blk_integrity_iter),
            "::",
            stringify!(interval)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blk_integrity_iter>())).disk_name as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(blk_integrity_iter),
            "::",
            stringify!(disk_name)
        )
    );
}
impl Default for blk_integrity_iter {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type integrity_processing_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut blk_integrity_iter) -> blk_status_t>;
pub type integrity_prepare_fn = ::core::option::Option<unsafe extern "C" fn(arg1: *mut request)>;
pub type integrity_complete_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut request, arg2: c_types::c_uint)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct blk_integrity_profile {
    pub generate_fn: integrity_processing_fn,
    pub verify_fn: integrity_processing_fn,
    pub prepare_fn: integrity_prepare_fn,
    pub complete_fn: integrity_complete_fn,
    pub name: *const c_types::c_char,
}
#[test]
fn bindgen_test_layout_blk_integrity_profile() {
    assert_eq!(
        ::core::mem::size_of::<blk_integrity_profile>(),
        40usize,
        concat!("Size of: ", stringify!(blk_integrity_profile))
    );
    assert_eq!(
        ::core::mem::align_of::<blk_integrity_profile>(),
        8usize,
        concat!("Alignment of ", stringify!(blk_integrity_profile))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<blk_integrity_profile>())).generate_fn as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(blk_integrity_profile),
            "::",
            stringify!(generate_fn)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<blk_integrity_profile>())).verify_fn as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(blk_integrity_profile),
            "::",
            stringify!(verify_fn)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<blk_integrity_profile>())).prepare_fn as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(blk_integrity_profile),
            "::",
            stringify!(prepare_fn)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<blk_integrity_profile>())).complete_fn as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(blk_integrity_profile),
            "::",
            stringify!(complete_fn)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blk_integrity_profile>())).name as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(blk_integrity_profile),
            "::",
            stringify!(name)
        )
    );
}
impl Default for blk_integrity_profile {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct block_device_operations {
    pub open: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut block_device, arg2: fmode_t) -> c_types::c_int,
    >,
    pub release: ::core::option::Option<unsafe extern "C" fn(arg1: *mut gendisk, arg2: fmode_t)>,
    pub rw_page: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut block_device,
            arg2: sector_t,
            arg3: *mut page,
            arg4: c_types::c_uint,
        ) -> c_types::c_int,
    >,
    pub ioctl: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut block_device,
            arg2: fmode_t,
            arg3: c_types::c_uint,
            arg4: c_types::c_ulong,
        ) -> c_types::c_int,
    >,
    pub compat_ioctl: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut block_device,
            arg2: fmode_t,
            arg3: c_types::c_uint,
            arg4: c_types::c_ulong,
        ) -> c_types::c_int,
    >,
    pub check_events: ::core::option::Option<
        unsafe extern "C" fn(disk: *mut gendisk, clearing: c_types::c_uint) -> c_types::c_uint,
    >,
    pub media_changed:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut gendisk) -> c_types::c_int>,
    pub unlock_native_capacity: ::core::option::Option<unsafe extern "C" fn(arg1: *mut gendisk)>,
    pub revalidate_disk:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut gendisk) -> c_types::c_int>,
    pub getgeo: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut block_device, arg2: *mut hd_geometry) -> c_types::c_int,
    >,
    pub swap_slot_free_notify: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut block_device, arg2: c_types::c_ulong),
    >,
    pub report_zones: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut gendisk,
            sector: sector_t,
            zones: *mut blk_zone,
            nr_zones: *mut c_types::c_uint,
        ) -> c_types::c_int,
    >,
    pub owner: *mut module,
    pub pr_ops: *const pr_ops,
}
#[test]
fn bindgen_test_layout_block_device_operations() {
    assert_eq!(
        ::core::mem::size_of::<block_device_operations>(),
        112usize,
        concat!("Size of: ", stringify!(block_device_operations))
    );
    assert_eq!(
        ::core::mem::align_of::<block_device_operations>(),
        8usize,
        concat!("Alignment of ", stringify!(block_device_operations))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<block_device_operations>())).open as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(block_device_operations),
            "::",
            stringify!(open)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<block_device_operations>())).release as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(block_device_operations),
            "::",
            stringify!(release)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<block_device_operations>())).rw_page as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(block_device_operations),
            "::",
            stringify!(rw_page)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<block_device_operations>())).ioctl as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(block_device_operations),
            "::",
            stringify!(ioctl)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<block_device_operations>())).compat_ioctl as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(block_device_operations),
            "::",
            stringify!(compat_ioctl)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<block_device_operations>())).check_events as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(block_device_operations),
            "::",
            stringify!(check_events)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<block_device_operations>())).media_changed as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(block_device_operations),
            "::",
            stringify!(media_changed)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<block_device_operations>())).unlock_native_capacity as *const _
                as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(block_device_operations),
            "::",
            stringify!(unlock_native_capacity)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<block_device_operations>())).revalidate_disk as *const _
                as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(block_device_operations),
            "::",
            stringify!(revalidate_disk)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<block_device_operations>())).getgeo as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(block_device_operations),
            "::",
            stringify!(getgeo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<block_device_operations>())).swap_slot_free_notify as *const _
                as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(block_device_operations),
            "::",
            stringify!(swap_slot_free_notify)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<block_device_operations>())).report_zones as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(block_device_operations),
            "::",
            stringify!(report_zones)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<block_device_operations>())).owner as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(block_device_operations),
            "::",
            stringify!(owner)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<block_device_operations>())).pr_ops as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(block_device_operations),
            "::",
            stringify!(pr_ops)
        )
    );
}
impl Default for block_device_operations {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct blkcg {
    pub css: cgroup_subsys_state,
    pub lock: spinlock_t,
    pub blkg_tree: xarray,
    pub blkg_hint: *mut blkcg_gq,
    pub blkg_list: hlist_head,
    pub cpd: [*mut blkcg_policy_data; 5usize],
    pub all_blkcgs_node: list_head,
    pub cgwb_list: list_head,
    pub cgwb_refcnt: refcount_t,
}
#[test]
fn bindgen_test_layout_blkcg() {
    assert_eq!(
        ::core::mem::size_of::<blkcg>(),
        360usize,
        concat!("Size of: ", stringify!(blkcg))
    );
    assert_eq!(
        ::core::mem::align_of::<blkcg>(),
        8usize,
        concat!("Alignment of ", stringify!(blkcg))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blkcg>())).css as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(blkcg),
            "::",
            stringify!(css)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blkcg>())).lock as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(blkcg),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blkcg>())).blkg_tree as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(blkcg),
            "::",
            stringify!(blkg_tree)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blkcg>())).blkg_hint as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(blkcg),
            "::",
            stringify!(blkg_hint)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blkcg>())).blkg_list as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(blkcg),
            "::",
            stringify!(blkg_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blkcg>())).cpd as *const _ as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(blkcg),
            "::",
            stringify!(cpd)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blkcg>())).all_blkcgs_node as *const _ as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(blkcg),
            "::",
            stringify!(all_blkcgs_node)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blkcg>())).cgwb_list as *const _ as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(blkcg),
            "::",
            stringify!(cgwb_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blkcg>())).cgwb_refcnt as *const _ as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(blkcg),
            "::",
            stringify!(cgwb_refcnt)
        )
    );
}
impl Default for blkcg {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct blkg_rwstat {
    pub cpu_cnt: [percpu_counter; 5usize],
    pub aux_cnt: [atomic64_t; 5usize],
}
#[test]
fn bindgen_test_layout_blkg_rwstat() {
    assert_eq!(
        ::core::mem::size_of::<blkg_rwstat>(),
        240usize,
        concat!("Size of: ", stringify!(blkg_rwstat))
    );
    assert_eq!(
        ::core::mem::align_of::<blkg_rwstat>(),
        8usize,
        concat!("Alignment of ", stringify!(blkg_rwstat))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blkg_rwstat>())).cpu_cnt as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(blkg_rwstat),
            "::",
            stringify!(cpu_cnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blkg_rwstat>())).aux_cnt as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(blkg_rwstat),
            "::",
            stringify!(aux_cnt)
        )
    );
}
impl Default for blkg_rwstat {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct blkg_policy_data {
    pub blkg: *mut blkcg_gq,
    pub plid: c_types::c_int,
}
#[test]
fn bindgen_test_layout_blkg_policy_data() {
    assert_eq!(
        ::core::mem::size_of::<blkg_policy_data>(),
        16usize,
        concat!("Size of: ", stringify!(blkg_policy_data))
    );
    assert_eq!(
        ::core::mem::align_of::<blkg_policy_data>(),
        8usize,
        concat!("Alignment of ", stringify!(blkg_policy_data))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blkg_policy_data>())).blkg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(blkg_policy_data),
            "::",
            stringify!(blkg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blkg_policy_data>())).plid as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(blkg_policy_data),
            "::",
            stringify!(plid)
        )
    );
}
impl Default for blkg_policy_data {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct blkcg_policy_data {
    pub blkcg: *mut blkcg,
    pub plid: c_types::c_int,
}
#[test]
fn bindgen_test_layout_blkcg_policy_data() {
    assert_eq!(
        ::core::mem::size_of::<blkcg_policy_data>(),
        16usize,
        concat!("Size of: ", stringify!(blkcg_policy_data))
    );
    assert_eq!(
        ::core::mem::align_of::<blkcg_policy_data>(),
        8usize,
        concat!("Alignment of ", stringify!(blkcg_policy_data))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blkcg_policy_data>())).blkcg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(blkcg_policy_data),
            "::",
            stringify!(blkcg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blkcg_policy_data>())).plid as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(blkcg_policy_data),
            "::",
            stringify!(plid)
        )
    );
}
impl Default for blkcg_policy_data {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct blkcg_gq {
    pub q: *mut request_queue,
    pub q_node: list_head,
    pub blkcg_node: hlist_node,
    pub blkcg: *mut blkcg,
    pub wb_congested: *mut bdi_writeback_congested,
    pub parent: *mut blkcg_gq,
    pub refcnt: percpu_ref,
    pub online: bool_,
    pub stat_bytes: blkg_rwstat,
    pub stat_ios: blkg_rwstat,
    pub pd: [*mut blkg_policy_data; 5usize],
    pub async_bio_lock: spinlock_t,
    pub async_bios: bio_list,
    pub async_bio_work: work_struct,
    pub use_delay: atomic_t,
    pub delay_nsec: atomic64_t,
    pub delay_start: atomic64_t,
    pub last_delay: u64_,
    pub last_use: c_types::c_int,
    pub callback_head: callback_head,
}
#[test]
fn bindgen_test_layout_blkcg_gq() {
    assert_eq!(
        ::core::mem::size_of::<blkcg_gq>(),
        760usize,
        concat!("Size of: ", stringify!(blkcg_gq))
    );
    assert_eq!(
        ::core::mem::align_of::<blkcg_gq>(),
        8usize,
        concat!("Alignment of ", stringify!(blkcg_gq))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blkcg_gq>())).q as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(blkcg_gq),
            "::",
            stringify!(q)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blkcg_gq>())).q_node as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(blkcg_gq),
            "::",
            stringify!(q_node)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blkcg_gq>())).blkcg_node as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(blkcg_gq),
            "::",
            stringify!(blkcg_node)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blkcg_gq>())).blkcg as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(blkcg_gq),
            "::",
            stringify!(blkcg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blkcg_gq>())).wb_congested as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(blkcg_gq),
            "::",
            stringify!(wb_congested)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blkcg_gq>())).parent as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(blkcg_gq),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blkcg_gq>())).refcnt as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(blkcg_gq),
            "::",
            stringify!(refcnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blkcg_gq>())).online as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(blkcg_gq),
            "::",
            stringify!(online)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blkcg_gq>())).stat_bytes as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(blkcg_gq),
            "::",
            stringify!(stat_bytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blkcg_gq>())).stat_ios as *const _ as usize },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(blkcg_gq),
            "::",
            stringify!(stat_ios)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blkcg_gq>())).pd as *const _ as usize },
        608usize,
        concat!(
            "Offset of field: ",
            stringify!(blkcg_gq),
            "::",
            stringify!(pd)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blkcg_gq>())).async_bio_lock as *const _ as usize },
        648usize,
        concat!(
            "Offset of field: ",
            stringify!(blkcg_gq),
            "::",
            stringify!(async_bio_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blkcg_gq>())).async_bios as *const _ as usize },
        656usize,
        concat!(
            "Offset of field: ",
            stringify!(blkcg_gq),
            "::",
            stringify!(async_bios)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blkcg_gq>())).async_bio_work as *const _ as usize },
        672usize,
        concat!(
            "Offset of field: ",
            stringify!(blkcg_gq),
            "::",
            stringify!(async_bio_work)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blkcg_gq>())).use_delay as *const _ as usize },
        704usize,
        concat!(
            "Offset of field: ",
            stringify!(blkcg_gq),
            "::",
            stringify!(use_delay)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blkcg_gq>())).delay_nsec as *const _ as usize },
        712usize,
        concat!(
            "Offset of field: ",
            stringify!(blkcg_gq),
            "::",
            stringify!(delay_nsec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blkcg_gq>())).delay_start as *const _ as usize },
        720usize,
        concat!(
            "Offset of field: ",
            stringify!(blkcg_gq),
            "::",
            stringify!(delay_start)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blkcg_gq>())).last_delay as *const _ as usize },
        728usize,
        concat!(
            "Offset of field: ",
            stringify!(blkcg_gq),
            "::",
            stringify!(last_delay)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blkcg_gq>())).last_use as *const _ as usize },
        736usize,
        concat!(
            "Offset of field: ",
            stringify!(blkcg_gq),
            "::",
            stringify!(last_use)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blkcg_gq>())).callback_head as *const _ as usize },
        744usize,
        concat!(
            "Offset of field: ",
            stringify!(blkcg_gq),
            "::",
            stringify!(callback_head)
        )
    );
}
impl Default for blkcg_gq {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub const writeback_sync_modes_WB_SYNC_NONE: writeback_sync_modes = 0;
pub const writeback_sync_modes_WB_SYNC_ALL: writeback_sync_modes = 1;
pub type writeback_sync_modes = c_types::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct writeback_control {
    pub nr_to_write: c_types::c_long,
    pub pages_skipped: c_types::c_long,
    pub range_start: loff_t,
    pub range_end: loff_t,
    pub sync_mode: writeback_sync_modes,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub wb: *mut bdi_writeback,
    pub inode: *mut inode,
    pub wb_id: c_types::c_int,
    pub wb_lcand_id: c_types::c_int,
    pub wb_tcand_id: c_types::c_int,
    pub wb_bytes: usize,
    pub wb_lcand_bytes: usize,
    pub wb_tcand_bytes: usize,
}
#[test]
fn bindgen_test_layout_writeback_control() {
    assert_eq!(
        ::core::mem::size_of::<writeback_control>(),
        96usize,
        concat!("Size of: ", stringify!(writeback_control))
    );
    assert_eq!(
        ::core::mem::align_of::<writeback_control>(),
        8usize,
        concat!("Alignment of ", stringify!(writeback_control))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<writeback_control>())).nr_to_write as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(writeback_control),
            "::",
            stringify!(nr_to_write)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<writeback_control>())).pages_skipped as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(writeback_control),
            "::",
            stringify!(pages_skipped)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<writeback_control>())).range_start as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(writeback_control),
            "::",
            stringify!(range_start)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<writeback_control>())).range_end as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(writeback_control),
            "::",
            stringify!(range_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<writeback_control>())).sync_mode as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(writeback_control),
            "::",
            stringify!(sync_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<writeback_control>())).wb as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(writeback_control),
            "::",
            stringify!(wb)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<writeback_control>())).inode as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(writeback_control),
            "::",
            stringify!(inode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<writeback_control>())).wb_id as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(writeback_control),
            "::",
            stringify!(wb_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<writeback_control>())).wb_lcand_id as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(writeback_control),
            "::",
            stringify!(wb_lcand_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<writeback_control>())).wb_tcand_id as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(writeback_control),
            "::",
            stringify!(wb_tcand_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<writeback_control>())).wb_bytes as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(writeback_control),
            "::",
            stringify!(wb_bytes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<writeback_control>())).wb_lcand_bytes as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(writeback_control),
            "::",
            stringify!(wb_lcand_bytes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<writeback_control>())).wb_tcand_bytes as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(writeback_control),
            "::",
            stringify!(wb_tcand_bytes)
        )
    );
}
impl Default for writeback_control {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl writeback_control {
    #[inline]
    pub fn for_kupdate(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_for_kupdate(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn for_background(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_for_background(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tagged_writepages(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tagged_writepages(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn for_reclaim(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_for_reclaim(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn range_cyclic(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_range_cyclic(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn for_sync(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_for_sync(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn no_cgroup_owner(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_no_cgroup_owner(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn punt_to_cgroup(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_punt_to_cgroup(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        for_kupdate: c_types::c_uint,
        for_background: c_types::c_uint,
        tagged_writepages: c_types::c_uint,
        for_reclaim: c_types::c_uint,
        range_cyclic: c_types::c_uint,
        for_sync: c_types::c_uint,
        no_cgroup_owner: c_types::c_uint,
        punt_to_cgroup: c_types::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let for_kupdate: u32 = unsafe { ::core::mem::transmute(for_kupdate) };
            for_kupdate as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let for_background: u32 = unsafe { ::core::mem::transmute(for_background) };
            for_background as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let tagged_writepages: u32 = unsafe { ::core::mem::transmute(tagged_writepages) };
            tagged_writepages as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let for_reclaim: u32 = unsafe { ::core::mem::transmute(for_reclaim) };
            for_reclaim as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let range_cyclic: u32 = unsafe { ::core::mem::transmute(range_cyclic) };
            range_cyclic as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let for_sync: u32 = unsafe { ::core::mem::transmute(for_sync) };
            for_sync as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let no_cgroup_owner: u32 = unsafe { ::core::mem::transmute(no_cgroup_owner) };
            no_cgroup_owner as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let punt_to_cgroup: u32 = unsafe { ::core::mem::transmute(punt_to_cgroup) };
            punt_to_cgroup as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wb_domain {
    pub lock: spinlock_t,
    pub completions: fprop_global,
    pub period_timer: timer_list,
    pub period_time: c_types::c_ulong,
    pub dirty_limit_tstamp: c_types::c_ulong,
    pub dirty_limit: c_types::c_ulong,
}
#[test]
fn bindgen_test_layout_wb_domain() {
    assert_eq!(
        ::core::mem::size_of::<wb_domain>(),
        120usize,
        concat!("Size of: ", stringify!(wb_domain))
    );
    assert_eq!(
        ::core::mem::align_of::<wb_domain>(),
        8usize,
        concat!("Alignment of ", stringify!(wb_domain))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<wb_domain>())).lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wb_domain),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<wb_domain>())).completions as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wb_domain),
            "::",
            stringify!(completions)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<wb_domain>())).period_timer as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(wb_domain),
            "::",
            stringify!(period_timer)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<wb_domain>())).period_time as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(wb_domain),
            "::",
            stringify!(period_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<wb_domain>())).dirty_limit_tstamp as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(wb_domain),
            "::",
            stringify!(dirty_limit_tstamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<wb_domain>())).dirty_limit as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(wb_domain),
            "::",
            stringify!(dirty_limit)
        )
    );
}
impl Default for wb_domain {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct mem_cgroup_id {
    pub id: c_types::c_int,
    pub ref_: refcount_t,
}
#[test]
fn bindgen_test_layout_mem_cgroup_id() {
    assert_eq!(
        ::core::mem::size_of::<mem_cgroup_id>(),
        8usize,
        concat!("Size of: ", stringify!(mem_cgroup_id))
    );
    assert_eq!(
        ::core::mem::align_of::<mem_cgroup_id>(),
        4usize,
        concat!("Alignment of ", stringify!(mem_cgroup_id))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mem_cgroup_id>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_cgroup_id),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mem_cgroup_id>())).ref_ as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_cgroup_id),
            "::",
            stringify!(ref_)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct memcg_vmstats_percpu {
    pub stat: [c_types::c_long; 38usize],
    pub events: [c_types::c_ulong; 85usize],
    pub nr_page_events: c_types::c_ulong,
    pub targets: [c_types::c_ulong; 3usize],
}
#[test]
fn bindgen_test_layout_memcg_vmstats_percpu() {
    assert_eq!(
        ::core::mem::size_of::<memcg_vmstats_percpu>(),
        1016usize,
        concat!("Size of: ", stringify!(memcg_vmstats_percpu))
    );
    assert_eq!(
        ::core::mem::align_of::<memcg_vmstats_percpu>(),
        8usize,
        concat!("Alignment of ", stringify!(memcg_vmstats_percpu))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<memcg_vmstats_percpu>())).stat as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(memcg_vmstats_percpu),
            "::",
            stringify!(stat)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<memcg_vmstats_percpu>())).events as *const _ as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(memcg_vmstats_percpu),
            "::",
            stringify!(events)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<memcg_vmstats_percpu>())).nr_page_events as *const _ as usize
        },
        984usize,
        concat!(
            "Offset of field: ",
            stringify!(memcg_vmstats_percpu),
            "::",
            stringify!(nr_page_events)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<memcg_vmstats_percpu>())).targets as *const _ as usize },
        992usize,
        concat!(
            "Offset of field: ",
            stringify!(memcg_vmstats_percpu),
            "::",
            stringify!(targets)
        )
    );
}
impl Default for memcg_vmstats_percpu {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mem_cgroup_reclaim_iter {
    pub position: *mut mem_cgroup,
    pub generation: c_types::c_uint,
}
#[test]
fn bindgen_test_layout_mem_cgroup_reclaim_iter() {
    assert_eq!(
        ::core::mem::size_of::<mem_cgroup_reclaim_iter>(),
        16usize,
        concat!("Size of: ", stringify!(mem_cgroup_reclaim_iter))
    );
    assert_eq!(
        ::core::mem::align_of::<mem_cgroup_reclaim_iter>(),
        8usize,
        concat!("Alignment of ", stringify!(mem_cgroup_reclaim_iter))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<mem_cgroup_reclaim_iter>())).position as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_cgroup_reclaim_iter),
            "::",
            stringify!(position)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<mem_cgroup_reclaim_iter>())).generation as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_cgroup_reclaim_iter),
            "::",
            stringify!(generation)
        )
    );
}
impl Default for mem_cgroup_reclaim_iter {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct lruvec_stat {
    pub count: [c_types::c_long; 32usize],
}
#[test]
fn bindgen_test_layout_lruvec_stat() {
    assert_eq!(
        ::core::mem::size_of::<lruvec_stat>(),
        256usize,
        concat!("Size of: ", stringify!(lruvec_stat))
    );
    assert_eq!(
        ::core::mem::align_of::<lruvec_stat>(),
        8usize,
        concat!("Alignment of ", stringify!(lruvec_stat))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<lruvec_stat>())).count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lruvec_stat),
            "::",
            stringify!(count)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct memcg_shrinker_map {
    pub rcu: callback_head,
    pub map: __IncompleteArrayField<c_types::c_ulong>,
}
#[test]
fn bindgen_test_layout_memcg_shrinker_map() {
    assert_eq!(
        ::core::mem::size_of::<memcg_shrinker_map>(),
        16usize,
        concat!("Size of: ", stringify!(memcg_shrinker_map))
    );
    assert_eq!(
        ::core::mem::align_of::<memcg_shrinker_map>(),
        8usize,
        concat!("Alignment of ", stringify!(memcg_shrinker_map))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<memcg_shrinker_map>())).rcu as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(memcg_shrinker_map),
            "::",
            stringify!(rcu)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<memcg_shrinker_map>())).map as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(memcg_shrinker_map),
            "::",
            stringify!(map)
        )
    );
}
impl Default for memcg_shrinker_map {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mem_cgroup_per_node {
    pub lruvec: lruvec,
    pub lruvec_stat_local: *mut lruvec_stat,
    pub lruvec_stat_cpu: *mut lruvec_stat,
    pub lruvec_stat: [atomic_long_t; 32usize],
    pub lru_zone_size: [[c_types::c_ulong; 5usize]; 5usize],
    pub iter: [mem_cgroup_reclaim_iter; 13usize],
    pub shrinker_map: *mut memcg_shrinker_map,
    pub tree_node: rb_node,
    pub usage_in_excess: c_types::c_ulong,
    pub on_tree: bool_,
    pub congested: bool_,
    pub memcg: *mut mem_cgroup,
}
#[test]
fn bindgen_test_layout_mem_cgroup_per_node() {
    assert_eq!(
        ::core::mem::size_of::<mem_cgroup_per_node>(),
        872usize,
        concat!("Size of: ", stringify!(mem_cgroup_per_node))
    );
    assert_eq!(
        ::core::mem::align_of::<mem_cgroup_per_node>(),
        8usize,
        concat!("Alignment of ", stringify!(mem_cgroup_per_node))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mem_cgroup_per_node>())).lruvec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_cgroup_per_node),
            "::",
            stringify!(lruvec)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<mem_cgroup_per_node>())).lruvec_stat_local as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_cgroup_per_node),
            "::",
            stringify!(lruvec_stat_local)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<mem_cgroup_per_node>())).lruvec_stat_cpu as *const _ as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_cgroup_per_node),
            "::",
            stringify!(lruvec_stat_cpu)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<mem_cgroup_per_node>())).lruvec_stat as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_cgroup_per_node),
            "::",
            stringify!(lruvec_stat)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<mem_cgroup_per_node>())).lru_zone_size as *const _ as usize
        },
        408usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_cgroup_per_node),
            "::",
            stringify!(lru_zone_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mem_cgroup_per_node>())).iter as *const _ as usize },
        608usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_cgroup_per_node),
            "::",
            stringify!(iter)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<mem_cgroup_per_node>())).shrinker_map as *const _ as usize
        },
        816usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_cgroup_per_node),
            "::",
            stringify!(shrinker_map)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mem_cgroup_per_node>())).tree_node as *const _ as usize },
        824usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_cgroup_per_node),
            "::",
            stringify!(tree_node)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<mem_cgroup_per_node>())).usage_in_excess as *const _ as usize
        },
        848usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_cgroup_per_node),
            "::",
            stringify!(usage_in_excess)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mem_cgroup_per_node>())).on_tree as *const _ as usize },
        856usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_cgroup_per_node),
            "::",
            stringify!(on_tree)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mem_cgroup_per_node>())).congested as *const _ as usize },
        857usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_cgroup_per_node),
            "::",
            stringify!(congested)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mem_cgroup_per_node>())).memcg as *const _ as usize },
        864usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_cgroup_per_node),
            "::",
            stringify!(memcg)
        )
    );
}
impl Default for mem_cgroup_per_node {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mem_cgroup_threshold {
    pub eventfd: *mut eventfd_ctx,
    pub threshold: c_types::c_ulong,
}
#[test]
fn bindgen_test_layout_mem_cgroup_threshold() {
    assert_eq!(
        ::core::mem::size_of::<mem_cgroup_threshold>(),
        16usize,
        concat!("Size of: ", stringify!(mem_cgroup_threshold))
    );
    assert_eq!(
        ::core::mem::align_of::<mem_cgroup_threshold>(),
        8usize,
        concat!("Alignment of ", stringify!(mem_cgroup_threshold))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mem_cgroup_threshold>())).eventfd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_cgroup_threshold),
            "::",
            stringify!(eventfd)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mem_cgroup_threshold>())).threshold as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_cgroup_threshold),
            "::",
            stringify!(threshold)
        )
    );
}
impl Default for mem_cgroup_threshold {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct mem_cgroup_threshold_ary {
    pub current_threshold: c_types::c_int,
    pub size: c_types::c_uint,
    pub entries: __IncompleteArrayField<mem_cgroup_threshold>,
}
#[test]
fn bindgen_test_layout_mem_cgroup_threshold_ary() {
    assert_eq!(
        ::core::mem::size_of::<mem_cgroup_threshold_ary>(),
        8usize,
        concat!("Size of: ", stringify!(mem_cgroup_threshold_ary))
    );
    assert_eq!(
        ::core::mem::align_of::<mem_cgroup_threshold_ary>(),
        8usize,
        concat!("Alignment of ", stringify!(mem_cgroup_threshold_ary))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<mem_cgroup_threshold_ary>())).current_threshold as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_cgroup_threshold_ary),
            "::",
            stringify!(current_threshold)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mem_cgroup_threshold_ary>())).size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_cgroup_threshold_ary),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<mem_cgroup_threshold_ary>())).entries as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_cgroup_threshold_ary),
            "::",
            stringify!(entries)
        )
    );
}
impl Default for mem_cgroup_threshold_ary {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mem_cgroup_thresholds {
    pub primary: *mut mem_cgroup_threshold_ary,
    pub spare: *mut mem_cgroup_threshold_ary,
}
#[test]
fn bindgen_test_layout_mem_cgroup_thresholds() {
    assert_eq!(
        ::core::mem::size_of::<mem_cgroup_thresholds>(),
        16usize,
        concat!("Size of: ", stringify!(mem_cgroup_thresholds))
    );
    assert_eq!(
        ::core::mem::align_of::<mem_cgroup_thresholds>(),
        8usize,
        concat!("Alignment of ", stringify!(mem_cgroup_thresholds))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mem_cgroup_thresholds>())).primary as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_cgroup_thresholds),
            "::",
            stringify!(primary)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mem_cgroup_thresholds>())).spare as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_cgroup_thresholds),
            "::",
            stringify!(spare)
        )
    );
}
impl Default for mem_cgroup_thresholds {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub const memcg_kmem_state_KMEM_NONE: memcg_kmem_state = 0;
pub const memcg_kmem_state_KMEM_ALLOCATED: memcg_kmem_state = 1;
pub const memcg_kmem_state_KMEM_ONLINE: memcg_kmem_state = 2;
pub type memcg_kmem_state = c_types::c_uint;
#[repr(C)]
#[repr(align(64))]
pub struct memcg_padding {
    pub x: __IncompleteArrayField<c_types::c_char>,
}
#[test]
fn bindgen_test_layout_memcg_padding() {
    assert_eq!(
        ::core::mem::size_of::<memcg_padding>(),
        0usize,
        concat!("Size of: ", stringify!(memcg_padding))
    );
    assert_eq!(
        ::core::mem::align_of::<memcg_padding>(),
        64usize,
        concat!("Alignment of ", stringify!(memcg_padding))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<memcg_padding>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(memcg_padding),
            "::",
            stringify!(x)
        )
    );
}
impl Default for memcg_padding {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct memcg_cgwb_frn {
    pub bdi_id: u64_,
    pub memcg_id: c_types::c_int,
    pub at: u64_,
    pub done: wb_completion,
}
#[test]
fn bindgen_test_layout_memcg_cgwb_frn() {
    assert_eq!(
        ::core::mem::size_of::<memcg_cgwb_frn>(),
        40usize,
        concat!("Size of: ", stringify!(memcg_cgwb_frn))
    );
    assert_eq!(
        ::core::mem::align_of::<memcg_cgwb_frn>(),
        8usize,
        concat!("Alignment of ", stringify!(memcg_cgwb_frn))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<memcg_cgwb_frn>())).bdi_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(memcg_cgwb_frn),
            "::",
            stringify!(bdi_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<memcg_cgwb_frn>())).memcg_id as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(memcg_cgwb_frn),
            "::",
            stringify!(memcg_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<memcg_cgwb_frn>())).at as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(memcg_cgwb_frn),
            "::",
            stringify!(at)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<memcg_cgwb_frn>())).done as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(memcg_cgwb_frn),
            "::",
            stringify!(done)
        )
    );
}
impl Default for memcg_cgwb_frn {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[repr(align(64))]
pub struct mem_cgroup {
    pub css: cgroup_subsys_state,
    pub id: mem_cgroup_id,
    pub memory: page_counter,
    pub swap: page_counter,
    pub memsw: page_counter,
    pub kmem: page_counter,
    pub tcpmem: page_counter,
    pub high: c_types::c_ulong,
    pub high_work: work_struct,
    pub soft_limit: c_types::c_ulong,
    pub vmpressure: vmpressure,
    pub use_hierarchy: bool_,
    pub oom_group: bool_,
    pub oom_lock: bool_,
    pub under_oom: c_types::c_int,
    pub swappiness: c_types::c_int,
    pub oom_kill_disable: c_types::c_int,
    pub events_file: cgroup_file,
    pub events_local_file: cgroup_file,
    pub swap_events_file: cgroup_file,
    pub thresholds_lock: mutex,
    pub thresholds: mem_cgroup_thresholds,
    pub memsw_thresholds: mem_cgroup_thresholds,
    pub oom_notify: list_head,
    pub move_charge_at_immigrate: c_types::c_ulong,
    pub move_lock: spinlock_t,
    pub move_lock_flags: c_types::c_ulong,
    pub __bindgen_padding_0: [u64; 7usize],
    pub _pad1_: memcg_padding,
    pub moving_account: atomic_t,
    pub move_lock_task: *mut task_struct,
    pub vmstats_local: *mut memcg_vmstats_percpu,
    pub vmstats_percpu: *mut memcg_vmstats_percpu,
    pub __bindgen_padding_1: [u64; 4usize],
    pub _pad2_: memcg_padding,
    pub vmstats: [atomic_long_t; 38usize],
    pub vmevents: [atomic_long_t; 85usize],
    pub memory_events: [atomic_long_t; 7usize],
    pub memory_events_local: [atomic_long_t; 7usize],
    pub socket_pressure: c_types::c_ulong,
    pub tcpmem_active: bool_,
    pub tcpmem_pressure: c_types::c_int,
    pub kmemcg_id: c_types::c_int,
    pub kmem_state: memcg_kmem_state,
    pub kmem_caches: list_head,
    pub last_scanned_node: c_types::c_int,
    pub scan_nodes: nodemask_t,
    pub numainfo_events: atomic_t,
    pub numainfo_updating: atomic_t,
    pub cgwb_list: list_head,
    pub cgwb_domain: wb_domain,
    pub cgwb_frn: [memcg_cgwb_frn; 4usize],
    pub event_list: list_head,
    pub event_list_lock: spinlock_t,
    pub deferred_split_queue: deferred_split,
    pub nodeinfo: __IncompleteArrayField<*mut mem_cgroup_per_node>,
}
#[test]
fn bindgen_test_layout_mem_cgroup() {
    assert_eq!(
        ::core::mem::size_of::<mem_cgroup>(),
        3008usize,
        concat!("Size of: ", stringify!(mem_cgroup))
    );
    assert_eq!(
        ::core::mem::align_of::<mem_cgroup>(),
        64usize,
        concat!("Alignment of ", stringify!(mem_cgroup))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mem_cgroup>())).css as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_cgroup),
            "::",
            stringify!(css)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mem_cgroup>())).id as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_cgroup),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mem_cgroup>())).memory as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_cgroup),
            "::",
            stringify!(memory)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mem_cgroup>())).swap as *const _ as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_cgroup),
            "::",
            stringify!(swap)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mem_cgroup>())).memsw as *const _ as usize },
        456usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_cgroup),
            "::",
            stringify!(memsw)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mem_cgroup>())).kmem as *const _ as usize },
        560usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_cgroup),
            "::",
            stringify!(kmem)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mem_cgroup>())).tcpmem as *const _ as usize },
        664usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_cgroup),
            "::",
            stringify!(tcpmem)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mem_cgroup>())).high as *const _ as usize },
        768usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_cgroup),
            "::",
            stringify!(high)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mem_cgroup>())).high_work as *const _ as usize },
        776usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_cgroup),
            "::",
            stringify!(high_work)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mem_cgroup>())).soft_limit as *const _ as usize },
        808usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_cgroup),
            "::",
            stringify!(soft_limit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mem_cgroup>())).vmpressure as *const _ as usize },
        816usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_cgroup),
            "::",
            stringify!(vmpressure)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mem_cgroup>())).use_hierarchy as *const _ as usize },
        936usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_cgroup),
            "::",
            stringify!(use_hierarchy)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mem_cgroup>())).oom_group as *const _ as usize },
        937usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_cgroup),
            "::",
            stringify!(oom_group)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mem_cgroup>())).oom_lock as *const _ as usize },
        938usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_cgroup),
            "::",
            stringify!(oom_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mem_cgroup>())).under_oom as *const _ as usize },
        940usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_cgroup),
            "::",
            stringify!(under_oom)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mem_cgroup>())).swappiness as *const _ as usize },
        944usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_cgroup),
            "::",
            stringify!(swappiness)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mem_cgroup>())).oom_kill_disable as *const _ as usize },
        948usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_cgroup),
            "::",
            stringify!(oom_kill_disable)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mem_cgroup>())).events_file as *const _ as usize },
        952usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_cgroup),
            "::",
            stringify!(events_file)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mem_cgroup>())).events_local_file as *const _ as usize },
        1008usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_cgroup),
            "::",
            stringify!(events_local_file)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mem_cgroup>())).swap_events_file as *const _ as usize },
        1064usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_cgroup),
            "::",
            stringify!(swap_events_file)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mem_cgroup>())).thresholds_lock as *const _ as usize },
        1120usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_cgroup),
            "::",
            stringify!(thresholds_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mem_cgroup>())).thresholds as *const _ as usize },
        1152usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_cgroup),
            "::",
            stringify!(thresholds)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mem_cgroup>())).memsw_thresholds as *const _ as usize },
        1168usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_cgroup),
            "::",
            stringify!(memsw_thresholds)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mem_cgroup>())).oom_notify as *const _ as usize },
        1184usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_cgroup),
            "::",
            stringify!(oom_notify)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<mem_cgroup>())).move_charge_at_immigrate as *const _ as usize
        },
        1200usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_cgroup),
            "::",
            stringify!(move_charge_at_immigrate)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mem_cgroup>())).move_lock as *const _ as usize },
        1208usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_cgroup),
            "::",
            stringify!(move_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mem_cgroup>())).move_lock_flags as *const _ as usize },
        1216usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_cgroup),
            "::",
            stringify!(move_lock_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mem_cgroup>()))._pad1_ as *const _ as usize },
        1280usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_cgroup),
            "::",
            stringify!(_pad1_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mem_cgroup>())).moving_account as *const _ as usize },
        1280usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_cgroup),
            "::",
            stringify!(moving_account)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mem_cgroup>())).move_lock_task as *const _ as usize },
        1288usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_cgroup),
            "::",
            stringify!(move_lock_task)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mem_cgroup>())).vmstats_local as *const _ as usize },
        1296usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_cgroup),
            "::",
            stringify!(vmstats_local)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mem_cgroup>())).vmstats_percpu as *const _ as usize },
        1304usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_cgroup),
            "::",
            stringify!(vmstats_percpu)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mem_cgroup>()))._pad2_ as *const _ as usize },
        1344usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_cgroup),
            "::",
            stringify!(_pad2_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mem_cgroup>())).vmstats as *const _ as usize },
        1344usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_cgroup),
            "::",
            stringify!(vmstats)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mem_cgroup>())).vmevents as *const _ as usize },
        1648usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_cgroup),
            "::",
            stringify!(vmevents)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mem_cgroup>())).memory_events as *const _ as usize },
        2328usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_cgroup),
            "::",
            stringify!(memory_events)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mem_cgroup>())).memory_events_local as *const _ as usize },
        2384usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_cgroup),
            "::",
            stringify!(memory_events_local)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mem_cgroup>())).socket_pressure as *const _ as usize },
        2440usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_cgroup),
            "::",
            stringify!(socket_pressure)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mem_cgroup>())).tcpmem_active as *const _ as usize },
        2448usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_cgroup),
            "::",
            stringify!(tcpmem_active)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mem_cgroup>())).tcpmem_pressure as *const _ as usize },
        2452usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_cgroup),
            "::",
            stringify!(tcpmem_pressure)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mem_cgroup>())).kmemcg_id as *const _ as usize },
        2456usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_cgroup),
            "::",
            stringify!(kmemcg_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mem_cgroup>())).kmem_state as *const _ as usize },
        2460usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_cgroup),
            "::",
            stringify!(kmem_state)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mem_cgroup>())).kmem_caches as *const _ as usize },
        2464usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_cgroup),
            "::",
            stringify!(kmem_caches)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mem_cgroup>())).last_scanned_node as *const _ as usize },
        2480usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_cgroup),
            "::",
            stringify!(last_scanned_node)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mem_cgroup>())).scan_nodes as *const _ as usize },
        2488usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_cgroup),
            "::",
            stringify!(scan_nodes)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mem_cgroup>())).numainfo_events as *const _ as usize },
        2616usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_cgroup),
            "::",
            stringify!(numainfo_events)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mem_cgroup>())).numainfo_updating as *const _ as usize },
        2620usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_cgroup),
            "::",
            stringify!(numainfo_updating)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mem_cgroup>())).cgwb_list as *const _ as usize },
        2624usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_cgroup),
            "::",
            stringify!(cgwb_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mem_cgroup>())).cgwb_domain as *const _ as usize },
        2640usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_cgroup),
            "::",
            stringify!(cgwb_domain)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mem_cgroup>())).cgwb_frn as *const _ as usize },
        2760usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_cgroup),
            "::",
            stringify!(cgwb_frn)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mem_cgroup>())).event_list as *const _ as usize },
        2920usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_cgroup),
            "::",
            stringify!(event_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mem_cgroup>())).event_list_lock as *const _ as usize },
        2936usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_cgroup),
            "::",
            stringify!(event_list_lock)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<mem_cgroup>())).deferred_split_queue as *const _ as usize
        },
        2944usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_cgroup),
            "::",
            stringify!(deferred_split_queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mem_cgroup>())).nodeinfo as *const _ as usize },
        2976usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_cgroup),
            "::",
            stringify!(nodeinfo)
        )
    );
}
impl Default for mem_cgroup {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vdso_image {
    pub data: *mut c_types::c_void,
    pub size: c_types::c_ulong,
    pub alt: c_types::c_ulong,
    pub alt_len: c_types::c_ulong,
    pub sym_vvar_start: c_types::c_long,
    pub sym_vvar_page: c_types::c_long,
    pub sym_pvclock_page: c_types::c_long,
    pub sym_hvclock_page: c_types::c_long,
    pub sym_VDSO32_NOTE_MASK: c_types::c_long,
    pub sym___kernel_sigreturn: c_types::c_long,
    pub sym___kernel_rt_sigreturn: c_types::c_long,
    pub sym___kernel_vsyscall: c_types::c_long,
    pub sym_int80_landing_pad: c_types::c_long,
}
#[test]
fn bindgen_test_layout_vdso_image() {
    assert_eq!(
        ::core::mem::size_of::<vdso_image>(),
        104usize,
        concat!("Size of: ", stringify!(vdso_image))
    );
    assert_eq!(
        ::core::mem::align_of::<vdso_image>(),
        8usize,
        concat!("Alignment of ", stringify!(vdso_image))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vdso_image>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vdso_image),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vdso_image>())).size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vdso_image),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vdso_image>())).alt as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vdso_image),
            "::",
            stringify!(alt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vdso_image>())).alt_len as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(vdso_image),
            "::",
            stringify!(alt_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vdso_image>())).sym_vvar_start as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(vdso_image),
            "::",
            stringify!(sym_vvar_start)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vdso_image>())).sym_vvar_page as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(vdso_image),
            "::",
            stringify!(sym_vvar_page)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vdso_image>())).sym_pvclock_page as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(vdso_image),
            "::",
            stringify!(sym_pvclock_page)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vdso_image>())).sym_hvclock_page as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(vdso_image),
            "::",
            stringify!(sym_hvclock_page)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<vdso_image>())).sym_VDSO32_NOTE_MASK as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(vdso_image),
            "::",
            stringify!(sym_VDSO32_NOTE_MASK)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<vdso_image>())).sym___kernel_sigreturn as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(vdso_image),
            "::",
            stringify!(sym___kernel_sigreturn)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<vdso_image>())).sym___kernel_rt_sigreturn as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(vdso_image),
            "::",
            stringify!(sym___kernel_rt_sigreturn)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<vdso_image>())).sym___kernel_vsyscall as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(vdso_image),
            "::",
            stringify!(sym___kernel_vsyscall)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<vdso_image>())).sym_int80_landing_pad as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(vdso_image),
            "::",
            stringify!(sym_int80_landing_pad)
        )
    );
}
impl Default for vdso_image {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type Elf64_Addr = __u64;
pub type Elf64_Half = __u16;
pub type Elf64_Off = __u64;
pub type Elf64_Word = __u32;
pub type Elf64_Xword = __u64;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct elf64_sym {
    pub st_name: Elf64_Word,
    pub st_info: c_types::c_uchar,
    pub st_other: c_types::c_uchar,
    pub st_shndx: Elf64_Half,
    pub st_value: Elf64_Addr,
    pub st_size: Elf64_Xword,
}
#[test]
fn bindgen_test_layout_elf64_sym() {
    assert_eq!(
        ::core::mem::size_of::<elf64_sym>(),
        24usize,
        concat!("Size of: ", stringify!(elf64_sym))
    );
    assert_eq!(
        ::core::mem::align_of::<elf64_sym>(),
        8usize,
        concat!("Alignment of ", stringify!(elf64_sym))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elf64_sym>())).st_name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(elf64_sym),
            "::",
            stringify!(st_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elf64_sym>())).st_info as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(elf64_sym),
            "::",
            stringify!(st_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elf64_sym>())).st_other as *const _ as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(elf64_sym),
            "::",
            stringify!(st_other)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elf64_sym>())).st_shndx as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(elf64_sym),
            "::",
            stringify!(st_shndx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elf64_sym>())).st_value as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(elf64_sym),
            "::",
            stringify!(st_value)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elf64_sym>())).st_size as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(elf64_sym),
            "::",
            stringify!(st_size)
        )
    );
}
pub type Elf64_Sym = elf64_sym;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct elf64_hdr {
    pub e_ident: [c_types::c_uchar; 16usize],
    pub e_type: Elf64_Half,
    pub e_machine: Elf64_Half,
    pub e_version: Elf64_Word,
    pub e_entry: Elf64_Addr,
    pub e_phoff: Elf64_Off,
    pub e_shoff: Elf64_Off,
    pub e_flags: Elf64_Word,
    pub e_ehsize: Elf64_Half,
    pub e_phentsize: Elf64_Half,
    pub e_phnum: Elf64_Half,
    pub e_shentsize: Elf64_Half,
    pub e_shnum: Elf64_Half,
    pub e_shstrndx: Elf64_Half,
}
#[test]
fn bindgen_test_layout_elf64_hdr() {
    assert_eq!(
        ::core::mem::size_of::<elf64_hdr>(),
        64usize,
        concat!("Size of: ", stringify!(elf64_hdr))
    );
    assert_eq!(
        ::core::mem::align_of::<elf64_hdr>(),
        8usize,
        concat!("Alignment of ", stringify!(elf64_hdr))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elf64_hdr>())).e_ident as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(elf64_hdr),
            "::",
            stringify!(e_ident)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elf64_hdr>())).e_type as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(elf64_hdr),
            "::",
            stringify!(e_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elf64_hdr>())).e_machine as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(elf64_hdr),
            "::",
            stringify!(e_machine)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elf64_hdr>())).e_version as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(elf64_hdr),
            "::",
            stringify!(e_version)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elf64_hdr>())).e_entry as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(elf64_hdr),
            "::",
            stringify!(e_entry)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elf64_hdr>())).e_phoff as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(elf64_hdr),
            "::",
            stringify!(e_phoff)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elf64_hdr>())).e_shoff as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(elf64_hdr),
            "::",
            stringify!(e_shoff)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elf64_hdr>())).e_flags as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(elf64_hdr),
            "::",
            stringify!(e_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elf64_hdr>())).e_ehsize as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(elf64_hdr),
            "::",
            stringify!(e_ehsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elf64_hdr>())).e_phentsize as *const _ as usize },
        54usize,
        concat!(
            "Offset of field: ",
            stringify!(elf64_hdr),
            "::",
            stringify!(e_phentsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elf64_hdr>())).e_phnum as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(elf64_hdr),
            "::",
            stringify!(e_phnum)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elf64_hdr>())).e_shentsize as *const _ as usize },
        58usize,
        concat!(
            "Offset of field: ",
            stringify!(elf64_hdr),
            "::",
            stringify!(e_shentsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elf64_hdr>())).e_shnum as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(elf64_hdr),
            "::",
            stringify!(e_shnum)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elf64_hdr>())).e_shstrndx as *const _ as usize },
        62usize,
        concat!(
            "Offset of field: ",
            stringify!(elf64_hdr),
            "::",
            stringify!(e_shstrndx)
        )
    );
}
pub type Elf64_Ehdr = elf64_hdr;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct elf64_shdr {
    pub sh_name: Elf64_Word,
    pub sh_type: Elf64_Word,
    pub sh_flags: Elf64_Xword,
    pub sh_addr: Elf64_Addr,
    pub sh_offset: Elf64_Off,
    pub sh_size: Elf64_Xword,
    pub sh_link: Elf64_Word,
    pub sh_info: Elf64_Word,
    pub sh_addralign: Elf64_Xword,
    pub sh_entsize: Elf64_Xword,
}
#[test]
fn bindgen_test_layout_elf64_shdr() {
    assert_eq!(
        ::core::mem::size_of::<elf64_shdr>(),
        64usize,
        concat!("Size of: ", stringify!(elf64_shdr))
    );
    assert_eq!(
        ::core::mem::align_of::<elf64_shdr>(),
        8usize,
        concat!("Alignment of ", stringify!(elf64_shdr))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elf64_shdr>())).sh_name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(elf64_shdr),
            "::",
            stringify!(sh_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elf64_shdr>())).sh_type as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(elf64_shdr),
            "::",
            stringify!(sh_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elf64_shdr>())).sh_flags as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(elf64_shdr),
            "::",
            stringify!(sh_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elf64_shdr>())).sh_addr as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(elf64_shdr),
            "::",
            stringify!(sh_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elf64_shdr>())).sh_offset as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(elf64_shdr),
            "::",
            stringify!(sh_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elf64_shdr>())).sh_size as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(elf64_shdr),
            "::",
            stringify!(sh_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elf64_shdr>())).sh_link as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(elf64_shdr),
            "::",
            stringify!(sh_link)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elf64_shdr>())).sh_info as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(elf64_shdr),
            "::",
            stringify!(sh_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elf64_shdr>())).sh_addralign as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(elf64_shdr),
            "::",
            stringify!(sh_addralign)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elf64_shdr>())).sh_entsize as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(elf64_shdr),
            "::",
            stringify!(sh_entsize)
        )
    );
}
pub type Elf64_Shdr = elf64_shdr;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kernel_param_ops {
    pub flags: c_types::c_uint,
    pub set: ::core::option::Option<
        unsafe extern "C" fn(
            val: *const c_types::c_char,
            kp: *const kernel_param,
        ) -> c_types::c_int,
    >,
    pub get: ::core::option::Option<
        unsafe extern "C" fn(
            buffer: *mut c_types::c_char,
            kp: *const kernel_param,
        ) -> c_types::c_int,
    >,
    pub free: ::core::option::Option<unsafe extern "C" fn(arg: *mut c_types::c_void)>,
}
#[test]
fn bindgen_test_layout_kernel_param_ops() {
    assert_eq!(
        ::core::mem::size_of::<kernel_param_ops>(),
        32usize,
        concat!("Size of: ", stringify!(kernel_param_ops))
    );
    assert_eq!(
        ::core::mem::align_of::<kernel_param_ops>(),
        8usize,
        concat!("Alignment of ", stringify!(kernel_param_ops))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernel_param_ops>())).flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kernel_param_ops),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernel_param_ops>())).set as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(kernel_param_ops),
            "::",
            stringify!(set)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernel_param_ops>())).get as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(kernel_param_ops),
            "::",
            stringify!(get)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernel_param_ops>())).free as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(kernel_param_ops),
            "::",
            stringify!(free)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kernel_param {
    pub name: *const c_types::c_char,
    pub mod_: *mut module,
    pub ops: *const kernel_param_ops,
    pub perm: u16_,
    pub level: s8,
    pub flags: u8_,
    pub __bindgen_anon_1: kernel_param__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union kernel_param__bindgen_ty_1 {
    pub arg: *mut c_types::c_void,
    pub str_: *const kparam_string,
    pub arr: *const kparam_array,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_kernel_param__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<kernel_param__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(kernel_param__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<kernel_param__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(kernel_param__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernel_param__bindgen_ty_1>())).arg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kernel_param__bindgen_ty_1),
            "::",
            stringify!(arg)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<kernel_param__bindgen_ty_1>())).str_ as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kernel_param__bindgen_ty_1),
            "::",
            stringify!(str_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernel_param__bindgen_ty_1>())).arr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kernel_param__bindgen_ty_1),
            "::",
            stringify!(arr)
        )
    );
}
impl Default for kernel_param__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_kernel_param() {
    assert_eq!(
        ::core::mem::size_of::<kernel_param>(),
        40usize,
        concat!("Size of: ", stringify!(kernel_param))
    );
    assert_eq!(
        ::core::mem::align_of::<kernel_param>(),
        8usize,
        concat!("Alignment of ", stringify!(kernel_param))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernel_param>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kernel_param),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernel_param>())).mod_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(kernel_param),
            "::",
            stringify!(mod_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernel_param>())).ops as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(kernel_param),
            "::",
            stringify!(ops)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernel_param>())).perm as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(kernel_param),
            "::",
            stringify!(perm)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernel_param>())).level as *const _ as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(kernel_param),
            "::",
            stringify!(level)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernel_param>())).flags as *const _ as usize },
        27usize,
        concat!(
            "Offset of field: ",
            stringify!(kernel_param),
            "::",
            stringify!(flags)
        )
    );
}
impl Default for kernel_param {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kparam_string {
    pub maxlen: c_types::c_uint,
    pub string: *mut c_types::c_char,
}
#[test]
fn bindgen_test_layout_kparam_string() {
    assert_eq!(
        ::core::mem::size_of::<kparam_string>(),
        16usize,
        concat!("Size of: ", stringify!(kparam_string))
    );
    assert_eq!(
        ::core::mem::align_of::<kparam_string>(),
        8usize,
        concat!("Alignment of ", stringify!(kparam_string))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kparam_string>())).maxlen as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kparam_string),
            "::",
            stringify!(maxlen)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kparam_string>())).string as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(kparam_string),
            "::",
            stringify!(string)
        )
    );
}
impl Default for kparam_string {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kparam_array {
    pub max: c_types::c_uint,
    pub elemsize: c_types::c_uint,
    pub num: *mut c_types::c_uint,
    pub ops: *const kernel_param_ops,
    pub elem: *mut c_types::c_void,
}
#[test]
fn bindgen_test_layout_kparam_array() {
    assert_eq!(
        ::core::mem::size_of::<kparam_array>(),
        32usize,
        concat!("Size of: ", stringify!(kparam_array))
    );
    assert_eq!(
        ::core::mem::align_of::<kparam_array>(),
        8usize,
        concat!("Alignment of ", stringify!(kparam_array))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kparam_array>())).max as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kparam_array),
            "::",
            stringify!(max)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kparam_array>())).elemsize as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(kparam_array),
            "::",
            stringify!(elemsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kparam_array>())).num as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(kparam_array),
            "::",
            stringify!(num)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kparam_array>())).ops as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(kparam_array),
            "::",
            stringify!(ops)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kparam_array>())).elem as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(kparam_array),
            "::",
            stringify!(elem)
        )
    );
}
impl Default for kparam_array {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct error_injection_entry {
    pub addr: c_types::c_ulong,
    pub etype: c_types::c_int,
}
#[test]
fn bindgen_test_layout_error_injection_entry() {
    assert_eq!(
        ::core::mem::size_of::<error_injection_entry>(),
        16usize,
        concat!("Size of: ", stringify!(error_injection_entry))
    );
    assert_eq!(
        ::core::mem::align_of::<error_injection_entry>(),
        8usize,
        concat!("Alignment of ", stringify!(error_injection_entry))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<error_injection_entry>())).addr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(error_injection_entry),
            "::",
            stringify!(addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<error_injection_entry>())).etype as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(error_injection_entry),
            "::",
            stringify!(etype)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct mod_arch_specific {}
#[test]
fn bindgen_test_layout_mod_arch_specific() {
    assert_eq!(
        ::core::mem::size_of::<mod_arch_specific>(),
        0usize,
        concat!("Size of: ", stringify!(mod_arch_specific))
    );
    assert_eq!(
        ::core::mem::align_of::<mod_arch_specific>(),
        1usize,
        concat!("Alignment of ", stringify!(mod_arch_specific))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct module_kobject {
    pub kobj: kobject,
    pub mod_: *mut module,
    pub drivers_dir: *mut kobject,
    pub mp: *mut module_param_attrs,
    pub kobj_completion: *mut completion,
}
#[test]
fn bindgen_test_layout_module_kobject() {
    assert_eq!(
        ::core::mem::size_of::<module_kobject>(),
        96usize,
        concat!("Size of: ", stringify!(module_kobject))
    );
    assert_eq!(
        ::core::mem::align_of::<module_kobject>(),
        8usize,
        concat!("Alignment of ", stringify!(module_kobject))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module_kobject>())).kobj as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(module_kobject),
            "::",
            stringify!(kobj)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module_kobject>())).mod_ as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(module_kobject),
            "::",
            stringify!(mod_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module_kobject>())).drivers_dir as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(module_kobject),
            "::",
            stringify!(drivers_dir)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module_kobject>())).mp as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(module_kobject),
            "::",
            stringify!(mp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module_kobject>())).kobj_completion as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(module_kobject),
            "::",
            stringify!(kobj_completion)
        )
    );
}
impl Default for module_kobject {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct module_attribute {
    pub attr: attribute,
    pub show: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut module_attribute,
            arg2: *mut module_kobject,
            arg3: *mut c_types::c_char,
        ) -> isize,
    >,
    pub store: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut module_attribute,
            arg2: *mut module_kobject,
            arg3: *const c_types::c_char,
            count: usize,
        ) -> isize,
    >,
    pub setup: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut module, arg2: *const c_types::c_char),
    >,
    pub test: ::core::option::Option<unsafe extern "C" fn(arg1: *mut module) -> c_types::c_int>,
    pub free: ::core::option::Option<unsafe extern "C" fn(arg1: *mut module)>,
}
#[test]
fn bindgen_test_layout_module_attribute() {
    assert_eq!(
        ::core::mem::size_of::<module_attribute>(),
        56usize,
        concat!("Size of: ", stringify!(module_attribute))
    );
    assert_eq!(
        ::core::mem::align_of::<module_attribute>(),
        8usize,
        concat!("Alignment of ", stringify!(module_attribute))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module_attribute>())).attr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(module_attribute),
            "::",
            stringify!(attr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module_attribute>())).show as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(module_attribute),
            "::",
            stringify!(show)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module_attribute>())).store as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(module_attribute),
            "::",
            stringify!(store)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module_attribute>())).setup as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(module_attribute),
            "::",
            stringify!(setup)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module_attribute>())).test as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(module_attribute),
            "::",
            stringify!(test)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module_attribute>())).free as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(module_attribute),
            "::",
            stringify!(free)
        )
    );
}
impl Default for module_attribute {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub const module_state_MODULE_STATE_LIVE: module_state = 0;
pub const module_state_MODULE_STATE_COMING: module_state = 1;
pub const module_state_MODULE_STATE_GOING: module_state = 2;
pub const module_state_MODULE_STATE_UNFORMED: module_state = 3;
pub type module_state = c_types::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mod_tree_node {
    pub mod_: *mut module,
    pub node: latch_tree_node,
}
#[test]
fn bindgen_test_layout_mod_tree_node() {
    assert_eq!(
        ::core::mem::size_of::<mod_tree_node>(),
        56usize,
        concat!("Size of: ", stringify!(mod_tree_node))
    );
    assert_eq!(
        ::core::mem::align_of::<mod_tree_node>(),
        8usize,
        concat!("Alignment of ", stringify!(mod_tree_node))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mod_tree_node>())).mod_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mod_tree_node),
            "::",
            stringify!(mod_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mod_tree_node>())).node as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mod_tree_node),
            "::",
            stringify!(node)
        )
    );
}
impl Default for mod_tree_node {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct module_layout {
    pub base: *mut c_types::c_void,
    pub size: c_types::c_uint,
    pub text_size: c_types::c_uint,
    pub ro_size: c_types::c_uint,
    pub ro_after_init_size: c_types::c_uint,
    pub mtn: mod_tree_node,
}
#[test]
fn bindgen_test_layout_module_layout() {
    assert_eq!(
        ::core::mem::size_of::<module_layout>(),
        80usize,
        concat!("Size of: ", stringify!(module_layout))
    );
    assert_eq!(
        ::core::mem::align_of::<module_layout>(),
        8usize,
        concat!("Alignment of ", stringify!(module_layout))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module_layout>())).base as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(module_layout),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module_layout>())).size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(module_layout),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module_layout>())).text_size as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(module_layout),
            "::",
            stringify!(text_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module_layout>())).ro_size as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(module_layout),
            "::",
            stringify!(ro_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<module_layout>())).ro_after_init_size as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(module_layout),
            "::",
            stringify!(ro_after_init_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module_layout>())).mtn as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(module_layout),
            "::",
            stringify!(mtn)
        )
    );
}
impl Default for module_layout {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mod_kallsyms {
    pub symtab: *mut Elf64_Sym,
    pub num_symtab: c_types::c_uint,
    pub strtab: *mut c_types::c_char,
    pub typetab: *mut c_types::c_char,
}
#[test]
fn bindgen_test_layout_mod_kallsyms() {
    assert_eq!(
        ::core::mem::size_of::<mod_kallsyms>(),
        32usize,
        concat!("Size of: ", stringify!(mod_kallsyms))
    );
    assert_eq!(
        ::core::mem::align_of::<mod_kallsyms>(),
        8usize,
        concat!("Alignment of ", stringify!(mod_kallsyms))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mod_kallsyms>())).symtab as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mod_kallsyms),
            "::",
            stringify!(symtab)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mod_kallsyms>())).num_symtab as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mod_kallsyms),
            "::",
            stringify!(num_symtab)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mod_kallsyms>())).strtab as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(mod_kallsyms),
            "::",
            stringify!(strtab)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mod_kallsyms>())).typetab as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(mod_kallsyms),
            "::",
            stringify!(typetab)
        )
    );
}
impl Default for mod_kallsyms {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct klp_modinfo {
    pub hdr: Elf64_Ehdr,
    pub sechdrs: *mut Elf64_Shdr,
    pub secstrings: *mut c_types::c_char,
    pub symndx: c_types::c_uint,
}
#[test]
fn bindgen_test_layout_klp_modinfo() {
    assert_eq!(
        ::core::mem::size_of::<klp_modinfo>(),
        88usize,
        concat!("Size of: ", stringify!(klp_modinfo))
    );
    assert_eq!(
        ::core::mem::align_of::<klp_modinfo>(),
        8usize,
        concat!("Alignment of ", stringify!(klp_modinfo))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<klp_modinfo>())).hdr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(klp_modinfo),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<klp_modinfo>())).sechdrs as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(klp_modinfo),
            "::",
            stringify!(sechdrs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<klp_modinfo>())).secstrings as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(klp_modinfo),
            "::",
            stringify!(secstrings)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<klp_modinfo>())).symndx as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(klp_modinfo),
            "::",
            stringify!(symndx)
        )
    );
}
impl Default for klp_modinfo {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[doc = "\t\tTraffic control messages."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct tcmsg {
    pub tcm_family: c_types::c_uchar,
    pub tcm__pad1: c_types::c_uchar,
    pub tcm__pad2: c_types::c_ushort,
    pub tcm_ifindex: c_types::c_int,
    pub tcm_handle: __u32,
    pub tcm_parent: __u32,
    pub tcm_info: __u32,
}
#[test]
fn bindgen_test_layout_tcmsg() {
    assert_eq!(
        ::core::mem::size_of::<tcmsg>(),
        20usize,
        concat!("Size of: ", stringify!(tcmsg))
    );
    assert_eq!(
        ::core::mem::align_of::<tcmsg>(),
        4usize,
        concat!("Alignment of ", stringify!(tcmsg))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tcmsg>())).tcm_family as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tcmsg),
            "::",
            stringify!(tcm_family)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tcmsg>())).tcm__pad1 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(tcmsg),
            "::",
            stringify!(tcm__pad1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tcmsg>())).tcm__pad2 as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(tcmsg),
            "::",
            stringify!(tcm__pad2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tcmsg>())).tcm_ifindex as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tcmsg),
            "::",
            stringify!(tcm_ifindex)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tcmsg>())).tcm_handle as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tcmsg),
            "::",
            stringify!(tcm_handle)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tcmsg>())).tcm_parent as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(tcmsg),
            "::",
            stringify!(tcm_parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tcmsg>())).tcm_info as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tcmsg),
            "::",
            stringify!(tcm_info)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct gnet_stats_basic_packed {
    pub bytes: __u64,
    pub packets: __u32,
}
#[test]
fn bindgen_test_layout_gnet_stats_basic_packed() {
    assert_eq!(
        ::core::mem::size_of::<gnet_stats_basic_packed>(),
        12usize,
        concat!("Size of: ", stringify!(gnet_stats_basic_packed))
    );
    assert_eq!(
        ::core::mem::align_of::<gnet_stats_basic_packed>(),
        1usize,
        concat!("Alignment of ", stringify!(gnet_stats_basic_packed))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<gnet_stats_basic_packed>())).bytes as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gnet_stats_basic_packed),
            "::",
            stringify!(bytes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<gnet_stats_basic_packed>())).packets as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(gnet_stats_basic_packed),
            "::",
            stringify!(packets)
        )
    );
}
#[doc = " struct gnet_stats_queue - queuing statistics"]
#[doc = " @qlen: queue length"]
#[doc = " @backlog: backlog size of queue"]
#[doc = " @drops: number of dropped packets"]
#[doc = " @requeues: number of requeues"]
#[doc = " @overlimits: number of enqueues over the limit"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct gnet_stats_queue {
    pub qlen: __u32,
    pub backlog: __u32,
    pub drops: __u32,
    pub requeues: __u32,
    pub overlimits: __u32,
}
#[test]
fn bindgen_test_layout_gnet_stats_queue() {
    assert_eq!(
        ::core::mem::size_of::<gnet_stats_queue>(),
        20usize,
        concat!("Size of: ", stringify!(gnet_stats_queue))
    );
    assert_eq!(
        ::core::mem::align_of::<gnet_stats_queue>(),
        4usize,
        concat!("Alignment of ", stringify!(gnet_stats_queue))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<gnet_stats_queue>())).qlen as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gnet_stats_queue),
            "::",
            stringify!(qlen)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<gnet_stats_queue>())).backlog as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(gnet_stats_queue),
            "::",
            stringify!(backlog)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<gnet_stats_queue>())).drops as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(gnet_stats_queue),
            "::",
            stringify!(drops)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<gnet_stats_queue>())).requeues as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(gnet_stats_queue),
            "::",
            stringify!(requeues)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<gnet_stats_queue>())).overlimits as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(gnet_stats_queue),
            "::",
            stringify!(overlimits)
        )
    );
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Default, Copy, Clone)]
pub struct gnet_stats_basic_cpu {
    pub bstats: gnet_stats_basic_packed,
    pub syncp: u64_stats_sync,
}
#[test]
fn bindgen_test_layout_gnet_stats_basic_cpu() {
    assert_eq!(
        ::core::mem::size_of::<gnet_stats_basic_cpu>(),
        16usize,
        concat!("Size of: ", stringify!(gnet_stats_basic_cpu))
    );
    assert_eq!(
        ::core::mem::align_of::<gnet_stats_basic_cpu>(),
        16usize,
        concat!("Alignment of ", stringify!(gnet_stats_basic_cpu))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<gnet_stats_basic_cpu>())).bstats as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gnet_stats_basic_cpu),
            "::",
            stringify!(bstats)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<gnet_stats_basic_cpu>())).syncp as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(gnet_stats_basic_cpu),
            "::",
            stringify!(syncp)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct net_rate_estimator {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gnet_dump {
    pub lock: *mut spinlock_t,
    pub skb: *mut sk_buff,
    pub tail: *mut nlattr,
    pub compat_tc_stats: c_types::c_int,
    pub compat_xstats: c_types::c_int,
    pub padattr: c_types::c_int,
    pub xstats: *mut c_types::c_void,
    pub xstats_len: c_types::c_int,
    pub tc_stats: tc_stats,
}
#[test]
fn bindgen_test_layout_gnet_dump() {
    assert_eq!(
        ::core::mem::size_of::<gnet_dump>(),
        96usize,
        concat!("Size of: ", stringify!(gnet_dump))
    );
    assert_eq!(
        ::core::mem::align_of::<gnet_dump>(),
        8usize,
        concat!("Alignment of ", stringify!(gnet_dump))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<gnet_dump>())).lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gnet_dump),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<gnet_dump>())).skb as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(gnet_dump),
            "::",
            stringify!(skb)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<gnet_dump>())).tail as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(gnet_dump),
            "::",
            stringify!(tail)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<gnet_dump>())).compat_tc_stats as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(gnet_dump),
            "::",
            stringify!(compat_tc_stats)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<gnet_dump>())).compat_xstats as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(gnet_dump),
            "::",
            stringify!(compat_xstats)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<gnet_dump>())).padattr as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(gnet_dump),
            "::",
            stringify!(padattr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<gnet_dump>())).xstats as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(gnet_dump),
            "::",
            stringify!(xstats)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<gnet_dump>())).xstats_len as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(gnet_dump),
            "::",
            stringify!(xstats_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<gnet_dump>())).tc_stats as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(gnet_dump),
            "::",
            stringify!(tc_stats)
        )
    );
}
impl Default for gnet_dump {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[doc = " struct nla_policy - attribute validation policy"]
#[doc = " @type: Type of attribute or NLA_UNSPEC"]
#[doc = " @validation_type: type of attribute validation done in addition to"]
#[doc = "\ttype-specific validation (e.g. range, function call), see"]
#[doc = "\t&enum nla_policy_validation"]
#[doc = " @len: Type specific length of payload"]
#[doc = ""]
#[doc = " Policies are defined as arrays of this struct, the array must be"]
#[doc = " accessible by attribute type up to the highest identifier to be expected."]
#[doc = ""]
#[doc = " Meaning of `len' field:"]
#[doc = "    NLA_STRING           Maximum length of string"]
#[doc = "    NLA_NUL_STRING       Maximum length of string (excluding NUL)"]
#[doc = "    NLA_FLAG             Unused"]
#[doc = "    NLA_BINARY           Maximum length of attribute payload"]
#[doc = "    NLA_MIN_LEN          Minimum length of attribute payload"]
#[doc = "    NLA_NESTED,"]
#[doc = "    NLA_NESTED_ARRAY     Length verification is done by checking len of"]
#[doc = "                         nested header (or empty); len field is used if"]
#[doc = "                         validation_data is also used, for the max attr"]
#[doc = "                         number in the nested policy."]
#[doc = "    NLA_U8, NLA_U16,"]
#[doc = "    NLA_U32, NLA_U64,"]
#[doc = "    NLA_S8, NLA_S16,"]
#[doc = "    NLA_S32, NLA_S64,"]
#[doc = "    NLA_MSECS            Leaving the length field zero will verify the"]
#[doc = "                         given type fits, using it verifies minimum length"]
#[doc = "                         just like \"All other\""]
#[doc = "    NLA_BITFIELD32       Unused"]
#[doc = "    NLA_REJECT           Unused"]
#[doc = "    NLA_EXACT_LEN        Attribute must have exactly this length, otherwise"]
#[doc = "                         it is rejected."]
#[doc = "    NLA_EXACT_LEN_WARN   Attribute should have exactly this length, a warning"]
#[doc = "                         is logged if it is longer, shorter is rejected."]
#[doc = "    NLA_MIN_LEN          Minimum length of attribute payload"]
#[doc = "    All other            Minimum length of attribute payload"]
#[doc = ""]
#[doc = " Meaning of `validation_data' field:"]
#[doc = "    NLA_BITFIELD32       This is a 32-bit bitmap/bitselector attribute and"]
#[doc = "                         validation data must point to a u32 value of valid"]
#[doc = "                         flags"]
#[doc = "    NLA_REJECT           This attribute is always rejected and validation data"]
#[doc = "                         may point to a string to report as the error instead"]
#[doc = "                         of the generic one in extended ACK."]
#[doc = "    NLA_NESTED           Points to a nested policy to validate, must also set"]
#[doc = "                         `len' to the max attribute number."]
#[doc = "                         Note that nla_parse() will validate, but of course not"]
#[doc = "                         parse, the nested sub-policies."]
#[doc = "    NLA_NESTED_ARRAY     Points to a nested policy to validate, must also set"]
#[doc = "                         `len' to the max attribute number. The difference to"]
#[doc = "                         NLA_NESTED is the structure - NLA_NESTED has the"]
#[doc = "                         nested attributes directly inside, while an array has"]
#[doc = "                         the nested attributes at another level down and the"]
#[doc = "                         attributes directly in the nesting don't matter."]
#[doc = "    All other            Unused - but note that it's a union"]
#[doc = ""]
#[doc = " Meaning of `min' and `max' fields, use via NLA_POLICY_MIN, NLA_POLICY_MAX"]
#[doc = " and NLA_POLICY_RANGE:"]
#[doc = "    NLA_U8,"]
#[doc = "    NLA_U16,"]
#[doc = "    NLA_U32,"]
#[doc = "    NLA_U64,"]
#[doc = "    NLA_S8,"]
#[doc = "    NLA_S16,"]
#[doc = "    NLA_S32,"]
#[doc = "    NLA_S64              These are used depending on the validation_type"]
#[doc = "                         field, if that is min/max/range then the minimum,"]
#[doc = "                         maximum and both are used (respectively) to check"]
#[doc = "                         the value of the integer attribute."]
#[doc = "                         Note that in the interest of code simplicity and"]
#[doc = "                         struct size both limits are s16, so you cannot"]
#[doc = "                         enforce a range that doesn't fall within the range"]
#[doc = "                         of s16 - do that as usual in the code instead."]
#[doc = "    All other            Unused - but note that it's a union"]
#[doc = ""]
#[doc = " Meaning of `validate' field, use via NLA_POLICY_VALIDATE_FN:"]
#[doc = "    NLA_BINARY           Validation function called for the attribute,"]
#[doc = "                         not compatible with use of the validation_data"]
#[doc = "                         as in NLA_BITFIELD32, NLA_REJECT, NLA_NESTED and"]
#[doc = "                         NLA_NESTED_ARRAY."]
#[doc = "    All other            Unused - but note that it's a union"]
#[doc = ""]
#[doc = " Example:"]
#[doc = " static const struct nla_policy my_policy[ATTR_MAX+1] = {"]
#[doc = " \t[ATTR_FOO] = { .type = NLA_U16 },"]
#[doc = "\t[ATTR_BAR] = { .type = NLA_STRING, .len = BARSIZ },"]
#[doc = "\t[ATTR_BAZ] = { .type = NLA_EXACT_LEN, .len = sizeof(struct mystruct) },"]
#[doc = "\t[ATTR_GOO] = { .type = NLA_BITFIELD32, .validation_data = &myvalidflags },"]
#[doc = " };"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nla_policy {
    pub type_: u8_,
    pub validation_type: u8_,
    pub len: u16_,
    pub __bindgen_anon_1: nla_policy__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union nla_policy__bindgen_ty_1 {
    pub validation_data: *const c_types::c_void,
    pub __bindgen_anon_1: nla_policy__bindgen_ty_1__bindgen_ty_1,
    pub validate: ::core::option::Option<
        unsafe extern "C" fn(attr: *const nlattr, extack: *mut netlink_ext_ack) -> c_types::c_int,
    >,
    pub strict_start_type: u16_,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct nla_policy__bindgen_ty_1__bindgen_ty_1 {
    pub min: s16,
    pub max: s16,
}
#[test]
fn bindgen_test_layout_nla_policy__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<nla_policy__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(nla_policy__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<nla_policy__bindgen_ty_1__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(nla_policy__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<nla_policy__bindgen_ty_1__bindgen_ty_1>())).min as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nla_policy__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(min)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<nla_policy__bindgen_ty_1__bindgen_ty_1>())).max as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(nla_policy__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(max)
        )
    );
}
#[test]
fn bindgen_test_layout_nla_policy__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<nla_policy__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(nla_policy__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<nla_policy__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(nla_policy__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<nla_policy__bindgen_ty_1>())).validation_data as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nla_policy__bindgen_ty_1),
            "::",
            stringify!(validation_data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<nla_policy__bindgen_ty_1>())).validate as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nla_policy__bindgen_ty_1),
            "::",
            stringify!(validate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<nla_policy__bindgen_ty_1>())).strict_start_type as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nla_policy__bindgen_ty_1),
            "::",
            stringify!(strict_start_type)
        )
    );
}
impl Default for nla_policy__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_nla_policy() {
    assert_eq!(
        ::core::mem::size_of::<nla_policy>(),
        16usize,
        concat!("Size of: ", stringify!(nla_policy))
    );
    assert_eq!(
        ::core::mem::align_of::<nla_policy>(),
        8usize,
        concat!("Alignment of ", stringify!(nla_policy))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nla_policy>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nla_policy),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nla_policy>())).validation_type as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(nla_policy),
            "::",
            stringify!(validation_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nla_policy>())).len as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(nla_policy),
            "::",
            stringify!(len)
        )
    );
}
impl Default for nla_policy {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[doc = "\tstruct rtnl_link_ops - rtnetlink link operations"]
#[doc = ""]
#[doc = "\t@list: Used internally"]
#[doc = "\t@kind: Identifier"]
#[doc = "\t@maxtype: Highest device specific netlink attribute number"]
#[doc = "\t@policy: Netlink policy for device specific attribute validation"]
#[doc = "\t@validate: Optional validation function for netlink/changelink parameters"]
#[doc = "\t@priv_size: sizeof net_device private space"]
#[doc = "\t@setup: net_device setup function"]
#[doc = "\t@newlink: Function for configuring and registering a new device"]
#[doc = "\t@changelink: Function for changing parameters of an existing device"]
#[doc = "\t@dellink: Function to remove a device"]
#[doc = "\t@get_size: Function to calculate required room for dumping device"]
#[doc = "\t\t   specific netlink attributes"]
#[doc = "\t@fill_info: Function to dump device specific netlink attributes"]
#[doc = "\t@get_xstats_size: Function to calculate required room for dumping device"]
#[doc = "\t\t\t  specific statistics"]
#[doc = "\t@fill_xstats: Function to dump device specific statistics"]
#[doc = "\t@get_num_tx_queues: Function to determine number of transmit queues"]
#[doc = "\t\t\t    to create when creating a new device."]
#[doc = "\t@get_num_rx_queues: Function to determine number of receive queues"]
#[doc = "\t\t\t    to create when creating a new device."]
#[doc = "\t@get_link_net: Function to get the i/o netns of the device"]
#[doc = "\t@get_linkxstats_size: Function to calculate the required room for"]
#[doc = "\t\t\t      dumping device-specific extended link stats"]
#[doc = "\t@fill_linkxstats: Function to dump device-specific extended link stats"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rtnl_link_ops {
    pub list: list_head,
    pub kind: *const c_types::c_char,
    pub priv_size: usize,
    pub setup: ::core::option::Option<unsafe extern "C" fn(dev: *mut net_device)>,
    pub maxtype: c_types::c_uint,
    pub policy: *const nla_policy,
    pub validate: ::core::option::Option<
        unsafe extern "C" fn(
            tb: *mut *mut nlattr,
            data: *mut *mut nlattr,
            extack: *mut netlink_ext_ack,
        ) -> c_types::c_int,
    >,
    pub newlink: ::core::option::Option<
        unsafe extern "C" fn(
            src_net: *mut net,
            dev: *mut net_device,
            tb: *mut *mut nlattr,
            data: *mut *mut nlattr,
            extack: *mut netlink_ext_ack,
        ) -> c_types::c_int,
    >,
    pub changelink: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut net_device,
            tb: *mut *mut nlattr,
            data: *mut *mut nlattr,
            extack: *mut netlink_ext_ack,
        ) -> c_types::c_int,
    >,
    pub dellink:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut net_device, head: *mut list_head)>,
    pub get_size: ::core::option::Option<unsafe extern "C" fn(dev: *const net_device) -> usize>,
    pub fill_info: ::core::option::Option<
        unsafe extern "C" fn(skb: *mut sk_buff, dev: *const net_device) -> c_types::c_int,
    >,
    pub get_xstats_size:
        ::core::option::Option<unsafe extern "C" fn(dev: *const net_device) -> usize>,
    pub fill_xstats: ::core::option::Option<
        unsafe extern "C" fn(skb: *mut sk_buff, dev: *const net_device) -> c_types::c_int,
    >,
    pub get_num_tx_queues: ::core::option::Option<unsafe extern "C" fn() -> c_types::c_uint>,
    pub get_num_rx_queues: ::core::option::Option<unsafe extern "C" fn() -> c_types::c_uint>,
    pub slave_maxtype: c_types::c_uint,
    pub slave_policy: *const nla_policy,
    pub slave_changelink: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut net_device,
            slave_dev: *mut net_device,
            tb: *mut *mut nlattr,
            data: *mut *mut nlattr,
            extack: *mut netlink_ext_ack,
        ) -> c_types::c_int,
    >,
    pub get_slave_size: ::core::option::Option<
        unsafe extern "C" fn(dev: *const net_device, slave_dev: *const net_device) -> usize,
    >,
    pub fill_slave_info: ::core::option::Option<
        unsafe extern "C" fn(
            skb: *mut sk_buff,
            dev: *const net_device,
            slave_dev: *const net_device,
        ) -> c_types::c_int,
    >,
    pub get_link_net:
        ::core::option::Option<unsafe extern "C" fn(dev: *const net_device) -> *mut net>,
    pub get_linkxstats_size: ::core::option::Option<
        unsafe extern "C" fn(dev: *const net_device, attr: c_types::c_int) -> usize,
    >,
    pub fill_linkxstats: ::core::option::Option<
        unsafe extern "C" fn(
            skb: *mut sk_buff,
            dev: *const net_device,
            prividx: *mut c_types::c_int,
            attr: c_types::c_int,
        ) -> c_types::c_int,
    >,
}
#[test]
fn bindgen_test_layout_rtnl_link_ops() {
    assert_eq!(
        ::core::mem::size_of::<rtnl_link_ops>(),
        200usize,
        concat!("Size of: ", stringify!(rtnl_link_ops))
    );
    assert_eq!(
        ::core::mem::align_of::<rtnl_link_ops>(),
        8usize,
        concat!("Alignment of ", stringify!(rtnl_link_ops))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rtnl_link_ops>())).list as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rtnl_link_ops),
            "::",
            stringify!(list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rtnl_link_ops>())).kind as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rtnl_link_ops),
            "::",
            stringify!(kind)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rtnl_link_ops>())).priv_size as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rtnl_link_ops),
            "::",
            stringify!(priv_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rtnl_link_ops>())).setup as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rtnl_link_ops),
            "::",
            stringify!(setup)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rtnl_link_ops>())).maxtype as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rtnl_link_ops),
            "::",
            stringify!(maxtype)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rtnl_link_ops>())).policy as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rtnl_link_ops),
            "::",
            stringify!(policy)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rtnl_link_ops>())).validate as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rtnl_link_ops),
            "::",
            stringify!(validate)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rtnl_link_ops>())).newlink as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rtnl_link_ops),
            "::",
            stringify!(newlink)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rtnl_link_ops>())).changelink as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rtnl_link_ops),
            "::",
            stringify!(changelink)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rtnl_link_ops>())).dellink as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rtnl_link_ops),
            "::",
            stringify!(dellink)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rtnl_link_ops>())).get_size as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rtnl_link_ops),
            "::",
            stringify!(get_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rtnl_link_ops>())).fill_info as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rtnl_link_ops),
            "::",
            stringify!(fill_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rtnl_link_ops>())).get_xstats_size as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rtnl_link_ops),
            "::",
            stringify!(get_xstats_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rtnl_link_ops>())).fill_xstats as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rtnl_link_ops),
            "::",
            stringify!(fill_xstats)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rtnl_link_ops>())).get_num_tx_queues as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(rtnl_link_ops),
            "::",
            stringify!(get_num_tx_queues)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rtnl_link_ops>())).get_num_rx_queues as *const _ as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(rtnl_link_ops),
            "::",
            stringify!(get_num_rx_queues)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rtnl_link_ops>())).slave_maxtype as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(rtnl_link_ops),
            "::",
            stringify!(slave_maxtype)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rtnl_link_ops>())).slave_policy as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(rtnl_link_ops),
            "::",
            stringify!(slave_policy)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rtnl_link_ops>())).slave_changelink as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(rtnl_link_ops),
            "::",
            stringify!(slave_changelink)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rtnl_link_ops>())).get_slave_size as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(rtnl_link_ops),
            "::",
            stringify!(get_slave_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rtnl_link_ops>())).fill_slave_info as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(rtnl_link_ops),
            "::",
            stringify!(fill_slave_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rtnl_link_ops>())).get_link_net as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(rtnl_link_ops),
            "::",
            stringify!(get_link_net)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rtnl_link_ops>())).get_linkxstats_size as *const _ as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(rtnl_link_ops),
            "::",
            stringify!(get_linkxstats_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rtnl_link_ops>())).fill_linkxstats as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(rtnl_link_ops),
            "::",
            stringify!(fill_linkxstats)
        )
    );
}
impl Default for rtnl_link_ops {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rhash_lock_head {}
#[test]
fn bindgen_test_layout_rhash_lock_head() {
    assert_eq!(
        ::core::mem::size_of::<rhash_lock_head>(),
        0usize,
        concat!("Size of: ", stringify!(rhash_lock_head))
    );
    assert_eq!(
        ::core::mem::align_of::<rhash_lock_head>(),
        1usize,
        concat!("Alignment of ", stringify!(rhash_lock_head))
    );
}
#[doc = " struct bucket_table - Table of hash buckets"]
#[doc = " @size: Number of hash buckets"]
#[doc = " @nest: Number of bits of first-level nested table."]
#[doc = " @rehash: Current bucket being rehashed"]
#[doc = " @hash_rnd: Random seed to fold into hash"]
#[doc = " @walkers: List of active walkers"]
#[doc = " @rcu: RCU structure for freeing the table"]
#[doc = " @future_tbl: Table under construction during rehashing"]
#[doc = " @ntbl: Nested table used when out of memory."]
#[doc = " @buckets: size * hash buckets"]
#[repr(C)]
#[repr(align(64))]
pub struct bucket_table {
    pub size: c_types::c_uint,
    pub nest: c_types::c_uint,
    pub hash_rnd: u32_,
    pub walkers: list_head,
    pub rcu: callback_head,
    pub future_tbl: *mut bucket_table,
    pub dep_map: lockdep_map,
    pub __bindgen_padding_0: u64,
    pub buckets: __IncompleteArrayField<*mut rhash_lock_head>,
}
#[test]
fn bindgen_test_layout_bucket_table() {
    assert_eq!(
        ::core::mem::size_of::<bucket_table>(),
        64usize,
        concat!("Size of: ", stringify!(bucket_table))
    );
    assert_eq!(
        ::core::mem::align_of::<bucket_table>(),
        64usize,
        concat!("Alignment of ", stringify!(bucket_table))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bucket_table>())).size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bucket_table),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bucket_table>())).nest as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(bucket_table),
            "::",
            stringify!(nest)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bucket_table>())).hash_rnd as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bucket_table),
            "::",
            stringify!(hash_rnd)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bucket_table>())).walkers as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(bucket_table),
            "::",
            stringify!(walkers)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bucket_table>())).rcu as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(bucket_table),
            "::",
            stringify!(rcu)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bucket_table>())).future_tbl as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(bucket_table),
            "::",
            stringify!(future_tbl)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bucket_table>())).dep_map as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(bucket_table),
            "::",
            stringify!(dep_map)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bucket_table>())).buckets as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(bucket_table),
            "::",
            stringify!(buckets)
        )
    );
}
impl Default for bucket_table {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct flow_block {
    pub cb_list: list_head,
}
#[test]
fn bindgen_test_layout_flow_block() {
    assert_eq!(
        ::core::mem::size_of::<flow_block>(),
        16usize,
        concat!("Size of: ", stringify!(flow_block))
    );
    assert_eq!(
        ::core::mem::align_of::<flow_block>(),
        8usize,
        concat!("Alignment of ", stringify!(flow_block))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<flow_block>())).cb_list as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(flow_block),
            "::",
            stringify!(cb_list)
        )
    );
}
impl Default for flow_block {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type flow_setup_cb_t = ::core::option::Option<
    unsafe extern "C" fn(
        type_: tc_setup_type,
        type_data: *mut c_types::c_void,
        cb_priv: *mut c_types::c_void,
    ) -> c_types::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct qdisc_walker {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tcf_walker {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct qdisc_size_table {
    pub rcu: callback_head,
    pub list: list_head,
    pub szopts: tc_sizespec,
    pub refcnt: c_types::c_int,
    pub data: __IncompleteArrayField<u16_>,
}
#[test]
fn bindgen_test_layout_qdisc_size_table() {
    assert_eq!(
        ::core::mem::size_of::<qdisc_size_table>(),
        64usize,
        concat!("Size of: ", stringify!(qdisc_size_table))
    );
    assert_eq!(
        ::core::mem::align_of::<qdisc_size_table>(),
        8usize,
        concat!("Alignment of ", stringify!(qdisc_size_table))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<qdisc_size_table>())).rcu as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qdisc_size_table),
            "::",
            stringify!(rcu)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<qdisc_size_table>())).list as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(qdisc_size_table),
            "::",
            stringify!(list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<qdisc_size_table>())).szopts as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(qdisc_size_table),
            "::",
            stringify!(szopts)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<qdisc_size_table>())).refcnt as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(qdisc_size_table),
            "::",
            stringify!(refcnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<qdisc_size_table>())).data as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(qdisc_size_table),
            "::",
            stringify!(data)
        )
    );
}
impl Default for qdisc_size_table {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct qdisc_skb_head {
    pub head: *mut sk_buff,
    pub tail: *mut sk_buff,
    pub qlen: __u32,
    pub lock: spinlock_t,
}
#[test]
fn bindgen_test_layout_qdisc_skb_head() {
    assert_eq!(
        ::core::mem::size_of::<qdisc_skb_head>(),
        24usize,
        concat!("Size of: ", stringify!(qdisc_skb_head))
    );
    assert_eq!(
        ::core::mem::align_of::<qdisc_skb_head>(),
        8usize,
        concat!("Alignment of ", stringify!(qdisc_skb_head))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<qdisc_skb_head>())).head as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qdisc_skb_head),
            "::",
            stringify!(head)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<qdisc_skb_head>())).tail as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(qdisc_skb_head),
            "::",
            stringify!(tail)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<qdisc_skb_head>())).qlen as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(qdisc_skb_head),
            "::",
            stringify!(qlen)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<qdisc_skb_head>())).lock as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(qdisc_skb_head),
            "::",
            stringify!(lock)
        )
    );
}
impl Default for qdisc_skb_head {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct Qdisc {
    pub enqueue: ::core::option::Option<
        unsafe extern "C" fn(
            skb: *mut sk_buff,
            sch: *mut Qdisc,
            to_free: *mut *mut sk_buff,
        ) -> c_types::c_int,
    >,
    pub dequeue: ::core::option::Option<unsafe extern "C" fn(sch: *mut Qdisc) -> *mut sk_buff>,
    pub flags: c_types::c_uint,
    pub limit: u32_,
    pub ops: *const Qdisc_ops,
    pub stab: *mut qdisc_size_table,
    pub hash: hlist_node,
    pub handle: u32_,
    pub parent: u32_,
    pub dev_queue: *mut netdev_queue,
    pub rate_est: *mut net_rate_estimator,
    pub cpu_bstats: *mut gnet_stats_basic_cpu,
    pub cpu_qstats: *mut gnet_stats_queue,
    pub padded: c_types::c_int,
    pub refcnt: refcount_t,
    pub __bindgen_padding_0: [u64; 3usize],
    pub gso_skb: sk_buff_head,
    pub q: qdisc_skb_head,
    pub bstats: gnet_stats_basic_packed,
    pub running: seqcount_t,
    pub qstats: gnet_stats_queue,
    pub state: c_types::c_ulong,
    pub next_sched: *mut Qdisc,
    pub skb_bad_txq: sk_buff_head,
    pub busylock: spinlock_t,
    pub seqlock: spinlock_t,
    pub empty: bool_,
    pub rcu: callback_head,
}
#[test]
fn bindgen_test_layout_Qdisc() {
    assert_eq!(
        ::core::mem::size_of::<Qdisc>(),
        320usize,
        concat!("Size of: ", stringify!(Qdisc))
    );
    assert_eq!(
        ::core::mem::align_of::<Qdisc>(),
        64usize,
        concat!("Alignment of ", stringify!(Qdisc))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Qdisc>())).enqueue as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Qdisc),
            "::",
            stringify!(enqueue)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Qdisc>())).dequeue as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Qdisc),
            "::",
            stringify!(dequeue)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Qdisc>())).flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Qdisc),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Qdisc>())).limit as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(Qdisc),
            "::",
            stringify!(limit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Qdisc>())).ops as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Qdisc),
            "::",
            stringify!(ops)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Qdisc>())).stab as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(Qdisc),
            "::",
            stringify!(stab)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Qdisc>())).hash as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(Qdisc),
            "::",
            stringify!(hash)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Qdisc>())).handle as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(Qdisc),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Qdisc>())).parent as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(Qdisc),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Qdisc>())).dev_queue as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(Qdisc),
            "::",
            stringify!(dev_queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Qdisc>())).rate_est as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(Qdisc),
            "::",
            stringify!(rate_est)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Qdisc>())).cpu_bstats as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(Qdisc),
            "::",
            stringify!(cpu_bstats)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Qdisc>())).cpu_qstats as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(Qdisc),
            "::",
            stringify!(cpu_qstats)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Qdisc>())).padded as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(Qdisc),
            "::",
            stringify!(padded)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Qdisc>())).refcnt as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(Qdisc),
            "::",
            stringify!(refcnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Qdisc>())).gso_skb as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(Qdisc),
            "::",
            stringify!(gso_skb)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Qdisc>())).q as *const _ as usize },
        152usize,
        concat!("Offset of field: ", stringify!(Qdisc), "::", stringify!(q))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Qdisc>())).bstats as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(Qdisc),
            "::",
            stringify!(bstats)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Qdisc>())).running as *const _ as usize },
        188usize,
        concat!(
            "Offset of field: ",
            stringify!(Qdisc),
            "::",
            stringify!(running)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Qdisc>())).qstats as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(Qdisc),
            "::",
            stringify!(qstats)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Qdisc>())).state as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(Qdisc),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Qdisc>())).next_sched as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(Qdisc),
            "::",
            stringify!(next_sched)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Qdisc>())).skb_bad_txq as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(Qdisc),
            "::",
            stringify!(skb_bad_txq)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Qdisc>())).busylock as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(Qdisc),
            "::",
            stringify!(busylock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Qdisc>())).seqlock as *const _ as usize },
        260usize,
        concat!(
            "Offset of field: ",
            stringify!(Qdisc),
            "::",
            stringify!(seqlock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Qdisc>())).empty as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(Qdisc),
            "::",
            stringify!(empty)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Qdisc>())).rcu as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(Qdisc),
            "::",
            stringify!(rcu)
        )
    );
}
impl Default for Qdisc {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct Qdisc_class_ops {
    pub flags: c_types::c_uint,
    pub select_queue: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut Qdisc, arg2: *mut tcmsg) -> *mut netdev_queue,
    >,
    pub graft: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut Qdisc,
            cl: c_types::c_ulong,
            arg2: *mut Qdisc,
            arg3: *mut *mut Qdisc,
            extack: *mut netlink_ext_ack,
        ) -> c_types::c_int,
    >,
    pub leaf: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut Qdisc, cl: c_types::c_ulong) -> *mut Qdisc,
    >,
    pub qlen_notify:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut Qdisc, arg2: c_types::c_ulong)>,
    pub find: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut Qdisc, classid: u32_) -> c_types::c_ulong,
    >,
    pub change: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut Qdisc,
            arg2: u32_,
            arg3: u32_,
            arg4: *mut *mut nlattr,
            arg5: *mut c_types::c_ulong,
            arg6: *mut netlink_ext_ack,
        ) -> c_types::c_int,
    >,
    pub delete: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut Qdisc, arg2: c_types::c_ulong) -> c_types::c_int,
    >,
    pub walk:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut Qdisc, arg: *mut qdisc_walker)>,
    pub tcf_block: ::core::option::Option<
        unsafe extern "C" fn(
            sch: *mut Qdisc,
            arg: c_types::c_ulong,
            extack: *mut netlink_ext_ack,
        ) -> *mut tcf_block,
    >,
    pub bind_tcf: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut Qdisc,
            arg2: c_types::c_ulong,
            classid: u32_,
        ) -> c_types::c_ulong,
    >,
    pub unbind_tcf:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut Qdisc, arg2: c_types::c_ulong)>,
    pub dump: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut Qdisc,
            arg2: c_types::c_ulong,
            skb: *mut sk_buff,
            arg3: *mut tcmsg,
        ) -> c_types::c_int,
    >,
    pub dump_stats: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut Qdisc,
            arg2: c_types::c_ulong,
            arg3: *mut gnet_dump,
        ) -> c_types::c_int,
    >,
}
#[test]
fn bindgen_test_layout_Qdisc_class_ops() {
    assert_eq!(
        ::core::mem::size_of::<Qdisc_class_ops>(),
        112usize,
        concat!("Size of: ", stringify!(Qdisc_class_ops))
    );
    assert_eq!(
        ::core::mem::align_of::<Qdisc_class_ops>(),
        8usize,
        concat!("Alignment of ", stringify!(Qdisc_class_ops))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Qdisc_class_ops>())).flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Qdisc_class_ops),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Qdisc_class_ops>())).select_queue as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Qdisc_class_ops),
            "::",
            stringify!(select_queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Qdisc_class_ops>())).graft as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Qdisc_class_ops),
            "::",
            stringify!(graft)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Qdisc_class_ops>())).leaf as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Qdisc_class_ops),
            "::",
            stringify!(leaf)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Qdisc_class_ops>())).qlen_notify as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(Qdisc_class_ops),
            "::",
            stringify!(qlen_notify)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Qdisc_class_ops>())).find as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(Qdisc_class_ops),
            "::",
            stringify!(find)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Qdisc_class_ops>())).change as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(Qdisc_class_ops),
            "::",
            stringify!(change)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Qdisc_class_ops>())).delete as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(Qdisc_class_ops),
            "::",
            stringify!(delete)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Qdisc_class_ops>())).walk as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(Qdisc_class_ops),
            "::",
            stringify!(walk)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Qdisc_class_ops>())).tcf_block as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(Qdisc_class_ops),
            "::",
            stringify!(tcf_block)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Qdisc_class_ops>())).bind_tcf as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(Qdisc_class_ops),
            "::",
            stringify!(bind_tcf)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Qdisc_class_ops>())).unbind_tcf as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(Qdisc_class_ops),
            "::",
            stringify!(unbind_tcf)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Qdisc_class_ops>())).dump as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(Qdisc_class_ops),
            "::",
            stringify!(dump)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Qdisc_class_ops>())).dump_stats as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(Qdisc_class_ops),
            "::",
            stringify!(dump_stats)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Qdisc_ops {
    pub next: *mut Qdisc_ops,
    pub cl_ops: *const Qdisc_class_ops,
    pub id: [c_types::c_char; 16usize],
    pub priv_size: c_types::c_int,
    pub static_flags: c_types::c_uint,
    pub enqueue: ::core::option::Option<
        unsafe extern "C" fn(
            skb: *mut sk_buff,
            sch: *mut Qdisc,
            to_free: *mut *mut sk_buff,
        ) -> c_types::c_int,
    >,
    pub dequeue: ::core::option::Option<unsafe extern "C" fn(arg1: *mut Qdisc) -> *mut sk_buff>,
    pub peek: ::core::option::Option<unsafe extern "C" fn(arg1: *mut Qdisc) -> *mut sk_buff>,
    pub init: ::core::option::Option<
        unsafe extern "C" fn(
            sch: *mut Qdisc,
            arg: *mut nlattr,
            extack: *mut netlink_ext_ack,
        ) -> c_types::c_int,
    >,
    pub reset: ::core::option::Option<unsafe extern "C" fn(arg1: *mut Qdisc)>,
    pub destroy: ::core::option::Option<unsafe extern "C" fn(arg1: *mut Qdisc)>,
    pub change: ::core::option::Option<
        unsafe extern "C" fn(
            sch: *mut Qdisc,
            arg: *mut nlattr,
            extack: *mut netlink_ext_ack,
        ) -> c_types::c_int,
    >,
    pub attach: ::core::option::Option<unsafe extern "C" fn(sch: *mut Qdisc)>,
    pub change_tx_queue_len: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut Qdisc, arg2: c_types::c_uint) -> c_types::c_int,
    >,
    pub dump: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut Qdisc, arg2: *mut sk_buff) -> c_types::c_int,
    >,
    pub dump_stats: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut Qdisc, arg2: *mut gnet_dump) -> c_types::c_int,
    >,
    pub ingress_block_set:
        ::core::option::Option<unsafe extern "C" fn(sch: *mut Qdisc, block_index: u32_)>,
    pub egress_block_set:
        ::core::option::Option<unsafe extern "C" fn(sch: *mut Qdisc, block_index: u32_)>,
    pub ingress_block_get: ::core::option::Option<unsafe extern "C" fn(sch: *mut Qdisc) -> u32_>,
    pub egress_block_get: ::core::option::Option<unsafe extern "C" fn(sch: *mut Qdisc) -> u32_>,
    pub owner: *mut module,
}
#[test]
fn bindgen_test_layout_Qdisc_ops() {
    assert_eq!(
        ::core::mem::size_of::<Qdisc_ops>(),
        168usize,
        concat!("Size of: ", stringify!(Qdisc_ops))
    );
    assert_eq!(
        ::core::mem::align_of::<Qdisc_ops>(),
        8usize,
        concat!("Alignment of ", stringify!(Qdisc_ops))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Qdisc_ops>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Qdisc_ops),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Qdisc_ops>())).cl_ops as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Qdisc_ops),
            "::",
            stringify!(cl_ops)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Qdisc_ops>())).id as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Qdisc_ops),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Qdisc_ops>())).priv_size as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(Qdisc_ops),
            "::",
            stringify!(priv_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Qdisc_ops>())).static_flags as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(Qdisc_ops),
            "::",
            stringify!(static_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Qdisc_ops>())).enqueue as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(Qdisc_ops),
            "::",
            stringify!(enqueue)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Qdisc_ops>())).dequeue as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(Qdisc_ops),
            "::",
            stringify!(dequeue)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Qdisc_ops>())).peek as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(Qdisc_ops),
            "::",
            stringify!(peek)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Qdisc_ops>())).init as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(Qdisc_ops),
            "::",
            stringify!(init)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Qdisc_ops>())).reset as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(Qdisc_ops),
            "::",
            stringify!(reset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Qdisc_ops>())).destroy as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(Qdisc_ops),
            "::",
            stringify!(destroy)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Qdisc_ops>())).change as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(Qdisc_ops),
            "::",
            stringify!(change)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Qdisc_ops>())).attach as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(Qdisc_ops),
            "::",
            stringify!(attach)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Qdisc_ops>())).change_tx_queue_len as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(Qdisc_ops),
            "::",
            stringify!(change_tx_queue_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Qdisc_ops>())).dump as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(Qdisc_ops),
            "::",
            stringify!(dump)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Qdisc_ops>())).dump_stats as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(Qdisc_ops),
            "::",
            stringify!(dump_stats)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Qdisc_ops>())).ingress_block_set as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(Qdisc_ops),
            "::",
            stringify!(ingress_block_set)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Qdisc_ops>())).egress_block_set as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(Qdisc_ops),
            "::",
            stringify!(egress_block_set)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Qdisc_ops>())).ingress_block_get as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(Qdisc_ops),
            "::",
            stringify!(ingress_block_get)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Qdisc_ops>())).egress_block_get as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(Qdisc_ops),
            "::",
            stringify!(egress_block_get)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Qdisc_ops>())).owner as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(Qdisc_ops),
            "::",
            stringify!(owner)
        )
    );
}
impl Default for Qdisc_ops {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tcf_result {
    pub __bindgen_anon_1: tcf_result__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union tcf_result__bindgen_ty_1 {
    pub __bindgen_anon_1: tcf_result__bindgen_ty_1__bindgen_ty_1,
    pub goto_tp: *const tcf_proto,
    pub __bindgen_anon_2: tcf_result__bindgen_ty_1__bindgen_ty_2,
    _bindgen_union_align: [u64; 2usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct tcf_result__bindgen_ty_1__bindgen_ty_1 {
    pub class: c_types::c_ulong,
    pub classid: u32_,
}
#[test]
fn bindgen_test_layout_tcf_result__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<tcf_result__bindgen_ty_1__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(tcf_result__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<tcf_result__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(tcf_result__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<tcf_result__bindgen_ty_1__bindgen_ty_1>())).class as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tcf_result__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(class)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<tcf_result__bindgen_ty_1__bindgen_ty_1>())).classid as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tcf_result__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(classid)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tcf_result__bindgen_ty_1__bindgen_ty_2 {
    pub ingress: bool_,
    pub qstats: *mut gnet_stats_queue,
}
#[test]
fn bindgen_test_layout_tcf_result__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<tcf_result__bindgen_ty_1__bindgen_ty_2>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(tcf_result__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<tcf_result__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(tcf_result__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<tcf_result__bindgen_ty_1__bindgen_ty_2>())).ingress as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tcf_result__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(ingress)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<tcf_result__bindgen_ty_1__bindgen_ty_2>())).qstats as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tcf_result__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(qstats)
        )
    );
}
impl Default for tcf_result__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_tcf_result__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<tcf_result__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(tcf_result__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<tcf_result__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(tcf_result__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<tcf_result__bindgen_ty_1>())).goto_tp as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tcf_result__bindgen_ty_1),
            "::",
            stringify!(goto_tp)
        )
    );
}
impl Default for tcf_result__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_tcf_result() {
    assert_eq!(
        ::core::mem::size_of::<tcf_result>(),
        16usize,
        concat!("Size of: ", stringify!(tcf_result))
    );
    assert_eq!(
        ::core::mem::align_of::<tcf_result>(),
        8usize,
        concat!("Alignment of ", stringify!(tcf_result))
    );
}
impl Default for tcf_result {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tcf_proto_ops {
    pub head: list_head,
    pub kind: [c_types::c_char; 16usize],
    pub classify: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sk_buff,
            arg2: *const tcf_proto,
            arg3: *mut tcf_result,
        ) -> c_types::c_int,
    >,
    pub init: ::core::option::Option<unsafe extern "C" fn(arg1: *mut tcf_proto) -> c_types::c_int>,
    pub destroy: ::core::option::Option<
        unsafe extern "C" fn(tp: *mut tcf_proto, rtnl_held: bool_, extack: *mut netlink_ext_ack),
    >,
    pub get: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut tcf_proto, handle: u32_) -> *mut c_types::c_void,
    >,
    pub put:
        ::core::option::Option<unsafe extern "C" fn(tp: *mut tcf_proto, f: *mut c_types::c_void)>,
    pub change: ::core::option::Option<
        unsafe extern "C" fn(
            net: *mut net,
            arg1: *mut sk_buff,
            arg2: *mut tcf_proto,
            arg3: c_types::c_ulong,
            handle: u32_,
            arg4: *mut *mut nlattr,
            arg5: *mut *mut c_types::c_void,
            arg6: bool_,
            arg7: bool_,
            arg8: *mut netlink_ext_ack,
        ) -> c_types::c_int,
    >,
    pub delete: ::core::option::Option<
        unsafe extern "C" fn(
            tp: *mut tcf_proto,
            arg: *mut c_types::c_void,
            last: *mut bool_,
            rtnl_held: bool_,
            arg1: *mut netlink_ext_ack,
        ) -> c_types::c_int,
    >,
    pub delete_empty: ::core::option::Option<unsafe extern "C" fn(tp: *mut tcf_proto) -> bool_>,
    pub walk: ::core::option::Option<
        unsafe extern "C" fn(tp: *mut tcf_proto, arg: *mut tcf_walker, rtnl_held: bool_),
    >,
    pub reoffload: ::core::option::Option<
        unsafe extern "C" fn(
            tp: *mut tcf_proto,
            add: bool_,
            cb: flow_setup_cb_t,
            cb_priv: *mut c_types::c_void,
            extack: *mut netlink_ext_ack,
        ) -> c_types::c_int,
    >,
    pub hw_add: ::core::option::Option<
        unsafe extern "C" fn(tp: *mut tcf_proto, type_data: *mut c_types::c_void),
    >,
    pub hw_del: ::core::option::Option<
        unsafe extern "C" fn(tp: *mut tcf_proto, type_data: *mut c_types::c_void),
    >,
    pub bind_class: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut c_types::c_void,
            arg2: u32_,
            arg3: c_types::c_ulong,
            arg4: *mut c_types::c_void,
            arg5: c_types::c_ulong,
        ),
    >,
    pub tmplt_create: ::core::option::Option<
        unsafe extern "C" fn(
            net: *mut net,
            chain: *mut tcf_chain,
            tca: *mut *mut nlattr,
            extack: *mut netlink_ext_ack,
        ) -> *mut c_types::c_void,
    >,
    pub tmplt_destroy:
        ::core::option::Option<unsafe extern "C" fn(tmplt_priv: *mut c_types::c_void)>,
    pub dump: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net,
            arg2: *mut tcf_proto,
            arg3: *mut c_types::c_void,
            skb: *mut sk_buff,
            arg4: *mut tcmsg,
            arg5: bool_,
        ) -> c_types::c_int,
    >,
    pub tmplt_dump: ::core::option::Option<
        unsafe extern "C" fn(
            skb: *mut sk_buff,
            net: *mut net,
            tmplt_priv: *mut c_types::c_void,
        ) -> c_types::c_int,
    >,
    pub owner: *mut module,
    pub flags: c_types::c_int,
}
#[test]
fn bindgen_test_layout_tcf_proto_ops() {
    assert_eq!(
        ::core::mem::size_of::<tcf_proto_ops>(),
        184usize,
        concat!("Size of: ", stringify!(tcf_proto_ops))
    );
    assert_eq!(
        ::core::mem::align_of::<tcf_proto_ops>(),
        8usize,
        concat!("Alignment of ", stringify!(tcf_proto_ops))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tcf_proto_ops>())).head as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tcf_proto_ops),
            "::",
            stringify!(head)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tcf_proto_ops>())).kind as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tcf_proto_ops),
            "::",
            stringify!(kind)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tcf_proto_ops>())).classify as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(tcf_proto_ops),
            "::",
            stringify!(classify)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tcf_proto_ops>())).init as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(tcf_proto_ops),
            "::",
            stringify!(init)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tcf_proto_ops>())).destroy as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(tcf_proto_ops),
            "::",
            stringify!(destroy)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tcf_proto_ops>())).get as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(tcf_proto_ops),
            "::",
            stringify!(get)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tcf_proto_ops>())).put as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(tcf_proto_ops),
            "::",
            stringify!(put)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tcf_proto_ops>())).change as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(tcf_proto_ops),
            "::",
            stringify!(change)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tcf_proto_ops>())).delete as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(tcf_proto_ops),
            "::",
            stringify!(delete)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tcf_proto_ops>())).delete_empty as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(tcf_proto_ops),
            "::",
            stringify!(delete_empty)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tcf_proto_ops>())).walk as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(tcf_proto_ops),
            "::",
            stringify!(walk)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tcf_proto_ops>())).reoffload as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(tcf_proto_ops),
            "::",
            stringify!(reoffload)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tcf_proto_ops>())).hw_add as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(tcf_proto_ops),
            "::",
            stringify!(hw_add)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tcf_proto_ops>())).hw_del as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(tcf_proto_ops),
            "::",
            stringify!(hw_del)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tcf_proto_ops>())).bind_class as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(tcf_proto_ops),
            "::",
            stringify!(bind_class)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tcf_proto_ops>())).tmplt_create as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(tcf_proto_ops),
            "::",
            stringify!(tmplt_create)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tcf_proto_ops>())).tmplt_destroy as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(tcf_proto_ops),
            "::",
            stringify!(tmplt_destroy)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tcf_proto_ops>())).dump as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(tcf_proto_ops),
            "::",
            stringify!(dump)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tcf_proto_ops>())).tmplt_dump as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(tcf_proto_ops),
            "::",
            stringify!(tmplt_dump)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tcf_proto_ops>())).owner as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(tcf_proto_ops),
            "::",
            stringify!(owner)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tcf_proto_ops>())).flags as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(tcf_proto_ops),
            "::",
            stringify!(flags)
        )
    );
}
impl Default for tcf_proto_ops {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tcf_proto {
    pub next: *mut tcf_proto,
    pub root: *mut c_types::c_void,
    pub classify: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sk_buff,
            arg2: *const tcf_proto,
            arg3: *mut tcf_result,
        ) -> c_types::c_int,
    >,
    pub protocol: __be16,
    pub prio: u32_,
    pub data: *mut c_types::c_void,
    pub ops: *const tcf_proto_ops,
    pub chain: *mut tcf_chain,
    pub lock: spinlock_t,
    pub deleting: bool_,
    pub refcnt: refcount_t,
    pub rcu: callback_head,
    pub destroy_ht_node: hlist_node,
}
#[test]
fn bindgen_test_layout_tcf_proto() {
    assert_eq!(
        ::core::mem::size_of::<tcf_proto>(),
        104usize,
        concat!("Size of: ", stringify!(tcf_proto))
    );
    assert_eq!(
        ::core::mem::align_of::<tcf_proto>(),
        8usize,
        concat!("Alignment of ", stringify!(tcf_proto))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tcf_proto>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tcf_proto),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tcf_proto>())).root as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tcf_proto),
            "::",
            stringify!(root)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tcf_proto>())).classify as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tcf_proto),
            "::",
            stringify!(classify)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tcf_proto>())).protocol as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(tcf_proto),
            "::",
            stringify!(protocol)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tcf_proto>())).prio as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(tcf_proto),
            "::",
            stringify!(prio)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tcf_proto>())).data as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(tcf_proto),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tcf_proto>())).ops as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(tcf_proto),
            "::",
            stringify!(ops)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tcf_proto>())).chain as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(tcf_proto),
            "::",
            stringify!(chain)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tcf_proto>())).lock as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(tcf_proto),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tcf_proto>())).deleting as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(tcf_proto),
            "::",
            stringify!(deleting)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tcf_proto>())).refcnt as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(tcf_proto),
            "::",
            stringify!(refcnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tcf_proto>())).rcu as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(tcf_proto),
            "::",
            stringify!(rcu)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tcf_proto>())).destroy_ht_node as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(tcf_proto),
            "::",
            stringify!(destroy_ht_node)
        )
    );
}
impl Default for tcf_proto {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tcf_chain {
    pub filter_chain_lock: mutex,
    pub filter_chain: *mut tcf_proto,
    pub list: list_head,
    pub block: *mut tcf_block,
    pub index: u32_,
    pub refcnt: c_types::c_uint,
    pub action_refcnt: c_types::c_uint,
    pub explicitly_created: bool_,
    pub flushing: bool_,
    pub tmplt_ops: *const tcf_proto_ops,
    pub tmplt_priv: *mut c_types::c_void,
    pub rcu: callback_head,
}
#[test]
fn bindgen_test_layout_tcf_chain() {
    assert_eq!(
        ::core::mem::size_of::<tcf_chain>(),
        112usize,
        concat!("Size of: ", stringify!(tcf_chain))
    );
    assert_eq!(
        ::core::mem::align_of::<tcf_chain>(),
        8usize,
        concat!("Alignment of ", stringify!(tcf_chain))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tcf_chain>())).filter_chain_lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tcf_chain),
            "::",
            stringify!(filter_chain_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tcf_chain>())).filter_chain as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(tcf_chain),
            "::",
            stringify!(filter_chain)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tcf_chain>())).list as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(tcf_chain),
            "::",
            stringify!(list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tcf_chain>())).block as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(tcf_chain),
            "::",
            stringify!(block)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tcf_chain>())).index as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(tcf_chain),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tcf_chain>())).refcnt as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(tcf_chain),
            "::",
            stringify!(refcnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tcf_chain>())).action_refcnt as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(tcf_chain),
            "::",
            stringify!(action_refcnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tcf_chain>())).explicitly_created as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(tcf_chain),
            "::",
            stringify!(explicitly_created)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tcf_chain>())).flushing as *const _ as usize },
        77usize,
        concat!(
            "Offset of field: ",
            stringify!(tcf_chain),
            "::",
            stringify!(flushing)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tcf_chain>())).tmplt_ops as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(tcf_chain),
            "::",
            stringify!(tmplt_ops)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tcf_chain>())).tmplt_priv as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(tcf_chain),
            "::",
            stringify!(tmplt_priv)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tcf_chain>())).rcu as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(tcf_chain),
            "::",
            stringify!(rcu)
        )
    );
}
impl Default for tcf_chain {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tcf_block {
    pub lock: mutex,
    pub chain_list: list_head,
    pub index: u32_,
    pub refcnt: refcount_t,
    pub net: *mut net,
    pub q: *mut Qdisc,
    pub cb_lock: rw_semaphore,
    pub flow_block: flow_block,
    pub owner_list: list_head,
    pub keep_dst: bool_,
    pub offloadcnt: atomic_t,
    pub nooffloaddevcnt: c_types::c_uint,
    pub lockeddevcnt: c_types::c_uint,
    pub chain0: tcf_block__bindgen_ty_1,
    pub rcu: callback_head,
    pub proto_destroy_ht: [hlist_head; 128usize],
    pub proto_destroy_lock: mutex,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tcf_block__bindgen_ty_1 {
    pub chain: *mut tcf_chain,
    pub filter_chain_list: list_head,
}
#[test]
fn bindgen_test_layout_tcf_block__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<tcf_block__bindgen_ty_1>(),
        24usize,
        concat!("Size of: ", stringify!(tcf_block__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<tcf_block__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(tcf_block__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tcf_block__bindgen_ty_1>())).chain as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tcf_block__bindgen_ty_1),
            "::",
            stringify!(chain)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<tcf_block__bindgen_ty_1>())).filter_chain_list as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tcf_block__bindgen_ty_1),
            "::",
            stringify!(filter_chain_list)
        )
    );
}
impl Default for tcf_block__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_tcf_block() {
    assert_eq!(
        ::core::mem::size_of::<tcf_block>(),
        1256usize,
        concat!("Size of: ", stringify!(tcf_block))
    );
    assert_eq!(
        ::core::mem::align_of::<tcf_block>(),
        8usize,
        concat!("Alignment of ", stringify!(tcf_block))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tcf_block>())).lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tcf_block),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tcf_block>())).chain_list as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(tcf_block),
            "::",
            stringify!(chain_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tcf_block>())).index as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(tcf_block),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tcf_block>())).refcnt as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(tcf_block),
            "::",
            stringify!(refcnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tcf_block>())).net as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(tcf_block),
            "::",
            stringify!(net)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tcf_block>())).q as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(tcf_block),
            "::",
            stringify!(q)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tcf_block>())).cb_lock as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(tcf_block),
            "::",
            stringify!(cb_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tcf_block>())).flow_block as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(tcf_block),
            "::",
            stringify!(flow_block)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tcf_block>())).owner_list as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(tcf_block),
            "::",
            stringify!(owner_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tcf_block>())).keep_dst as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(tcf_block),
            "::",
            stringify!(keep_dst)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tcf_block>())).offloadcnt as *const _ as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(tcf_block),
            "::",
            stringify!(offloadcnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tcf_block>())).nooffloaddevcnt as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(tcf_block),
            "::",
            stringify!(nooffloaddevcnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tcf_block>())).lockeddevcnt as *const _ as usize },
        156usize,
        concat!(
            "Offset of field: ",
            stringify!(tcf_block),
            "::",
            stringify!(lockeddevcnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tcf_block>())).chain0 as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(tcf_block),
            "::",
            stringify!(chain0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tcf_block>())).rcu as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(tcf_block),
            "::",
            stringify!(rcu)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tcf_block>())).proto_destroy_ht as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(tcf_block),
            "::",
            stringify!(proto_destroy_ht)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tcf_block>())).proto_destroy_lock as *const _ as usize },
        1224usize,
        concat!(
            "Offset of field: ",
            stringify!(tcf_block),
            "::",
            stringify!(proto_destroy_lock)
        )
    );
}
impl Default for tcf_block {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mini_Qdisc {
    pub filter_list: *mut tcf_proto,
    pub cpu_bstats: *mut gnet_stats_basic_cpu,
    pub cpu_qstats: *mut gnet_stats_queue,
    pub rcu: callback_head,
}
#[test]
fn bindgen_test_layout_mini_Qdisc() {
    assert_eq!(
        ::core::mem::size_of::<mini_Qdisc>(),
        40usize,
        concat!("Size of: ", stringify!(mini_Qdisc))
    );
    assert_eq!(
        ::core::mem::align_of::<mini_Qdisc>(),
        8usize,
        concat!("Alignment of ", stringify!(mini_Qdisc))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mini_Qdisc>())).filter_list as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mini_Qdisc),
            "::",
            stringify!(filter_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mini_Qdisc>())).cpu_bstats as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mini_Qdisc),
            "::",
            stringify!(cpu_bstats)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mini_Qdisc>())).cpu_qstats as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(mini_Qdisc),
            "::",
            stringify!(cpu_qstats)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mini_Qdisc>())).rcu as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(mini_Qdisc),
            "::",
            stringify!(rcu)
        )
    );
}
impl Default for mini_Qdisc {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct sock_filter {
    pub code: __u16,
    pub jt: __u8,
    pub jf: __u8,
    pub k: __u32,
}
#[test]
fn bindgen_test_layout_sock_filter() {
    assert_eq!(
        ::core::mem::size_of::<sock_filter>(),
        8usize,
        concat!("Size of: ", stringify!(sock_filter))
    );
    assert_eq!(
        ::core::mem::align_of::<sock_filter>(),
        4usize,
        concat!("Alignment of ", stringify!(sock_filter))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sock_filter>())).code as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sock_filter),
            "::",
            stringify!(code)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sock_filter>())).jt as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sock_filter),
            "::",
            stringify!(jt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sock_filter>())).jf as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(sock_filter),
            "::",
            stringify!(jf)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sock_filter>())).k as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sock_filter),
            "::",
            stringify!(k)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sock_reuseport {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sock_fprog_kern {
    pub len: u16_,
    pub filter: *mut sock_filter,
}
#[test]
fn bindgen_test_layout_sock_fprog_kern() {
    assert_eq!(
        ::core::mem::size_of::<sock_fprog_kern>(),
        16usize,
        concat!("Size of: ", stringify!(sock_fprog_kern))
    );
    assert_eq!(
        ::core::mem::align_of::<sock_fprog_kern>(),
        8usize,
        concat!("Alignment of ", stringify!(sock_fprog_kern))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sock_fprog_kern>())).len as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sock_fprog_kern),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sock_fprog_kern>())).filter as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sock_fprog_kern),
            "::",
            stringify!(filter)
        )
    );
}
impl Default for sock_fprog_kern {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct bpf_prog {
    pub pages: u16_,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
    pub type_: bpf_prog_type,
    pub expected_attach_type: bpf_attach_type,
    pub len: u32_,
    pub jited_len: u32_,
    pub tag: [u8_; 8usize],
    pub aux: *mut bpf_prog_aux,
    pub orig_prog: *mut sock_fprog_kern,
    pub bpf_func: ::core::option::Option<
        unsafe extern "C" fn(ctx: *const c_types::c_void, insn: *const bpf_insn) -> c_types::c_uint,
    >,
    pub __bindgen_anon_1: bpf_prog__bindgen_ty_1,
}
#[repr(C)]
pub struct bpf_prog__bindgen_ty_1 {
    pub insns: __BindgenUnionField<[sock_filter; 0usize]>,
    pub insnsi: __BindgenUnionField<[bpf_insn; 0usize]>,
    pub bindgen_union_field: [u32; 0usize],
}
#[test]
fn bindgen_test_layout_bpf_prog__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<bpf_prog__bindgen_ty_1>(),
        0usize,
        concat!("Size of: ", stringify!(bpf_prog__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<bpf_prog__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(bpf_prog__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_prog__bindgen_ty_1>())).insns as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_prog__bindgen_ty_1),
            "::",
            stringify!(insns)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_prog__bindgen_ty_1>())).insnsi as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_prog__bindgen_ty_1),
            "::",
            stringify!(insnsi)
        )
    );
}
impl Default for bpf_prog__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_bpf_prog() {
    assert_eq!(
        ::core::mem::size_of::<bpf_prog>(),
        56usize,
        concat!("Size of: ", stringify!(bpf_prog))
    );
    assert_eq!(
        ::core::mem::align_of::<bpf_prog>(),
        8usize,
        concat!("Alignment of ", stringify!(bpf_prog))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_prog>())).pages as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_prog),
            "::",
            stringify!(pages)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_prog>())).type_ as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_prog),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_prog>())).expected_attach_type as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_prog),
            "::",
            stringify!(expected_attach_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_prog>())).len as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_prog),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_prog>())).jited_len as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_prog),
            "::",
            stringify!(jited_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_prog>())).tag as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_prog),
            "::",
            stringify!(tag)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_prog>())).aux as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_prog),
            "::",
            stringify!(aux)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_prog>())).orig_prog as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_prog),
            "::",
            stringify!(orig_prog)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bpf_prog>())).bpf_func as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_prog),
            "::",
            stringify!(bpf_func)
        )
    );
}
impl Default for bpf_prog {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl bpf_prog {
    #[inline]
    pub fn jited(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_jited(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn jit_requested(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_jit_requested(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn gpl_compatible(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_gpl_compatible(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cb_access(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_cb_access(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dst_needed(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_dst_needed(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn blinded(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_blinded(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_func(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_is_func(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn kprobe_override(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_kprobe_override(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn has_callchain_buf(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_has_callchain_buf(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enforce_expected_attach_type(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_enforce_expected_attach_type(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        jited: u16_,
        jit_requested: u16_,
        gpl_compatible: u16_,
        cb_access: u16_,
        dst_needed: u16_,
        blinded: u16_,
        is_func: u16_,
        kprobe_override: u16_,
        has_callchain_buf: u16_,
        enforce_expected_attach_type: u16_,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let jited: u16 = unsafe { ::core::mem::transmute(jited) };
            jited as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let jit_requested: u16 = unsafe { ::core::mem::transmute(jit_requested) };
            jit_requested as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let gpl_compatible: u16 = unsafe { ::core::mem::transmute(gpl_compatible) };
            gpl_compatible as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let cb_access: u16 = unsafe { ::core::mem::transmute(cb_access) };
            cb_access as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let dst_needed: u16 = unsafe { ::core::mem::transmute(dst_needed) };
            dst_needed as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let blinded: u16 = unsafe { ::core::mem::transmute(blinded) };
            blinded as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let is_func: u16 = unsafe { ::core::mem::transmute(is_func) };
            is_func as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let kprobe_override: u16 = unsafe { ::core::mem::transmute(kprobe_override) };
            kprobe_override as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let has_callchain_buf: u16 = unsafe { ::core::mem::transmute(has_callchain_buf) };
            has_callchain_buf as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let enforce_expected_attach_type: u16 =
                unsafe { ::core::mem::transmute(enforce_expected_attach_type) };
            enforce_expected_attach_type as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_filter {
    pub refcnt: refcount_t,
    pub rcu: callback_head,
    pub prog: *mut bpf_prog,
}
#[test]
fn bindgen_test_layout_sk_filter() {
    assert_eq!(
        ::core::mem::size_of::<sk_filter>(),
        32usize,
        concat!("Size of: ", stringify!(sk_filter))
    );
    assert_eq!(
        ::core::mem::align_of::<sk_filter>(),
        8usize,
        concat!("Alignment of ", stringify!(sk_filter))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sk_filter>())).refcnt as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_filter),
            "::",
            stringify!(refcnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sk_filter>())).rcu as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_filter),
            "::",
            stringify!(rcu)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sk_filter>())).prog as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_filter),
            "::",
            stringify!(prog)
        )
    );
}
impl Default for sk_filter {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct pollfd {
    pub fd: c_types::c_int,
    pub events: c_types::c_short,
    pub revents: c_types::c_short,
}
#[test]
fn bindgen_test_layout_pollfd() {
    assert_eq!(
        ::core::mem::size_of::<pollfd>(),
        8usize,
        concat!("Size of: ", stringify!(pollfd))
    );
    assert_eq!(
        ::core::mem::align_of::<pollfd>(),
        4usize,
        concat!("Alignment of ", stringify!(pollfd))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pollfd>())).fd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pollfd),
            "::",
            stringify!(fd)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pollfd>())).events as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(pollfd),
            "::",
            stringify!(events)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pollfd>())).revents as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(pollfd),
            "::",
            stringify!(revents)
        )
    );
}
pub type poll_queue_proc = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut file,
        arg2: *mut wait_queue_head_t,
        arg3: *mut poll_table_struct,
    ),
>;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct poll_table_struct {
    pub _qproc: poll_queue_proc,
    pub _key: __poll_t,
}
#[test]
fn bindgen_test_layout_poll_table_struct() {
    assert_eq!(
        ::core::mem::size_of::<poll_table_struct>(),
        16usize,
        concat!("Size of: ", stringify!(poll_table_struct))
    );
    assert_eq!(
        ::core::mem::align_of::<poll_table_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(poll_table_struct))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<poll_table_struct>()))._qproc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(poll_table_struct),
            "::",
            stringify!(_qproc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<poll_table_struct>()))._key as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(poll_table_struct),
            "::",
            stringify!(_key)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct neigh_parms {
    pub net: possible_net_t,
    pub dev: *mut net_device,
    pub list: list_head,
    pub neigh_setup:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut neighbour) -> c_types::c_int>,
    pub tbl: *mut neigh_table,
    pub sysctl_table: *mut c_types::c_void,
    pub dead: c_types::c_int,
    pub refcnt: refcount_t,
    pub callback_head: callback_head,
    pub reachable_time: c_types::c_int,
    pub data: [c_types::c_int; 13usize],
    pub data_state: [c_types::c_ulong; 1usize],
}
#[test]
fn bindgen_test_layout_neigh_parms() {
    assert_eq!(
        ::core::mem::size_of::<neigh_parms>(),
        144usize,
        concat!("Size of: ", stringify!(neigh_parms))
    );
    assert_eq!(
        ::core::mem::align_of::<neigh_parms>(),
        8usize,
        concat!("Alignment of ", stringify!(neigh_parms))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<neigh_parms>())).net as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(neigh_parms),
            "::",
            stringify!(net)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<neigh_parms>())).dev as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(neigh_parms),
            "::",
            stringify!(dev)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<neigh_parms>())).list as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(neigh_parms),
            "::",
            stringify!(list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<neigh_parms>())).neigh_setup as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(neigh_parms),
            "::",
            stringify!(neigh_setup)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<neigh_parms>())).tbl as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(neigh_parms),
            "::",
            stringify!(tbl)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<neigh_parms>())).sysctl_table as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(neigh_parms),
            "::",
            stringify!(sysctl_table)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<neigh_parms>())).dead as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(neigh_parms),
            "::",
            stringify!(dead)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<neigh_parms>())).refcnt as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(neigh_parms),
            "::",
            stringify!(refcnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<neigh_parms>())).callback_head as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(neigh_parms),
            "::",
            stringify!(callback_head)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<neigh_parms>())).reachable_time as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(neigh_parms),
            "::",
            stringify!(reachable_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<neigh_parms>())).data as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(neigh_parms),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<neigh_parms>())).data_state as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(neigh_parms),
            "::",
            stringify!(data_state)
        )
    );
}
impl Default for neigh_parms {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct neigh_statistics {
    pub allocs: c_types::c_ulong,
    pub destroys: c_types::c_ulong,
    pub hash_grows: c_types::c_ulong,
    pub res_failed: c_types::c_ulong,
    pub lookups: c_types::c_ulong,
    pub hits: c_types::c_ulong,
    pub rcv_probes_mcast: c_types::c_ulong,
    pub rcv_probes_ucast: c_types::c_ulong,
    pub periodic_gc_runs: c_types::c_ulong,
    pub forced_gc_runs: c_types::c_ulong,
    pub unres_discards: c_types::c_ulong,
    pub table_fulls: c_types::c_ulong,
}
#[test]
fn bindgen_test_layout_neigh_statistics() {
    assert_eq!(
        ::core::mem::size_of::<neigh_statistics>(),
        96usize,
        concat!("Size of: ", stringify!(neigh_statistics))
    );
    assert_eq!(
        ::core::mem::align_of::<neigh_statistics>(),
        8usize,
        concat!("Alignment of ", stringify!(neigh_statistics))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<neigh_statistics>())).allocs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(neigh_statistics),
            "::",
            stringify!(allocs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<neigh_statistics>())).destroys as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(neigh_statistics),
            "::",
            stringify!(destroys)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<neigh_statistics>())).hash_grows as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(neigh_statistics),
            "::",
            stringify!(hash_grows)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<neigh_statistics>())).res_failed as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(neigh_statistics),
            "::",
            stringify!(res_failed)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<neigh_statistics>())).lookups as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(neigh_statistics),
            "::",
            stringify!(lookups)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<neigh_statistics>())).hits as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(neigh_statistics),
            "::",
            stringify!(hits)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<neigh_statistics>())).rcv_probes_mcast as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(neigh_statistics),
            "::",
            stringify!(rcv_probes_mcast)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<neigh_statistics>())).rcv_probes_ucast as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(neigh_statistics),
            "::",
            stringify!(rcv_probes_ucast)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<neigh_statistics>())).periodic_gc_runs as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(neigh_statistics),
            "::",
            stringify!(periodic_gc_runs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<neigh_statistics>())).forced_gc_runs as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(neigh_statistics),
            "::",
            stringify!(forced_gc_runs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<neigh_statistics>())).unres_discards as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(neigh_statistics),
            "::",
            stringify!(unres_discards)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<neigh_statistics>())).table_fulls as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(neigh_statistics),
            "::",
            stringify!(table_fulls)
        )
    );
}
#[repr(C)]
pub struct neighbour {
    pub next: *mut neighbour,
    pub tbl: *mut neigh_table,
    pub parms: *mut neigh_parms,
    pub confirmed: c_types::c_ulong,
    pub updated: c_types::c_ulong,
    pub lock: rwlock_t,
    pub refcnt: refcount_t,
    pub arp_queue_len_bytes: c_types::c_uint,
    pub arp_queue: sk_buff_head,
    pub timer: timer_list,
    pub used: c_types::c_ulong,
    pub probes: atomic_t,
    pub flags: __u8,
    pub nud_state: __u8,
    pub type_: __u8,
    pub dead: __u8,
    pub protocol: u8_,
    pub ha_lock: seqlock_t,
    pub __bindgen_padding_0: [u8; 4usize],
    pub ha: [c_types::c_uchar; 32usize],
    pub hh: hh_cache,
    pub output: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut neighbour, arg2: *mut sk_buff) -> c_types::c_int,
    >,
    pub ops: *const neigh_ops,
    pub gc_list: list_head,
    pub rcu: callback_head,
    pub dev: *mut net_device,
    pub primary_key: __IncompleteArrayField<u8_>,
}
#[test]
fn bindgen_test_layout_neighbour() {
    assert_eq!(
        ::core::mem::size_of::<neighbour>(),
        384usize,
        concat!("Size of: ", stringify!(neighbour))
    );
    assert_eq!(
        ::core::mem::align_of::<neighbour>(),
        8usize,
        concat!("Alignment of ", stringify!(neighbour))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<neighbour>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(neighbour),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<neighbour>())).tbl as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(neighbour),
            "::",
            stringify!(tbl)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<neighbour>())).parms as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(neighbour),
            "::",
            stringify!(parms)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<neighbour>())).confirmed as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(neighbour),
            "::",
            stringify!(confirmed)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<neighbour>())).updated as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(neighbour),
            "::",
            stringify!(updated)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<neighbour>())).lock as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(neighbour),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<neighbour>())).refcnt as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(neighbour),
            "::",
            stringify!(refcnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<neighbour>())).arp_queue_len_bytes as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(neighbour),
            "::",
            stringify!(arp_queue_len_bytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<neighbour>())).arp_queue as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(neighbour),
            "::",
            stringify!(arp_queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<neighbour>())).timer as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(neighbour),
            "::",
            stringify!(timer)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<neighbour>())).used as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(neighbour),
            "::",
            stringify!(used)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<neighbour>())).probes as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(neighbour),
            "::",
            stringify!(probes)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<neighbour>())).flags as *const _ as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(neighbour),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<neighbour>())).nud_state as *const _ as usize },
        133usize,
        concat!(
            "Offset of field: ",
            stringify!(neighbour),
            "::",
            stringify!(nud_state)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<neighbour>())).type_ as *const _ as usize },
        134usize,
        concat!(
            "Offset of field: ",
            stringify!(neighbour),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<neighbour>())).dead as *const _ as usize },
        135usize,
        concat!(
            "Offset of field: ",
            stringify!(neighbour),
            "::",
            stringify!(dead)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<neighbour>())).protocol as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(neighbour),
            "::",
            stringify!(protocol)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<neighbour>())).ha_lock as *const _ as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(neighbour),
            "::",
            stringify!(ha_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<neighbour>())).ha as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(neighbour),
            "::",
            stringify!(ha)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<neighbour>())).hh as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(neighbour),
            "::",
            stringify!(hh)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<neighbour>())).output as *const _ as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(neighbour),
            "::",
            stringify!(output)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<neighbour>())).ops as *const _ as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(neighbour),
            "::",
            stringify!(ops)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<neighbour>())).gc_list as *const _ as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(neighbour),
            "::",
            stringify!(gc_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<neighbour>())).rcu as *const _ as usize },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(neighbour),
            "::",
            stringify!(rcu)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<neighbour>())).dev as *const _ as usize },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(neighbour),
            "::",
            stringify!(dev)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<neighbour>())).primary_key as *const _ as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(neighbour),
            "::",
            stringify!(primary_key)
        )
    );
}
impl Default for neighbour {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct neigh_ops {
    pub family: c_types::c_int,
    pub solicit:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut neighbour, arg2: *mut sk_buff)>,
    pub error_report:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut neighbour, arg2: *mut sk_buff)>,
    pub output: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut neighbour, arg2: *mut sk_buff) -> c_types::c_int,
    >,
    pub connected_output: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut neighbour, arg2: *mut sk_buff) -> c_types::c_int,
    >,
}
#[test]
fn bindgen_test_layout_neigh_ops() {
    assert_eq!(
        ::core::mem::size_of::<neigh_ops>(),
        40usize,
        concat!("Size of: ", stringify!(neigh_ops))
    );
    assert_eq!(
        ::core::mem::align_of::<neigh_ops>(),
        8usize,
        concat!("Alignment of ", stringify!(neigh_ops))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<neigh_ops>())).family as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(neigh_ops),
            "::",
            stringify!(family)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<neigh_ops>())).solicit as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(neigh_ops),
            "::",
            stringify!(solicit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<neigh_ops>())).error_report as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(neigh_ops),
            "::",
            stringify!(error_report)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<neigh_ops>())).output as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(neigh_ops),
            "::",
            stringify!(output)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<neigh_ops>())).connected_output as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(neigh_ops),
            "::",
            stringify!(connected_output)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct pneigh_entry {
    pub next: *mut pneigh_entry,
    pub net: possible_net_t,
    pub dev: *mut net_device,
    pub flags: u8_,
    pub protocol: u8_,
    pub key: __IncompleteArrayField<u8_>,
}
#[test]
fn bindgen_test_layout_pneigh_entry() {
    assert_eq!(
        ::core::mem::size_of::<pneigh_entry>(),
        32usize,
        concat!("Size of: ", stringify!(pneigh_entry))
    );
    assert_eq!(
        ::core::mem::align_of::<pneigh_entry>(),
        8usize,
        concat!("Alignment of ", stringify!(pneigh_entry))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pneigh_entry>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pneigh_entry),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pneigh_entry>())).net as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pneigh_entry),
            "::",
            stringify!(net)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pneigh_entry>())).dev as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pneigh_entry),
            "::",
            stringify!(dev)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pneigh_entry>())).flags as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(pneigh_entry),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pneigh_entry>())).protocol as *const _ as usize },
        25usize,
        concat!(
            "Offset of field: ",
            stringify!(pneigh_entry),
            "::",
            stringify!(protocol)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pneigh_entry>())).key as *const _ as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(pneigh_entry),
            "::",
            stringify!(key)
        )
    );
}
impl Default for pneigh_entry {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct neigh_hash_table {
    pub hash_buckets: *mut *mut neighbour,
    pub hash_shift: c_types::c_uint,
    pub hash_rnd: [__u32; 4usize],
    pub rcu: callback_head,
}
#[test]
fn bindgen_test_layout_neigh_hash_table() {
    assert_eq!(
        ::core::mem::size_of::<neigh_hash_table>(),
        48usize,
        concat!("Size of: ", stringify!(neigh_hash_table))
    );
    assert_eq!(
        ::core::mem::align_of::<neigh_hash_table>(),
        8usize,
        concat!("Alignment of ", stringify!(neigh_hash_table))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<neigh_hash_table>())).hash_buckets as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(neigh_hash_table),
            "::",
            stringify!(hash_buckets)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<neigh_hash_table>())).hash_shift as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(neigh_hash_table),
            "::",
            stringify!(hash_shift)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<neigh_hash_table>())).hash_rnd as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(neigh_hash_table),
            "::",
            stringify!(hash_rnd)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<neigh_hash_table>())).rcu as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(neigh_hash_table),
            "::",
            stringify!(rcu)
        )
    );
}
impl Default for neigh_hash_table {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct neigh_table {
    pub family: c_types::c_int,
    pub entry_size: c_types::c_uint,
    pub key_len: c_types::c_uint,
    pub protocol: __be16,
    pub hash: ::core::option::Option<
        unsafe extern "C" fn(
            pkey: *const c_types::c_void,
            dev: *const net_device,
            hash_rnd: *mut __u32,
        ) -> __u32,
    >,
    pub key_eq: ::core::option::Option<
        unsafe extern "C" fn(arg1: *const neighbour, pkey: *const c_types::c_void) -> bool_,
    >,
    pub constructor:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut neighbour) -> c_types::c_int>,
    pub pconstructor:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut pneigh_entry) -> c_types::c_int>,
    pub pdestructor: ::core::option::Option<unsafe extern "C" fn(arg1: *mut pneigh_entry)>,
    pub proxy_redo: ::core::option::Option<unsafe extern "C" fn(skb: *mut sk_buff)>,
    pub allow_add: ::core::option::Option<
        unsafe extern "C" fn(dev: *const net_device, extack: *mut netlink_ext_ack) -> bool_,
    >,
    pub id: *mut c_types::c_char,
    pub parms: neigh_parms,
    pub parms_list: list_head,
    pub gc_interval: c_types::c_int,
    pub gc_thresh1: c_types::c_int,
    pub gc_thresh2: c_types::c_int,
    pub gc_thresh3: c_types::c_int,
    pub last_flush: c_types::c_ulong,
    pub gc_work: delayed_work,
    pub proxy_timer: timer_list,
    pub proxy_queue: sk_buff_head,
    pub entries: atomic_t,
    pub gc_entries: atomic_t,
    pub gc_list: list_head,
    pub lock: rwlock_t,
    pub last_rand: c_types::c_ulong,
    pub stats: *mut neigh_statistics,
    pub nht: *mut neigh_hash_table,
    pub phash_buckets: *mut *mut pneigh_entry,
}
#[test]
fn bindgen_test_layout_neigh_table() {
    assert_eq!(
        ::core::mem::size_of::<neigh_table>(),
        480usize,
        concat!("Size of: ", stringify!(neigh_table))
    );
    assert_eq!(
        ::core::mem::align_of::<neigh_table>(),
        8usize,
        concat!("Alignment of ", stringify!(neigh_table))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<neigh_table>())).family as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(neigh_table),
            "::",
            stringify!(family)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<neigh_table>())).entry_size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(neigh_table),
            "::",
            stringify!(entry_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<neigh_table>())).key_len as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(neigh_table),
            "::",
            stringify!(key_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<neigh_table>())).protocol as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(neigh_table),
            "::",
            stringify!(protocol)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<neigh_table>())).hash as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(neigh_table),
            "::",
            stringify!(hash)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<neigh_table>())).key_eq as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(neigh_table),
            "::",
            stringify!(key_eq)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<neigh_table>())).constructor as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(neigh_table),
            "::",
            stringify!(constructor)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<neigh_table>())).pconstructor as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(neigh_table),
            "::",
            stringify!(pconstructor)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<neigh_table>())).pdestructor as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(neigh_table),
            "::",
            stringify!(pdestructor)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<neigh_table>())).proxy_redo as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(neigh_table),
            "::",
            stringify!(proxy_redo)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<neigh_table>())).allow_add as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(neigh_table),
            "::",
            stringify!(allow_add)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<neigh_table>())).id as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(neigh_table),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<neigh_table>())).parms as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(neigh_table),
            "::",
            stringify!(parms)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<neigh_table>())).parms_list as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(neigh_table),
            "::",
            stringify!(parms_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<neigh_table>())).gc_interval as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(neigh_table),
            "::",
            stringify!(gc_interval)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<neigh_table>())).gc_thresh1 as *const _ as usize },
        244usize,
        concat!(
            "Offset of field: ",
            stringify!(neigh_table),
            "::",
            stringify!(gc_thresh1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<neigh_table>())).gc_thresh2 as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(neigh_table),
            "::",
            stringify!(gc_thresh2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<neigh_table>())).gc_thresh3 as *const _ as usize },
        252usize,
        concat!(
            "Offset of field: ",
            stringify!(neigh_table),
            "::",
            stringify!(gc_thresh3)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<neigh_table>())).last_flush as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(neigh_table),
            "::",
            stringify!(last_flush)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<neigh_table>())).gc_work as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(neigh_table),
            "::",
            stringify!(gc_work)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<neigh_table>())).proxy_timer as *const _ as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(neigh_table),
            "::",
            stringify!(proxy_timer)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<neigh_table>())).proxy_queue as *const _ as usize },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(neigh_table),
            "::",
            stringify!(proxy_queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<neigh_table>())).entries as *const _ as usize },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(neigh_table),
            "::",
            stringify!(entries)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<neigh_table>())).gc_entries as *const _ as usize },
        420usize,
        concat!(
            "Offset of field: ",
            stringify!(neigh_table),
            "::",
            stringify!(gc_entries)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<neigh_table>())).gc_list as *const _ as usize },
        424usize,
        concat!(
            "Offset of field: ",
            stringify!(neigh_table),
            "::",
            stringify!(gc_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<neigh_table>())).lock as *const _ as usize },
        440usize,
        concat!(
            "Offset of field: ",
            stringify!(neigh_table),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<neigh_table>())).last_rand as *const _ as usize },
        448usize,
        concat!(
            "Offset of field: ",
            stringify!(neigh_table),
            "::",
            stringify!(last_rand)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<neigh_table>())).stats as *const _ as usize },
        456usize,
        concat!(
            "Offset of field: ",
            stringify!(neigh_table),
            "::",
            stringify!(stats)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<neigh_table>())).nht as *const _ as usize },
        464usize,
        concat!(
            "Offset of field: ",
            stringify!(neigh_table),
            "::",
            stringify!(nht)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<neigh_table>())).phash_buckets as *const _ as usize },
        472usize,
        concat!(
            "Offset of field: ",
            stringify!(neigh_table),
            "::",
            stringify!(phash_buckets)
        )
    );
}
impl Default for neigh_table {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dst_entry {
    pub dev: *mut net_device,
    pub ops: *mut dst_ops,
    pub _metrics: c_types::c_ulong,
    pub expires: c_types::c_ulong,
    pub xfrm: *mut xfrm_state,
    pub input: ::core::option::Option<unsafe extern "C" fn(arg1: *mut sk_buff) -> c_types::c_int>,
    pub output: ::core::option::Option<
        unsafe extern "C" fn(net: *mut net, sk: *mut sock, skb: *mut sk_buff) -> c_types::c_int,
    >,
    pub flags: c_types::c_ushort,
    pub obsolete: c_types::c_short,
    pub header_len: c_types::c_ushort,
    pub trailer_len: c_types::c_ushort,
    pub __refcnt: atomic_t,
    pub __use: c_types::c_int,
    pub lastuse: c_types::c_ulong,
    pub lwtstate: *mut lwtunnel_state,
    pub callback_head: callback_head,
    pub error: c_types::c_short,
    pub __pad: c_types::c_short,
    pub tclassid: __u32,
}
#[test]
fn bindgen_test_layout_dst_entry() {
    assert_eq!(
        ::core::mem::size_of::<dst_entry>(),
        112usize,
        concat!("Size of: ", stringify!(dst_entry))
    );
    assert_eq!(
        ::core::mem::align_of::<dst_entry>(),
        8usize,
        concat!("Alignment of ", stringify!(dst_entry))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dst_entry>())).dev as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dst_entry),
            "::",
            stringify!(dev)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dst_entry>())).ops as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(dst_entry),
            "::",
            stringify!(ops)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dst_entry>()))._metrics as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(dst_entry),
            "::",
            stringify!(_metrics)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dst_entry>())).expires as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(dst_entry),
            "::",
            stringify!(expires)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dst_entry>())).xfrm as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(dst_entry),
            "::",
            stringify!(xfrm)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dst_entry>())).input as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(dst_entry),
            "::",
            stringify!(input)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dst_entry>())).output as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(dst_entry),
            "::",
            stringify!(output)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dst_entry>())).flags as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(dst_entry),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dst_entry>())).obsolete as *const _ as usize },
        58usize,
        concat!(
            "Offset of field: ",
            stringify!(dst_entry),
            "::",
            stringify!(obsolete)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dst_entry>())).header_len as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(dst_entry),
            "::",
            stringify!(header_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dst_entry>())).trailer_len as *const _ as usize },
        62usize,
        concat!(
            "Offset of field: ",
            stringify!(dst_entry),
            "::",
            stringify!(trailer_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dst_entry>())).__refcnt as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(dst_entry),
            "::",
            stringify!(__refcnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dst_entry>())).__use as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(dst_entry),
            "::",
            stringify!(__use)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dst_entry>())).lastuse as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(dst_entry),
            "::",
            stringify!(lastuse)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dst_entry>())).lwtstate as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(dst_entry),
            "::",
            stringify!(lwtstate)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dst_entry>())).callback_head as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(dst_entry),
            "::",
            stringify!(callback_head)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dst_entry>())).error as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(dst_entry),
            "::",
            stringify!(error)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dst_entry>())).__pad as *const _ as usize },
        106usize,
        concat!(
            "Offset of field: ",
            stringify!(dst_entry),
            "::",
            stringify!(__pad)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dst_entry>())).tclassid as *const _ as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(dst_entry),
            "::",
            stringify!(tclassid)
        )
    );
}
impl Default for dst_entry {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct smc_hashinfo {
    pub lock: rwlock_t,
    pub ht: hlist_head,
}
#[test]
fn bindgen_test_layout_smc_hashinfo() {
    assert_eq!(
        ::core::mem::size_of::<smc_hashinfo>(),
        16usize,
        concat!("Size of: ", stringify!(smc_hashinfo))
    );
    assert_eq!(
        ::core::mem::align_of::<smc_hashinfo>(),
        8usize,
        concat!("Alignment of ", stringify!(smc_hashinfo))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<smc_hashinfo>())).lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(smc_hashinfo),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<smc_hashinfo>())).ht as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(smc_hashinfo),
            "::",
            stringify!(ht)
        )
    );
}
impl Default for smc_hashinfo {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct fib_rule_hdr {
    pub family: __u8,
    pub dst_len: __u8,
    pub src_len: __u8,
    pub tos: __u8,
    pub table: __u8,
    pub res1: __u8,
    pub res2: __u8,
    pub action: __u8,
    pub flags: __u32,
}
#[test]
fn bindgen_test_layout_fib_rule_hdr() {
    assert_eq!(
        ::core::mem::size_of::<fib_rule_hdr>(),
        12usize,
        concat!("Size of: ", stringify!(fib_rule_hdr))
    );
    assert_eq!(
        ::core::mem::align_of::<fib_rule_hdr>(),
        4usize,
        concat!("Alignment of ", stringify!(fib_rule_hdr))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fib_rule_hdr>())).family as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fib_rule_hdr),
            "::",
            stringify!(family)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fib_rule_hdr>())).dst_len as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(fib_rule_hdr),
            "::",
            stringify!(dst_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fib_rule_hdr>())).src_len as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(fib_rule_hdr),
            "::",
            stringify!(src_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fib_rule_hdr>())).tos as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(fib_rule_hdr),
            "::",
            stringify!(tos)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fib_rule_hdr>())).table as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(fib_rule_hdr),
            "::",
            stringify!(table)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fib_rule_hdr>())).res1 as *const _ as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(fib_rule_hdr),
            "::",
            stringify!(res1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fib_rule_hdr>())).res2 as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(fib_rule_hdr),
            "::",
            stringify!(res2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fib_rule_hdr>())).action as *const _ as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(fib_rule_hdr),
            "::",
            stringify!(action)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fib_rule_hdr>())).flags as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(fib_rule_hdr),
            "::",
            stringify!(flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct fib_rule_port_range {
    pub start: __u16,
    pub end: __u16,
}
#[test]
fn bindgen_test_layout_fib_rule_port_range() {
    assert_eq!(
        ::core::mem::size_of::<fib_rule_port_range>(),
        4usize,
        concat!("Size of: ", stringify!(fib_rule_port_range))
    );
    assert_eq!(
        ::core::mem::align_of::<fib_rule_port_range>(),
        2usize,
        concat!("Alignment of ", stringify!(fib_rule_port_range))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fib_rule_port_range>())).start as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fib_rule_port_range),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fib_rule_port_range>())).end as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(fib_rule_port_range),
            "::",
            stringify!(end)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fib_notifier_ops {
    pub family: c_types::c_int,
    pub list: list_head,
    pub fib_seq_read:
        ::core::option::Option<unsafe extern "C" fn(net: *mut net) -> c_types::c_uint>,
    pub fib_dump: ::core::option::Option<
        unsafe extern "C" fn(net: *mut net, nb: *mut notifier_block) -> c_types::c_int,
    >,
    pub owner: *mut module,
    pub rcu: callback_head,
}
#[test]
fn bindgen_test_layout_fib_notifier_ops() {
    assert_eq!(
        ::core::mem::size_of::<fib_notifier_ops>(),
        64usize,
        concat!("Size of: ", stringify!(fib_notifier_ops))
    );
    assert_eq!(
        ::core::mem::align_of::<fib_notifier_ops>(),
        8usize,
        concat!("Alignment of ", stringify!(fib_notifier_ops))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fib_notifier_ops>())).family as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fib_notifier_ops),
            "::",
            stringify!(family)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fib_notifier_ops>())).list as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(fib_notifier_ops),
            "::",
            stringify!(list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fib_notifier_ops>())).fib_seq_read as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(fib_notifier_ops),
            "::",
            stringify!(fib_seq_read)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fib_notifier_ops>())).fib_dump as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(fib_notifier_ops),
            "::",
            stringify!(fib_dump)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fib_notifier_ops>())).owner as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(fib_notifier_ops),
            "::",
            stringify!(owner)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fib_notifier_ops>())).rcu as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(fib_notifier_ops),
            "::",
            stringify!(rcu)
        )
    );
}
impl Default for fib_notifier_ops {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct fib_kuid_range {
    pub start: kuid_t,
    pub end: kuid_t,
}
#[test]
fn bindgen_test_layout_fib_kuid_range() {
    assert_eq!(
        ::core::mem::size_of::<fib_kuid_range>(),
        8usize,
        concat!("Size of: ", stringify!(fib_kuid_range))
    );
    assert_eq!(
        ::core::mem::align_of::<fib_kuid_range>(),
        4usize,
        concat!("Alignment of ", stringify!(fib_kuid_range))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fib_kuid_range>())).start as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fib_kuid_range),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fib_kuid_range>())).end as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(fib_kuid_range),
            "::",
            stringify!(end)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fib_rule {
    pub list: list_head,
    pub iifindex: c_types::c_int,
    pub oifindex: c_types::c_int,
    pub mark: u32_,
    pub mark_mask: u32_,
    pub flags: u32_,
    pub table: u32_,
    pub action: u8_,
    pub l3mdev: u8_,
    pub proto: u8_,
    pub ip_proto: u8_,
    pub target: u32_,
    pub tun_id: __be64,
    pub ctarget: *mut fib_rule,
    pub fr_net: *mut net,
    pub refcnt: refcount_t,
    pub pref: u32_,
    pub suppress_ifgroup: c_types::c_int,
    pub suppress_prefixlen: c_types::c_int,
    pub iifname: [c_types::c_char; 16usize],
    pub oifname: [c_types::c_char; 16usize],
    pub uid_range: fib_kuid_range,
    pub sport_range: fib_rule_port_range,
    pub dport_range: fib_rule_port_range,
    pub rcu: callback_head,
}
#[test]
fn bindgen_test_layout_fib_rule() {
    assert_eq!(
        ::core::mem::size_of::<fib_rule>(),
        152usize,
        concat!("Size of: ", stringify!(fib_rule))
    );
    assert_eq!(
        ::core::mem::align_of::<fib_rule>(),
        8usize,
        concat!("Alignment of ", stringify!(fib_rule))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fib_rule>())).list as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fib_rule),
            "::",
            stringify!(list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fib_rule>())).iifindex as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(fib_rule),
            "::",
            stringify!(iifindex)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fib_rule>())).oifindex as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(fib_rule),
            "::",
            stringify!(oifindex)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fib_rule>())).mark as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(fib_rule),
            "::",
            stringify!(mark)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fib_rule>())).mark_mask as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(fib_rule),
            "::",
            stringify!(mark_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fib_rule>())).flags as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(fib_rule),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fib_rule>())).table as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(fib_rule),
            "::",
            stringify!(table)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fib_rule>())).action as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(fib_rule),
            "::",
            stringify!(action)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fib_rule>())).l3mdev as *const _ as usize },
        41usize,
        concat!(
            "Offset of field: ",
            stringify!(fib_rule),
            "::",
            stringify!(l3mdev)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fib_rule>())).proto as *const _ as usize },
        42usize,
        concat!(
            "Offset of field: ",
            stringify!(fib_rule),
            "::",
            stringify!(proto)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fib_rule>())).ip_proto as *const _ as usize },
        43usize,
        concat!(
            "Offset of field: ",
            stringify!(fib_rule),
            "::",
            stringify!(ip_proto)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fib_rule>())).target as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(fib_rule),
            "::",
            stringify!(target)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fib_rule>())).tun_id as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(fib_rule),
            "::",
            stringify!(tun_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fib_rule>())).ctarget as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(fib_rule),
            "::",
            stringify!(ctarget)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fib_rule>())).fr_net as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(fib_rule),
            "::",
            stringify!(fr_net)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fib_rule>())).refcnt as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(fib_rule),
            "::",
            stringify!(refcnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fib_rule>())).pref as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(fib_rule),
            "::",
            stringify!(pref)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fib_rule>())).suppress_ifgroup as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(fib_rule),
            "::",
            stringify!(suppress_ifgroup)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fib_rule>())).suppress_prefixlen as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(fib_rule),
            "::",
            stringify!(suppress_prefixlen)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fib_rule>())).iifname as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(fib_rule),
            "::",
            stringify!(iifname)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fib_rule>())).oifname as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(fib_rule),
            "::",
            stringify!(oifname)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fib_rule>())).uid_range as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(fib_rule),
            "::",
            stringify!(uid_range)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fib_rule>())).sport_range as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(fib_rule),
            "::",
            stringify!(sport_range)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fib_rule>())).dport_range as *const _ as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(fib_rule),
            "::",
            stringify!(dport_range)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fib_rule>())).rcu as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(fib_rule),
            "::",
            stringify!(rcu)
        )
    );
}
impl Default for fib_rule {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fib_lookup_arg {
    pub lookup_ptr: *mut c_types::c_void,
    pub lookup_data: *const c_types::c_void,
    pub result: *mut c_types::c_void,
    pub rule: *mut fib_rule,
    pub table: u32_,
    pub flags: c_types::c_int,
}
#[test]
fn bindgen_test_layout_fib_lookup_arg() {
    assert_eq!(
        ::core::mem::size_of::<fib_lookup_arg>(),
        40usize,
        concat!("Size of: ", stringify!(fib_lookup_arg))
    );
    assert_eq!(
        ::core::mem::align_of::<fib_lookup_arg>(),
        8usize,
        concat!("Alignment of ", stringify!(fib_lookup_arg))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fib_lookup_arg>())).lookup_ptr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fib_lookup_arg),
            "::",
            stringify!(lookup_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fib_lookup_arg>())).lookup_data as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(fib_lookup_arg),
            "::",
            stringify!(lookup_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fib_lookup_arg>())).result as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(fib_lookup_arg),
            "::",
            stringify!(result)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fib_lookup_arg>())).rule as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(fib_lookup_arg),
            "::",
            stringify!(rule)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fib_lookup_arg>())).table as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(fib_lookup_arg),
            "::",
            stringify!(table)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fib_lookup_arg>())).flags as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(fib_lookup_arg),
            "::",
            stringify!(flags)
        )
    );
}
impl Default for fib_lookup_arg {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fib_rules_ops {
    pub family: c_types::c_int,
    pub list: list_head,
    pub rule_size: c_types::c_int,
    pub addr_size: c_types::c_int,
    pub unresolved_rules: c_types::c_int,
    pub nr_goto_rules: c_types::c_int,
    pub fib_rules_seq: c_types::c_uint,
    pub action: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut fib_rule,
            arg2: *mut flowi,
            arg3: c_types::c_int,
            arg4: *mut fib_lookup_arg,
        ) -> c_types::c_int,
    >,
    pub suppress: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut fib_rule, arg2: *mut fib_lookup_arg) -> bool_,
    >,
    pub match_: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut fib_rule,
            arg2: *mut flowi,
            arg3: c_types::c_int,
        ) -> c_types::c_int,
    >,
    pub configure: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut fib_rule,
            arg2: *mut sk_buff,
            arg3: *mut fib_rule_hdr,
            arg4: *mut *mut nlattr,
            arg5: *mut netlink_ext_ack,
        ) -> c_types::c_int,
    >,
    pub delete: ::core::option::Option<unsafe extern "C" fn(arg1: *mut fib_rule) -> c_types::c_int>,
    pub compare: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut fib_rule,
            arg2: *mut fib_rule_hdr,
            arg3: *mut *mut nlattr,
        ) -> c_types::c_int,
    >,
    pub fill: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut fib_rule,
            arg2: *mut sk_buff,
            arg3: *mut fib_rule_hdr,
        ) -> c_types::c_int,
    >,
    pub nlmsg_payload: ::core::option::Option<unsafe extern "C" fn(arg1: *mut fib_rule) -> usize>,
    pub flush_cache: ::core::option::Option<unsafe extern "C" fn(ops: *mut fib_rules_ops)>,
    pub nlgroup: c_types::c_int,
    pub policy: *const nla_policy,
    pub rules_list: list_head,
    pub owner: *mut module,
    pub fro_net: *mut net,
    pub rcu: callback_head,
}
#[test]
fn bindgen_test_layout_fib_rules_ops() {
    assert_eq!(
        ::core::mem::size_of::<fib_rules_ops>(),
        184usize,
        concat!("Size of: ", stringify!(fib_rules_ops))
    );
    assert_eq!(
        ::core::mem::align_of::<fib_rules_ops>(),
        8usize,
        concat!("Alignment of ", stringify!(fib_rules_ops))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fib_rules_ops>())).family as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fib_rules_ops),
            "::",
            stringify!(family)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fib_rules_ops>())).list as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(fib_rules_ops),
            "::",
            stringify!(list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fib_rules_ops>())).rule_size as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(fib_rules_ops),
            "::",
            stringify!(rule_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fib_rules_ops>())).addr_size as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(fib_rules_ops),
            "::",
            stringify!(addr_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fib_rules_ops>())).unresolved_rules as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(fib_rules_ops),
            "::",
            stringify!(unresolved_rules)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fib_rules_ops>())).nr_goto_rules as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(fib_rules_ops),
            "::",
            stringify!(nr_goto_rules)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fib_rules_ops>())).fib_rules_seq as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(fib_rules_ops),
            "::",
            stringify!(fib_rules_seq)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fib_rules_ops>())).action as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(fib_rules_ops),
            "::",
            stringify!(action)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fib_rules_ops>())).suppress as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(fib_rules_ops),
            "::",
            stringify!(suppress)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fib_rules_ops>())).match_ as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(fib_rules_ops),
            "::",
            stringify!(match_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fib_rules_ops>())).configure as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(fib_rules_ops),
            "::",
            stringify!(configure)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fib_rules_ops>())).delete as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(fib_rules_ops),
            "::",
            stringify!(delete)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fib_rules_ops>())).compare as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(fib_rules_ops),
            "::",
            stringify!(compare)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fib_rules_ops>())).fill as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(fib_rules_ops),
            "::",
            stringify!(fill)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fib_rules_ops>())).nlmsg_payload as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(fib_rules_ops),
            "::",
            stringify!(nlmsg_payload)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fib_rules_ops>())).flush_cache as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(fib_rules_ops),
            "::",
            stringify!(flush_cache)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fib_rules_ops>())).nlgroup as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(fib_rules_ops),
            "::",
            stringify!(nlgroup)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fib_rules_ops>())).policy as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(fib_rules_ops),
            "::",
            stringify!(policy)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fib_rules_ops>())).rules_list as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(fib_rules_ops),
            "::",
            stringify!(rules_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fib_rules_ops>())).owner as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(fib_rules_ops),
            "::",
            stringify!(owner)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fib_rules_ops>())).fro_net as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(fib_rules_ops),
            "::",
            stringify!(fro_net)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fib_rules_ops>())).rcu as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(fib_rules_ops),
            "::",
            stringify!(rcu)
        )
    );
}
impl Default for fib_rules_ops {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[doc = " struct l3mdev_ops - l3mdev operations"]
#[doc = ""]
#[doc = " @l3mdev_fib_table: Get FIB table id to use for lookups"]
#[doc = ""]
#[doc = " @l3mdev_l3_rcv:    Hook in L3 receive path"]
#[doc = ""]
#[doc = " @l3mdev_l3_out:    Hook in L3 output path"]
#[doc = ""]
#[doc = " @l3mdev_link_scope_lookup: IPv6 lookup for linklocal and mcast destinations"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct l3mdev_ops {
    pub l3mdev_fib_table:
        ::core::option::Option<unsafe extern "C" fn(dev: *const net_device) -> u32_>,
    pub l3mdev_l3_rcv: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut net_device, skb: *mut sk_buff, proto: u16_) -> *mut sk_buff,
    >,
    pub l3mdev_l3_out: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut net_device,
            sk: *mut sock,
            skb: *mut sk_buff,
            proto: u16_,
        ) -> *mut sk_buff,
    >,
    pub l3mdev_link_scope_lookup: ::core::option::Option<
        unsafe extern "C" fn(dev: *const net_device, fl6: *mut flowi6) -> *mut dst_entry,
    >,
}
#[test]
fn bindgen_test_layout_l3mdev_ops() {
    assert_eq!(
        ::core::mem::size_of::<l3mdev_ops>(),
        32usize,
        concat!("Size of: ", stringify!(l3mdev_ops))
    );
    assert_eq!(
        ::core::mem::align_of::<l3mdev_ops>(),
        8usize,
        concat!("Alignment of ", stringify!(l3mdev_ops))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<l3mdev_ops>())).l3mdev_fib_table as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(l3mdev_ops),
            "::",
            stringify!(l3mdev_fib_table)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<l3mdev_ops>())).l3mdev_l3_rcv as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(l3mdev_ops),
            "::",
            stringify!(l3mdev_l3_rcv)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<l3mdev_ops>())).l3mdev_l3_out as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(l3mdev_ops),
            "::",
            stringify!(l3mdev_l3_out)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<l3mdev_ops>())).l3mdev_link_scope_lookup as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(l3mdev_ops),
            "::",
            stringify!(l3mdev_link_scope_lookup)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct socket_lock_t {
    pub slock: spinlock_t,
    pub owned: c_types::c_int,
    pub wq: wait_queue_head_t,
}
#[test]
fn bindgen_test_layout_socket_lock_t() {
    assert_eq!(
        ::core::mem::size_of::<socket_lock_t>(),
        32usize,
        concat!("Size of: ", stringify!(socket_lock_t))
    );
    assert_eq!(
        ::core::mem::align_of::<socket_lock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(socket_lock_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<socket_lock_t>())).slock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(socket_lock_t),
            "::",
            stringify!(slock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<socket_lock_t>())).owned as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(socket_lock_t),
            "::",
            stringify!(owned)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<socket_lock_t>())).wq as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(socket_lock_t),
            "::",
            stringify!(wq)
        )
    );
}
impl Default for socket_lock_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type __portpair = __u32;
pub type __addrpair = __u64;
#[doc = "\tstruct sock_common - minimal network layer representation of sockets"]
#[doc = "\t@skc_daddr: Foreign IPv4 addr"]
#[doc = "\t@skc_rcv_saddr: Bound local IPv4 addr"]
#[doc = "\t@skc_hash: hash value used with various protocol lookup tables"]
#[doc = "\t@skc_u16hashes: two u16 hash values used by UDP lookup tables"]
#[doc = "\t@skc_dport: placeholder for inet_dport/tw_dport"]
#[doc = "\t@skc_num: placeholder for inet_num/tw_num"]
#[doc = "\t@skc_family: network address family"]
#[doc = "\t@skc_state: Connection state"]
#[doc = "\t@skc_reuse: %SO_REUSEADDR setting"]
#[doc = "\t@skc_reuseport: %SO_REUSEPORT setting"]
#[doc = "\t@skc_bound_dev_if: bound device index if != 0"]
#[doc = "\t@skc_bind_node: bind hash linkage for various protocol lookup tables"]
#[doc = "\t@skc_portaddr_node: second hash linkage for UDP/UDP-Lite protocol"]
#[doc = "\t@skc_prot: protocol handlers inside a network family"]
#[doc = "\t@skc_net: reference to the network namespace of this socket"]
#[doc = "\t@skc_node: main hash linkage for various protocol lookup tables"]
#[doc = "\t@skc_nulls_node: main hash linkage for TCP/UDP/UDP-Lite protocol"]
#[doc = "\t@skc_tx_queue_mapping: tx queue number for this connection"]
#[doc = "\t@skc_rx_queue_mapping: rx queue number for this connection"]
#[doc = "\t@skc_flags: place holder for sk_flags"]
#[doc = "\t\t%SO_LINGER (l_onoff), %SO_BROADCAST, %SO_KEEPALIVE,"]
#[doc = "\t\t%SO_OOBINLINE settings, %SO_TIMESTAMPING settings"]
#[doc = "\t@skc_incoming_cpu: record/match cpu processing incoming packets"]
#[doc = "\t@skc_refcnt: reference count"]
#[doc = ""]
#[doc = "\tThis is the minimal network layer representation of sockets, the header"]
#[doc = "\tfor struct sock and struct inet_timewait_sock."]
#[repr(C)]
pub struct sock_common {
    pub __bindgen_anon_1: sock_common__bindgen_ty_1,
    pub __bindgen_anon_2: sock_common__bindgen_ty_2,
    pub __bindgen_anon_3: sock_common__bindgen_ty_3,
    pub skc_family: c_types::c_ushort,
    pub skc_state: c_types::c_uchar,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub skc_bound_dev_if: c_types::c_int,
    pub __bindgen_anon_4: sock_common__bindgen_ty_4,
    pub skc_prot: *mut proto,
    pub skc_net: possible_net_t,
    pub skc_v6_daddr: in6_addr,
    pub skc_v6_rcv_saddr: in6_addr,
    pub skc_cookie: atomic64_t,
    pub __bindgen_anon_5: sock_common__bindgen_ty_5,
    pub skc_dontcopy_begin: __IncompleteArrayField<c_types::c_int>,
    pub __bindgen_anon_6: sock_common__bindgen_ty_6,
    pub skc_tx_queue_mapping: c_types::c_ushort,
    pub skc_rx_queue_mapping: c_types::c_ushort,
    pub __bindgen_anon_7: sock_common__bindgen_ty_7,
    pub skc_refcnt: refcount_t,
    pub skc_dontcopy_end: __IncompleteArrayField<c_types::c_int>,
    pub __bindgen_anon_8: sock_common__bindgen_ty_8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sock_common__bindgen_ty_1 {
    pub skc_addrpair: __addrpair,
    pub __bindgen_anon_1: sock_common__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct sock_common__bindgen_ty_1__bindgen_ty_1 {
    pub skc_daddr: __be32,
    pub skc_rcv_saddr: __be32,
}
#[test]
fn bindgen_test_layout_sock_common__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<sock_common__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(sock_common__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sock_common__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(sock_common__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sock_common__bindgen_ty_1__bindgen_ty_1>())).skc_daddr
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sock_common__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(skc_daddr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sock_common__bindgen_ty_1__bindgen_ty_1>())).skc_rcv_saddr
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sock_common__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(skc_rcv_saddr)
        )
    );
}
#[test]
fn bindgen_test_layout_sock_common__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<sock_common__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(sock_common__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<sock_common__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(sock_common__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sock_common__bindgen_ty_1>())).skc_addrpair as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sock_common__bindgen_ty_1),
            "::",
            stringify!(skc_addrpair)
        )
    );
}
impl Default for sock_common__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sock_common__bindgen_ty_2 {
    pub skc_hash: c_types::c_uint,
    pub skc_u16hashes: [__u16; 2usize],
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_sock_common__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<sock_common__bindgen_ty_2>(),
        4usize,
        concat!("Size of: ", stringify!(sock_common__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<sock_common__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(sock_common__bindgen_ty_2))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sock_common__bindgen_ty_2>())).skc_hash as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sock_common__bindgen_ty_2),
            "::",
            stringify!(skc_hash)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sock_common__bindgen_ty_2>())).skc_u16hashes as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sock_common__bindgen_ty_2),
            "::",
            stringify!(skc_u16hashes)
        )
    );
}
impl Default for sock_common__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sock_common__bindgen_ty_3 {
    pub skc_portpair: __portpair,
    pub __bindgen_anon_1: sock_common__bindgen_ty_3__bindgen_ty_1,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct sock_common__bindgen_ty_3__bindgen_ty_1 {
    pub skc_dport: __be16,
    pub skc_num: __u16,
}
#[test]
fn bindgen_test_layout_sock_common__bindgen_ty_3__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<sock_common__bindgen_ty_3__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(sock_common__bindgen_ty_3__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sock_common__bindgen_ty_3__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(sock_common__bindgen_ty_3__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sock_common__bindgen_ty_3__bindgen_ty_1>())).skc_dport
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sock_common__bindgen_ty_3__bindgen_ty_1),
            "::",
            stringify!(skc_dport)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sock_common__bindgen_ty_3__bindgen_ty_1>())).skc_num as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sock_common__bindgen_ty_3__bindgen_ty_1),
            "::",
            stringify!(skc_num)
        )
    );
}
#[test]
fn bindgen_test_layout_sock_common__bindgen_ty_3() {
    assert_eq!(
        ::core::mem::size_of::<sock_common__bindgen_ty_3>(),
        4usize,
        concat!("Size of: ", stringify!(sock_common__bindgen_ty_3))
    );
    assert_eq!(
        ::core::mem::align_of::<sock_common__bindgen_ty_3>(),
        4usize,
        concat!("Alignment of ", stringify!(sock_common__bindgen_ty_3))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sock_common__bindgen_ty_3>())).skc_portpair as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sock_common__bindgen_ty_3),
            "::",
            stringify!(skc_portpair)
        )
    );
}
impl Default for sock_common__bindgen_ty_3 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sock_common__bindgen_ty_4 {
    pub skc_bind_node: hlist_node,
    pub skc_portaddr_node: hlist_node,
    _bindgen_union_align: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_sock_common__bindgen_ty_4() {
    assert_eq!(
        ::core::mem::size_of::<sock_common__bindgen_ty_4>(),
        16usize,
        concat!("Size of: ", stringify!(sock_common__bindgen_ty_4))
    );
    assert_eq!(
        ::core::mem::align_of::<sock_common__bindgen_ty_4>(),
        8usize,
        concat!("Alignment of ", stringify!(sock_common__bindgen_ty_4))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sock_common__bindgen_ty_4>())).skc_bind_node as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sock_common__bindgen_ty_4),
            "::",
            stringify!(skc_bind_node)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sock_common__bindgen_ty_4>())).skc_portaddr_node as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sock_common__bindgen_ty_4),
            "::",
            stringify!(skc_portaddr_node)
        )
    );
}
impl Default for sock_common__bindgen_ty_4 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sock_common__bindgen_ty_5 {
    pub skc_flags: c_types::c_ulong,
    pub skc_listener: *mut sock,
    pub skc_tw_dr: *mut inet_timewait_death_row,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_sock_common__bindgen_ty_5() {
    assert_eq!(
        ::core::mem::size_of::<sock_common__bindgen_ty_5>(),
        8usize,
        concat!("Size of: ", stringify!(sock_common__bindgen_ty_5))
    );
    assert_eq!(
        ::core::mem::align_of::<sock_common__bindgen_ty_5>(),
        8usize,
        concat!("Alignment of ", stringify!(sock_common__bindgen_ty_5))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sock_common__bindgen_ty_5>())).skc_flags as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sock_common__bindgen_ty_5),
            "::",
            stringify!(skc_flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sock_common__bindgen_ty_5>())).skc_listener as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sock_common__bindgen_ty_5),
            "::",
            stringify!(skc_listener)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sock_common__bindgen_ty_5>())).skc_tw_dr as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sock_common__bindgen_ty_5),
            "::",
            stringify!(skc_tw_dr)
        )
    );
}
impl Default for sock_common__bindgen_ty_5 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sock_common__bindgen_ty_6 {
    pub skc_node: hlist_node,
    pub skc_nulls_node: hlist_nulls_node,
    _bindgen_union_align: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_sock_common__bindgen_ty_6() {
    assert_eq!(
        ::core::mem::size_of::<sock_common__bindgen_ty_6>(),
        16usize,
        concat!("Size of: ", stringify!(sock_common__bindgen_ty_6))
    );
    assert_eq!(
        ::core::mem::align_of::<sock_common__bindgen_ty_6>(),
        8usize,
        concat!("Alignment of ", stringify!(sock_common__bindgen_ty_6))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sock_common__bindgen_ty_6>())).skc_node as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sock_common__bindgen_ty_6),
            "::",
            stringify!(skc_node)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sock_common__bindgen_ty_6>())).skc_nulls_node as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sock_common__bindgen_ty_6),
            "::",
            stringify!(skc_nulls_node)
        )
    );
}
impl Default for sock_common__bindgen_ty_6 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sock_common__bindgen_ty_7 {
    pub skc_incoming_cpu: c_types::c_int,
    pub skc_rcv_wnd: u32_,
    pub skc_tw_rcv_nxt: u32_,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_sock_common__bindgen_ty_7() {
    assert_eq!(
        ::core::mem::size_of::<sock_common__bindgen_ty_7>(),
        4usize,
        concat!("Size of: ", stringify!(sock_common__bindgen_ty_7))
    );
    assert_eq!(
        ::core::mem::align_of::<sock_common__bindgen_ty_7>(),
        4usize,
        concat!("Alignment of ", stringify!(sock_common__bindgen_ty_7))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sock_common__bindgen_ty_7>())).skc_incoming_cpu as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sock_common__bindgen_ty_7),
            "::",
            stringify!(skc_incoming_cpu)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sock_common__bindgen_ty_7>())).skc_rcv_wnd as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sock_common__bindgen_ty_7),
            "::",
            stringify!(skc_rcv_wnd)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sock_common__bindgen_ty_7>())).skc_tw_rcv_nxt as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sock_common__bindgen_ty_7),
            "::",
            stringify!(skc_tw_rcv_nxt)
        )
    );
}
impl Default for sock_common__bindgen_ty_7 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sock_common__bindgen_ty_8 {
    pub skc_rxhash: u32_,
    pub skc_window_clamp: u32_,
    pub skc_tw_snd_nxt: u32_,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_sock_common__bindgen_ty_8() {
    assert_eq!(
        ::core::mem::size_of::<sock_common__bindgen_ty_8>(),
        4usize,
        concat!("Size of: ", stringify!(sock_common__bindgen_ty_8))
    );
    assert_eq!(
        ::core::mem::align_of::<sock_common__bindgen_ty_8>(),
        4usize,
        concat!("Alignment of ", stringify!(sock_common__bindgen_ty_8))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sock_common__bindgen_ty_8>())).skc_rxhash as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sock_common__bindgen_ty_8),
            "::",
            stringify!(skc_rxhash)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sock_common__bindgen_ty_8>())).skc_window_clamp as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sock_common__bindgen_ty_8),
            "::",
            stringify!(skc_window_clamp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sock_common__bindgen_ty_8>())).skc_tw_snd_nxt as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sock_common__bindgen_ty_8),
            "::",
            stringify!(skc_tw_snd_nxt)
        )
    );
}
impl Default for sock_common__bindgen_ty_8 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_sock_common() {
    assert_eq!(
        ::core::mem::size_of::<sock_common>(),
        136usize,
        concat!("Size of: ", stringify!(sock_common))
    );
    assert_eq!(
        ::core::mem::align_of::<sock_common>(),
        8usize,
        concat!("Alignment of ", stringify!(sock_common))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sock_common>())).skc_family as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sock_common),
            "::",
            stringify!(skc_family)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sock_common>())).skc_state as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(sock_common),
            "::",
            stringify!(skc_state)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sock_common>())).skc_bound_dev_if as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(sock_common),
            "::",
            stringify!(skc_bound_dev_if)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sock_common>())).skc_prot as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(sock_common),
            "::",
            stringify!(skc_prot)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sock_common>())).skc_net as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(sock_common),
            "::",
            stringify!(skc_net)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sock_common>())).skc_v6_daddr as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(sock_common),
            "::",
            stringify!(skc_v6_daddr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sock_common>())).skc_v6_rcv_saddr as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(sock_common),
            "::",
            stringify!(skc_v6_rcv_saddr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sock_common>())).skc_cookie as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(sock_common),
            "::",
            stringify!(skc_cookie)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sock_common>())).skc_dontcopy_begin as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(sock_common),
            "::",
            stringify!(skc_dontcopy_begin)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sock_common>())).skc_tx_queue_mapping as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(sock_common),
            "::",
            stringify!(skc_tx_queue_mapping)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sock_common>())).skc_rx_queue_mapping as *const _ as usize
        },
        122usize,
        concat!(
            "Offset of field: ",
            stringify!(sock_common),
            "::",
            stringify!(skc_rx_queue_mapping)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sock_common>())).skc_refcnt as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(sock_common),
            "::",
            stringify!(skc_refcnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sock_common>())).skc_dontcopy_end as *const _ as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(sock_common),
            "::",
            stringify!(skc_dontcopy_end)
        )
    );
}
impl Default for sock_common {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl sock_common {
    #[inline]
    pub fn skc_reuse(&self) -> c_types::c_uchar {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_skc_reuse(&mut self, val: c_types::c_uchar) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn skc_reuseport(&self) -> c_types::c_uchar {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_skc_reuseport(&mut self, val: c_types::c_uchar) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn skc_ipv6only(&self) -> c_types::c_uchar {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_skc_ipv6only(&mut self, val: c_types::c_uchar) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn skc_net_refcnt(&self) -> c_types::c_uchar {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_skc_net_refcnt(&mut self, val: c_types::c_uchar) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        skc_reuse: c_types::c_uchar,
        skc_reuseport: c_types::c_uchar,
        skc_ipv6only: c_types::c_uchar,
        skc_net_refcnt: c_types::c_uchar,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let skc_reuse: u8 = unsafe { ::core::mem::transmute(skc_reuse) };
            skc_reuse as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let skc_reuseport: u8 = unsafe { ::core::mem::transmute(skc_reuseport) };
            skc_reuseport as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let skc_ipv6only: u8 = unsafe { ::core::mem::transmute(skc_ipv6only) };
            skc_ipv6only as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let skc_net_refcnt: u8 = unsafe { ::core::mem::transmute(skc_net_refcnt) };
            skc_net_refcnt as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_sk_storage {
    _unused: [u8; 0],
}
#[doc = "\tstruct sock - network layer representation of sockets"]
#[doc = "\t@__sk_common: shared layout with inet_timewait_sock"]
#[doc = "\t@sk_shutdown: mask of %SEND_SHUTDOWN and/or %RCV_SHUTDOWN"]
#[doc = "\t@sk_userlocks: %SO_SNDBUF and %SO_RCVBUF settings"]
#[doc = "\t@sk_lock:\tsynchronizer"]
#[doc = "\t@sk_kern_sock: True if sock is using kernel lock classes"]
#[doc = "\t@sk_rcvbuf: size of receive buffer in bytes"]
#[doc = "\t@sk_wq: sock wait queue and async head"]
#[doc = "\t@sk_rx_dst: receive input route used by early demux"]
#[doc = "\t@sk_dst_cache: destination cache"]
#[doc = "\t@sk_dst_pending_confirm: need to confirm neighbour"]
#[doc = "\t@sk_policy: flow policy"]
#[doc = "\t@sk_receive_queue: incoming packets"]
#[doc = "\t@sk_wmem_alloc: transmit queue bytes committed"]
#[doc = "\t@sk_tsq_flags: TCP Small Queues flags"]
#[doc = "\t@sk_write_queue: Packet sending queue"]
#[doc = "\t@sk_omem_alloc: \"o\" is \"option\" or \"other\""]
#[doc = "\t@sk_wmem_queued: persistent queue size"]
#[doc = "\t@sk_forward_alloc: space allocated forward"]
#[doc = "\t@sk_napi_id: id of the last napi context to receive data for sk"]
#[doc = "\t@sk_ll_usec: usecs to busypoll when there is no data"]
#[doc = "\t@sk_allocation: allocation mode"]
#[doc = "\t@sk_pacing_rate: Pacing rate (if supported by transport/packet scheduler)"]
#[doc = "\t@sk_pacing_status: Pacing status (requested, handled by sch_fq)"]
#[doc = "\t@sk_max_pacing_rate: Maximum pacing rate (%SO_MAX_PACING_RATE)"]
#[doc = "\t@sk_sndbuf: size of send buffer in bytes"]
#[doc = "\t@__sk_flags_offset: empty field used to determine location of bitfield"]
#[doc = "\t@sk_padding: unused element for alignment"]
#[doc = "\t@sk_no_check_tx: %SO_NO_CHECK setting, set checksum in TX packets"]
#[doc = "\t@sk_no_check_rx: allow zero checksum in RX packets"]
#[doc = "\t@sk_route_caps: route capabilities (e.g. %NETIF_F_TSO)"]
#[doc = "\t@sk_route_nocaps: forbidden route capabilities (e.g NETIF_F_GSO_MASK)"]
#[doc = "\t@sk_gso_type: GSO type (e.g. %SKB_GSO_TCPV4)"]
#[doc = "\t@sk_gso_max_size: Maximum GSO segment size to build"]
#[doc = "\t@sk_gso_max_segs: Maximum number of GSO segments"]
#[doc = "\t@sk_pacing_shift: scaling factor for TCP Small Queues"]
#[doc = "\t@sk_lingertime: %SO_LINGER l_linger setting"]
#[doc = "\t@sk_backlog: always used with the per-socket spinlock held"]
#[doc = "\t@sk_callback_lock: used with the callbacks in the end of this struct"]
#[doc = "\t@sk_error_queue: rarely used"]
#[doc = "\t@sk_prot_creator: sk_prot of original sock creator (see ipv6_setsockopt,"]
#[doc = "\t\t\t  IPV6_ADDRFORM for instance)"]
#[doc = "\t@sk_err: last error"]
#[doc = "\t@sk_err_soft: errors that don't cause failure but are the cause of a"]
#[doc = "\t\t      persistent failure not just 'timed out'"]
#[doc = "\t@sk_drops: raw/udp drops counter"]
#[doc = "\t@sk_ack_backlog: current listen backlog"]
#[doc = "\t@sk_max_ack_backlog: listen backlog set in listen()"]
#[doc = "\t@sk_uid: user id of owner"]
#[doc = "\t@sk_priority: %SO_PRIORITY setting"]
#[doc = "\t@sk_type: socket type (%SOCK_STREAM, etc)"]
#[doc = "\t@sk_protocol: which protocol this socket belongs in this network family"]
#[doc = "\t@sk_peer_pid: &struct pid for this socket's peer"]
#[doc = "\t@sk_peer_cred: %SO_PEERCRED setting"]
#[doc = "\t@sk_rcvlowat: %SO_RCVLOWAT setting"]
#[doc = "\t@sk_rcvtimeo: %SO_RCVTIMEO setting"]
#[doc = "\t@sk_sndtimeo: %SO_SNDTIMEO setting"]
#[doc = "\t@sk_txhash: computed flow hash for use on transmit"]
#[doc = "\t@sk_filter: socket filtering instructions"]
#[doc = "\t@sk_timer: sock cleanup timer"]
#[doc = "\t@sk_stamp: time stamp of last packet received"]
#[doc = "\t@sk_stamp_seq: lock for accessing sk_stamp on 32 bit architectures only"]
#[doc = "\t@sk_tsflags: SO_TIMESTAMPING socket options"]
#[doc = "\t@sk_tskey: counter to disambiguate concurrent tstamp requests"]
#[doc = "\t@sk_zckey: counter to order MSG_ZEROCOPY notifications"]
#[doc = "\t@sk_socket: Identd and reporting IO signals"]
#[doc = "\t@sk_user_data: RPC layer private data"]
#[doc = "\t@sk_frag: cached page frag"]
#[doc = "\t@sk_peek_off: current peek_offset value"]
#[doc = "\t@sk_send_head: front of stuff to transmit"]
#[doc = "\t@sk_security: used by security modules"]
#[doc = "\t@sk_mark: generic packet mark"]
#[doc = "\t@sk_cgrp_data: cgroup data for this cgroup"]
#[doc = "\t@sk_memcg: this socket's memory cgroup association"]
#[doc = "\t@sk_write_pending: a write to stream socket waits to start"]
#[doc = "\t@sk_state_change: callback to indicate change in the state of the sock"]
#[doc = "\t@sk_data_ready: callback to indicate there is data to be processed"]
#[doc = "\t@sk_write_space: callback to indicate there is bf sending space available"]
#[doc = "\t@sk_error_report: callback to indicate errors (e.g. %MSG_ERRQUEUE)"]
#[doc = "\t@sk_backlog_rcv: callback to process the backlog"]
#[doc = "\t@sk_destruct: called at sock freeing time, i.e. when all refcnt == 0"]
#[doc = "\t@sk_reuseport_cb: reuseport group container"]
#[doc = "\t@sk_rcu: used during RCU grace period"]
#[doc = "\t@sk_clockid: clockid used by time-based scheduling (SO_TXTIME)"]
#[doc = "\t@sk_txtime_deadline_mode: set deadline mode for SO_TXTIME"]
#[doc = "\t@sk_txtime_unused: unused txtime flags"]
#[repr(C)]
pub struct sock {
    pub __sk_common: sock_common,
    pub sk_lock: socket_lock_t,
    pub sk_drops: atomic_t,
    pub sk_rcvlowat: c_types::c_int,
    pub sk_error_queue: sk_buff_head,
    pub sk_rx_skb_cache: *mut sk_buff,
    pub sk_receive_queue: sk_buff_head,
    pub sk_backlog: sock__bindgen_ty_1,
    pub sk_forward_alloc: c_types::c_int,
    pub sk_ll_usec: c_types::c_uint,
    pub sk_napi_id: c_types::c_uint,
    pub sk_rcvbuf: c_types::c_int,
    pub sk_filter: *mut sk_filter,
    pub __bindgen_anon_1: sock__bindgen_ty_2,
    pub sk_policy: [*mut xfrm_policy; 2usize],
    pub sk_rx_dst: *mut dst_entry,
    pub sk_dst_cache: *mut dst_entry,
    pub sk_omem_alloc: atomic_t,
    pub sk_sndbuf: c_types::c_int,
    pub sk_wmem_queued: c_types::c_int,
    pub sk_wmem_alloc: refcount_t,
    pub sk_tsq_flags: c_types::c_ulong,
    pub __bindgen_anon_2: sock__bindgen_ty_3,
    pub sk_tx_skb_cache: *mut sk_buff,
    pub sk_write_queue: sk_buff_head,
    pub sk_peek_off: __s32,
    pub sk_write_pending: c_types::c_int,
    pub sk_dst_pending_confirm: __u32,
    pub sk_pacing_status: u32_,
    pub sk_sndtimeo: c_types::c_long,
    pub sk_timer: timer_list,
    pub sk_priority: __u32,
    pub sk_mark: __u32,
    pub sk_pacing_rate: c_types::c_ulong,
    pub sk_max_pacing_rate: c_types::c_ulong,
    pub sk_frag: page_frag,
    pub sk_route_caps: netdev_features_t,
    pub sk_route_nocaps: netdev_features_t,
    pub sk_route_forced_caps: netdev_features_t,
    pub sk_gso_type: c_types::c_int,
    pub sk_gso_max_size: c_types::c_uint,
    pub sk_allocation: gfp_t,
    pub sk_txhash: __u32,
    pub __sk_flags_offset: __IncompleteArrayField<c_types::c_uint>,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
    pub sk_gso_max_segs: u16_,
    pub sk_pacing_shift: u8_,
    pub sk_lingertime: c_types::c_ulong,
    pub sk_prot_creator: *mut proto,
    pub sk_callback_lock: rwlock_t,
    pub sk_err: c_types::c_int,
    pub sk_err_soft: c_types::c_int,
    pub sk_ack_backlog: u32_,
    pub sk_max_ack_backlog: u32_,
    pub sk_uid: kuid_t,
    pub sk_peer_pid: *mut pid,
    pub sk_peer_cred: *const cred,
    pub sk_rcvtimeo: c_types::c_long,
    pub sk_stamp: ktime_t,
    pub sk_tsflags: u16_,
    pub sk_shutdown: u8_,
    pub sk_tskey: u32_,
    pub sk_zckey: atomic_t,
    pub sk_clockid: u8_,
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub sk_socket: *mut socket,
    pub sk_user_data: *mut c_types::c_void,
    pub sk_security: *mut c_types::c_void,
    pub sk_cgrp_data: sock_cgroup_data,
    pub sk_memcg: *mut mem_cgroup,
    pub sk_state_change: ::core::option::Option<unsafe extern "C" fn(sk: *mut sock)>,
    pub sk_data_ready: ::core::option::Option<unsafe extern "C" fn(sk: *mut sock)>,
    pub sk_write_space: ::core::option::Option<unsafe extern "C" fn(sk: *mut sock)>,
    pub sk_error_report: ::core::option::Option<unsafe extern "C" fn(sk: *mut sock)>,
    pub sk_backlog_rcv: ::core::option::Option<
        unsafe extern "C" fn(sk: *mut sock, skb: *mut sk_buff) -> c_types::c_int,
    >,
    pub sk_validate_xmit_skb: ::core::option::Option<
        unsafe extern "C" fn(
            sk: *mut sock,
            dev: *mut net_device,
            skb: *mut sk_buff,
        ) -> *mut sk_buff,
    >,
    pub sk_destruct: ::core::option::Option<unsafe extern "C" fn(sk: *mut sock)>,
    pub sk_reuseport_cb: *mut sock_reuseport,
    pub sk_bpf_storage: *mut bpf_sk_storage,
    pub sk_rcu: callback_head,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sock__bindgen_ty_1 {
    pub rmem_alloc: atomic_t,
    pub len: c_types::c_int,
    pub head: *mut sk_buff,
    pub tail: *mut sk_buff,
}
#[test]
fn bindgen_test_layout_sock__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<sock__bindgen_ty_1>(),
        24usize,
        concat!("Size of: ", stringify!(sock__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<sock__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(sock__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sock__bindgen_ty_1>())).rmem_alloc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sock__bindgen_ty_1),
            "::",
            stringify!(rmem_alloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sock__bindgen_ty_1>())).len as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sock__bindgen_ty_1),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sock__bindgen_ty_1>())).head as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sock__bindgen_ty_1),
            "::",
            stringify!(head)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sock__bindgen_ty_1>())).tail as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sock__bindgen_ty_1),
            "::",
            stringify!(tail)
        )
    );
}
impl Default for sock__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sock__bindgen_ty_2 {
    pub sk_wq: *mut socket_wq,
    pub sk_wq_raw: *mut socket_wq,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_sock__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<sock__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(sock__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<sock__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(sock__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sock__bindgen_ty_2>())).sk_wq as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sock__bindgen_ty_2),
            "::",
            stringify!(sk_wq)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sock__bindgen_ty_2>())).sk_wq_raw as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sock__bindgen_ty_2),
            "::",
            stringify!(sk_wq_raw)
        )
    );
}
impl Default for sock__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sock__bindgen_ty_3 {
    pub sk_send_head: *mut sk_buff,
    pub tcp_rtx_queue: rb_root,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_sock__bindgen_ty_3() {
    assert_eq!(
        ::core::mem::size_of::<sock__bindgen_ty_3>(),
        8usize,
        concat!("Size of: ", stringify!(sock__bindgen_ty_3))
    );
    assert_eq!(
        ::core::mem::align_of::<sock__bindgen_ty_3>(),
        8usize,
        concat!("Alignment of ", stringify!(sock__bindgen_ty_3))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sock__bindgen_ty_3>())).sk_send_head as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sock__bindgen_ty_3),
            "::",
            stringify!(sk_send_head)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sock__bindgen_ty_3>())).tcp_rtx_queue as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sock__bindgen_ty_3),
            "::",
            stringify!(tcp_rtx_queue)
        )
    );
}
impl Default for sock__bindgen_ty_3 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_sock() {
    assert_eq!(
        ::core::mem::size_of::<sock>(),
        760usize,
        concat!("Size of: ", stringify!(sock))
    );
    assert_eq!(
        ::core::mem::align_of::<sock>(),
        8usize,
        concat!("Alignment of ", stringify!(sock))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sock>())).__sk_common as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sock),
            "::",
            stringify!(__sk_common)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sock>())).sk_lock as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(sock),
            "::",
            stringify!(sk_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sock>())).sk_drops as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(sock),
            "::",
            stringify!(sk_drops)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sock>())).sk_rcvlowat as *const _ as usize },
        172usize,
        concat!(
            "Offset of field: ",
            stringify!(sock),
            "::",
            stringify!(sk_rcvlowat)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sock>())).sk_error_queue as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(sock),
            "::",
            stringify!(sk_error_queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sock>())).sk_rx_skb_cache as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(sock),
            "::",
            stringify!(sk_rx_skb_cache)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sock>())).sk_receive_queue as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(sock),
            "::",
            stringify!(sk_receive_queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sock>())).sk_backlog as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(sock),
            "::",
            stringify!(sk_backlog)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sock>())).sk_forward_alloc as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(sock),
            "::",
            stringify!(sk_forward_alloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sock>())).sk_ll_usec as *const _ as usize },
        260usize,
        concat!(
            "Offset of field: ",
            stringify!(sock),
            "::",
            stringify!(sk_ll_usec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sock>())).sk_napi_id as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(sock),
            "::",
            stringify!(sk_napi_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sock>())).sk_rcvbuf as *const _ as usize },
        268usize,
        concat!(
            "Offset of field: ",
            stringify!(sock),
            "::",
            stringify!(sk_rcvbuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sock>())).sk_filter as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(sock),
            "::",
            stringify!(sk_filter)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sock>())).sk_policy as *const _ as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(sock),
            "::",
            stringify!(sk_policy)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sock>())).sk_rx_dst as *const _ as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(sock),
            "::",
            stringify!(sk_rx_dst)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sock>())).sk_dst_cache as *const _ as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(sock),
            "::",
            stringify!(sk_dst_cache)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sock>())).sk_omem_alloc as *const _ as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(sock),
            "::",
            stringify!(sk_omem_alloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sock>())).sk_sndbuf as *const _ as usize },
        324usize,
        concat!(
            "Offset of field: ",
            stringify!(sock),
            "::",
            stringify!(sk_sndbuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sock>())).sk_wmem_queued as *const _ as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(sock),
            "::",
            stringify!(sk_wmem_queued)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sock>())).sk_wmem_alloc as *const _ as usize },
        332usize,
        concat!(
            "Offset of field: ",
            stringify!(sock),
            "::",
            stringify!(sk_wmem_alloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sock>())).sk_tsq_flags as *const _ as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(sock),
            "::",
            stringify!(sk_tsq_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sock>())).sk_tx_skb_cache as *const _ as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(sock),
            "::",
            stringify!(sk_tx_skb_cache)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sock>())).sk_write_queue as *const _ as usize },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(sock),
            "::",
            stringify!(sk_write_queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sock>())).sk_peek_off as *const _ as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(sock),
            "::",
            stringify!(sk_peek_off)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sock>())).sk_write_pending as *const _ as usize },
        388usize,
        concat!(
            "Offset of field: ",
            stringify!(sock),
            "::",
            stringify!(sk_write_pending)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sock>())).sk_dst_pending_confirm as *const _ as usize },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(sock),
            "::",
            stringify!(sk_dst_pending_confirm)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sock>())).sk_pacing_status as *const _ as usize },
        396usize,
        concat!(
            "Offset of field: ",
            stringify!(sock),
            "::",
            stringify!(sk_pacing_status)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sock>())).sk_sndtimeo as *const _ as usize },
        400usize,
        concat!(
            "Offset of field: ",
            stringify!(sock),
            "::",
            stringify!(sk_sndtimeo)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sock>())).sk_timer as *const _ as usize },
        408usize,
        concat!(
            "Offset of field: ",
            stringify!(sock),
            "::",
            stringify!(sk_timer)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sock>())).sk_priority as *const _ as usize },
        448usize,
        concat!(
            "Offset of field: ",
            stringify!(sock),
            "::",
            stringify!(sk_priority)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sock>())).sk_mark as *const _ as usize },
        452usize,
        concat!(
            "Offset of field: ",
            stringify!(sock),
            "::",
            stringify!(sk_mark)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sock>())).sk_pacing_rate as *const _ as usize },
        456usize,
        concat!(
            "Offset of field: ",
            stringify!(sock),
            "::",
            stringify!(sk_pacing_rate)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sock>())).sk_max_pacing_rate as *const _ as usize },
        464usize,
        concat!(
            "Offset of field: ",
            stringify!(sock),
            "::",
            stringify!(sk_max_pacing_rate)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sock>())).sk_frag as *const _ as usize },
        472usize,
        concat!(
            "Offset of field: ",
            stringify!(sock),
            "::",
            stringify!(sk_frag)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sock>())).sk_route_caps as *const _ as usize },
        488usize,
        concat!(
            "Offset of field: ",
            stringify!(sock),
            "::",
            stringify!(sk_route_caps)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sock>())).sk_route_nocaps as *const _ as usize },
        496usize,
        concat!(
            "Offset of field: ",
            stringify!(sock),
            "::",
            stringify!(sk_route_nocaps)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sock>())).sk_route_forced_caps as *const _ as usize },
        504usize,
        concat!(
            "Offset of field: ",
            stringify!(sock),
            "::",
            stringify!(sk_route_forced_caps)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sock>())).sk_gso_type as *const _ as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(sock),
            "::",
            stringify!(sk_gso_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sock>())).sk_gso_max_size as *const _ as usize },
        516usize,
        concat!(
            "Offset of field: ",
            stringify!(sock),
            "::",
            stringify!(sk_gso_max_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sock>())).sk_allocation as *const _ as usize },
        520usize,
        concat!(
            "Offset of field: ",
            stringify!(sock),
            "::",
            stringify!(sk_allocation)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sock>())).sk_txhash as *const _ as usize },
        524usize,
        concat!(
            "Offset of field: ",
            stringify!(sock),
            "::",
            stringify!(sk_txhash)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sock>())).__sk_flags_offset as *const _ as usize },
        528usize,
        concat!(
            "Offset of field: ",
            stringify!(sock),
            "::",
            stringify!(__sk_flags_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sock>())).sk_gso_max_segs as *const _ as usize },
        532usize,
        concat!(
            "Offset of field: ",
            stringify!(sock),
            "::",
            stringify!(sk_gso_max_segs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sock>())).sk_pacing_shift as *const _ as usize },
        534usize,
        concat!(
            "Offset of field: ",
            stringify!(sock),
            "::",
            stringify!(sk_pacing_shift)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sock>())).sk_lingertime as *const _ as usize },
        536usize,
        concat!(
            "Offset of field: ",
            stringify!(sock),
            "::",
            stringify!(sk_lingertime)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sock>())).sk_prot_creator as *const _ as usize },
        544usize,
        concat!(
            "Offset of field: ",
            stringify!(sock),
            "::",
            stringify!(sk_prot_creator)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sock>())).sk_callback_lock as *const _ as usize },
        552usize,
        concat!(
            "Offset of field: ",
            stringify!(sock),
            "::",
            stringify!(sk_callback_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sock>())).sk_err as *const _ as usize },
        560usize,
        concat!(
            "Offset of field: ",
            stringify!(sock),
            "::",
            stringify!(sk_err)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sock>())).sk_err_soft as *const _ as usize },
        564usize,
        concat!(
            "Offset of field: ",
            stringify!(sock),
            "::",
            stringify!(sk_err_soft)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sock>())).sk_ack_backlog as *const _ as usize },
        568usize,
        concat!(
            "Offset of field: ",
            stringify!(sock),
            "::",
            stringify!(sk_ack_backlog)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sock>())).sk_max_ack_backlog as *const _ as usize },
        572usize,
        concat!(
            "Offset of field: ",
            stringify!(sock),
            "::",
            stringify!(sk_max_ack_backlog)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sock>())).sk_uid as *const _ as usize },
        576usize,
        concat!(
            "Offset of field: ",
            stringify!(sock),
            "::",
            stringify!(sk_uid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sock>())).sk_peer_pid as *const _ as usize },
        584usize,
        concat!(
            "Offset of field: ",
            stringify!(sock),
            "::",
            stringify!(sk_peer_pid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sock>())).sk_peer_cred as *const _ as usize },
        592usize,
        concat!(
            "Offset of field: ",
            stringify!(sock),
            "::",
            stringify!(sk_peer_cred)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sock>())).sk_rcvtimeo as *const _ as usize },
        600usize,
        concat!(
            "Offset of field: ",
            stringify!(sock),
            "::",
            stringify!(sk_rcvtimeo)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sock>())).sk_stamp as *const _ as usize },
        608usize,
        concat!(
            "Offset of field: ",
            stringify!(sock),
            "::",
            stringify!(sk_stamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sock>())).sk_tsflags as *const _ as usize },
        616usize,
        concat!(
            "Offset of field: ",
            stringify!(sock),
            "::",
            stringify!(sk_tsflags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sock>())).sk_shutdown as *const _ as usize },
        618usize,
        concat!(
            "Offset of field: ",
            stringify!(sock),
            "::",
            stringify!(sk_shutdown)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sock>())).sk_tskey as *const _ as usize },
        620usize,
        concat!(
            "Offset of field: ",
            stringify!(sock),
            "::",
            stringify!(sk_tskey)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sock>())).sk_zckey as *const _ as usize },
        624usize,
        concat!(
            "Offset of field: ",
            stringify!(sock),
            "::",
            stringify!(sk_zckey)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sock>())).sk_clockid as *const _ as usize },
        628usize,
        concat!(
            "Offset of field: ",
            stringify!(sock),
            "::",
            stringify!(sk_clockid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sock>())).sk_socket as *const _ as usize },
        632usize,
        concat!(
            "Offset of field: ",
            stringify!(sock),
            "::",
            stringify!(sk_socket)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sock>())).sk_user_data as *const _ as usize },
        640usize,
        concat!(
            "Offset of field: ",
            stringify!(sock),
            "::",
            stringify!(sk_user_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sock>())).sk_security as *const _ as usize },
        648usize,
        concat!(
            "Offset of field: ",
            stringify!(sock),
            "::",
            stringify!(sk_security)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sock>())).sk_cgrp_data as *const _ as usize },
        656usize,
        concat!(
            "Offset of field: ",
            stringify!(sock),
            "::",
            stringify!(sk_cgrp_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sock>())).sk_memcg as *const _ as usize },
        664usize,
        concat!(
            "Offset of field: ",
            stringify!(sock),
            "::",
            stringify!(sk_memcg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sock>())).sk_state_change as *const _ as usize },
        672usize,
        concat!(
            "Offset of field: ",
            stringify!(sock),
            "::",
            stringify!(sk_state_change)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sock>())).sk_data_ready as *const _ as usize },
        680usize,
        concat!(
            "Offset of field: ",
            stringify!(sock),
            "::",
            stringify!(sk_data_ready)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sock>())).sk_write_space as *const _ as usize },
        688usize,
        concat!(
            "Offset of field: ",
            stringify!(sock),
            "::",
            stringify!(sk_write_space)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sock>())).sk_error_report as *const _ as usize },
        696usize,
        concat!(
            "Offset of field: ",
            stringify!(sock),
            "::",
            stringify!(sk_error_report)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sock>())).sk_backlog_rcv as *const _ as usize },
        704usize,
        concat!(
            "Offset of field: ",
            stringify!(sock),
            "::",
            stringify!(sk_backlog_rcv)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sock>())).sk_validate_xmit_skb as *const _ as usize },
        712usize,
        concat!(
            "Offset of field: ",
            stringify!(sock),
            "::",
            stringify!(sk_validate_xmit_skb)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sock>())).sk_destruct as *const _ as usize },
        720usize,
        concat!(
            "Offset of field: ",
            stringify!(sock),
            "::",
            stringify!(sk_destruct)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sock>())).sk_reuseport_cb as *const _ as usize },
        728usize,
        concat!(
            "Offset of field: ",
            stringify!(sock),
            "::",
            stringify!(sk_reuseport_cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sock>())).sk_bpf_storage as *const _ as usize },
        736usize,
        concat!(
            "Offset of field: ",
            stringify!(sock),
            "::",
            stringify!(sk_bpf_storage)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sock>())).sk_rcu as *const _ as usize },
        744usize,
        concat!(
            "Offset of field: ",
            stringify!(sock),
            "::",
            stringify!(sk_rcu)
        )
    );
}
impl Default for sock {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl sock {
    #[inline]
    pub fn sk_padding(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sk_padding(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sk_kern_sock(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sk_kern_sock(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sk_no_check_tx(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sk_no_check_tx(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sk_no_check_rx(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sk_no_check_rx(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sk_userlocks(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_sk_userlocks(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn sk_protocol(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_sk_protocol(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn sk_type(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_sk_type(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        sk_padding: c_types::c_uint,
        sk_kern_sock: c_types::c_uint,
        sk_no_check_tx: c_types::c_uint,
        sk_no_check_rx: c_types::c_uint,
        sk_userlocks: c_types::c_uint,
        sk_protocol: c_types::c_uint,
        sk_type: c_types::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let sk_padding: u32 = unsafe { ::core::mem::transmute(sk_padding) };
            sk_padding as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let sk_kern_sock: u32 = unsafe { ::core::mem::transmute(sk_kern_sock) };
            sk_kern_sock as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let sk_no_check_tx: u32 = unsafe { ::core::mem::transmute(sk_no_check_tx) };
            sk_no_check_tx as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let sk_no_check_rx: u32 = unsafe { ::core::mem::transmute(sk_no_check_rx) };
            sk_no_check_rx as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let sk_userlocks: u32 = unsafe { ::core::mem::transmute(sk_userlocks) };
            sk_userlocks as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let sk_protocol: u32 = unsafe { ::core::mem::transmute(sk_protocol) };
            sk_protocol as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let sk_type: u32 = unsafe { ::core::mem::transmute(sk_type) };
            sk_type as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn sk_txtime_deadline_mode(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_sk_txtime_deadline_mode(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sk_txtime_report_errors(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_sk_txtime_report_errors(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sk_txtime_unused(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(2usize, 6u8) as u8) }
    }
    #[inline]
    pub fn set_sk_txtime_unused(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(2usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_2(
        sk_txtime_deadline_mode: u8_,
        sk_txtime_report_errors: u8_,
        sk_txtime_unused: u8_,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let sk_txtime_deadline_mode: u8 =
                unsafe { ::core::mem::transmute(sk_txtime_deadline_mode) };
            sk_txtime_deadline_mode as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let sk_txtime_report_errors: u8 =
                unsafe { ::core::mem::transmute(sk_txtime_report_errors) };
            sk_txtime_report_errors as u64
        });
        __bindgen_bitfield_unit.set(2usize, 6u8, {
            let sk_txtime_unused: u8 = unsafe { ::core::mem::transmute(sk_txtime_unused) };
            sk_txtime_unused as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct raw_hashinfo {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct proto {
    pub close:
        ::core::option::Option<unsafe extern "C" fn(sk: *mut sock, timeout: c_types::c_long)>,
    pub pre_connect: ::core::option::Option<
        unsafe extern "C" fn(
            sk: *mut sock,
            uaddr: *mut sockaddr,
            addr_len: c_types::c_int,
        ) -> c_types::c_int,
    >,
    pub connect: ::core::option::Option<
        unsafe extern "C" fn(
            sk: *mut sock,
            uaddr: *mut sockaddr,
            addr_len: c_types::c_int,
        ) -> c_types::c_int,
    >,
    pub disconnect: ::core::option::Option<
        unsafe extern "C" fn(sk: *mut sock, flags: c_types::c_int) -> c_types::c_int,
    >,
    pub accept: ::core::option::Option<
        unsafe extern "C" fn(
            sk: *mut sock,
            flags: c_types::c_int,
            err: *mut c_types::c_int,
            kern: bool_,
        ) -> *mut sock,
    >,
    pub ioctl: ::core::option::Option<
        unsafe extern "C" fn(
            sk: *mut sock,
            cmd: c_types::c_int,
            arg: c_types::c_ulong,
        ) -> c_types::c_int,
    >,
    pub init: ::core::option::Option<unsafe extern "C" fn(sk: *mut sock) -> c_types::c_int>,
    pub destroy: ::core::option::Option<unsafe extern "C" fn(sk: *mut sock)>,
    pub shutdown: ::core::option::Option<unsafe extern "C" fn(sk: *mut sock, how: c_types::c_int)>,
    pub setsockopt: ::core::option::Option<
        unsafe extern "C" fn(
            sk: *mut sock,
            level: c_types::c_int,
            optname: c_types::c_int,
            optval: *mut c_types::c_char,
            optlen: c_types::c_uint,
        ) -> c_types::c_int,
    >,
    pub getsockopt: ::core::option::Option<
        unsafe extern "C" fn(
            sk: *mut sock,
            level: c_types::c_int,
            optname: c_types::c_int,
            optval: *mut c_types::c_char,
            option: *mut c_types::c_int,
        ) -> c_types::c_int,
    >,
    pub keepalive:
        ::core::option::Option<unsafe extern "C" fn(sk: *mut sock, valbool: c_types::c_int)>,
    pub compat_setsockopt: ::core::option::Option<
        unsafe extern "C" fn(
            sk: *mut sock,
            level: c_types::c_int,
            optname: c_types::c_int,
            optval: *mut c_types::c_char,
            optlen: c_types::c_uint,
        ) -> c_types::c_int,
    >,
    pub compat_getsockopt: ::core::option::Option<
        unsafe extern "C" fn(
            sk: *mut sock,
            level: c_types::c_int,
            optname: c_types::c_int,
            optval: *mut c_types::c_char,
            option: *mut c_types::c_int,
        ) -> c_types::c_int,
    >,
    pub compat_ioctl: ::core::option::Option<
        unsafe extern "C" fn(
            sk: *mut sock,
            cmd: c_types::c_uint,
            arg: c_types::c_ulong,
        ) -> c_types::c_int,
    >,
    pub sendmsg: ::core::option::Option<
        unsafe extern "C" fn(sk: *mut sock, msg: *mut msghdr, len: usize) -> c_types::c_int,
    >,
    pub recvmsg: ::core::option::Option<
        unsafe extern "C" fn(
            sk: *mut sock,
            msg: *mut msghdr,
            len: usize,
            noblock: c_types::c_int,
            flags: c_types::c_int,
            addr_len: *mut c_types::c_int,
        ) -> c_types::c_int,
    >,
    pub sendpage: ::core::option::Option<
        unsafe extern "C" fn(
            sk: *mut sock,
            page: *mut page,
            offset: c_types::c_int,
            size: usize,
            flags: c_types::c_int,
        ) -> c_types::c_int,
    >,
    pub bind: ::core::option::Option<
        unsafe extern "C" fn(
            sk: *mut sock,
            uaddr: *mut sockaddr,
            addr_len: c_types::c_int,
        ) -> c_types::c_int,
    >,
    pub backlog_rcv: ::core::option::Option<
        unsafe extern "C" fn(sk: *mut sock, skb: *mut sk_buff) -> c_types::c_int,
    >,
    pub release_cb: ::core::option::Option<unsafe extern "C" fn(sk: *mut sock)>,
    pub hash: ::core::option::Option<unsafe extern "C" fn(sk: *mut sock) -> c_types::c_int>,
    pub unhash: ::core::option::Option<unsafe extern "C" fn(sk: *mut sock)>,
    pub rehash: ::core::option::Option<unsafe extern "C" fn(sk: *mut sock)>,
    pub get_port: ::core::option::Option<
        unsafe extern "C" fn(sk: *mut sock, snum: c_types::c_ushort) -> c_types::c_int,
    >,
    pub inuse_idx: c_types::c_uint,
    pub stream_memory_free: ::core::option::Option<
        unsafe extern "C" fn(sk: *const sock, wake: c_types::c_int) -> bool_,
    >,
    pub stream_memory_read: ::core::option::Option<unsafe extern "C" fn(sk: *const sock) -> bool_>,
    pub enter_memory_pressure: ::core::option::Option<unsafe extern "C" fn(sk: *mut sock)>,
    pub leave_memory_pressure: ::core::option::Option<unsafe extern "C" fn(sk: *mut sock)>,
    pub memory_allocated: *mut atomic_long_t,
    pub sockets_allocated: *mut percpu_counter,
    pub memory_pressure: *mut c_types::c_ulong,
    pub sysctl_mem: *mut c_types::c_long,
    pub sysctl_wmem: *mut c_types::c_int,
    pub sysctl_rmem: *mut c_types::c_int,
    pub sysctl_wmem_offset: u32_,
    pub sysctl_rmem_offset: u32_,
    pub max_header: c_types::c_int,
    pub no_autobind: bool_,
    pub slab: *mut kmem_cache,
    pub obj_size: c_types::c_uint,
    pub slab_flags: slab_flags_t,
    pub useroffset: c_types::c_uint,
    pub usersize: c_types::c_uint,
    pub orphan_count: *mut percpu_counter,
    pub rsk_prot: *mut request_sock_ops,
    pub twsk_prot: *mut timewait_sock_ops,
    pub h: proto__bindgen_ty_1,
    pub owner: *mut module,
    pub name: [c_types::c_char; 32usize],
    pub node: list_head,
    pub diag_destroy: ::core::option::Option<
        unsafe extern "C" fn(sk: *mut sock, err: c_types::c_int) -> c_types::c_int,
    >,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union proto__bindgen_ty_1 {
    pub hashinfo: *mut inet_hashinfo,
    pub udp_table: *mut udp_table,
    pub raw_hash: *mut raw_hashinfo,
    pub smc_hash: *mut smc_hashinfo,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_proto__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<proto__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(proto__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<proto__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(proto__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<proto__bindgen_ty_1>())).hashinfo as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(proto__bindgen_ty_1),
            "::",
            stringify!(hashinfo)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<proto__bindgen_ty_1>())).udp_table as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(proto__bindgen_ty_1),
            "::",
            stringify!(udp_table)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<proto__bindgen_ty_1>())).raw_hash as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(proto__bindgen_ty_1),
            "::",
            stringify!(raw_hash)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<proto__bindgen_ty_1>())).smc_hash as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(proto__bindgen_ty_1),
            "::",
            stringify!(smc_hash)
        )
    );
}
impl Default for proto__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_proto() {
    assert_eq!(
        ::core::mem::size_of::<proto>(),
        424usize,
        concat!("Size of: ", stringify!(proto))
    );
    assert_eq!(
        ::core::mem::align_of::<proto>(),
        8usize,
        concat!("Alignment of ", stringify!(proto))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<proto>())).close as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(proto),
            "::",
            stringify!(close)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<proto>())).pre_connect as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(proto),
            "::",
            stringify!(pre_connect)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<proto>())).connect as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(proto),
            "::",
            stringify!(connect)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<proto>())).disconnect as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(proto),
            "::",
            stringify!(disconnect)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<proto>())).accept as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(proto),
            "::",
            stringify!(accept)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<proto>())).ioctl as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(proto),
            "::",
            stringify!(ioctl)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<proto>())).init as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(proto),
            "::",
            stringify!(init)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<proto>())).destroy as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(proto),
            "::",
            stringify!(destroy)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<proto>())).shutdown as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(proto),
            "::",
            stringify!(shutdown)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<proto>())).setsockopt as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(proto),
            "::",
            stringify!(setsockopt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<proto>())).getsockopt as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(proto),
            "::",
            stringify!(getsockopt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<proto>())).keepalive as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(proto),
            "::",
            stringify!(keepalive)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<proto>())).compat_setsockopt as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(proto),
            "::",
            stringify!(compat_setsockopt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<proto>())).compat_getsockopt as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(proto),
            "::",
            stringify!(compat_getsockopt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<proto>())).compat_ioctl as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(proto),
            "::",
            stringify!(compat_ioctl)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<proto>())).sendmsg as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(proto),
            "::",
            stringify!(sendmsg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<proto>())).recvmsg as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(proto),
            "::",
            stringify!(recvmsg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<proto>())).sendpage as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(proto),
            "::",
            stringify!(sendpage)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<proto>())).bind as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(proto),
            "::",
            stringify!(bind)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<proto>())).backlog_rcv as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(proto),
            "::",
            stringify!(backlog_rcv)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<proto>())).release_cb as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(proto),
            "::",
            stringify!(release_cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<proto>())).hash as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(proto),
            "::",
            stringify!(hash)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<proto>())).unhash as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(proto),
            "::",
            stringify!(unhash)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<proto>())).rehash as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(proto),
            "::",
            stringify!(rehash)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<proto>())).get_port as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(proto),
            "::",
            stringify!(get_port)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<proto>())).inuse_idx as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(proto),
            "::",
            stringify!(inuse_idx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<proto>())).stream_memory_free as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(proto),
            "::",
            stringify!(stream_memory_free)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<proto>())).stream_memory_read as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(proto),
            "::",
            stringify!(stream_memory_read)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<proto>())).enter_memory_pressure as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(proto),
            "::",
            stringify!(enter_memory_pressure)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<proto>())).leave_memory_pressure as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(proto),
            "::",
            stringify!(leave_memory_pressure)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<proto>())).memory_allocated as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(proto),
            "::",
            stringify!(memory_allocated)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<proto>())).sockets_allocated as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(proto),
            "::",
            stringify!(sockets_allocated)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<proto>())).memory_pressure as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(proto),
            "::",
            stringify!(memory_pressure)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<proto>())).sysctl_mem as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(proto),
            "::",
            stringify!(sysctl_mem)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<proto>())).sysctl_wmem as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(proto),
            "::",
            stringify!(sysctl_wmem)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<proto>())).sysctl_rmem as *const _ as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(proto),
            "::",
            stringify!(sysctl_rmem)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<proto>())).sysctl_wmem_offset as *const _ as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(proto),
            "::",
            stringify!(sysctl_wmem_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<proto>())).sysctl_rmem_offset as *const _ as usize },
        292usize,
        concat!(
            "Offset of field: ",
            stringify!(proto),
            "::",
            stringify!(sysctl_rmem_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<proto>())).max_header as *const _ as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(proto),
            "::",
            stringify!(max_header)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<proto>())).no_autobind as *const _ as usize },
        300usize,
        concat!(
            "Offset of field: ",
            stringify!(proto),
            "::",
            stringify!(no_autobind)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<proto>())).slab as *const _ as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(proto),
            "::",
            stringify!(slab)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<proto>())).obj_size as *const _ as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(proto),
            "::",
            stringify!(obj_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<proto>())).slab_flags as *const _ as usize },
        316usize,
        concat!(
            "Offset of field: ",
            stringify!(proto),
            "::",
            stringify!(slab_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<proto>())).useroffset as *const _ as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(proto),
            "::",
            stringify!(useroffset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<proto>())).usersize as *const _ as usize },
        324usize,
        concat!(
            "Offset of field: ",
            stringify!(proto),
            "::",
            stringify!(usersize)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<proto>())).orphan_count as *const _ as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(proto),
            "::",
            stringify!(orphan_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<proto>())).rsk_prot as *const _ as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(proto),
            "::",
            stringify!(rsk_prot)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<proto>())).twsk_prot as *const _ as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(proto),
            "::",
            stringify!(twsk_prot)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<proto>())).h as *const _ as usize },
        352usize,
        concat!("Offset of field: ", stringify!(proto), "::", stringify!(h))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<proto>())).owner as *const _ as usize },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(proto),
            "::",
            stringify!(owner)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<proto>())).name as *const _ as usize },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(proto),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<proto>())).node as *const _ as usize },
        400usize,
        concat!(
            "Offset of field: ",
            stringify!(proto),
            "::",
            stringify!(node)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<proto>())).diag_destroy as *const _ as usize },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(proto),
            "::",
            stringify!(diag_destroy)
        )
    );
}
impl Default for proto {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct request_sock_ops {
    pub family: c_types::c_int,
    pub obj_size: c_types::c_uint,
    pub slab: *mut kmem_cache,
    pub slab_name: *mut c_types::c_char,
    pub rtx_syn_ack: ::core::option::Option<
        unsafe extern "C" fn(sk: *const sock, req: *mut request_sock) -> c_types::c_int,
    >,
    pub send_ack: ::core::option::Option<
        unsafe extern "C" fn(sk: *const sock, skb: *mut sk_buff, req: *mut request_sock),
    >,
    pub send_reset:
        ::core::option::Option<unsafe extern "C" fn(sk: *const sock, skb: *mut sk_buff)>,
    pub destructor: ::core::option::Option<unsafe extern "C" fn(req: *mut request_sock)>,
    pub syn_ack_timeout: ::core::option::Option<unsafe extern "C" fn(req: *const request_sock)>,
}
#[test]
fn bindgen_test_layout_request_sock_ops() {
    assert_eq!(
        ::core::mem::size_of::<request_sock_ops>(),
        64usize,
        concat!("Size of: ", stringify!(request_sock_ops))
    );
    assert_eq!(
        ::core::mem::align_of::<request_sock_ops>(),
        8usize,
        concat!("Alignment of ", stringify!(request_sock_ops))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_sock_ops>())).family as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(request_sock_ops),
            "::",
            stringify!(family)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_sock_ops>())).obj_size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(request_sock_ops),
            "::",
            stringify!(obj_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_sock_ops>())).slab as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(request_sock_ops),
            "::",
            stringify!(slab)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_sock_ops>())).slab_name as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(request_sock_ops),
            "::",
            stringify!(slab_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_sock_ops>())).rtx_syn_ack as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(request_sock_ops),
            "::",
            stringify!(rtx_syn_ack)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_sock_ops>())).send_ack as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(request_sock_ops),
            "::",
            stringify!(send_ack)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_sock_ops>())).send_reset as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(request_sock_ops),
            "::",
            stringify!(send_reset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_sock_ops>())).destructor as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(request_sock_ops),
            "::",
            stringify!(destructor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<request_sock_ops>())).syn_ack_timeout as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(request_sock_ops),
            "::",
            stringify!(syn_ack_timeout)
        )
    );
}
impl Default for request_sock_ops {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct request_sock {
    pub __req_common: sock_common,
    pub dl_next: *mut request_sock,
    pub mss: u16_,
    pub num_retrans: u8_,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub ts_recent: u32_,
    pub rsk_timer: timer_list,
    pub rsk_ops: *const request_sock_ops,
    pub sk: *mut sock,
    pub saved_syn: *mut u32_,
    pub secid: u32_,
    pub peer_secid: u32_,
}
#[test]
fn bindgen_test_layout_request_sock() {
    assert_eq!(
        ::core::mem::size_of::<request_sock>(),
        224usize,
        concat!("Size of: ", stringify!(request_sock))
    );
    assert_eq!(
        ::core::mem::align_of::<request_sock>(),
        8usize,
        concat!("Alignment of ", stringify!(request_sock))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_sock>())).__req_common as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(request_sock),
            "::",
            stringify!(__req_common)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_sock>())).dl_next as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(request_sock),
            "::",
            stringify!(dl_next)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_sock>())).mss as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(request_sock),
            "::",
            stringify!(mss)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_sock>())).num_retrans as *const _ as usize },
        146usize,
        concat!(
            "Offset of field: ",
            stringify!(request_sock),
            "::",
            stringify!(num_retrans)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_sock>())).ts_recent as *const _ as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(request_sock),
            "::",
            stringify!(ts_recent)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_sock>())).rsk_timer as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(request_sock),
            "::",
            stringify!(rsk_timer)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_sock>())).rsk_ops as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(request_sock),
            "::",
            stringify!(rsk_ops)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_sock>())).sk as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(request_sock),
            "::",
            stringify!(sk)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_sock>())).saved_syn as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(request_sock),
            "::",
            stringify!(saved_syn)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_sock>())).secid as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(request_sock),
            "::",
            stringify!(secid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<request_sock>())).peer_secid as *const _ as usize },
        220usize,
        concat!(
            "Offset of field: ",
            stringify!(request_sock),
            "::",
            stringify!(peer_secid)
        )
    );
}
impl Default for request_sock {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl request_sock {
    #[inline]
    pub fn cookie_ts(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_cookie_ts(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn num_timeout(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 7u8) as u8) }
    }
    #[inline]
    pub fn set_num_timeout(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        cookie_ts: u8_,
        num_timeout: u8_,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let cookie_ts: u8 = unsafe { ::core::mem::transmute(cookie_ts) };
            cookie_ts as u64
        });
        __bindgen_bitfield_unit.set(1usize, 7u8, {
            let num_timeout: u8 = unsafe { ::core::mem::transmute(num_timeout) };
            num_timeout as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tcp_congestion_ops {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timewait_sock_ops {
    pub twsk_slab: *mut kmem_cache,
    pub twsk_slab_name: *mut c_types::c_char,
    pub twsk_obj_size: c_types::c_uint,
    pub twsk_unique: ::core::option::Option<
        unsafe extern "C" fn(
            sk: *mut sock,
            sktw: *mut sock,
            twp: *mut c_types::c_void,
        ) -> c_types::c_int,
    >,
    pub twsk_destructor: ::core::option::Option<unsafe extern "C" fn(sk: *mut sock)>,
}
#[test]
fn bindgen_test_layout_timewait_sock_ops() {
    assert_eq!(
        ::core::mem::size_of::<timewait_sock_ops>(),
        40usize,
        concat!("Size of: ", stringify!(timewait_sock_ops))
    );
    assert_eq!(
        ::core::mem::align_of::<timewait_sock_ops>(),
        8usize,
        concat!("Alignment of ", stringify!(timewait_sock_ops))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timewait_sock_ops>())).twsk_slab as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timewait_sock_ops),
            "::",
            stringify!(twsk_slab)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<timewait_sock_ops>())).twsk_slab_name as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timewait_sock_ops),
            "::",
            stringify!(twsk_slab_name)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<timewait_sock_ops>())).twsk_obj_size as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(timewait_sock_ops),
            "::",
            stringify!(twsk_obj_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timewait_sock_ops>())).twsk_unique as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(timewait_sock_ops),
            "::",
            stringify!(twsk_unique)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<timewait_sock_ops>())).twsk_destructor as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(timewait_sock_ops),
            "::",
            stringify!(twsk_destructor)
        )
    );
}
impl Default for timewait_sock_ops {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct tcphdr {
    pub source: __be16,
    pub dest: __be16,
    pub seq: __be32,
    pub ack_seq: __be32,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
    pub window: __be16,
    pub check: __sum16,
    pub urg_ptr: __be16,
}
#[test]
fn bindgen_test_layout_tcphdr() {
    assert_eq!(
        ::core::mem::size_of::<tcphdr>(),
        20usize,
        concat!("Size of: ", stringify!(tcphdr))
    );
    assert_eq!(
        ::core::mem::align_of::<tcphdr>(),
        4usize,
        concat!("Alignment of ", stringify!(tcphdr))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tcphdr>())).source as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tcphdr),
            "::",
            stringify!(source)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tcphdr>())).dest as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(tcphdr),
            "::",
            stringify!(dest)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tcphdr>())).seq as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tcphdr),
            "::",
            stringify!(seq)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tcphdr>())).ack_seq as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tcphdr),
            "::",
            stringify!(ack_seq)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tcphdr>())).window as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(tcphdr),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tcphdr>())).check as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tcphdr),
            "::",
            stringify!(check)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tcphdr>())).urg_ptr as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(tcphdr),
            "::",
            stringify!(urg_ptr)
        )
    );
}
impl tcphdr {
    #[inline]
    pub fn res1(&self) -> __u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_res1(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn doff(&self) -> __u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_doff(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn fin(&self) -> __u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_fin(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn syn(&self) -> __u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_syn(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rst(&self) -> __u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_rst(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn psh(&self) -> __u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_psh(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ack(&self) -> __u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_ack(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn urg(&self) -> __u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_urg(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ece(&self) -> __u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_ece(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cwr(&self) -> __u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_cwr(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        res1: __u16,
        doff: __u16,
        fin: __u16,
        syn: __u16,
        rst: __u16,
        psh: __u16,
        ack: __u16,
        urg: __u16,
        ece: __u16,
        cwr: __u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let res1: u16 = unsafe { ::core::mem::transmute(res1) };
            res1 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let doff: u16 = unsafe { ::core::mem::transmute(doff) };
            doff as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let fin: u16 = unsafe { ::core::mem::transmute(fin) };
            fin as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let syn: u16 = unsafe { ::core::mem::transmute(syn) };
            syn as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let rst: u16 = unsafe { ::core::mem::transmute(rst) };
            rst as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let psh: u16 = unsafe { ::core::mem::transmute(psh) };
            psh as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let ack: u16 = unsafe { ::core::mem::transmute(ack) };
            ack as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let urg: u16 = unsafe { ::core::mem::transmute(urg) };
            urg as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let ece: u16 = unsafe { ::core::mem::transmute(ece) };
            ece as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let cwr: u16 = unsafe { ::core::mem::transmute(cwr) };
            cwr as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct udphdr {
    pub source: __be16,
    pub dest: __be16,
    pub len: __be16,
    pub check: __sum16,
}
#[test]
fn bindgen_test_layout_udphdr() {
    assert_eq!(
        ::core::mem::size_of::<udphdr>(),
        8usize,
        concat!("Size of: ", stringify!(udphdr))
    );
    assert_eq!(
        ::core::mem::align_of::<udphdr>(),
        2usize,
        concat!("Alignment of ", stringify!(udphdr))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<udphdr>())).source as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(udphdr),
            "::",
            stringify!(source)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<udphdr>())).dest as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(udphdr),
            "::",
            stringify!(dest)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<udphdr>())).len as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(udphdr),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<udphdr>())).check as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(udphdr),
            "::",
            stringify!(check)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct icmphdr {
    pub type_: __u8,
    pub code: __u8,
    pub checksum: __sum16,
    pub un: icmphdr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union icmphdr__bindgen_ty_1 {
    pub echo: icmphdr__bindgen_ty_1__bindgen_ty_1,
    pub gateway: __be32,
    pub frag: icmphdr__bindgen_ty_1__bindgen_ty_2,
    pub reserved: [__u8; 4usize],
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct icmphdr__bindgen_ty_1__bindgen_ty_1 {
    pub id: __be16,
    pub sequence: __be16,
}
#[test]
fn bindgen_test_layout_icmphdr__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<icmphdr__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(icmphdr__bindgen_ty_1__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<icmphdr__bindgen_ty_1__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(icmphdr__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<icmphdr__bindgen_ty_1__bindgen_ty_1>())).id as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(icmphdr__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<icmphdr__bindgen_ty_1__bindgen_ty_1>())).sequence as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(icmphdr__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct icmphdr__bindgen_ty_1__bindgen_ty_2 {
    pub __unused: __be16,
    pub mtu: __be16,
}
#[test]
fn bindgen_test_layout_icmphdr__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<icmphdr__bindgen_ty_1__bindgen_ty_2>(),
        4usize,
        concat!("Size of: ", stringify!(icmphdr__bindgen_ty_1__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<icmphdr__bindgen_ty_1__bindgen_ty_2>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(icmphdr__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<icmphdr__bindgen_ty_1__bindgen_ty_2>())).__unused as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(icmphdr__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(__unused)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<icmphdr__bindgen_ty_1__bindgen_ty_2>())).mtu as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(icmphdr__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(mtu)
        )
    );
}
#[test]
fn bindgen_test_layout_icmphdr__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<icmphdr__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(icmphdr__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<icmphdr__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(icmphdr__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<icmphdr__bindgen_ty_1>())).echo as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(icmphdr__bindgen_ty_1),
            "::",
            stringify!(echo)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<icmphdr__bindgen_ty_1>())).gateway as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(icmphdr__bindgen_ty_1),
            "::",
            stringify!(gateway)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<icmphdr__bindgen_ty_1>())).frag as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(icmphdr__bindgen_ty_1),
            "::",
            stringify!(frag)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<icmphdr__bindgen_ty_1>())).reserved as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(icmphdr__bindgen_ty_1),
            "::",
            stringify!(reserved)
        )
    );
}
impl Default for icmphdr__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_icmphdr() {
    assert_eq!(
        ::core::mem::size_of::<icmphdr>(),
        8usize,
        concat!("Size of: ", stringify!(icmphdr))
    );
    assert_eq!(
        ::core::mem::align_of::<icmphdr>(),
        4usize,
        concat!("Alignment of ", stringify!(icmphdr))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<icmphdr>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(icmphdr),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<icmphdr>())).code as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(icmphdr),
            "::",
            stringify!(code)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<icmphdr>())).checksum as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(icmphdr),
            "::",
            stringify!(checksum)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<icmphdr>())).un as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(icmphdr),
            "::",
            stringify!(un)
        )
    );
}
impl Default for icmphdr {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn nlmsg_data_non_inline(nlh: *mut nlmsghdr) -> *mut c_types::c_void;
}
extern "C" {
    pub fn netlink_cb(skb: *mut sk_buff) -> netlink_skb_parms;
}
extern "C" {
    pub fn nlmsg_new_non_inline(payload: usize, flags: gfp_t) -> *mut sk_buff;
}
extern "C" {
    pub fn nlmsg_put_wrapped(
        skb: *mut sk_buff,
        portid: u32_,
        seq: u32_,
        type_: u16_,
        len: u32_,
        flags: u16_,
    ) -> *mut nlmsghdr;
}
extern "C" {
    pub fn kmalloc_wrapped(size: usize, flags: gfp_t) -> *mut c_types::c_void;
}
extern "C" {
    pub fn kcalloc_wrapped(n: usize, size: usize, flags: gfp_t) -> *mut c_types::c_void;
}
extern "C" {
    pub fn kfree_wrapped(ptr: *const c_types::c_void);
}
extern "C" {
    pub fn ip_hdr_wrapped(skb: *const sk_buff) -> *mut iphdr;
}
extern "C" {
    pub fn tcp_hdr_wrapped(skb: *const sk_buff) -> *mut tcphdr;
}
extern "C" {
    pub fn udp_hdr_wrapped(skb: *const sk_buff) -> *mut udphdr;
}
extern "C" {
    pub fn icmp_hdr_wrapped(skb: *const sk_buff) -> *mut icmphdr;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct GFP {}
pub const GFP_KERNEL: c_types::c_uint = 3264;
pub type GFP__bindgen_ty_1 = c_types::c_uint;
#[test]
fn bindgen_test_layout_GFP() {
    assert_eq!(
        ::core::mem::size_of::<GFP>(),
        0usize,
        concat!("Size of: ", stringify!(GFP))
    );
    assert_eq!(
        ::core::mem::align_of::<GFP>(),
        1usize,
        concat!("Alignment of ", stringify!(GFP))
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ProtocolFamily {}
pub const ProtocolFamily_UNSPEC: c_types::c_uint = 0;
pub const ProtocolFamily_LOCAL: c_types::c_uint = 1;
pub const ProtocolFamily_UNIX: c_types::c_uint = 1;
pub const ProtocolFamily_FILE: c_types::c_uint = 1;
pub const ProtocolFamily_INET: c_types::c_uint = 2;
pub const ProtocolFamily_AX25: c_types::c_uint = 3;
pub const ProtocolFamily_IPX: c_types::c_uint = 4;
pub const ProtocolFamily_APPLETALK: c_types::c_uint = 5;
pub const ProtocolFamily_NETROM: c_types::c_uint = 6;
pub const ProtocolFamily_BRIDGE: c_types::c_uint = 7;
pub const ProtocolFamily_ATMPVC: c_types::c_uint = 8;
pub const ProtocolFamily_X25: c_types::c_uint = 9;
pub const ProtocolFamily_INET6: c_types::c_uint = 10;
pub const ProtocolFamily_ROSE: c_types::c_uint = 11;
pub const ProtocolFamily_DECnet: c_types::c_uint = 12;
pub const ProtocolFamily_NETBEUI: c_types::c_uint = 13;
pub const ProtocolFamily_SECURITY: c_types::c_uint = 14;
pub const ProtocolFamily_KEY: c_types::c_uint = 15;
pub const ProtocolFamily_NETLINK: c_types::c_uint = 16;
pub const ProtocolFamily_ROUTE: c_types::c_uint = 16;
pub const ProtocolFamily_PACKET: c_types::c_uint = 17;
pub const ProtocolFamily_ASH: c_types::c_uint = 18;
pub const ProtocolFamily_ECONET: c_types::c_uint = 19;
pub const ProtocolFamily_ATMSVC: c_types::c_uint = 20;
pub const ProtocolFamily_RDS: c_types::c_uint = 21;
pub const ProtocolFamily_RXRPC: c_types::c_uint = 33;
pub const ProtocolFamily_ISDN: c_types::c_uint = 34;
pub const ProtocolFamily_PHONET: c_types::c_uint = 35;
pub const ProtocolFamily_IEEE802154: c_types::c_uint = 36;
pub const ProtocolFamily_CAIF: c_types::c_uint = 37;
pub const ProtocolFamily_ALG: c_types::c_uint = 38;
pub const ProtocolFamily_NFC: c_types::c_uint = 39;
pub const ProtocolFamily_VSOCK: c_types::c_uint = 40;
pub const ProtocolFamily_KCM: c_types::c_uint = 41;
pub const ProtocolFamily_QIPCRTR: c_types::c_uint = 42;
pub const ProtocolFamily_SMC: c_types::c_uint = 43;
pub const ProtocolFamily_XDP: c_types::c_uint = 44;
pub const ProtocolFamily_MAX: c_types::c_uint = 45;
pub type ProtocolFamily__bindgen_ty_1 = c_types::c_uint;
#[test]
fn bindgen_test_layout_ProtocolFamily() {
    assert_eq!(
        ::core::mem::size_of::<ProtocolFamily>(),
        0usize,
        concat!("Size of: ", stringify!(ProtocolFamily))
    );
    assert_eq!(
        ::core::mem::align_of::<ProtocolFamily>(),
        1usize,
        concat!("Alignment of ", stringify!(ProtocolFamily))
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IpProtocol {}
pub const IpProtocol_IP: c_types::c_uint = 0;
pub const IpProtocol_ICMP: c_types::c_uint = 1;
pub const IpProtocol_IGMP: c_types::c_uint = 2;
pub const IpProtocol_IPIP: c_types::c_uint = 4;
pub const IpProtocol_TCP: c_types::c_uint = 6;
pub const IpProtocol_EGP: c_types::c_uint = 8;
pub const IpProtocol_PUP: c_types::c_uint = 12;
pub const IpProtocol_UDP: c_types::c_uint = 17;
pub const IpProtocol_IDP: c_types::c_uint = 22;
pub const IpProtocol_TP: c_types::c_uint = 29;
pub const IpProtocol_DCCP: c_types::c_uint = 33;
pub const IpProtocol_IPV6: c_types::c_uint = 41;
pub const IpProtocol_RSVP: c_types::c_uint = 46;
pub const IpProtocol_GRE: c_types::c_uint = 47;
pub const IpProtocol_ESP: c_types::c_uint = 50;
pub const IpProtocol_AH: c_types::c_uint = 51;
pub const IpProtocol_MTP: c_types::c_uint = 92;
pub const IpProtocol_BEETPH: c_types::c_uint = 94;
pub const IpProtocol_ENCAP: c_types::c_uint = 98;
pub const IpProtocol_PIM: c_types::c_uint = 103;
pub const IpProtocol_COMP: c_types::c_uint = 108;
pub const IpProtocol_SCTP: c_types::c_uint = 132;
pub const IpProtocol_UDPLITE: c_types::c_uint = 136;
pub const IpProtocol_MPLS: c_types::c_uint = 137;
pub const IpProtocol_RAW: c_types::c_uint = 255;
pub type IpProtocol__bindgen_ty_1 = c_types::c_uint;
#[test]
fn bindgen_test_layout_IpProtocol() {
    assert_eq!(
        ::core::mem::size_of::<IpProtocol>(),
        0usize,
        concat!("Size of: ", stringify!(IpProtocol))
    );
    assert_eq!(
        ::core::mem::align_of::<IpProtocol>(),
        1usize,
        concat!("Alignment of ", stringify!(IpProtocol))
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct module_sect_attrs {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct module_notes_attrs {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct trace_event_call {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct trace_eval_map {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct static_key_mod {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct uprobe {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ldt_struct {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct userfaultfd_ctx {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct linux_binfmt {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct mmu_notifier_mm {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rt_rq {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct sched_class {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rt_mutex_waiter {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct numa_group {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ftrace_ret_stack {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct cdev {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct xattr_handler {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct mtd_info {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct dev_pm_qos {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct of_device_id {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct acpi_device_id {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct irq_domain {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct assoc_array_ptr {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct key_user {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct tty_struct {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct autogroup {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct tty_audit_buf {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ip_ra_chain {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct inet_peer_base {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct xt_table {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ipv6_devconf {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct fib6_info {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rt6_info {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rt6_statistics {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct fib6_table {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct seg6_pernet_data {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct nf_ct_event_notifier {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct nf_exp_event_notifier {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct devlink_port {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct iw_handler_def {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct iw_public_data {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ndisc_ops {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct vlan_info {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct tipc_bearer {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct in_device {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct dn_dev {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct inet6_dev {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct cpu_rmap {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct pcpu_dstats {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct garp_port {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct mrp_port {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct timer_rand_state {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct blk_mq_ctx {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct blk_mq_ops {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct throtl_data {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct blk_mq_tag_set {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct module_param_attrs {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct lwtunnel_state {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct udp_table {
    pub _address: u8,
}
