/* automatically generated by rust-bindgen 0.55.1 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage, Align> {
    storage: Storage,
    align: [Align; 0],
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage, align: [] }
    }
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::core::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::core::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::core::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::core::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::core::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
pub type __u8 = c_types::c_uchar;
pub type __u16 = c_types::c_ushort;
pub type __u32 = c_types::c_uint;
pub type __s64 = c_types::c_longlong;
pub type __u64 = c_types::c_ulonglong;
pub type u8_ = __u8;
pub type u16_ = __u16;
pub type u32_ = __u32;
pub type s64 = __s64;
pub type u64_ = __u64;
pub type __kernel_ulong_t = c_types::c_ulong;
pub type __kernel_uid32_t = c_types::c_uint;
pub type __kernel_gid32_t = c_types::c_uint;
pub type __kernel_size_t = __kernel_ulong_t;
pub type __be16 = __u16;
pub type __wsum = __u32;
pub type bool_ = bool;
pub type uid_t = __kernel_uid32_t;
pub type gid_t = __kernel_gid32_t;
pub type gfp_t = c_types::c_uint;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct atomic_t {
    pub counter: c_types::c_int,
}
#[test]
fn bindgen_test_layout_atomic_t() {
    assert_eq!(
        ::core::mem::size_of::<atomic_t>(),
        4usize,
        concat!("Size of: ", stringify!(atomic_t))
    );
    assert_eq!(
        ::core::mem::align_of::<atomic_t>(),
        4usize,
        concat!("Alignment of ", stringify!(atomic_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<atomic_t>())).counter as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(atomic_t),
            "::",
            stringify!(counter)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct atomic64_t {
    pub counter: s64,
}
#[test]
fn bindgen_test_layout_atomic64_t() {
    assert_eq!(
        ::core::mem::size_of::<atomic64_t>(),
        8usize,
        concat!("Size of: ", stringify!(atomic64_t))
    );
    assert_eq!(
        ::core::mem::align_of::<atomic64_t>(),
        8usize,
        concat!("Alignment of ", stringify!(atomic64_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<atomic64_t>())).counter as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(atomic64_t),
            "::",
            stringify!(counter)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct list_head {
    pub next: *mut list_head,
    pub prev: *mut list_head,
}
#[test]
fn bindgen_test_layout_list_head() {
    assert_eq!(
        ::core::mem::size_of::<list_head>(),
        16usize,
        concat!("Size of: ", stringify!(list_head))
    );
    assert_eq!(
        ::core::mem::align_of::<list_head>(),
        8usize,
        concat!("Alignment of ", stringify!(list_head))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<list_head>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(list_head),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<list_head>())).prev as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(list_head),
            "::",
            stringify!(prev)
        )
    );
}
impl Default for list_head {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kuid_t {
    pub val: uid_t,
}
#[test]
fn bindgen_test_layout_kuid_t() {
    assert_eq!(
        ::core::mem::size_of::<kuid_t>(),
        4usize,
        concat!("Size of: ", stringify!(kuid_t))
    );
    assert_eq!(
        ::core::mem::align_of::<kuid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(kuid_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kuid_t>())).val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kuid_t),
            "::",
            stringify!(val)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kgid_t {
    pub val: gid_t,
}
#[test]
fn bindgen_test_layout_kgid_t() {
    assert_eq!(
        ::core::mem::size_of::<kgid_t>(),
        4usize,
        concat!("Size of: ", stringify!(kgid_t))
    );
    assert_eq!(
        ::core::mem::align_of::<kgid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(kgid_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kgid_t>())).val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kgid_t),
            "::",
            stringify!(val)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct module {
    _unused: [u8; 0],
}
extern "C" {
    pub fn printk(fmt: *const c_types::c_char, ...) -> c_types::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct net_device {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct qspinlock {
    pub __bindgen_anon_1: qspinlock__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union qspinlock__bindgen_ty_1 {
    pub val: atomic_t,
    pub __bindgen_anon_1: qspinlock__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: qspinlock__bindgen_ty_1__bindgen_ty_2,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct qspinlock__bindgen_ty_1__bindgen_ty_1 {
    pub locked: u8_,
    pub pending: u8_,
}
#[test]
fn bindgen_test_layout_qspinlock__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<qspinlock__bindgen_ty_1__bindgen_ty_1>(),
        2usize,
        concat!(
            "Size of: ",
            stringify!(qspinlock__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<qspinlock__bindgen_ty_1__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(qspinlock__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<qspinlock__bindgen_ty_1__bindgen_ty_1>())).locked as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qspinlock__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(locked)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<qspinlock__bindgen_ty_1__bindgen_ty_1>())).pending as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(qspinlock__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(pending)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct qspinlock__bindgen_ty_1__bindgen_ty_2 {
    pub locked_pending: u16_,
    pub tail: u16_,
}
#[test]
fn bindgen_test_layout_qspinlock__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<qspinlock__bindgen_ty_1__bindgen_ty_2>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(qspinlock__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<qspinlock__bindgen_ty_1__bindgen_ty_2>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(qspinlock__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<qspinlock__bindgen_ty_1__bindgen_ty_2>())).locked_pending
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qspinlock__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(locked_pending)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<qspinlock__bindgen_ty_1__bindgen_ty_2>())).tail as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(qspinlock__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(tail)
        )
    );
}
#[test]
fn bindgen_test_layout_qspinlock__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<qspinlock__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(qspinlock__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<qspinlock__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(qspinlock__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<qspinlock__bindgen_ty_1>())).val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qspinlock__bindgen_ty_1),
            "::",
            stringify!(val)
        )
    );
}
impl Default for qspinlock__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_qspinlock() {
    assert_eq!(
        ::core::mem::size_of::<qspinlock>(),
        4usize,
        concat!("Size of: ", stringify!(qspinlock))
    );
    assert_eq!(
        ::core::mem::align_of::<qspinlock>(),
        4usize,
        concat!("Alignment of ", stringify!(qspinlock))
    );
}
impl Default for qspinlock {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type arch_spinlock_t = qspinlock;
pub type atomic_long_t = atomic64_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct raw_spinlock {
    pub raw_lock: arch_spinlock_t,
}
#[test]
fn bindgen_test_layout_raw_spinlock() {
    assert_eq!(
        ::core::mem::size_of::<raw_spinlock>(),
        4usize,
        concat!("Size of: ", stringify!(raw_spinlock))
    );
    assert_eq!(
        ::core::mem::align_of::<raw_spinlock>(),
        4usize,
        concat!("Alignment of ", stringify!(raw_spinlock))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<raw_spinlock>())).raw_lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(raw_spinlock),
            "::",
            stringify!(raw_lock)
        )
    );
}
impl Default for raw_spinlock {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct spinlock {
    pub __bindgen_anon_1: spinlock__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spinlock__bindgen_ty_1 {
    pub rlock: raw_spinlock,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_spinlock__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<spinlock__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(spinlock__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<spinlock__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(spinlock__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<spinlock__bindgen_ty_1>())).rlock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spinlock__bindgen_ty_1),
            "::",
            stringify!(rlock)
        )
    );
}
impl Default for spinlock__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_spinlock() {
    assert_eq!(
        ::core::mem::size_of::<spinlock>(),
        4usize,
        concat!("Size of: ", stringify!(spinlock))
    );
    assert_eq!(
        ::core::mem::align_of::<spinlock>(),
        4usize,
        concat!("Alignment of ", stringify!(spinlock))
    );
}
impl Default for spinlock {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type spinlock_t = spinlock;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rb_node {
    pub __rb_parent_color: c_types::c_ulong,
    pub rb_right: *mut rb_node,
    pub rb_left: *mut rb_node,
}
#[test]
fn bindgen_test_layout_rb_node() {
    assert_eq!(
        ::core::mem::size_of::<rb_node>(),
        24usize,
        concat!("Size of: ", stringify!(rb_node))
    );
    assert_eq!(
        ::core::mem::align_of::<rb_node>(),
        8usize,
        concat!("Alignment of ", stringify!(rb_node))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rb_node>())).__rb_parent_color as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rb_node),
            "::",
            stringify!(__rb_parent_color)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rb_node>())).rb_right as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rb_node),
            "::",
            stringify!(rb_right)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rb_node>())).rb_left as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rb_node),
            "::",
            stringify!(rb_left)
        )
    );
}
impl Default for rb_node {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct optimistic_spin_queue {
    pub tail: atomic_t,
}
#[test]
fn bindgen_test_layout_optimistic_spin_queue() {
    assert_eq!(
        ::core::mem::size_of::<optimistic_spin_queue>(),
        4usize,
        concat!("Size of: ", stringify!(optimistic_spin_queue))
    );
    assert_eq!(
        ::core::mem::align_of::<optimistic_spin_queue>(),
        4usize,
        concat!("Alignment of ", stringify!(optimistic_spin_queue))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<optimistic_spin_queue>())).tail as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(optimistic_spin_queue),
            "::",
            stringify!(tail)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mutex {
    pub owner: atomic_long_t,
    pub wait_lock: spinlock_t,
    pub osq: optimistic_spin_queue,
    pub wait_list: list_head,
}
#[test]
fn bindgen_test_layout_mutex() {
    assert_eq!(
        ::core::mem::size_of::<mutex>(),
        32usize,
        concat!("Size of: ", stringify!(mutex))
    );
    assert_eq!(
        ::core::mem::align_of::<mutex>(),
        8usize,
        concat!("Alignment of ", stringify!(mutex))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mutex>())).owner as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mutex),
            "::",
            stringify!(owner)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mutex>())).wait_lock as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mutex),
            "::",
            stringify!(wait_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mutex>())).osq as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(mutex),
            "::",
            stringify!(osq)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mutex>())).wait_list as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(mutex),
            "::",
            stringify!(wait_list)
        )
    );
}
impl Default for mutex {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type ktime_t = s64;
#[doc = " struct refcount_t - variant of atomic_t specialized for reference counts"]
#[doc = " @refs: atomic_t counter field"]
#[doc = ""]
#[doc = " The counter saturates at UINT_MAX and will not move once"]
#[doc = " there. This avoids wrapping the counter and causing 'spurious'"]
#[doc = " use-after-free bugs."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct refcount_struct {
    pub refs: atomic_t,
}
#[test]
fn bindgen_test_layout_refcount_struct() {
    assert_eq!(
        ::core::mem::size_of::<refcount_struct>(),
        4usize,
        concat!("Size of: ", stringify!(refcount_struct))
    );
    assert_eq!(
        ::core::mem::align_of::<refcount_struct>(),
        4usize,
        concat!("Alignment of ", stringify!(refcount_struct))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<refcount_struct>())).refs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(refcount_struct),
            "::",
            stringify!(refs)
        )
    );
}
#[doc = " struct refcount_t - variant of atomic_t specialized for reference counts"]
#[doc = " @refs: atomic_t counter field"]
#[doc = ""]
#[doc = " The counter saturates at UINT_MAX and will not move once"]
#[doc = " there. This avoids wrapping the counter and causing 'spurious'"]
#[doc = " use-after-free bugs."]
pub type refcount_t = refcount_struct;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct net {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sock {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sk_buff_head {
    pub next: *mut sk_buff,
    pub prev: *mut sk_buff,
    pub qlen: __u32,
    pub lock: spinlock_t,
}
#[test]
fn bindgen_test_layout_sk_buff_head() {
    assert_eq!(
        ::core::mem::size_of::<sk_buff_head>(),
        24usize,
        concat!("Size of: ", stringify!(sk_buff_head))
    );
    assert_eq!(
        ::core::mem::align_of::<sk_buff_head>(),
        8usize,
        concat!("Alignment of ", stringify!(sk_buff_head))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sk_buff_head>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff_head),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sk_buff_head>())).prev as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff_head),
            "::",
            stringify!(prev)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sk_buff_head>())).qlen as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff_head),
            "::",
            stringify!(qlen)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sk_buff_head>())).lock as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff_head),
            "::",
            stringify!(lock)
        )
    );
}
impl Default for sk_buff_head {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type sk_buff_data_t = c_types::c_uint;
#[doc = "\tstruct sk_buff - socket buffer"]
#[doc = "\t@next: Next buffer in list"]
#[doc = "\t@prev: Previous buffer in list"]
#[doc = "\t@tstamp: Time we arrived/left"]
#[doc = "\t@rbnode: RB tree node, alternative to next/prev for netem/tcp"]
#[doc = "\t@sk: Socket we are owned by"]
#[doc = "\t@dev: Device we arrived on/are leaving by"]
#[doc = "\t@cb: Control buffer. Free for use by every layer. Put private vars here"]
#[doc = "\t@_skb_refdst: destination entry (with norefcount bit)"]
#[doc = "\t@sp: the security path, used for xfrm"]
#[doc = "\t@len: Length of actual data"]
#[doc = "\t@data_len: Data length"]
#[doc = "\t@mac_len: Length of link layer header"]
#[doc = "\t@hdr_len: writable header length of cloned skb"]
#[doc = "\t@csum: Checksum (must include start/offset pair)"]
#[doc = "\t@csum_start: Offset from skb->head where checksumming should start"]
#[doc = "\t@csum_offset: Offset from csum_start where checksum should be stored"]
#[doc = "\t@priority: Packet queueing priority"]
#[doc = "\t@ignore_df: allow local fragmentation"]
#[doc = "\t@cloned: Head may be cloned (check refcnt to be sure)"]
#[doc = "\t@ip_summed: Driver fed us an IP checksum"]
#[doc = "\t@nohdr: Payload reference only, must not modify header"]
#[doc = "\t@pkt_type: Packet class"]
#[doc = "\t@fclone: skbuff clone status"]
#[doc = "\t@ipvs_property: skbuff is owned by ipvs"]
#[doc = "\t@offload_fwd_mark: Packet was L2-forwarded in hardware"]
#[doc = "\t@offload_l3_fwd_mark: Packet was L3-forwarded in hardware"]
#[doc = "\t@tc_skip_classify: do not classify packet. set by IFB device"]
#[doc = "\t@tc_at_ingress: used within tc_classify to distinguish in/egress"]
#[doc = "\t@redirected: packet was redirected by packet classifier"]
#[doc = "\t@from_ingress: packet was redirected from the ingress path"]
#[doc = "\t@peeked: this packet has been seen already, so stats have been"]
#[doc = "\t\tdone for it, don't do them again"]
#[doc = "\t@nf_trace: netfilter packet trace flag"]
#[doc = "\t@protocol: Packet protocol from driver"]
#[doc = "\t@destructor: Destruct function"]
#[doc = "\t@tcp_tsorted_anchor: list structure for TCP (tp->tsorted_sent_queue)"]
#[doc = "\t@_nfct: Associated connection, if any (with nfctinfo bits)"]
#[doc = "\t@nf_bridge: Saved data about a bridged frame - see br_netfilter.c"]
#[doc = "\t@skb_iif: ifindex of device we arrived on"]
#[doc = "\t@tc_index: Traffic control index"]
#[doc = "\t@hash: the packet hash"]
#[doc = "\t@queue_mapping: Queue mapping for multiqueue devices"]
#[doc = "\t@pfmemalloc: skbuff was allocated from PFMEMALLOC reserves"]
#[doc = "\t@active_extensions: active extensions (skb_ext_id types)"]
#[doc = "\t@ndisc_nodetype: router type (from link layer)"]
#[doc = "\t@ooo_okay: allow the mapping of a socket to a queue to be changed"]
#[doc = "\t@l4_hash: indicate hash is a canonical 4-tuple hash over transport"]
#[doc = "\t\tports."]
#[doc = "\t@sw_hash: indicates hash was computed in software stack"]
#[doc = "\t@wifi_acked_valid: wifi_acked was set"]
#[doc = "\t@wifi_acked: whether frame was acked on wifi or not"]
#[doc = "\t@no_fcs:  Request NIC to treat last 4 bytes as Ethernet FCS"]
#[doc = "\t@csum_not_inet: use CRC32c to resolve CHECKSUM_PARTIAL"]
#[doc = "\t@dst_pending_confirm: need to confirm neighbour"]
#[doc = "\t@decrypted: Decrypted SKB"]
#[doc = "\t@napi_id: id of the NAPI struct this skb came from"]
#[doc = "\t@secmark: security marking"]
#[doc = "\t@mark: Generic packet mark"]
#[doc = "\t@vlan_proto: vlan encapsulation protocol"]
#[doc = "\t@vlan_tci: vlan tag control information"]
#[doc = "\t@inner_protocol: Protocol (encapsulation)"]
#[doc = "\t@inner_transport_header: Inner transport layer header (encapsulation)"]
#[doc = "\t@inner_network_header: Network layer header (encapsulation)"]
#[doc = "\t@inner_mac_header: Link layer header (encapsulation)"]
#[doc = "\t@transport_header: Transport layer header"]
#[doc = "\t@network_header: Network layer header"]
#[doc = "\t@mac_header: Link layer header"]
#[doc = "\t@tail: Tail pointer"]
#[doc = "\t@end: End pointer"]
#[doc = "\t@head: Head of buffer"]
#[doc = "\t@data: Data head pointer"]
#[doc = "\t@truesize: Buffer size"]
#[doc = "\t@users: User count - see {datagram,tcp}.c"]
#[doc = "\t@extensions: allocated extensions, valid if active_extensions is nonzero"]
#[repr(C)]
pub struct sk_buff {
    pub __bindgen_anon_1: sk_buff__bindgen_ty_1,
    pub __bindgen_anon_2: sk_buff__bindgen_ty_2,
    pub __bindgen_anon_3: sk_buff__bindgen_ty_3,
    pub cb: [c_types::c_char; 48usize],
    pub __bindgen_anon_4: sk_buff__bindgen_ty_4,
    pub _nfct: c_types::c_ulong,
    pub len: c_types::c_uint,
    pub data_len: c_types::c_uint,
    pub mac_len: __u16,
    pub hdr_len: __u16,
    pub queue_mapping: __u16,
    pub __cloned_offset: __IncompleteArrayField<__u8>,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub active_extensions: __u8,
    pub headers_start: __IncompleteArrayField<__u32>,
    pub __pkt_type_offset: __IncompleteArrayField<__u8>,
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 2usize], u8>,
    pub __pkt_vlan_present_offset: __IncompleteArrayField<__u8>,
    pub _bitfield_3: __BindgenBitfieldUnit<[u8; 3usize], u8>,
    pub tc_index: __u16,
    pub __bindgen_anon_5: sk_buff__bindgen_ty_5,
    pub priority: __u32,
    pub skb_iif: c_types::c_int,
    pub hash: __u32,
    pub vlan_proto: __be16,
    pub vlan_tci: __u16,
    pub __bindgen_anon_6: sk_buff__bindgen_ty_6,
    pub secmark: __u32,
    pub __bindgen_anon_7: sk_buff__bindgen_ty_7,
    pub __bindgen_anon_8: sk_buff__bindgen_ty_8,
    pub inner_transport_header: __u16,
    pub inner_network_header: __u16,
    pub inner_mac_header: __u16,
    pub protocol: __be16,
    pub transport_header: __u16,
    pub network_header: __u16,
    pub mac_header: __u16,
    pub headers_end: __IncompleteArrayField<__u32>,
    pub tail: sk_buff_data_t,
    pub end: sk_buff_data_t,
    pub head: *mut c_types::c_uchar,
    pub data: *mut c_types::c_uchar,
    pub truesize: c_types::c_uint,
    pub users: refcount_t,
    pub extensions: *mut skb_ext,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sk_buff__bindgen_ty_1 {
    pub __bindgen_anon_1: sk_buff__bindgen_ty_1__bindgen_ty_1,
    pub rbnode: rb_node,
    pub list: list_head,
    _bindgen_union_align: [u64; 3usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sk_buff__bindgen_ty_1__bindgen_ty_1 {
    pub next: *mut sk_buff,
    pub prev: *mut sk_buff,
    pub __bindgen_anon_1: sk_buff__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sk_buff__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub dev: *mut net_device,
    pub dev_scratch: c_types::c_ulong,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_sk_buff__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<sk_buff__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(sk_buff__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_buff__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(sk_buff__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sk_buff__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>())).dev
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(dev)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sk_buff__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>()))
                .dev_scratch as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(dev_scratch)
        )
    );
}
impl Default for sk_buff__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_sk_buff__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<sk_buff__bindgen_ty_1__bindgen_ty_1>(),
        24usize,
        concat!("Size of: ", stringify!(sk_buff__bindgen_ty_1__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<sk_buff__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(sk_buff__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sk_buff__bindgen_ty_1__bindgen_ty_1>())).next as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sk_buff__bindgen_ty_1__bindgen_ty_1>())).prev as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(prev)
        )
    );
}
impl Default for sk_buff__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_sk_buff__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<sk_buff__bindgen_ty_1>(),
        24usize,
        concat!("Size of: ", stringify!(sk_buff__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<sk_buff__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(sk_buff__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sk_buff__bindgen_ty_1>())).rbnode as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff__bindgen_ty_1),
            "::",
            stringify!(rbnode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sk_buff__bindgen_ty_1>())).list as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff__bindgen_ty_1),
            "::",
            stringify!(list)
        )
    );
}
impl Default for sk_buff__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sk_buff__bindgen_ty_2 {
    pub sk: *mut sock,
    pub ip_defrag_offset: c_types::c_int,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_sk_buff__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<sk_buff__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(sk_buff__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<sk_buff__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(sk_buff__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sk_buff__bindgen_ty_2>())).sk as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff__bindgen_ty_2),
            "::",
            stringify!(sk)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sk_buff__bindgen_ty_2>())).ip_defrag_offset as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff__bindgen_ty_2),
            "::",
            stringify!(ip_defrag_offset)
        )
    );
}
impl Default for sk_buff__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sk_buff__bindgen_ty_3 {
    pub tstamp: ktime_t,
    pub skb_mstamp_ns: u64_,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_sk_buff__bindgen_ty_3() {
    assert_eq!(
        ::core::mem::size_of::<sk_buff__bindgen_ty_3>(),
        8usize,
        concat!("Size of: ", stringify!(sk_buff__bindgen_ty_3))
    );
    assert_eq!(
        ::core::mem::align_of::<sk_buff__bindgen_ty_3>(),
        8usize,
        concat!("Alignment of ", stringify!(sk_buff__bindgen_ty_3))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sk_buff__bindgen_ty_3>())).tstamp as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff__bindgen_ty_3),
            "::",
            stringify!(tstamp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sk_buff__bindgen_ty_3>())).skb_mstamp_ns as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff__bindgen_ty_3),
            "::",
            stringify!(skb_mstamp_ns)
        )
    );
}
impl Default for sk_buff__bindgen_ty_3 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sk_buff__bindgen_ty_4 {
    pub __bindgen_anon_1: sk_buff__bindgen_ty_4__bindgen_ty_1,
    pub tcp_tsorted_anchor: list_head,
    _bindgen_union_align: [u64; 2usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct sk_buff__bindgen_ty_4__bindgen_ty_1 {
    pub _skb_refdst: c_types::c_ulong,
    pub destructor: ::core::option::Option<unsafe extern "C" fn(skb: *mut sk_buff)>,
}
#[test]
fn bindgen_test_layout_sk_buff__bindgen_ty_4__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<sk_buff__bindgen_ty_4__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(sk_buff__bindgen_ty_4__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<sk_buff__bindgen_ty_4__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(sk_buff__bindgen_ty_4__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sk_buff__bindgen_ty_4__bindgen_ty_1>()))._skb_refdst as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff__bindgen_ty_4__bindgen_ty_1),
            "::",
            stringify!(_skb_refdst)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sk_buff__bindgen_ty_4__bindgen_ty_1>())).destructor as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff__bindgen_ty_4__bindgen_ty_1),
            "::",
            stringify!(destructor)
        )
    );
}
#[test]
fn bindgen_test_layout_sk_buff__bindgen_ty_4() {
    assert_eq!(
        ::core::mem::size_of::<sk_buff__bindgen_ty_4>(),
        16usize,
        concat!("Size of: ", stringify!(sk_buff__bindgen_ty_4))
    );
    assert_eq!(
        ::core::mem::align_of::<sk_buff__bindgen_ty_4>(),
        8usize,
        concat!("Alignment of ", stringify!(sk_buff__bindgen_ty_4))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sk_buff__bindgen_ty_4>())).tcp_tsorted_anchor as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff__bindgen_ty_4),
            "::",
            stringify!(tcp_tsorted_anchor)
        )
    );
}
impl Default for sk_buff__bindgen_ty_4 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sk_buff__bindgen_ty_5 {
    pub csum: __wsum,
    pub __bindgen_anon_1: sk_buff__bindgen_ty_5__bindgen_ty_1,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct sk_buff__bindgen_ty_5__bindgen_ty_1 {
    pub csum_start: __u16,
    pub csum_offset: __u16,
}
#[test]
fn bindgen_test_layout_sk_buff__bindgen_ty_5__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<sk_buff__bindgen_ty_5__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(sk_buff__bindgen_ty_5__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<sk_buff__bindgen_ty_5__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(sk_buff__bindgen_ty_5__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sk_buff__bindgen_ty_5__bindgen_ty_1>())).csum_start as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff__bindgen_ty_5__bindgen_ty_1),
            "::",
            stringify!(csum_start)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sk_buff__bindgen_ty_5__bindgen_ty_1>())).csum_offset as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff__bindgen_ty_5__bindgen_ty_1),
            "::",
            stringify!(csum_offset)
        )
    );
}
#[test]
fn bindgen_test_layout_sk_buff__bindgen_ty_5() {
    assert_eq!(
        ::core::mem::size_of::<sk_buff__bindgen_ty_5>(),
        4usize,
        concat!("Size of: ", stringify!(sk_buff__bindgen_ty_5))
    );
    assert_eq!(
        ::core::mem::align_of::<sk_buff__bindgen_ty_5>(),
        4usize,
        concat!("Alignment of ", stringify!(sk_buff__bindgen_ty_5))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sk_buff__bindgen_ty_5>())).csum as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff__bindgen_ty_5),
            "::",
            stringify!(csum)
        )
    );
}
impl Default for sk_buff__bindgen_ty_5 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sk_buff__bindgen_ty_6 {
    pub napi_id: c_types::c_uint,
    pub sender_cpu: c_types::c_uint,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_sk_buff__bindgen_ty_6() {
    assert_eq!(
        ::core::mem::size_of::<sk_buff__bindgen_ty_6>(),
        4usize,
        concat!("Size of: ", stringify!(sk_buff__bindgen_ty_6))
    );
    assert_eq!(
        ::core::mem::align_of::<sk_buff__bindgen_ty_6>(),
        4usize,
        concat!("Alignment of ", stringify!(sk_buff__bindgen_ty_6))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sk_buff__bindgen_ty_6>())).napi_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff__bindgen_ty_6),
            "::",
            stringify!(napi_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sk_buff__bindgen_ty_6>())).sender_cpu as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff__bindgen_ty_6),
            "::",
            stringify!(sender_cpu)
        )
    );
}
impl Default for sk_buff__bindgen_ty_6 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sk_buff__bindgen_ty_7 {
    pub mark: __u32,
    pub reserved_tailroom: __u32,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_sk_buff__bindgen_ty_7() {
    assert_eq!(
        ::core::mem::size_of::<sk_buff__bindgen_ty_7>(),
        4usize,
        concat!("Size of: ", stringify!(sk_buff__bindgen_ty_7))
    );
    assert_eq!(
        ::core::mem::align_of::<sk_buff__bindgen_ty_7>(),
        4usize,
        concat!("Alignment of ", stringify!(sk_buff__bindgen_ty_7))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sk_buff__bindgen_ty_7>())).mark as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff__bindgen_ty_7),
            "::",
            stringify!(mark)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sk_buff__bindgen_ty_7>())).reserved_tailroom as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff__bindgen_ty_7),
            "::",
            stringify!(reserved_tailroom)
        )
    );
}
impl Default for sk_buff__bindgen_ty_7 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sk_buff__bindgen_ty_8 {
    pub inner_protocol: __be16,
    pub inner_ipproto: __u8,
    _bindgen_union_align: u16,
}
#[test]
fn bindgen_test_layout_sk_buff__bindgen_ty_8() {
    assert_eq!(
        ::core::mem::size_of::<sk_buff__bindgen_ty_8>(),
        2usize,
        concat!("Size of: ", stringify!(sk_buff__bindgen_ty_8))
    );
    assert_eq!(
        ::core::mem::align_of::<sk_buff__bindgen_ty_8>(),
        2usize,
        concat!("Alignment of ", stringify!(sk_buff__bindgen_ty_8))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sk_buff__bindgen_ty_8>())).inner_protocol as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff__bindgen_ty_8),
            "::",
            stringify!(inner_protocol)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sk_buff__bindgen_ty_8>())).inner_ipproto as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff__bindgen_ty_8),
            "::",
            stringify!(inner_ipproto)
        )
    );
}
impl Default for sk_buff__bindgen_ty_8 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_sk_buff() {
    assert_eq!(
        ::core::mem::size_of::<sk_buff>(),
        224usize,
        concat!("Size of: ", stringify!(sk_buff))
    );
    assert_eq!(
        ::core::mem::align_of::<sk_buff>(),
        8usize,
        concat!("Alignment of ", stringify!(sk_buff))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sk_buff>())).cb as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff),
            "::",
            stringify!(cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sk_buff>()))._nfct as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff),
            "::",
            stringify!(_nfct)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sk_buff>())).len as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sk_buff>())).data_len as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff),
            "::",
            stringify!(data_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sk_buff>())).mac_len as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff),
            "::",
            stringify!(mac_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sk_buff>())).hdr_len as *const _ as usize },
        122usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff),
            "::",
            stringify!(hdr_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sk_buff>())).queue_mapping as *const _ as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff),
            "::",
            stringify!(queue_mapping)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sk_buff>())).__cloned_offset as *const _ as usize },
        126usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff),
            "::",
            stringify!(__cloned_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sk_buff>())).active_extensions as *const _ as usize },
        127usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff),
            "::",
            stringify!(active_extensions)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sk_buff>())).headers_start as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff),
            "::",
            stringify!(headers_start)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sk_buff>())).__pkt_type_offset as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff),
            "::",
            stringify!(__pkt_type_offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sk_buff>())).__pkt_vlan_present_offset as *const _ as usize
        },
        130usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff),
            "::",
            stringify!(__pkt_vlan_present_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sk_buff>())).tc_index as *const _ as usize },
        134usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff),
            "::",
            stringify!(tc_index)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sk_buff>())).priority as *const _ as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff),
            "::",
            stringify!(priority)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sk_buff>())).skb_iif as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff),
            "::",
            stringify!(skb_iif)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sk_buff>())).hash as *const _ as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff),
            "::",
            stringify!(hash)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sk_buff>())).vlan_proto as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff),
            "::",
            stringify!(vlan_proto)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sk_buff>())).vlan_tci as *const _ as usize },
        154usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff),
            "::",
            stringify!(vlan_tci)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sk_buff>())).secmark as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff),
            "::",
            stringify!(secmark)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sk_buff>())).inner_transport_header as *const _ as usize },
        170usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff),
            "::",
            stringify!(inner_transport_header)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sk_buff>())).inner_network_header as *const _ as usize },
        172usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff),
            "::",
            stringify!(inner_network_header)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sk_buff>())).inner_mac_header as *const _ as usize },
        174usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff),
            "::",
            stringify!(inner_mac_header)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sk_buff>())).protocol as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff),
            "::",
            stringify!(protocol)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sk_buff>())).transport_header as *const _ as usize },
        178usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff),
            "::",
            stringify!(transport_header)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sk_buff>())).network_header as *const _ as usize },
        180usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff),
            "::",
            stringify!(network_header)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sk_buff>())).mac_header as *const _ as usize },
        182usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff),
            "::",
            stringify!(mac_header)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sk_buff>())).headers_end as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff),
            "::",
            stringify!(headers_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sk_buff>())).tail as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff),
            "::",
            stringify!(tail)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sk_buff>())).end as *const _ as usize },
        188usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff),
            "::",
            stringify!(end)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sk_buff>())).head as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff),
            "::",
            stringify!(head)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sk_buff>())).data as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sk_buff>())).truesize as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff),
            "::",
            stringify!(truesize)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sk_buff>())).users as *const _ as usize },
        212usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff),
            "::",
            stringify!(users)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sk_buff>())).extensions as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff),
            "::",
            stringify!(extensions)
        )
    );
}
impl Default for sk_buff {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl sk_buff {
    #[inline]
    pub fn cloned(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_cloned(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn nohdr(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_nohdr(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fclone(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_fclone(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn peeked(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_peeked(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn head_frag(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_head_frag(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pfmemalloc(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_pfmemalloc(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        cloned: __u8,
        nohdr: __u8,
        fclone: __u8,
        peeked: __u8,
        head_frag: __u8,
        pfmemalloc: __u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let cloned: u8 = unsafe { ::core::mem::transmute(cloned) };
            cloned as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let nohdr: u8 = unsafe { ::core::mem::transmute(nohdr) };
            nohdr as u64
        });
        __bindgen_bitfield_unit.set(2usize, 2u8, {
            let fclone: u8 = unsafe { ::core::mem::transmute(fclone) };
            fclone as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let peeked: u8 = unsafe { ::core::mem::transmute(peeked) };
            peeked as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let head_frag: u8 = unsafe { ::core::mem::transmute(head_frag) };
            head_frag as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let pfmemalloc: u8 = unsafe { ::core::mem::transmute(pfmemalloc) };
            pfmemalloc as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn pkt_type(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(0usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_pkt_type(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn ignore_df(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ignore_df(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn nf_trace(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_nf_trace(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ip_summed(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(5usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_ip_summed(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(5usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn ooo_okay(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ooo_okay(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn l4_hash(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(8usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_l4_hash(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sw_hash(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(9usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_sw_hash(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wifi_acked_valid(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(10usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_wifi_acked_valid(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wifi_acked(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(11usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_wifi_acked(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn no_fcs(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(12usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_no_fcs(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn encapsulation(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(13usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_encapsulation(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn encap_hdr_csum(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(14usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_encap_hdr_csum(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn csum_valid(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(15usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_csum_valid(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_2(
        pkt_type: __u8,
        ignore_df: __u8,
        nf_trace: __u8,
        ip_summed: __u8,
        ooo_okay: __u8,
        l4_hash: __u8,
        sw_hash: __u8,
        wifi_acked_valid: __u8,
        wifi_acked: __u8,
        no_fcs: __u8,
        encapsulation: __u8,
        encap_hdr_csum: __u8,
        csum_valid: __u8,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let pkt_type: u8 = unsafe { ::core::mem::transmute(pkt_type) };
            pkt_type as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let ignore_df: u8 = unsafe { ::core::mem::transmute(ignore_df) };
            ignore_df as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let nf_trace: u8 = unsafe { ::core::mem::transmute(nf_trace) };
            nf_trace as u64
        });
        __bindgen_bitfield_unit.set(5usize, 2u8, {
            let ip_summed: u8 = unsafe { ::core::mem::transmute(ip_summed) };
            ip_summed as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let ooo_okay: u8 = unsafe { ::core::mem::transmute(ooo_okay) };
            ooo_okay as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let l4_hash: u8 = unsafe { ::core::mem::transmute(l4_hash) };
            l4_hash as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let sw_hash: u8 = unsafe { ::core::mem::transmute(sw_hash) };
            sw_hash as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let wifi_acked_valid: u8 = unsafe { ::core::mem::transmute(wifi_acked_valid) };
            wifi_acked_valid as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let wifi_acked: u8 = unsafe { ::core::mem::transmute(wifi_acked) };
            wifi_acked as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let no_fcs: u8 = unsafe { ::core::mem::transmute(no_fcs) };
            no_fcs as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let encapsulation: u8 = unsafe { ::core::mem::transmute(encapsulation) };
            encapsulation as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let encap_hdr_csum: u8 = unsafe { ::core::mem::transmute(encap_hdr_csum) };
            encap_hdr_csum as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let csum_valid: u8 = unsafe { ::core::mem::transmute(csum_valid) };
            csum_valid as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn vlan_present(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_vlan_present(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_3.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn csum_complete_sw(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_csum_complete_sw(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_3.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn csum_level(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(2usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_csum_level(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_3.set(2usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn csum_not_inet(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_csum_not_inet(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_3.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dst_pending_confirm(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_dst_pending_confirm(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_3.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ndisc_nodetype(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(6usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_ndisc_nodetype(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_3.set(6usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn ipvs_property(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(8usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ipvs_property(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_3.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn inner_protocol_type(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(9usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_inner_protocol_type(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_3.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn remcsum_offload(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(10usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_remcsum_offload(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_3.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn offload_fwd_mark(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(11usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_offload_fwd_mark(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_3.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn offload_l3_fwd_mark(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(12usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_offload_l3_fwd_mark(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_3.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tc_skip_classify(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(13usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_tc_skip_classify(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_3.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tc_at_ingress(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(14usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_tc_at_ingress(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_3.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn redirected(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(15usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_redirected(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_3.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn from_ingress(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(16usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_from_ingress(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_3.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn decrypted(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(17usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_decrypted(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_3.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_3(
        vlan_present: __u8,
        csum_complete_sw: __u8,
        csum_level: __u8,
        csum_not_inet: __u8,
        dst_pending_confirm: __u8,
        ndisc_nodetype: __u8,
        ipvs_property: __u8,
        inner_protocol_type: __u8,
        remcsum_offload: __u8,
        offload_fwd_mark: __u8,
        offload_l3_fwd_mark: __u8,
        tc_skip_classify: __u8,
        tc_at_ingress: __u8,
        redirected: __u8,
        from_ingress: __u8,
        decrypted: __u8,
    ) -> __BindgenBitfieldUnit<[u8; 3usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let vlan_present: u8 = unsafe { ::core::mem::transmute(vlan_present) };
            vlan_present as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let csum_complete_sw: u8 = unsafe { ::core::mem::transmute(csum_complete_sw) };
            csum_complete_sw as u64
        });
        __bindgen_bitfield_unit.set(2usize, 2u8, {
            let csum_level: u8 = unsafe { ::core::mem::transmute(csum_level) };
            csum_level as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let csum_not_inet: u8 = unsafe { ::core::mem::transmute(csum_not_inet) };
            csum_not_inet as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let dst_pending_confirm: u8 = unsafe { ::core::mem::transmute(dst_pending_confirm) };
            dst_pending_confirm as u64
        });
        __bindgen_bitfield_unit.set(6usize, 2u8, {
            let ndisc_nodetype: u8 = unsafe { ::core::mem::transmute(ndisc_nodetype) };
            ndisc_nodetype as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let ipvs_property: u8 = unsafe { ::core::mem::transmute(ipvs_property) };
            ipvs_property as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let inner_protocol_type: u8 = unsafe { ::core::mem::transmute(inner_protocol_type) };
            inner_protocol_type as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let remcsum_offload: u8 = unsafe { ::core::mem::transmute(remcsum_offload) };
            remcsum_offload as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let offload_fwd_mark: u8 = unsafe { ::core::mem::transmute(offload_fwd_mark) };
            offload_fwd_mark as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let offload_l3_fwd_mark: u8 = unsafe { ::core::mem::transmute(offload_l3_fwd_mark) };
            offload_l3_fwd_mark as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let tc_skip_classify: u8 = unsafe { ::core::mem::transmute(tc_skip_classify) };
            tc_skip_classify as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let tc_at_ingress: u8 = unsafe { ::core::mem::transmute(tc_at_ingress) };
            tc_at_ingress as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let redirected: u8 = unsafe { ::core::mem::transmute(redirected) };
            redirected as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let from_ingress: u8 = unsafe { ::core::mem::transmute(from_ingress) };
            from_ingress as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let decrypted: u8 = unsafe { ::core::mem::transmute(decrypted) };
            decrypted as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub fn skb_dequeue(list: *mut sk_buff_head) -> *mut sk_buff;
}
#[doc = "\tstruct skb_ext - sk_buff extensions"]
#[doc = "\t@refcnt: 1 on allocation, deallocated on 0"]
#[doc = "\t@offset: offset to add to @data to obtain extension address"]
#[doc = "\t@chunks: size currently allocated, stored in SKB_EXT_ALIGN_SHIFT units"]
#[doc = "\t@data: start of extension data, variable sized"]
#[doc = ""]
#[doc = "\tNote: offsets/lengths are stored in chunks of 8 bytes, this allows"]
#[doc = "\tto use 'u8' types while allowing up to 2kb worth of extension data."]
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Default)]
pub struct skb_ext {
    pub refcnt: refcount_t,
    pub offset: [u8_; 3usize],
    pub chunks: u8_,
    pub data: __IncompleteArrayField<c_types::c_char>,
}
#[test]
fn bindgen_test_layout_skb_ext() {
    assert_eq!(
        ::core::mem::size_of::<skb_ext>(),
        8usize,
        concat!("Size of: ", stringify!(skb_ext))
    );
    assert_eq!(
        ::core::mem::align_of::<skb_ext>(),
        8usize,
        concat!("Alignment of ", stringify!(skb_ext))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<skb_ext>())).refcnt as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(skb_ext),
            "::",
            stringify!(refcnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<skb_ext>())).offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(skb_ext),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<skb_ext>())).chunks as *const _ as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(skb_ext),
            "::",
            stringify!(chunks)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<skb_ext>())).data as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(skb_ext),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct scm_creds {
    pub pid: u32_,
    pub uid: kuid_t,
    pub gid: kgid_t,
}
#[test]
fn bindgen_test_layout_scm_creds() {
    assert_eq!(
        ::core::mem::size_of::<scm_creds>(),
        12usize,
        concat!("Size of: ", stringify!(scm_creds))
    );
    assert_eq!(
        ::core::mem::align_of::<scm_creds>(),
        4usize,
        concat!("Alignment of ", stringify!(scm_creds))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<scm_creds>())).pid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_creds),
            "::",
            stringify!(pid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<scm_creds>())).uid as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_creds),
            "::",
            stringify!(uid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<scm_creds>())).gid as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_creds),
            "::",
            stringify!(gid)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct nlmsghdr {
    pub nlmsg_len: __u32,
    pub nlmsg_type: __u16,
    pub nlmsg_flags: __u16,
    pub nlmsg_seq: __u32,
    pub nlmsg_pid: __u32,
}
#[test]
fn bindgen_test_layout_nlmsghdr() {
    assert_eq!(
        ::core::mem::size_of::<nlmsghdr>(),
        16usize,
        concat!("Size of: ", stringify!(nlmsghdr))
    );
    assert_eq!(
        ::core::mem::align_of::<nlmsghdr>(),
        4usize,
        concat!("Alignment of ", stringify!(nlmsghdr))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nlmsghdr>())).nlmsg_len as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nlmsghdr),
            "::",
            stringify!(nlmsg_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nlmsghdr>())).nlmsg_type as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nlmsghdr),
            "::",
            stringify!(nlmsg_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nlmsghdr>())).nlmsg_flags as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(nlmsghdr),
            "::",
            stringify!(nlmsg_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nlmsghdr>())).nlmsg_seq as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nlmsghdr),
            "::",
            stringify!(nlmsg_seq)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nlmsghdr>())).nlmsg_pid as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(nlmsghdr),
            "::",
            stringify!(nlmsg_pid)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct netlink_skb_parms {
    pub creds: scm_creds,
    pub portid: __u32,
    pub dst_group: __u32,
    pub flags: __u32,
    pub sk: *mut sock,
    pub nsid_is_set: bool_,
    pub nsid: c_types::c_int,
}
#[test]
fn bindgen_test_layout_netlink_skb_parms() {
    assert_eq!(
        ::core::mem::size_of::<netlink_skb_parms>(),
        40usize,
        concat!("Size of: ", stringify!(netlink_skb_parms))
    );
    assert_eq!(
        ::core::mem::align_of::<netlink_skb_parms>(),
        8usize,
        concat!("Alignment of ", stringify!(netlink_skb_parms))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netlink_skb_parms>())).creds as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(netlink_skb_parms),
            "::",
            stringify!(creds)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netlink_skb_parms>())).portid as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(netlink_skb_parms),
            "::",
            stringify!(portid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netlink_skb_parms>())).dst_group as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(netlink_skb_parms),
            "::",
            stringify!(dst_group)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netlink_skb_parms>())).flags as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(netlink_skb_parms),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netlink_skb_parms>())).sk as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(netlink_skb_parms),
            "::",
            stringify!(sk)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netlink_skb_parms>())).nsid_is_set as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(netlink_skb_parms),
            "::",
            stringify!(nsid_is_set)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netlink_skb_parms>())).nsid as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(netlink_skb_parms),
            "::",
            stringify!(nsid)
        )
    );
}
impl Default for netlink_skb_parms {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct netlink_kernel_cfg {
    pub groups: c_types::c_uint,
    pub flags: c_types::c_uint,
    pub input: ::core::option::Option<unsafe extern "C" fn(skb: *mut sk_buff)>,
    pub cb_mutex: *mut mutex,
    pub bind: ::core::option::Option<
        unsafe extern "C" fn(net: *mut net, group: c_types::c_int) -> c_types::c_int,
    >,
    pub unbind: ::core::option::Option<unsafe extern "C" fn(net: *mut net, group: c_types::c_int)>,
    pub compare:
        ::core::option::Option<unsafe extern "C" fn(net: *mut net, sk: *mut sock) -> bool_>,
}
#[test]
fn bindgen_test_layout_netlink_kernel_cfg() {
    assert_eq!(
        ::core::mem::size_of::<netlink_kernel_cfg>(),
        48usize,
        concat!("Size of: ", stringify!(netlink_kernel_cfg))
    );
    assert_eq!(
        ::core::mem::align_of::<netlink_kernel_cfg>(),
        8usize,
        concat!("Alignment of ", stringify!(netlink_kernel_cfg))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netlink_kernel_cfg>())).groups as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(netlink_kernel_cfg),
            "::",
            stringify!(groups)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netlink_kernel_cfg>())).flags as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(netlink_kernel_cfg),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netlink_kernel_cfg>())).input as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(netlink_kernel_cfg),
            "::",
            stringify!(input)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netlink_kernel_cfg>())).cb_mutex as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(netlink_kernel_cfg),
            "::",
            stringify!(cb_mutex)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netlink_kernel_cfg>())).bind as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(netlink_kernel_cfg),
            "::",
            stringify!(bind)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netlink_kernel_cfg>())).unbind as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(netlink_kernel_cfg),
            "::",
            stringify!(unbind)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<netlink_kernel_cfg>())).compare as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(netlink_kernel_cfg),
            "::",
            stringify!(compare)
        )
    );
}
impl Default for netlink_kernel_cfg {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn __netlink_kernel_create(
        net: *mut net,
        unit: c_types::c_int,
        module: *mut module,
        cfg: *mut netlink_kernel_cfg,
    ) -> *mut sock;
}
extern "C" {
    pub fn netlink_kernel_release(sk: *mut sock);
}
extern "C" {
    pub fn netlink_unicast(
        ssk: *mut sock,
        skb: *mut sk_buff,
        portid: __u32,
        nonblock: c_types::c_int,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn netlink_broadcast(
        ssk: *mut sock,
        skb: *mut sk_buff,
        portid: __u32,
        group: __u32,
        allocation: gfp_t,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn nlmsg_data_non_inline(nlh: *mut nlmsghdr) -> *mut c_types::c_void;
}
extern "C" {
    pub fn netlink_cb(skb: *mut sk_buff) -> netlink_skb_parms;
}
extern "C" {
    pub fn nlmsg_new_non_inline(payload: usize, flags: gfp_t) -> *mut sk_buff;
}
extern "C" {
    pub fn kmalloc_wrapped(size: usize, flags: gfp_t) -> *mut c_types::c_void;
}
extern "C" {
    pub fn kcalloc_wrapped(n: usize, size: usize, flags: gfp_t) -> *mut c_types::c_void;
}
extern "C" {
    pub fn kfree_wrapped(ptr: *const c_types::c_void);
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct GFP {}
pub const GFP_KERNEL: c_types::c_uint = 3264;
pub type GFP__bindgen_ty_1 = c_types::c_uint;
#[test]
fn bindgen_test_layout_GFP() {
    assert_eq!(
        ::core::mem::size_of::<GFP>(),
        0usize,
        concat!("Size of: ", stringify!(GFP))
    );
    assert_eq!(
        ::core::mem::align_of::<GFP>(),
        1usize,
        concat!("Alignment of ", stringify!(GFP))
    );
}
